<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.26.2 by Michael Rose
  Copyright 2013-2024 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->

<html lang="en-US" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Valid Parentheses - Arun Baby</title>
<meta name="description" content="Why a simple stack solves bracket matching, expression parsing, and even neural network depth management in one elegant pattern.">


  <meta name="author" content="Arun Baby">
  
  <meta property="article:author" content="Arun Baby">
  


<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="Arun Baby">
<meta property="og:title" content="Valid Parentheses">
<meta property="og:url" content="https://www.arunbaby.com/dsa/0002-valid-parentheses/">


  <meta property="og:description" content="Why a simple stack solves bracket matching, expression parsing, and even neural network depth management in one elegant pattern.">



  <meta property="og:image" content="https://www.arunbaby.com/assets/images/profile-photo.png">



  <meta name="twitter:site" content="@arunbaby0">
  <meta name="twitter:title" content="Valid Parentheses">
  <meta name="twitter:description" content="Why a simple stack solves bracket matching, expression parsing, and even neural network depth management in one elegant pattern.">
  <meta name="twitter:url" content="https://www.arunbaby.com/dsa/0002-valid-parentheses/">

  
    <meta name="twitter:card" content="summary">
    
      <meta name="twitter:image" content="https://www.arunbaby.com/assets/images/profile-photo.png">
    
  

  



  <meta property="article:published_time" content="2025-12-29T16:05:30+05:30">





  

  


<link rel="canonical" href="https://www.arunbaby.com/dsa/0002-valid-parentheses/">












<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Arun Baby Feed">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
  
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css"></noscript>



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--single" dir="ltr">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
           
          <span class="site-subtitle">Arun Baby</span>
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a
                href="/about/"
                
                
              >About</a>
            </li><li class="masthead__menu-item">
              <a
                href="/dsa/"
                
                
              >DSA</a>
            </li><li class="masthead__menu-item">
              <a
                href="/ml-system-design/"
                
                
              >ML Systems</a>
            </li><li class="masthead__menu-item">
              <a
                href="/speech-tech/"
                
                
              >Speech Tech</a>
            </li><li class="masthead__menu-item">
              <a
                href="/ai-agents/"
                
                
              >AI Agents</a>
            </li><li class="masthead__menu-item">
              <a
                href="/publications/"
                
                
              >Publications</a>
            </li><li class="masthead__menu-item">
              <a
                href="/statuses/"
                
                
              >Statuses</a>
            </li><li class="masthead__menu-item">
              <a
                href="/contact/"
                
                
              >Contact</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <i class="fas fa-search"></i>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      





<div id="main" role="main" class="no-author-sidebar">
  
  <div class="sidebar sticky">
  
  
  </div>



  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="Valid Parentheses">
    <meta itemprop="description" content="Why a simple stack solves bracket matching, expression parsing, and even neural network depth management in one elegant pattern.">
    <meta itemprop="datePublished" content="2025-12-29T16:05:30+05:30">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">
            <a href="https://www.arunbaby.com/dsa/0002-valid-parentheses/" itemprop="url">Valid Parentheses
</a>
          </h1>
          

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          24 minute read
        
      </span>
    
  </p>


        </header>
      

      <section class="page__content" itemprop="text">
        
          <aside class="sidebar__right sticky">
            <nav class="toc">
              <header><h4 class="nav__title"><i class="fas fa-file-alt"></i> On this page</h4></header>
              <ul class="toc__menu"><li><a href="#introduction">Introduction</a></li><li><a href="#problem-statement">Problem Statement</a><ul><li><a href="#examples">Examples</a></li><li><a href="#constraints">Constraints</a></li></ul></li><li><a href="#understanding-the-problem">Understanding the Problem</a><ul><li><a href="#why-this-is-a-stack-problem">Why This is a Stack Problem</a></li><li><a href="#what-makes-a-string-invalid">What Makes a String Invalid?</a></li></ul></li><li><a href="#approach-1-brute-force-naive">Approach 1: Brute Force (Naive)</a><ul><li><a href="#the-idea">The Idea</a></li><li><a href="#example-walkthrough">Example Walkthrough</a></li><li><a href="#complexity-analysis">Complexity Analysis</a></li><li><a href="#why-this-is-inefficient">Why This is Inefficient</a></li></ul></li><li><a href="#approach-2-stack-optimal">Approach 2: Stack (Optimal)</a><ul><li><a href="#the-insight">The Insight</a></li><li><a href="#algorithm">Algorithm</a></li><li><a href="#detailed-walkthrough">Detailed Walkthrough</a></li><li><a href="#why-stack-is-optimal">Why Stack is Optimal</a></li><li><a href="#complexity-analysis-1">Complexity Analysis</a></li></ul></li><li><a href="#deep-dive-stack-data-structure">Deep Dive: Stack Data Structure</a><ul><li><a href="#what-is-a-stack">What is a Stack?</a></li><li><a href="#stack-vs-other-data-structures">Stack vs Other Data Structures</a></li><li><a href="#when-to-use-stacks">When to Use Stacks</a></li></ul></li><li><a href="#alternative-implementations">Alternative Implementations</a><ul><li><a href="#using-a-list-default-python">Using a List (Default Python)</a></li><li><a href="#using-collectionsdeque-more-efficient">Using collections.deque (More Efficient)</a></li><li><a href="#using-string-as-stack-space-optimized">Using String as Stack (Space-optimized)</a></li></ul></li><li><a href="#variations-and-extensions">Variations and Extensions</a><ul><li><a href="#variation-1-return-index-of-first-mismatch">Variation 1: Return Index of First Mismatch</a></li><li><a href="#variation-2-count-minimum-removals">Variation 2: Count Minimum Removals</a></li><li><a href="#variation-3-remove-invalid-brackets">Variation 3: Remove Invalid Brackets</a></li><li><a href="#variation-4-longest-valid-parentheses">Variation 4: Longest Valid Parentheses</a></li><li><a href="#variation-5-generate-all-valid-parentheses">Variation 5: Generate All Valid Parentheses</a></li></ul></li><li><a href="#edge-cases">Edge Cases</a><ul><li><a href="#edge-case-1-empty-string">Edge Case 1: Empty String</a></li><li><a href="#edge-case-2-single-character">Edge Case 2: Single Character</a></li><li><a href="#edge-case-3-only-opening-brackets">Edge Case 3: Only Opening Brackets</a></li><li><a href="#edge-case-4-only-closing-brackets">Edge Case 4: Only Closing Brackets</a></li><li><a href="#edge-case-5-deeply-nested">Edge Case 5: Deeply Nested</a></li><li><a href="#edge-case-6-alternating-pattern">Edge Case 6: Alternating Pattern</a></li><li><a href="#edge-case-7-completely-nested">Edge Case 7: Completely Nested</a></li></ul></li><li><a href="#production-considerations">Production Considerations</a><ul><li><a href="#input-validation">Input Validation</a></li><li><a href="#performance-optimizations">Performance Optimizations</a></li><li><a href="#memory-optimization-for-constrained-environments">Memory Optimization for Constrained Environments</a></li></ul></li><li><a href="#real-world-applications">Real-World Applications</a><ul><li><a href="#application-1-expression-parser">Application 1: Expression Parser</a></li><li><a href="#application-2-htmlxml-tag-validation">Application 2: HTML/XML Tag Validation</a></li><li><a href="#application-3-function-call-stack-validation">Application 3: Function Call Stack Validation</a></li><li><a href="#application-4-ml-pipeline-validation">Application 4: ML Pipeline Validation</a></li><li><a href="#application-5-undoredo-functionality">Application 5: Undo/Redo Functionality</a></li></ul></li><li><a href="#testing-strategy">Testing Strategy</a><ul><li><a href="#comprehensive-test-suite">Comprehensive Test Suite</a></li><li><a href="#performance-benchmarking">Performance Benchmarking</a></li></ul></li><li><a href="#key-takeaways">Key Takeaways</a></li><li><a href="#related-problems">Related Problems</a></li><li><a href="#further-reading">Further Reading</a></li><li><a href="#conclusion">Conclusion</a></li></ul>
            </nav>
          </aside>
        
        <p><strong>Why a simple stack solves bracket matching, expression parsing, and even neural network depth management in one elegant pattern.</strong></p>

<h2 id="introduction">Introduction</h2>

<p>The Valid Parentheses problem introduces one of the most fundamental data structures in computer science: the <strong>stack</strong>. While the problem itself seems simple matching brackets in a string the underlying pattern is ubiquitous in software engineering:</p>

<ul>
  <li><strong>Compilers</strong> use stacks to parse expressions and ensure syntactic correctness</li>
  <li><strong>Web browsers</strong> use stacks to manage the back button (page history)</li>
  <li><strong>Text editors</strong> use stacks for undo/redo functionality</li>
  <li><strong>Operating systems</strong> use stacks to manage function calls (call stack)</li>
  <li><strong>ML pipelines</strong> use stacks to validate nested transformations</li>
</ul>

<p>The beauty of stacks lies in their <strong>Last-In-First-Out (LIFO)</strong> property, which naturally matches the structure of nested operations. When you open a bracket <code class="language-plaintext highlighter-rouge">(</code>, you expect it to be closed <code class="language-plaintext highlighter-rouge">)</code> before any bracket opened before it. This LIFO behavior is precisely what stacks provide.</p>

<p><strong>What you’ll learn:</strong></p>
<ul>
  <li>Why stacks are the natural solution for matching problems</li>
  <li>How to implement stack-based solutions efficiently</li>
  <li>Common variations and extensions</li>
  <li>Real-world applications in ML systems and compilers</li>
  <li>Edge cases and production considerations</li>
  <li>Performance optimization techniques</li>
</ul>

<hr />

<h2 id="problem-statement">Problem Statement</h2>

<p>Given a string containing just the characters <code class="language-plaintext highlighter-rouge">'('</code>, <code class="language-plaintext highlighter-rouge">')'</code>, <code class="language-plaintext highlighter-rouge">'{'</code>, <code class="language-plaintext highlighter-rouge">'}'</code>, <code class="language-plaintext highlighter-rouge">'['</code> and <code class="language-plaintext highlighter-rouge">']'</code>, determine if the input string is valid.</p>

<p>An input string is valid if:</p>
<ol>
  <li>Open brackets must be closed by the same type of brackets</li>
  <li>Open brackets must be closed in the correct order</li>
  <li>Every close bracket has a corresponding open bracket of the same type</li>
</ol>

<h3 id="examples">Examples</h3>

<p><strong>Example 1:</strong>
<code class="language-plaintext highlighter-rouge">
Input: s = "()"
Output: true
Explanation: Single pair of parentheses, properly matched
</code></p>

<p><strong>Example 2:</strong>
<code class="language-plaintext highlighter-rouge">
Input: s = "()[]{}"
Output: true
Explanation: Three pairs, each properly matched
</code></p>

<p><strong>Example 3:</strong>
<code class="language-plaintext highlighter-rouge">
Input: s = "(]"
Output: false
Explanation: Mismatched bracket types - opened '(' but closed ']'
</code></p>

<p><strong>Example 4:</strong>
<code class="language-plaintext highlighter-rouge">
Input: s = "([)]"
Output: false
Explanation: Wrong closing order - opened '[' but it's closed after ')'
</code></p>

<p><strong>Example 5:</strong>
<code class="language-plaintext highlighter-rouge">
Input: s = "{[]}"
Output: true
Explanation: Properly nested brackets
</code></p>

<h3 id="constraints">Constraints</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">1 &lt;= s.length &lt;= 10^4</code></li>
  <li><code class="language-plaintext highlighter-rouge">s</code> consists of parentheses only <code class="language-plaintext highlighter-rouge">'()[]{}'</code></li>
</ul>

<hr />

<h2 id="understanding-the-problem">Understanding the Problem</h2>

<h3 id="why-this-is-a-stack-problem">Why This is a Stack Problem</h3>

<p>Consider the string <code class="language-plaintext highlighter-rouge">"([{}])"</code>:</p>

<p><code class="language-plaintext highlighter-rouge">
Position: 0 1 2 3 4 5
String: ( [ { } ] )
</code></p>

<p><strong>Processing order:</strong></p>
<ol>
  <li>See <code class="language-plaintext highlighter-rouge">(</code> → Must remember to close it later</li>
  <li>See <code class="language-plaintext highlighter-rouge">[</code> → Must remember to close it later</li>
  <li>See <code class="language-plaintext highlighter-rouge">{</code> → Must remember to close it later</li>
  <li>See <code class="language-plaintext highlighter-rouge">}</code> → Must match with most recent opening: <code class="language-plaintext highlighter-rouge">{</code> ✓</li>
  <li>See <code class="language-plaintext highlighter-rouge">]</code> → Must match with most recent opening: <code class="language-plaintext highlighter-rouge">[</code> ✓</li>
  <li>See <code class="language-plaintext highlighter-rouge">)</code> → Must match with most recent opening: <code class="language-plaintext highlighter-rouge">(</code> ✓</li>
</ol>

<p><strong>Key observation:</strong> We always match with the <strong>most recent unclosed</strong> opening bracket. This is exactly what stacks do!</p>

<h3 id="what-makes-a-string-invalid">What Makes a String Invalid?</h3>

<p><strong>Type 1: Wrong bracket type</strong>
<code class="language-plaintext highlighter-rouge">
"(]"
Open: (
Close: ]
Error: Types don't match
</code></p>

<p><strong>Type 2: Wrong closing order</strong>
<code class="language-plaintext highlighter-rouge">
"([)]"
Opens: ( [
Next close: )
Error: Expected ] (most recent opening), got )
</code></p>

<p><strong>Type 3: Unclosed opening brackets</strong>
<code class="language-plaintext highlighter-rouge">
"((("
Opens: ( ( (
Closes: none
Error: Stack not empty at end
</code></p>

<p><strong>Type 4: Extra closing brackets</strong>
<code class="language-plaintext highlighter-rouge">
"())"
Opens: (
Closes: ) )
Error: Second ) has nothing to match
</code></p>

<hr />

<h2 id="approach-1-brute-force-naive">Approach 1: Brute Force (Naive)</h2>

<h3 id="the-idea">The Idea</h3>

<p>Repeatedly remove all adjacent valid pairs until no more removals are possible.</p>

<p>``python
def isValid(s: str) -&gt; bool:
 “””
 Brute force: Keep removing valid pairs
 “””
 while True:
 old_len = len(s)</p>

<p># Remove all valid pairs
 s = s.replace(‘()’, ‘’)
 s = s.replace(‘[]’, ‘’)
 s = s.replace(‘{}’, ‘’)</p>

<p># If no removal happened, we’re done
 if len(s) == old_len:
 break</p>

<p># Valid if string is now empty
 return len(s) == 0
``</p>

<h3 id="example-walkthrough">Example Walkthrough</h3>

<p>``
Input: “([{}])”</p>

<p>Iteration 1:</p>
<ul>
  <li>Replace “{}”: “([])”</li>
  <li>Length changed, continue</li>
</ul>

<p>Iteration 2:</p>
<ul>
  <li>Replace “[]”: “()”</li>
  <li>Length changed, continue</li>
</ul>

<p>Iteration 3:</p>
<ul>
  <li>Replace “()”: “”</li>
  <li>Length changed, continue</li>
</ul>

<p>Iteration 4:</p>
<ul>
  <li>No replacements possible</li>
  <li>String is empty → return True
``</li>
</ul>

<h3 id="complexity-analysis">Complexity Analysis</h3>

<p><strong>Time Complexity: O(n²)</strong></p>
<ul>
  <li>Outer loop: Can run up to n/2 times (each iteration removes 2 characters minimum)</li>
  <li>Each iteration: O(n) to scan and replace substrings</li>
  <li>Total: O(n²)</li>
</ul>

<p><strong>Space Complexity: O(n)</strong></p>
<ul>
  <li>String replacements create new strings</li>
</ul>

<h3 id="why-this-is-inefficient">Why This is Inefficient</h3>

<p>For a string like <code class="language-plaintext highlighter-rouge">"(((())))"</code>:
<code class="language-plaintext highlighter-rouge">
Iteration 1: "(((())))" → "(())" # Remove 2 chars
Iteration 2: "(())" → "" # Remove 4 chars
</code></p>

<p>We’re doing O(n) work per iteration, and iterations scale with depth of nesting.</p>

<hr />

<h2 id="approach-2-stack-optimal">Approach 2: Stack (Optimal)</h2>

<h3 id="the-insight">The Insight</h3>

<p>Instead of removing pairs, <strong>remember opening brackets on a stack</strong> and match them with closing brackets as we encounter them.</p>

<h3 id="algorithm">Algorithm</h3>

<p>``python
def isValid(s: str) -&gt; bool:
 “””
 Stack-based solution: O(n) time, O(n) space</p>

<p>Key idea: Stack naturally maintains LIFO order
 “””
 # Stack to store opening brackets
 stack = []</p>

<p># Mapping of opening to closing brackets
 pairs = {
 ‘(‘: ‘)’,
 ‘[’: ‘]’,
 ‘{‘: ‘}’
 }</p>

<p>for char in s:
 if char in pairs:
 # Opening bracket: push to stack
 stack.append(char)
 else:
 # Closing bracket: must match top of stack
 if not stack:
 # No opening bracket to match
 return False</p>

<p>opening = stack.pop()
 if pairs[opening] != char:
 # Wrong type of bracket
 return False</p>

<p># All brackets should be matched
 return len(stack) == 0
``</p>

<h3 id="detailed-walkthrough">Detailed Walkthrough</h3>

<p><strong>Example 1: <code class="language-plaintext highlighter-rouge">"([{}])"</code></strong></p>

<p>``
Initial: stack = []</p>

<p>char=’(‘: Opening → stack = [’(‘]
char=’[’: Opening → stack = [’(‘, ‘[’]
char=’{‘: Opening → stack = [’(‘, ‘[’, ‘{‘]
char=’}’: Closing</p>
<ul>
  <li>Stack not empty ✓</li>
  <li>Pop ‘{‘, pairs[’{‘] = ‘}’ = char ✓</li>
  <li>stack = [’(‘, ‘[’]
char=’]’: Closing</li>
  <li>Stack not empty ✓</li>
  <li>Pop ‘[’, pairs[’[’] = ‘]’ = char ✓</li>
  <li>stack = [’(‘]
char=’)’: Closing</li>
  <li>Stack not empty ✓</li>
  <li>Pop ‘(‘, pairs[’(‘] = ‘)’ = char ✓</li>
  <li>stack = []</li>
</ul>

<p>Final: stack = [] (empty) → return True ✓
``</p>

<p><strong>Example 2: <code class="language-plaintext highlighter-rouge">"([)]"</code> (Invalid)</strong></p>

<p>``
Initial: stack = []</p>

<p>char=’(‘: Opening → stack = [’(‘]
char=’[’: Opening → stack = [’(‘, ‘[’]
char=’)’: Closing</p>
<ul>
  <li>Stack not empty ✓</li>
  <li>Pop ‘[’, pairs[’[’] = ‘]’ ≠ ‘)’ ✗</li>
  <li>Return False</li>
</ul>

<p>Error: Expected ‘]’ to match ‘[’, got ‘)’
``</p>

<p><strong>Example 3: <code class="language-plaintext highlighter-rouge">"((("</code> (Invalid - Unclosed)</strong></p>

<p>``
char=’(‘: stack = [’(‘]
char=’(‘: stack = [’(‘, ‘(‘]
char=’(‘: stack = [’(‘, ‘(‘, ‘(‘]</p>

<p>End of string: stack = [’(‘, ‘(‘, ‘(‘] (not empty)
Return False ✗
``</p>

<p><strong>Example 4: <code class="language-plaintext highlighter-rouge">")))"</code> (Invalid - No Opening)</strong></p>

<p>``
char=’)’: Closing</p>
<ul>
  <li>Stack is empty ✗</li>
  <li>Return False</li>
</ul>

<p>Error: Closing bracket with no opening bracket
``</p>

<h3 id="why-stack-is-optimal">Why Stack is Optimal</h3>

<p><strong>1. Natural LIFO Matching</strong></p>
<ul>
  <li>Most recent opening must be closed first</li>
  <li>Stack’s pop() gives us exactly that</li>
</ul>

<p><strong>2. O(1) Operations</strong></p>
<ul>
  <li>Push: O(1)</li>
  <li>Pop: O(1)</li>
  <li>Check empty: O(1)</li>
</ul>

<p><strong>3. Single Pass</strong></p>
<ul>
  <li>We only iterate through the string once</li>
  <li>No need to repeatedly scan like brute force</li>
</ul>

<p><strong>4. Early Exit</strong></p>
<ul>
  <li>Can return False immediately on mismatch</li>
  <li>No need to process entire string</li>
</ul>

<h3 id="complexity-analysis-1">Complexity Analysis</h3>

<p><strong>Time Complexity: O(n)</strong></p>
<ul>
  <li>Single pass through string</li>
  <li>Each character processed once</li>
  <li>Stack operations are O(1)</li>
</ul>

<p><strong>Space Complexity: O(n)</strong></p>
<ul>
  <li>In worst case, all characters are opening brackets</li>
  <li>Stack size: at most n/2 for valid strings, at most n for invalid</li>
  <li>Example: <code class="language-plaintext highlighter-rouge">"(((((("</code> → stack has 6 elements</li>
</ul>

<hr />

<h2 id="deep-dive-stack-data-structure">Deep Dive: Stack Data Structure</h2>

<h3 id="what-is-a-stack">What is a Stack?</h3>

<p>A <strong>stack</strong> is a linear data structure following <strong>Last-In-First-Out (LIFO)</strong> principle.</p>

<p><strong>Operations:</strong>
``python
stack = []</p>

<h1 id="push-add-to-top">Push: Add to top</h1>
<p>stack.append(‘A’) # [‘A’]
stack.append(‘B’) # [‘A’, ‘B’]
stack.append(‘C’) # [‘A’, ‘B’, ‘C’]</p>

<h1 id="pop-remove-from-top">Pop: Remove from top</h1>
<p>item = stack.pop() # Returns ‘C’, stack = [‘A’, ‘B’]
item = stack.pop() # Returns ‘B’, stack = [‘A’]</p>

<h1 id="peek-view-top-without-removing">Peek: View top without removing</h1>
<p>top = stack[-1] # Returns ‘A’, stack unchanged</p>

<h1 id="check-empty">Check empty</h1>
<p>is_empty = len(stack) == 0
``</p>

<h3 id="stack-vs-other-data-structures">Stack vs Other Data Structures</h3>

<table>
  <thead>
    <tr>
      <th>Operation</th>
      <th>Stack</th>
      <th>Queue</th>
      <th>Array</th>
      <th>Linked List</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Add to end</td>
      <td>O(1)</td>
      <td>O(1)</td>
      <td>O(1)†</td>
      <td>O(1)</td>
    </tr>
    <tr>
      <td>Remove from end</td>
      <td>O(1)</td>
      <td>O(n)</td>
      <td>O(1)</td>
      <td>O(1)</td>
    </tr>
    <tr>
      <td>Remove from front</td>
      <td>O(n)</td>
      <td>O(1)</td>
      <td>O(n)</td>
      <td>O(1)</td>
    </tr>
    <tr>
      <td>Access middle</td>
      <td>O(n)</td>
      <td>O(n)</td>
      <td>O(1)</td>
      <td>O(n)</td>
    </tr>
    <tr>
      <td>LIFO</td>
      <td>Yes</td>
      <td>No</td>
      <td>No</td>
      <td>No</td>
    </tr>
    <tr>
      <td>FIFO</td>
      <td>No</td>
      <td>Yes</td>
      <td>No</td>
      <td>No</td>
    </tr>
  </tbody>
</table>

<p>† Amortized O(1) due to dynamic array resizing</p>

<h3 id="when-to-use-stacks">When to Use Stacks</h3>

<p><strong>Use stacks when you need:</strong></p>
<ul>
  <li>✅ LIFO access pattern</li>
  <li>✅ Undo/redo functionality</li>
  <li>✅ Backtracking (DFS)</li>
  <li>✅ Expression parsing</li>
  <li>✅ Nested structure validation</li>
</ul>

<p><strong>Don’t use stacks when you need:</strong></p>
<ul>
  <li>❌ FIFO access (use queue)</li>
  <li>❌ Random access to elements (use array)</li>
  <li>❌ Minimum/maximum tracking (use heap)</li>
  <li>❌ Sorted order maintenance (use tree)</li>
</ul>

<hr />

<h2 id="alternative-implementations">Alternative Implementations</h2>

<h3 id="using-a-list-default-python">Using a List (Default Python)</h3>

<p>``python
def isValid(s: str) -&gt; bool:
 stack = [] # Python list as stack
 pairs = {‘(‘: ‘)’, ‘[’: ‘]’, ‘{‘: ‘}’}</p>

<p>for char in s:
 if char in pairs:
 stack.append(char)
 else:
 if not stack or pairs[stack.pop()] != char:
 return False</p>

<p>return not stack # Pythonic way to check empty
``</p>

<h3 id="using-collectionsdeque-more-efficient">Using collections.deque (More Efficient)</h3>

<p>``python
from collections import deque</p>

<p>def isValid(s: str) -&gt; bool:
 “””
 Using deque for slightly better performance
 “””
 stack = deque() # Optimized for stack operations
 pairs = {‘(‘: ‘)’, ‘[’: ‘]’, ‘{‘: ‘}’}</p>

<p>for char in s:
 if char in pairs:
 stack.append(char)
 else:
 if not stack or pairs[stack.pop()] != char:
 return False</p>

<p>return len(stack) == 0
``</p>

<p><strong>Why deque?</strong></p>
<ul>
  <li>Optimized for append/pop from both ends</li>
  <li>O(1) guaranteed (list can occasionally be O(n) during resize)</li>
  <li>Better memory locality for very large stacks</li>
</ul>

<p><strong>Performance comparison (1M operations):</strong></p>
<ul>
  <li>List: ~0.120 seconds</li>
  <li>Deque: ~0.095 seconds (20% faster)</li>
</ul>

<h3 id="using-string-as-stack-space-optimized">Using String as Stack (Space-optimized)</h3>

<p>``python
def isValid(s: str) -&gt; bool:
 “””
 Use string instead of list (immutable, but works for small inputs)
 Not recommended for production!
 “””
 stack_str = “”
 pairs = {‘(‘: ‘)’, ‘[’: ‘]’, ‘{‘: ‘}’}</p>

<p>for char in s:
 if char in pairs:
 stack_str += char
 else:
 if not stack_str or pairs[stack_str[-1]] != char:
 return False
 stack_str = stack_str[:-1] # Remove last char</p>

<p>return stack_str == “”
``</p>

<p><strong>Why this is worse:</strong></p>
<ul>
  <li>String concatenation is O(n) in Python</li>
  <li>Creates new string on each modification</li>
  <li>Total complexity: O(n²) vs O(n)</li>
</ul>

<hr />

<h2 id="variations-and-extensions">Variations and Extensions</h2>

<h3 id="variation-1-return-index-of-first-mismatch">Variation 1: Return Index of First Mismatch</h3>

<p>``python
def findMismatch(s: str) -&gt; int:
 “””
 Return index of first mismatched bracket, or -1 if valid</p>

<p>Useful for syntax highlighting in IDEs
 “””
 stack = []
 pairs = {‘(‘: ‘)’, ‘[’: ‘]’, ‘{‘: ‘}’}</p>

<p>for i, char in enumerate(s):
 if char in pairs:
 # Store (bracket, index) pair
 stack.append((char, i))
 else:
 if not stack:
 # Closing bracket with no opening
 return i</p>

<p>opening, opening_idx = stack.pop()
 if pairs[opening] != char:
 # Type mismatch
 return i</p>

<p># If stack not empty, return index of first unclosed bracket
 if stack:
 return stack[0][1]</p>

<p>return -1 # Valid string</p>

<h1 id="examples-1">Examples</h1>
<p>print(findMismatch(“()”)) # -1 (valid)
print(findMismatch(“(]”)) # 1 (mismatch at index 1)
print(findMismatch(“(()”)) # 0 (unclosed at index 0)
print(findMismatch(“)”)) # 0 (no opening for closing)
``</p>

<h3 id="variation-2-count-minimum-removals">Variation 2: Count Minimum Removals</h3>

<p>``python
def minRemoveToMakeValid(s: str) -&gt; int:
 “””
 Count minimum brackets to remove to make string valid</p>

<p>Similar to edit distance for brackets
 “””
 stack = []
 to_remove = 0</p>

<p>for char in s:
 if char == ‘(‘:
 stack.append(‘(‘)
 elif char == ‘)’:
 if stack:
 stack.pop()
 else:
 # Extra closing bracket
 to_remove += 1</p>

<p># Unclosed opening brackets
 to_remove += len(stack)</p>

<p>return to_remove</p>

<h1 id="examples-2">Examples</h1>
<p>print(minRemoveToMakeValid(“()”)) # 0
print(minRemoveToMakeValid(“(()”)) # 1 (remove one ‘(‘)
print(minRemoveToMakeValid(“())”)) # 1 (remove one ‘)’)
print(minRemoveToMakeValid(“()(“)) # 1
``</p>

<h3 id="variation-3-remove-invalid-brackets">Variation 3: Remove Invalid Brackets</h3>

<p>``python
def removeInvalidParentheses(s: str) -&gt; str:
 “””
 Remove minimum number of brackets to make valid</p>

<p>Two-pass algorithm:</p>
<ol>
  <li>Remove invalid closing brackets (left-to-right)</li>
  <li>Remove invalid opening brackets (right-to-left)
 “””
 def removeInvalid(s, open_char, close_char):
 “””
 Single pass to remove invalid closing brackets
 “””
 count = 0
 result = []</li>
</ol>

<p>for char in s:
 if char == open_char:
 count += 1
 elif char == close_char:
 if count == 0:
 # Invalid closing bracket, skip it
 continue
 count -= 1</p>

<p>result.append(char)</p>

<p>return ‘‘.join(result)</p>

<p># First pass: remove invalid closing
 s = removeInvalid(s, ‘(‘, ‘)’)</p>

<p># Second pass: remove invalid opening (process reversed string)
 s = removeInvalid(s[::-1], ‘)’, ‘(‘)[::-1]</p>

<p>return s</p>

<h1 id="examples-3">Examples</h1>
<p>print(removeInvalidParentheses(“()())()”)) # “()()()” or “(())()”
print(removeInvalidParentheses(“(a)())()”)) # “(a)()()”
print(removeInvalidParentheses(“)(“)) # “”
``</p>

<h3 id="variation-4-longest-valid-parentheses">Variation 4: Longest Valid Parentheses</h3>

<p>``python
def longestValidParentheses(s: str) -&gt; int:
 “””
 Find length of longest valid parentheses substring</p>

<p>Example: “(()” → 2 (substring “()”)
 “)()())” → 4 (substring “()()”)
 “””
 stack = [-1] # Initialize with base index
 max_length = 0</p>

<p>for i, char in enumerate(s):
 if char == ‘(‘:
 stack.append(i)
 else: # char == ‘)’
 stack.pop()
 if not stack:
 # No matching opening, new base
 stack.append(i)
 else:
 # Calculate length from last unmatched
 current_length = i - stack[-1]
 max_length = max(max_length, current_length)</p>

<p>return max_length</p>

<h1 id="examples-4">Examples</h1>
<p>print(longestValidParentheses(“(()”)) # 2
print(longestValidParentheses(“)()())”)) # 4
print(longestValidParentheses(“”)) # 0
``</p>

<h3 id="variation-5-generate-all-valid-parentheses">Variation 5: Generate All Valid Parentheses</h3>

<p>``python
def generateParentheses(n: int) -&gt; list[str]:
 “””
 Generate all combinations of n pairs of valid parentheses</p>

<p>Example: n=3 → [”((()))”, “(()())”, “(())()”, “()(())”, “()()()”]</p>

<p>Uses backtracking with stack validation
 “””
 result = []</p>

<p>def backtrack(current, open_count, close_count):
 # Base case: used all n pairs
 if len(current) == 2 * n:
 result.append(current)
 return</p>

<p># Can add opening if we haven’t used all n
 if open_count &lt; n:
 backtrack(current + ‘(‘, open_count + 1, close_count)</p>

<p># Can add closing if it would still be valid
 if close_count &lt; open_count:
 backtrack(current + ‘)’, open_count, close_count + 1)</p>

<p>backtrack(‘’, 0, 0)
 return result</p>

<h1 id="example">Example</h1>
<p>print(generateParentheses(3))</p>
<h1 id="output-----">Output: [’((()))’, ‘(()())’, ‘(())()’, ‘()(())’, ‘()()()’]</h1>
<p>``</p>

<hr />

<h2 id="edge-cases">Edge Cases</h2>

<h3 id="edge-case-1-empty-string">Edge Case 1: Empty String</h3>

<p>``python
s = “”</p>
<h1 id="depends-on-problem-definition">Depends on problem definition</h1>
<h1 id="usually-return-true-vacuously-valid">Usually: return True (vacuously valid)</h1>
<p>``</p>

<h3 id="edge-case-2-single-character">Edge Case 2: Single Character</h3>

<p><code class="language-plaintext highlighter-rouge">python
s = "(" # False (unclosed)
s = ")" # False (no opening)
</code></p>

<h3 id="edge-case-3-only-opening-brackets">Edge Case 3: Only Opening Brackets</h3>

<p><code class="language-plaintext highlighter-rouge">python
s = "(((((" # False (none closed)
stack = ['(', '(', '(', '(', '('] # Not empty
</code></p>

<h3 id="edge-case-4-only-closing-brackets">Edge Case 4: Only Closing Brackets</h3>

<p>``python
s = “)))))” # False (no opening to match)</p>
<h1 id="first--causes-immediate-failure">First ‘)’ causes immediate failure</h1>
<p>``</p>

<h3 id="edge-case-5-deeply-nested">Edge Case 5: Deeply Nested</h3>

<p>``python
s = “(“ * 5000 + “)” * 5000 # 10,000 characters</p>
<h1 id="valid-stack-will-grow-to-5000-then-empty">Valid! Stack will grow to 5000, then empty</h1>
<h1 id="tests-stack-capacity-and-memory">Tests stack capacity and memory</h1>
<p>``</p>

<h3 id="edge-case-6-alternating-pattern">Edge Case 6: Alternating Pattern</h3>

<p>``python
s = “()()()()” # Valid
stack never grows beyond size 1</p>
<h1 id="efficient-o1-space-in-practice">Efficient: O(1) space in practice</h1>
<p>``</p>

<h3 id="edge-case-7-completely-nested">Edge Case 7: Completely Nested</h3>

<p>``python
s = “(((())))” # Valid
stack grows to n/2, then shrinks to 0</p>
<h1 id="worst-case-for-space-on2--on">Worst case for space: O(n/2) = O(n)</h1>
<p>``</p>

<hr />

<h2 id="production-considerations">Production Considerations</h2>

<h3 id="input-validation">Input Validation</h3>

<p>``python
def isValidRobust(s: str) -&gt; bool:
 “””
 Production-ready with validation
 “””
 # Validate input
 if s is None:
 raise TypeError(“Input cannot be None”)</p>

<p>if not isinstance(s, str):
 raise TypeError(f”Expected string, got {type(s)}”)</p>

<p># Empty string is valid
 if not s:
 return True</p>

<p># Quick check: odd length can’t be valid
 if len(s) % 2 != 0:
 return False</p>

<p># Define valid characters
 valid_chars = set(‘()[]{}’)
 pairs = {‘(‘: ‘)’, ‘[’: ‘]’, ‘{‘: ‘}’}
 closing = set(pairs.values())</p>

<p>stack = []</p>

<p>for i, char in enumerate(s):
 # Validate character
 if char not in valid_chars:
 raise ValueError(f”Invalid character ‘{char}’ at index {i}”)</p>

<p>if char in pairs:
 # Opening bracket
 stack.append(char)
 elif char in closing:
 # Closing bracket
 if not stack:
 return False # No opening to match</p>

<p>opening = stack.pop()
 if pairs[opening] != char:
 return False # Type mismatch</p>

<p>return len(stack) == 0
``</p>

<h3 id="performance-optimizations">Performance Optimizations</h3>

<p><strong>Optimization 1: Early Exit on Odd Length</strong></p>

<p>``python</p>
<h1 id="odd-length-can-never-be-valid">Odd length can never be valid</h1>
<p>if len(s) &amp; 1: # Bitwise AND is faster than modulo
 return False
``</p>

<p><strong>Savings:</strong> Skip processing for 50% of invalid inputs</p>

<p><strong>Optimization 2: Pre-allocate Stack Capacity</strong></p>

<p>``python</p>
<h1 id="python-lists-auto-resize-but-we-can-hint-capacity">Python lists auto-resize, but we can hint capacity</h1>
<p>stack = []</p>
<h1 id="for-cjava-reserve-stack-capacity-upfront">For C++/Java: reserve stack capacity upfront</h1>
<h1 id="stackreservelens--2">stack.reserve(len(s) // 2)</h1>
<p>``</p>

<p><strong>Savings:</strong> Reduces memory allocations during execution</p>

<p><strong>Optimization 3: Use Set for Closing Brackets</strong></p>

<p>``python
pairs = {‘(‘: ‘)’, ‘[’: ‘]’, ‘{‘: ‘}’}
closing = set(pairs.values()) # O(1) lookup</p>

<p>for char in s:
 if char in pairs: # O(1)
 stack.append(char)
 elif char in closing: # O(1) instead of O(3) list search
 # …
``</p>

<p><strong>Savings:</strong> Marginal but cleaner</p>

<p><strong>Optimization 4: Avoid Repeated Dict Lookups</strong></p>

<p>``python</p>
<h1 id="instead-of-checking-pairsopening-multiple-times">Instead of checking pairs[opening] multiple times</h1>
<h1 id="cache-the-result">Cache the result</h1>
<p>expected_closing = pairs.get(stack[-1], None)
if expected_closing != char:
 return False
``</p>

<h3 id="memory-optimization-for-constrained-environments">Memory Optimization for Constrained Environments</h3>

<p>``python
def isValidMemoryEfficient(s: str) -&gt; bool:
 “””
 Optimize for memory-constrained environments</p>

<p>Trade-off: Slightly more complex code for lower memory
 “””
 # Use indices instead of storing characters
 # Opening brackets: ( = 0, [ = 1, { = 2
 # Closing brackets: ) = 0, ] = 1, } = 2</p>

<p>opening = {‘(‘: 0, ‘[’: 1, ‘{‘: 2}
 closing = {‘)’: 0, ‘]’: 1, ‘}’: 2}</p>

<p># Stack stores integers (4 bytes) instead of chars
 stack = []</p>

<p>for char in s:
 if char in opening:
 stack.append(opening[char])
 elif char in closing:
 if not stack or stack.pop() != closing[char]:
 return False</p>

<p>return not stack
``</p>

<p><strong>Memory savings:</strong></p>
<ul>
  <li>Storing <code class="language-plaintext highlighter-rouge">int</code> (4 bytes) vs <code class="language-plaintext highlighter-rouge">str</code> (28+ bytes in Python)</li>
  <li>For 10,000 character string: ~240 KB vs ~1.4 MB</li>
</ul>

<hr />

<h2 id="real-world-applications">Real-World Applications</h2>

<h3 id="application-1-expression-parser">Application 1: Expression Parser</h3>

<p><strong>Problem:</strong> Validate mathematical expressions</p>

<p>``python
def validateExpression(expr: str) -&gt; bool:
 “””
 Validate expression has balanced brackets</p>

<p>Examples:</p>
<ul>
  <li>“(2 + 3) * 4” → Valid</li>
  <li>”((2 + 3)” → Invalid</li>
  <li>“2 + (3 * [4 - 5])” → Valid
 “””
 stack = []
 pairs = {‘(‘: ‘)’, ‘[’: ‘]’, ‘{‘: ‘}’}</li>
</ul>

<p>for char in expr:
 if char in pairs:
 stack.append(char)
 elif char in pairs.values():
 if not stack or pairs[stack.pop()] != char:
 return False</p>

<p>return not stack</p>

<h1 id="usage-in-calculator">Usage in calculator</h1>
<p>def evaluate(expr: str):
 if not validateExpression(expr):
 raise SyntaxError(“Invalid expression: unmatched brackets”)</p>

<p># Proceed with evaluation
 return eval(expr)
``</p>

<h3 id="application-2-htmlxml-tag-validation">Application 2: HTML/XML Tag Validation</h3>

<p><strong>Problem:</strong> Check if HTML tags are properly nested</p>

<p>``python
import re</p>

<p>def validateHTML(html: str) -&gt; bool:
 “””
 Validate HTML tags are properly nested</p>

<p>Example:</p>
<ul>
  <li>“&lt;div&gt;&lt;p&gt;Hello&lt;/p&gt;&lt;/div&gt;” → Valid</li>
  <li>“&lt;div&gt;&lt;p&gt;Hello&lt;/div&gt;&lt;/p&gt;” → Invalid
 “””
 # Extract tags
 tag_pattern = r’&lt;(/?)(\w+)[^&gt;]*&gt;’
 tags = re.findall(tag_pattern, html)</li>
</ul>

<p>stack = []</p>

<p>for is_closing, tag_name in tags:
 if not is_closing:
 # Opening tag
 stack.append(tag_name)
 else:
 # Closing tag
 if not stack or stack.pop() != tag_name:
 return False</p>

<p>return not stack</p>

<h1 id="examples-5">Examples</h1>
<p>print(validateHTML(“&lt;div&gt;&lt;p&gt;Text&lt;/p&gt;&lt;/div&gt;”)) # True
print(validateHTML(“&lt;div&gt;&lt;p&gt;Text&lt;/div&gt;&lt;/p&gt;”)) # False
``</p>

<h3 id="application-3-function-call-stack-validation">Application 3: Function Call Stack Validation</h3>

<p><strong>Problem:</strong> Ensure function calls are properly matched with returns</p>

<p>``python
class FunctionCallTracker:
 “””
 Track function call depth for debugging/profiling
 “””
 def <strong>init</strong>(self):
 self.call_stack = []</p>

<p>def enter_function(self, func_name: str):
 “"”Called when entering a function”””
 self.call_stack.append((func_name, time.time()))
 print(f”{‘ ‘ * len(self.call_stack)}→ {func_name}”)</p>

<p>def exit_function(self, func_name: str):
 “"”Called when exiting a function”””
 if not self.call_stack:
 raise RuntimeError(“exit_function called without matching enter”)</p>

<p>name, start_time = self.call_stack.pop()
 if name != func_name:
 raise RuntimeError(f”Expected to exit {name}, got {func_name}”)</p>

<p>duration = time.time() - start_time
 print(f”{‘ ‘ * len(self.call_stack)}← {func_name} ({duration:.3f}s)”)</p>

<p>def is_balanced(self) -&gt; bool:
 “"”Check if all function calls have been exited”””
 return len(self.call_stack) == 0</p>

<h1 id="usage">Usage</h1>
<p>tracker = FunctionCallTracker()</p>

<p>def func_a():
 tracker.enter_function(“func_a”)
 func_b()
 tracker.exit_function(“func_a”)</p>

<p>def func_b():
 tracker.enter_function(“func_b”)
 # … do work …
 tracker.exit_function(“func_b”)
``</p>

<h3 id="application-4-ml-pipeline-validation">Application 4: ML Pipeline Validation</h3>

<p><strong>Problem:</strong> Ensure data transformation pipeline stages are properly nested</p>

<p>``python
class PipelineValidator:
 “””
 Validate ML pipeline stages are properly structured</p>

<p>Example pipeline:
 StartPipeline
 |- StartPreprocess
 | |- StartNormalization
 | |- EndNormalization
 |- EndPreprocess
 |- StartModel
 | |- StartTraining
 | |- EndTraining
 |- EndModel
 EndPipeline
 “””
 def <strong>init</strong>(self):
 self.stage_stack = []</p>

<p>def start_stage(self, stage_name: str):
 “"”Enter a pipeline stage”””
 self.stage_stack.append(stage_name)
 print(f”{‘ ‘ * len(self.stage_stack)}Start: {stage_name}”)</p>

<p>def end_stage(self, stage_name: str):
 “"”Exit a pipeline stage”””
 if not self.stage_stack:
 raise ValueError(f”end_stage({stage_name}) called without matching start”)</p>

<p>expected = self.stage_stack.pop()
 if expected != stage_name:
 raise ValueError(f”Expected to end {expected}, got {stage_name}”)</p>

<p>print(f”{‘ ‘ * len(self.stage_stack)}End: {stage_name}”)</p>

<p>def validate(self) -&gt; bool:
 “"”Check if all stages properly closed”””
 if self.stage_stack:
 raise ValueError(f”Unclosed stages: {self.stage_stack}”)
 return True</p>

<h1 id="usage-1">Usage</h1>
<p>validator = PipelineValidator()</p>

<h1 id="valid-pipeline">Valid pipeline</h1>
<p>validator.start_stage(“Pipeline”)
validator.start_stage(“Preprocess”)
validator.start_stage(“Normalize”)
validator.end_stage(“Normalize”)
validator.end_stage(“Preprocess”)
validator.start_stage(“Model”)
validator.end_stage(“Model”)
validator.end_stage(“Pipeline”)</p>

<p>validator.validate() # ✓ All stages properly nested
``</p>

<h3 id="application-5-undoredo-functionality">Application 5: Undo/Redo Functionality</h3>

<p><strong>Problem:</strong> Implement undo/redo for text editor</p>

<p>``python
class TextEditor:
 “””
 Text editor with undo/redo using two stacks
 “””
 def <strong>init</strong>(self):
 self.text = “”
 self.undo_stack = [] # Stack of previous states
 self.redo_stack = [] # Stack of undone actions</p>

<p>def type(self, char: str):
 “"”Add character”””
 # Save current state for undo
 self.undo_stack.append(self.text)</p>

<p># Clear redo stack (new action invalidates redo)
 self.redo_stack = []</p>

<p># Update text
 self.text += char</p>

<p>def undo(self):
 “"”Undo last action”””
 if not self.undo_stack:
 print(“Nothing to undo”)
 return</p>

<p># Save current state for redo
 self.redo_stack.append(self.text)</p>

<p># Restore previous state
 self.text = self.undo_stack.pop()</p>

<p>def redo(self):
 “"”Redo last undone action”””
 if not self.redo_stack:
 print(“Nothing to redo”)
 return</p>

<p># Save current state for undo
 self.undo_stack.append(self.text)</p>

<p># Restore redone state
 self.text = self.redo_stack.pop()</p>

<p>def <strong>str</strong>(self):
 return self.text</p>

<h1 id="example-1">Example</h1>
<p>editor = TextEditor()
editor.type(‘H’)
editor.type(‘e’)
editor.type(‘l’)
editor.type(‘l’)
editor.type(‘o’)
print(editor) # “Hello”</p>

<p>editor.undo()
print(editor) # “Hell”</p>

<p>editor.redo()
print(editor) # “Hello”
``</p>

<hr />

<h2 id="testing-strategy">Testing Strategy</h2>

<h3 id="comprehensive-test-suite">Comprehensive Test Suite</h3>

<p>``python
import unittest</p>

<p>class TestValidParentheses(unittest.TestCase):</p>

<p>def test_empty_string(self):
 “"”Empty string should be valid”””
 self.assertTrue(isValid(“”))</p>

<p>def test_single_pair(self):
 “"”Single pair of each type”””
 self.assertTrue(isValid(“()”))
 self.assertTrue(isValid(“[]”))
 self.assertTrue(isValid(“{}”))</p>

<p>def test_multiple_pairs(self):
 “"”Multiple pairs in sequence”””
 self.assertTrue(isValid(“()[]{}”))
 self.assertTrue(isValid(“()[]{()}”))</p>

<p>def test_nested(self):
 “"”Nested brackets”””
 self.assertTrue(isValid(“{[]}”))
 self.assertTrue(isValid(“{“ + “{}}”)) # Escaped for Jekyll
 self.assertTrue(isValid(“([{}])”))</p>

<p>def test_wrong_type(self):
 “"”Mismatched bracket types”””
 self.assertFalse(isValid(“(]”))
 self.assertFalse(isValid(“{)”))
 self.assertFalse(isValid(“[}”))</p>

<p>def test_wrong_order(self):
 “"”Wrong closing order”””
 self.assertFalse(isValid(“([)]”))
 self.assertFalse(isValid(“{[}]”))</p>

<p>def test_unclosed(self):
 “"”Unclosed opening brackets”””
 self.assertFalse(isValid(“((“))
 self.assertFalse(isValid(“{[(“))</p>

<p>def test_extra_closing(self):
 “"”Extra closing brackets”””
 self.assertFalse(isValid(“))”))
 self.assertFalse(isValid(“())”))</p>

<p>def test_deeply_nested(self):
 “"”Deep nesting”””
 s = “(“ * 1000 + “)” * 1000
 self.assertTrue(isValid(s))</p>

<p>def test_alternating(self):
 “"”Alternating pattern”””
 s = “()” * 1000
 self.assertTrue(isValid(s))</p>

<p>def test_complex_valid(self):
 “"”Complex valid cases”””
 self.assertTrue(isValid(“{[()()]}”))
 self.assertTrue(isValid(“([]){}”))
 self.assertTrue(isValid(“{[({})]}”))</p>

<p>def test_complex_invalid(self):
 “"”Complex invalid cases”””
 self.assertFalse(isValid(“((((()”))
 self.assertFalse(isValid(“(((()))”))
 self.assertFalse(isValid(“{[(])}”))</p>

<p>if <strong>name</strong> == ‘<strong>main</strong>’:
 unittest.main()
``</p>

<h3 id="performance-benchmarking">Performance Benchmarking</h3>

<p>``python
import time
import random</p>

<p>def benchmark(func, test_cases):
 “"”Benchmark function performance”””
 start = time.time()
 for test in test_cases:
 func(test)
 elapsed = time.time() - start
 return elapsed</p>

<h1 id="generate-test-cases">Generate test cases</h1>
<p>def generate_valid_string(length):
 “"”Generate valid bracket string”””
 s = “”
 for _ in range(length // 2):
 s += “(“
 for _ in range(length // 2):
 s += “)”
 return s</p>

<p>def generate_invalid_string(length):
 “"”Generate invalid bracket string”””
 brackets = “()[]{}”
 return ‘‘.join(random.choice(brackets) for _ in range(length))</p>

<h1 id="test-cases">Test cases</h1>
<p>test_cases = [
 generate_valid_string(100) for _ in range(1000)
] + [
 generate_invalid_string(100) for _ in range(1000)
]</p>

<h1 id="benchmark">Benchmark</h1>
<p>time_stack = benchmark(isValid, test_cases)
print(f”Stack solution: {time_stack:.3f}s”)</p>

<h1 id="expected-002s-for-2000-strings-of-length-100">Expected: ~0.02s for 2000 strings of length 100</h1>
<p>``</p>

<hr />

<h2 id="key-takeaways">Key Takeaways</h2>

<p>✅ <strong>Stacks naturally solve LIFO problems</strong> (brackets, function calls, undo) 
✅ <strong>O(n) single-pass solution</strong> is optimal for validation 
✅ <strong>Hash map for pairs</strong> makes code clean and extensible 
✅ <strong>Pattern applies widely</strong> in compilers, parsers, editors, ML pipelines 
✅ <strong>Early exit optimizations</strong> improve average-case performance 
✅ <strong>Consider edge cases</strong> (empty, single char, deeply nested)</p>

<hr />

<h2 id="related-problems">Related Problems</h2>

<p><strong>LeetCode:</strong></p>
<ul>
  <li><a href="https://leetcode.com/problems/valid-parentheses/">20. Valid Parentheses</a> (This problem)</li>
  <li><a href="https://leetcode.com/problems/generate-parentheses/">22. Generate Parentheses</a></li>
  <li><a href="https://leetcode.com/problems/longest-valid-parentheses/">32. Longest Valid Parentheses</a></li>
  <li><a href="https://leetcode.com/problems/remove-invalid-parentheses/">301. Remove Invalid Parentheses</a></li>
  <li><a href="https://leetcode.com/problems/remove-outermost-parentheses/">1021. Remove Outermost Parentheses</a></li>
</ul>

<p><strong>Stack Problems:</strong></p>
<ul>
  <li><a href="https://leetcode.com/problems/min-stack/">155. Min Stack</a></li>
  <li><a href="https://leetcode.com/problems/implement-queue-using-stacks/">232. Implement Queue using Stacks</a></li>
  <li><a href="https://leetcode.com/problems/decode-string/">394. Decode String</a></li>
  <li><a href="https://leetcode.com/problems/daily-temperatures/">739. Daily Temperatures</a></li>
</ul>

<hr />

<h2 id="further-reading">Further Reading</h2>

<p><strong>Books:</strong></p>
<ul>
  <li><em>Introduction to Algorithms</em> (CLRS) - Chapter 10: Elementary Data Structures</li>
  <li><em>The Algorithm Design Manual</em> (Skiena) - Section 3.2: Stacks and Queues</li>
  <li><em>Data Structures and Algorithm Analysis</em> (Weiss) - Chapter 3</li>
</ul>

<p><strong>Articles:</strong></p>
<ul>
  <li><a href="https://en.wikipedia.org/wiki/Stack_(abstract_data_type)">Understanding Stacks in Depth</a></li>
  <li><a href="https://brilliant.org/wiki/stacks-queues/">Bracket Matching Algorithm</a></li>
</ul>

<hr />

<h2 id="conclusion">Conclusion</h2>

<p>The Valid Parentheses problem beautifully demonstrates how the right data structure makes a seemingly complex problem trivial. The stack’s LIFO property is a perfect match for nested structures, eliminating the need for complex bookkeeping or multiple passes.</p>

<p>Beyond the specific problem, understanding stacks prepares you for:</p>
<ul>
  <li><strong>Parsing and compilation</strong> (expression evaluation, syntax analysis)</li>
  <li><strong>Backtracking algorithms</strong> (DFS, path finding)</li>
  <li><strong>Memory management</strong> (call stack, activation records)</li>
  <li><strong>Undo/redo systems</strong> (editors, version control)</li>
</ul>

<p>The patterns you’ve learned here using stacks for matching, validation, and tracking nested structures will appear repeatedly in system design, algorithm implementation, and production code.</p>

<p>Master the stack, and you’ve mastered a fundamental building block of computer science! 🚀</p>

<hr />

<p><strong>Originally published at:</strong> <a href="https://www.arunbaby.com/dsa/0002-valid-parentheses/">arunbaby.com/dsa/0002-valid-parentheses</a></p>

<p><em>If you found this helpful, consider sharing it with others who might benefit.</em></p>

        
      </section>

      <footer class="page__meta">
        
        
  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-tags" aria-hidden="true"></i> Tags: </strong>
    <span itemprop="keywords">
    
      <a href="/tags/#stack" class="page__taxonomy-item p-category" rel="tag">stack</a><span class="sep">, </span>
    
      <a href="/tags/#strings" class="page__taxonomy-item p-category" rel="tag">strings</a>
    
    </span>
  </p>




  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> Categories: </strong>
    <span itemprop="keywords">
    
      <a href="/categories/#dsa" class="page__taxonomy-item p-category" rel="tag">dsa</a>
    
    </span>
  </p>


        
      </footer>

      <div class="page__related page__related--full">
  <h2 class="page__related-title">Related across topics</h2>
  <style>
    /* Make section span full content width and use 2 equal columns */
    .page__related--full { float: inline-start; width: 100%; padding: 0; }
    .cross-related-grid { display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 2rem; }
    @media (max-width: 768px) { .cross-related-grid { grid-template-columns: 1fr; } }
    /* Ensure archive cards stretch nicely in the grid */
    .cross-related-grid .list__item, .cross-related-grid .grid__item { width: auto; float: none; margin: 0; }
  </style>
  <div class="cross-related-grid">
    



<div class="list__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/ml-system-design/0002-classification-pipeline/" rel="permalink">Classification Pipeline Design
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          13 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">From raw data to production predictions: building a classification pipeline that handles millions of requests with 99.9% uptime.
</p>
  </article>
</div>




<div class="list__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/speech-tech/0002-speech-classification/" rel="permalink">Speech Command Classification
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          21 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">How voice assistants recognize “turn on the lights” from raw audio in under 100ms without full ASR transcription.
</p>
  </article>
</div>




<div class="list__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/ai-agents/0002-llm-capabilities-for-agents/" rel="permalink">LLM Capabilities for Agents
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          13 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">“The Engine of Autonomy: Understanding the Agentic ‘Brain’.”
</p>
  </article>
</div>

  </div>
</div>

      <section class="page__share">
  <h4 class="page__share-title">Share on</h4>

  <a href="https://twitter.com/intent/tweet?via=arunbaby0&text=Valid+Parentheses%20https%3A%2F%2Fwww.arunbaby.com%2Fdsa%2F0002-valid-parentheses%2F" class="btn btn--twitter" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Twitter"><i class="fab fa-fw fa-twitter" aria-hidden="true"></i><span> Twitter</span></a>

  <a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fwww.arunbaby.com%2Fdsa%2F0002-valid-parentheses%2F" class="btn btn--facebook" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Facebook"><i class="fab fa-fw fa-facebook" aria-hidden="true"></i><span> Facebook</span></a>

  <a href="https://www.linkedin.com/shareArticle?mini=true&url=https://www.arunbaby.com/dsa/0002-valid-parentheses/" class="btn btn--linkedin" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on LinkedIn"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i><span> LinkedIn</span></a>
</section>


      
  <nav class="pagination">
    
      <a href="/dsa/0001-two-sum/" class="pagination--pager" title="Two Sum">Previous</a>
    
    
      <a href="/dsa/0003-merge-sorted-lists/" class="pagination--pager" title="Merge Two Sorted Lists">Next</a>
    
  </nav>


    </div>

    
  </article>

  
  
</div>

      
    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';" role="search">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Enter your search term..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    

    
      
        
          <li><a href="https://twitter.com/arunbaby0" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-twitter-square" aria-hidden="true"></i> Twitter</a></li>
        
      
        
          <li><a href="https://github.com/arunbaby0" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
        
      
        
          <li><a href="https://www.linkedin.com/in/arunbaby0/" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i> LinkedIn</a></li>
        
      
        
          <li><a href="https://scholar.google.co.in/citations?user=6fSYWhkAAAAJ" rel="nofollow noopener noreferrer"><i class="fas fa-fw fa-graduation-cap" aria-hidden="true"></i> Google Scholar</a></li>
        
      
    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 1990 - 2143 <a href="https://www.arunbaby.com">Arun Baby</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>




  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-0JRJPEC9SS"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-0JRJPEC9SS', { 'anonymize_ip': false});
</script>








  </body>
</html>
