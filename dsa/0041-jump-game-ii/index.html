<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.26.2 by Michael Rose
  Copyright 2013-2024 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->

<html lang="en-US" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Jump Game II - Arun Baby</title>
<meta name="description" content="“Finding the optimal path through a sequence of choices.”">


  <meta name="author" content="Arun Baby">
  
  <meta property="article:author" content="Arun Baby">
  


<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="Arun Baby">
<meta property="og:title" content="Jump Game II">
<meta property="og:url" content="https://www.arunbaby.com/dsa/0041-jump-game-ii/">


  <meta property="og:description" content="“Finding the optimal path through a sequence of choices.”">



  <meta property="og:image" content="https://www.arunbaby.com/assets/images/profile-photo.png">



  <meta name="twitter:site" content="@arunbaby0">
  <meta name="twitter:title" content="Jump Game II">
  <meta name="twitter:description" content="“Finding the optimal path through a sequence of choices.”">
  <meta name="twitter:url" content="https://www.arunbaby.com/dsa/0041-jump-game-ii/">

  
    <meta name="twitter:card" content="summary">
    
      <meta name="twitter:image" content="https://www.arunbaby.com/assets/images/profile-photo.png">
    
  

  



  <meta property="article:published_time" content="2025-12-31T10:08:45+05:30">





  

  


<link rel="canonical" href="https://www.arunbaby.com/dsa/0041-jump-game-ii/">












<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Arun Baby Feed">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
  
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css"></noscript>



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--single" dir="ltr">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
           
          <span class="site-subtitle">Arun Baby</span>
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a
                href="/about/"
                
                
              >About</a>
            </li><li class="masthead__menu-item">
              <a
                href="/dsa/"
                
                
              >DSA</a>
            </li><li class="masthead__menu-item">
              <a
                href="/ml-system-design/"
                
                
              >ML Systems</a>
            </li><li class="masthead__menu-item">
              <a
                href="/speech-tech/"
                
                
              >Speech Tech</a>
            </li><li class="masthead__menu-item">
              <a
                href="/ai-agents/"
                
                
              >AI Agents</a>
            </li><li class="masthead__menu-item">
              <a
                href="/publications/"
                
                
              >Publications</a>
            </li><li class="masthead__menu-item">
              <a
                href="/statuses/"
                
                
              >Statuses</a>
            </li><li class="masthead__menu-item">
              <a
                href="/contact/"
                
                
              >Contact</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <i class="fas fa-search"></i>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      





<div id="main" role="main" class="no-author-sidebar">
  
  <div class="sidebar sticky">
  
  
  </div>



  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="Jump Game II">
    <meta itemprop="description" content="“Finding the optimal path through a sequence of choices.”">
    <meta itemprop="datePublished" content="2025-12-31T10:08:45+05:30">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">
            <a href="https://www.arunbaby.com/dsa/0041-jump-game-ii/" itemprop="url">Jump Game II
</a>
          </h1>
          

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          24 minute read
        
      </span>
    
  </p>


        </header>
      

      <section class="page__content" itemprop="text">
        
          <aside class="sidebar__right sticky">
            <nav class="toc">
              <header><h4 class="nav__title"><i class="fas fa-file-alt"></i> On this page</h4></header>
              <ul class="toc__menu"><li><a href="#1-problem-statement">1. Problem Statement</a></li><li><a href="#2-intuition">2. Intuition</a></li><li><a href="#3-approach-1-greedy-optimal">3. Approach 1: Greedy (Optimal)</a></li><li><a href="#4-approach-2-bfs-level-order-traversal">4. Approach 2: BFS (Level-Order Traversal)</a></li><li><a href="#5-approach-3-dynamic-programming">5. Approach 3: Dynamic Programming</a></li><li><a href="#6-deep-dive-why-greedy-works-proof">6. Deep Dive: Why Greedy Works (Proof)</a></li><li><a href="#7-detailed-walkthrough">7. Detailed Walkthrough</a></li><li><a href="#8-variant-jump-game-i-can-reach">8. Variant: Jump Game I (Can Reach?)</a></li><li><a href="#9-variant-jump-game-iii-reach-zero">9. Variant: Jump Game III (Reach Zero)</a></li><li><a href="#10-system-design-pathfinding-in-games">10. System Design: Pathfinding in Games</a></li><li><a href="#11-deep-dive-jump-game-with-costs">11. Deep Dive: Jump Game with Costs</a></li><li><a href="#12-interview-questions">12. Interview Questions</a></li><li><a href="#13-common-mistakes">13. Common Mistakes</a></li><li><a href="#14-performance-comparison">14. Performance Comparison</a></li><li><a href="#15-deep-dive-jump-game-iv-bfs-with-hashmap">15. Deep Dive: Jump Game IV (BFS with HashMap)</a></li><li><a href="#16-deep-dive-frog-jump-dp-with-set">16. Deep Dive: Frog Jump (DP with Set)</a></li><li><a href="#17-production-application-route-optimization">17. Production Application: Route Optimization</a></li><li><a href="#18-production-application-network-packet-routing">18. Production Application: Network Packet Routing</a></li><li><a href="#19-advanced-variant-jump-game-with-obstacles">19. Advanced Variant: Jump Game with Obstacles</a></li><li><a href="#20-mathematical-analysis-expected-jumps">20. Mathematical Analysis: Expected Jumps</a></li><li><a href="#21-parallel-algorithm-jump-game-on-gpu">21. Parallel Algorithm: Jump Game on GPU</a></li><li><a href="#22-interview-deep-dive-jump-game-v">22. Interview Deep Dive: Jump Game V</a></li><li><a href="#23-conclusion">23. Conclusion</a></li><li><a href="#24-advanced-variant-jump-game-vi-dp-with-deque">24. Advanced Variant: Jump Game VI (DP with Deque)</a></li><li><a href="#25-advanced-variant-jump-game-vii-string-with-constraints">25. Advanced Variant: Jump Game VII (String with Constraints)</a></li><li><a href="#26-competitive-programming-jump-game-speedrun">26. Competitive Programming: Jump Game Speedrun</a></li><li><a href="#27-interview-strategy-recognizing-jump-game-patterns">27. Interview Strategy: Recognizing Jump Game Patterns</a></li><li><a href="#28-code-template-universal-jump-game-solver">28. Code Template: Universal Jump Game Solver</a></li><li><a href="#29-testing-strategy">29. Testing Strategy</a></li><li><a href="#30-common-interview-follow-ups">30. Common Interview Follow-ups</a></li><li><a href="#31-optimization-space-efficient-dp">31. Optimization: Space-Efficient DP</a></li><li><a href="#32-conclusion--summary">32. Conclusion &amp; Summary</a></li></ul>
            </nav>
          </aside>
        
        <p><strong>“Finding the optimal path through a sequence of choices.”</strong></p>

<h2 id="1-problem-statement">1. Problem Statement</h2>

<p>You are given a <strong>0-indexed</strong> array of integers <code class="language-plaintext highlighter-rouge">nums</code> of length <code class="language-plaintext highlighter-rouge">n</code>. You are initially positioned at <code class="language-plaintext highlighter-rouge">nums[0]</code>.</p>

<p>Each element <code class="language-plaintext highlighter-rouge">nums[i]</code> represents the <strong>maximum</strong> length of a forward jump from index <code class="language-plaintext highlighter-rouge">i</code>. In other words, if you are at <code class="language-plaintext highlighter-rouge">nums[i]</code>, you can jump to any <code class="language-plaintext highlighter-rouge">nums[i + j]</code> where:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">0 &lt;= j &lt;= nums[i]</code></li>
  <li><code class="language-plaintext highlighter-rouge">i + j &lt; n</code></li>
</ul>

<p>Return the <strong>minimum number of jumps</strong> to reach <code class="language-plaintext highlighter-rouge">nums[n - 1]</code>. The test cases are generated such that you can reach <code class="language-plaintext highlighter-rouge">nums[n - 1]</code>.</p>

<p><strong>Example 1:</strong>
<code class="language-plaintext highlighter-rouge">
Input: nums = [2,3,1,1,4]
Output: 2
Explanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.
</code></p>

<p><strong>Example 2:</strong>
<code class="language-plaintext highlighter-rouge">
Input: nums = [2,3,0,1,4]
Output: 2
</code></p>

<p><strong>Constraints:</strong></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">1 &lt;= nums.length &lt;= 10^4</code></li>
  <li><code class="language-plaintext highlighter-rouge">0 &lt;= nums[i] &lt;= 1000</code></li>
  <li>It’s guaranteed that you can reach <code class="language-plaintext highlighter-rouge">nums[n-1]</code>.</li>
</ul>

<h2 id="2-intuition">2. Intuition</h2>

<p>This is a classic <strong>Greedy</strong> problem disguised as a graph traversal.</p>

<p><strong>Key Insight:</strong> At each position, we want to jump to the position that allows us to reach the farthest in the next jump. This is a <strong>local greedy choice</strong> that leads to a <strong>global optimal solution</strong>.</p>

<p>Think of it as BFS where each “level” represents the positions reachable with <code class="language-plaintext highlighter-rouge">k</code> jumps.</p>

<h2 id="3-approach-1-greedy-optimal">3. Approach 1: Greedy (Optimal)</h2>

<p><strong>Idea:</strong> We maintain the farthest position we can reach with the current number of jumps. When we exhaust the current range, we increment the jump count.</p>

<p><strong>Algorithm:</strong></p>
<ol>
  <li>Initialize <code class="language-plaintext highlighter-rouge">jumps = 0</code>, <code class="language-plaintext highlighter-rouge">current_end = 0</code> (end of current jump range), <code class="language-plaintext highlighter-rouge">farthest = 0</code> (farthest we can reach).</li>
  <li>Iterate through the array (except the last element, since we’re already there if we reach it).</li>
  <li>For each position <code class="language-plaintext highlighter-rouge">i</code>:
    <ul>
      <li>Update <code class="language-plaintext highlighter-rouge">farthest = max(farthest, i + nums[i])</code>.</li>
      <li>If <code class="language-plaintext highlighter-rouge">i == current_end</code> (we’ve exhausted the current jump range):</li>
      <li>Increment <code class="language-plaintext highlighter-rouge">jumps</code>.</li>
      <li>Set <code class="language-plaintext highlighter-rouge">current_end = farthest</code> (start a new jump range).</li>
    </ul>
  </li>
  <li>Return <code class="language-plaintext highlighter-rouge">jumps</code>.</li>
</ol>

<p>``python
class Solution:
 def jump(self, nums: List[int]) -&gt; int:
 n = len(nums)
 if n == 1:
 return 0</p>

<p>jumps = 0
 current_end = 0
 farthest = 0</p>

<p>for i in range(n - 1): # Don’t need to check the last element
 farthest = max(farthest, i + nums[i])</p>

<p>if i == current_end:
 jumps += 1
 current_end = farthest</p>

<p># Early exit if we can already reach the end
 if current_end &gt;= n - 1:
 break</p>

<p>return jumps
``</p>

<p><strong>Complexity:</strong></p>
<ul>
  <li><strong>Time:</strong> O(N). Single pass through the array.</li>
  <li><strong>Space:</strong> O(1). Constant extra space.</li>
</ul>

<h2 id="4-approach-2-bfs-level-order-traversal">4. Approach 2: BFS (Level-Order Traversal)</h2>

<p>We can model this as a graph where each index is a node, and there’s an edge from <code class="language-plaintext highlighter-rouge">i</code> to <code class="language-plaintext highlighter-rouge">j</code> if <code class="language-plaintext highlighter-rouge">j &lt;= i + nums[i]</code>.</p>

<p><strong>Algorithm:</strong></p>
<ol>
  <li>Use BFS. Each level represents positions reachable with <code class="language-plaintext highlighter-rouge">k</code> jumps.</li>
  <li>For each level, find the farthest position reachable.</li>
  <li>If the farthest position reaches or exceeds <code class="language-plaintext highlighter-rouge">n-1</code>, return the level count.</li>
</ol>

<p>``python
from collections import deque</p>

<p>class Solution:
 def jump(self, nums: List[int]) -&gt; int:
 n = len(nums)
 if n == 1:
 return 0</p>

<p>queue = deque([0])
 visited = {0}
 jumps = 0</p>

<p>while queue:
 size = len(queue)
 jumps += 1</p>

<p>for _ in range(size):
 i = queue.popleft()</p>

<p># Try all possible jumps from position i
 for j in range(i + 1, min(i + nums[i] + 1, n)):
 if j == n - 1:
 return jumps
 if j not in visited:
 visited.add(j)
 queue.append(j)</p>

<p>return jumps
``</p>

<p><strong>Complexity:</strong></p>
<ul>
  <li><strong>Time:</strong> O(N^2) in worst case (e.g., <code class="language-plaintext highlighter-rouge">[1,1,1,1,1]</code>).</li>
  <li><strong>Space:</strong> O(N) for the queue and visited set.</li>
</ul>

<h2 id="5-approach-3-dynamic-programming">5. Approach 3: Dynamic Programming</h2>

<p>Define <code class="language-plaintext highlighter-rouge">dp[i]</code> = minimum jumps to reach index <code class="language-plaintext highlighter-rouge">i</code>.</p>

<p><strong>Transition:</strong>
For each position <code class="language-plaintext highlighter-rouge">i</code>, we can jump to any position <code class="language-plaintext highlighter-rouge">j</code> where <code class="language-plaintext highlighter-rouge">i &lt; j &lt;= i + nums[i]</code>.
<code class="language-plaintext highlighter-rouge">dp[j] = min(dp[j], dp[i] + 1)</code>.</p>

<p>``python
class Solution:
 def jump(self, nums: List[int]) -&gt; int:
 n = len(nums)
 dp = [float(‘inf’)] * n
 dp[0] = 0</p>

<p>for i in range(n):
 for j in range(i + 1, min(i + nums[i] + 1, n)):
 dp[j] = min(dp[j], dp[i] + 1)</p>

<p>return dp[n - 1]
``</p>

<p><strong>Complexity:</strong></p>
<ul>
  <li><strong>Time:</strong> O(N \times M) where <code class="language-plaintext highlighter-rouge">M</code> is the average jump length. Worst case O(N^2).</li>
  <li><strong>Space:</strong> O(N) for the DP array.</li>
</ul>

<h2 id="6-deep-dive-why-greedy-works-proof">6. Deep Dive: Why Greedy Works (Proof)</h2>

<p><strong>Claim:</strong> The greedy algorithm always finds the minimum number of jumps.</p>

<p><strong>Proof by Exchange Argument:</strong>
Suppose the greedy algorithm produces a solution with <code class="language-plaintext highlighter-rouge">k</code> jumps: <code class="language-plaintext highlighter-rouge">0 \to i_1 \to i_2 \to \dots \to i_k = n-1</code>.
Suppose there exists an optimal solution with fewer jumps: <code class="language-plaintext highlighter-rouge">0 \to j_1 \to j_2 \to \dots \to j_m = n-1</code> where <code class="language-plaintext highlighter-rouge">m &lt; k</code>.</p>

<p>Consider the first position where the two solutions differ. Let’s say the greedy chooses <code class="language-plaintext highlighter-rouge">i_1</code> and the optimal chooses <code class="language-plaintext highlighter-rouge">j_1</code>.
By the greedy choice, <code class="language-plaintext highlighter-rouge">i_1</code> is the farthest position reachable from 0. Therefore, <code class="language-plaintext highlighter-rouge">j_1 \leq i_1</code>.</p>

<p>Now, from <code class="language-plaintext highlighter-rouge">j_1</code>, the optimal solution reaches <code class="language-plaintext highlighter-rouge">j_2</code>. But since <code class="language-plaintext highlighter-rouge">j_1 \leq i_1</code>, and the greedy algorithm considers all positions reachable from <code class="language-plaintext highlighter-rouge">i_1</code>, it must be that the greedy can also reach <code class="language-plaintext highlighter-rouge">j_2</code> (or farther) in the next jump.</p>

<p>By induction, we can show that the greedy solution reaches at least as far as the optimal solution at each step. Since both reach <code class="language-plaintext highlighter-rouge">n-1</code>, and the greedy makes the farthest jump at each step, it cannot make more jumps than the optimal.</p>

<p><strong>Contradiction.</strong> Therefore, the greedy algorithm is optimal.</p>

<h2 id="7-detailed-walkthrough">7. Detailed Walkthrough</h2>

<p>Let’s trace <code class="language-plaintext highlighter-rouge">nums = [2, 3, 1, 1, 4]</code>.</p>

<p><strong>Initial State:</strong></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">jumps = 0</code>, <code class="language-plaintext highlighter-rouge">current_end = 0</code>, <code class="language-plaintext highlighter-rouge">farthest = 0</code>.</li>
</ul>

<p><strong>Iteration:</strong></p>
<ol>
  <li><code class="language-plaintext highlighter-rouge">i = 0</code>: <code class="language-plaintext highlighter-rouge">farthest = max(0, 0 + 2) = 2</code>. <code class="language-plaintext highlighter-rouge">i == current_end</code>, so <code class="language-plaintext highlighter-rouge">jumps = 1</code>, <code class="language-plaintext highlighter-rouge">current_end = 2</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">i = 1</code>: <code class="language-plaintext highlighter-rouge">farthest = max(2, 1 + 3) = 4</code>. <code class="language-plaintext highlighter-rouge">i &lt; current_end</code>, so no jump yet.</li>
  <li><code class="language-plaintext highlighter-rouge">i = 2</code>: <code class="language-plaintext highlighter-rouge">farthest = max(4, 2 + 1) = 4</code>. <code class="language-plaintext highlighter-rouge">i == current_end</code>, so <code class="language-plaintext highlighter-rouge">jumps = 2</code>, <code class="language-plaintext highlighter-rouge">current_end = 4</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">i = 3</code>: We’ve reached <code class="language-plaintext highlighter-rouge">n - 1 = 4</code> with <code class="language-plaintext highlighter-rouge">current_end = 4</code>, so we stop.</li>
</ol>

<p><strong>Result:</strong> <code class="language-plaintext highlighter-rouge">jumps = 2</code>.</p>

<p><strong>Path:</strong> <code class="language-plaintext highlighter-rouge">0 \to 1 \to 4</code> (Jump to index 1, then jump to index 4).</p>

<h2 id="8-variant-jump-game-i-can-reach">8. Variant: Jump Game I (Can Reach?)</h2>

<p><strong>Problem:</strong> Given <code class="language-plaintext highlighter-rouge">nums</code>, return <code class="language-plaintext highlighter-rouge">true</code> if you can reach the last index.</p>

<p><strong>Greedy Solution:</strong>
<code class="language-plaintext highlighter-rouge">python
def canJump(nums):
 farthest = 0
 for i in range(len(nums)):
 if i &gt; farthest:
 return False # Can't reach position i
 farthest = max(farthest, i + nums[i])
 if farthest &gt;= len(nums) - 1:
 return True
 return True
</code></p>

<h2 id="9-variant-jump-game-iii-reach-zero">9. Variant: Jump Game III (Reach Zero)</h2>

<p><strong>Problem:</strong> Given <code class="language-plaintext highlighter-rouge">arr</code> and <code class="language-plaintext highlighter-rouge">start</code>, you can jump to <code class="language-plaintext highlighter-rouge">start + arr[start]</code> or <code class="language-plaintext highlighter-rouge">start - arr[start]</code>. Return <code class="language-plaintext highlighter-rouge">true</code> if you can reach any index with value 0.</p>

<p><strong>BFS Solution:</strong>
``python
from collections import deque</p>

<p>def canReach(arr, start):
 n = len(arr)
 queue = deque([start])
 visited = {start}</p>

<p>while queue:
 i = queue.popleft()
 if arr[i] == 0:
 return True</p>

<p>for next_i in [i + arr[i], i - arr[i]]:
 if 0 &lt;= next_i &lt; n and next_i not in visited:
 visited.add(next_i)
 queue.append(next_i)</p>

<p>return False
``</p>

<h2 id="10-system-design-pathfinding-in-games">10. System Design: Pathfinding in Games</h2>

<p>Jump Game II is essentially a simplified version of pathfinding algorithms used in game AI.</p>

<p><strong>Real-World Application: Platformer Games</strong></p>
<ul>
  <li><strong>Problem:</strong> Find the shortest sequence of jumps for a character to reach a goal.</li>
  <li><strong>Constraints:</strong> Jump height, gravity, obstacles.</li>
  <li><strong>Algorithm:</strong> A* search with heuristic = Manhattan distance to goal.</li>
</ul>

<p><strong>Optimization:</strong></p>
<ul>
  <li><strong>Precompute Reachability Graph:</strong> For static levels, precompute which platforms are reachable from each platform.</li>
  <li><strong>Caching:</strong> Cache optimal paths for frequently visited platform pairs.</li>
</ul>

<h2 id="11-deep-dive-jump-game-with-costs">11. Deep Dive: Jump Game with Costs</h2>

<p><strong>Problem:</strong> Each jump from <code class="language-plaintext highlighter-rouge">i</code> to <code class="language-plaintext highlighter-rouge">j</code> has a cost <code class="language-plaintext highlighter-rouge">cost[i][j]</code>. Find the minimum cost to reach the end.</p>

<p><strong>Algorithm:</strong> Dijkstra’s Algorithm.
``python
import heapq</p>

<p>def minCostJump(nums, cost):
 n = len(nums)
 dist = [float(‘inf’)] * n
 dist[0] = 0
 heap = [(0, 0)] # (cost, index)</p>

<p>while heap:
 d, i = heapq.heappop(heap)
 if i == n - 1:
 return d
 if d &gt; dist[i]:
 continue</p>

<p>for j in range(i + 1, min(i + nums[i] + 1, n)):
 new_cost = d + cost[i][j]
 if new_cost &lt; dist[j]:
 dist[j] = new_cost
 heapq.heappush(heap, (new_cost, j))</p>

<p>return dist[n - 1]
``</p>

<h2 id="12-interview-questions">12. Interview Questions</h2>

<ol>
  <li><strong>Jump Game II (Classic):</strong> Solve in O(N) time and O(1) space.</li>
  <li><strong>Jump Game I:</strong> Can you reach the last index?</li>
  <li><strong>Jump Game III:</strong> Can you reach any index with value 0?</li>
  <li><strong>Jump Game IV:</strong> Given <code class="language-plaintext highlighter-rouge">arr</code>, you can jump to <code class="language-plaintext highlighter-rouge">i+1</code>, <code class="language-plaintext highlighter-rouge">i-1</code>, or any <code class="language-plaintext highlighter-rouge">j</code> where <code class="language-plaintext highlighter-rouge">arr[j] == arr[i]</code>. Find minimum jumps to reach the last index.</li>
  <li><strong>Frog Jump:</strong> A frog can jump <code class="language-plaintext highlighter-rouge">k-1</code>, <code class="language-plaintext highlighter-rouge">k</code>, or <code class="language-plaintext highlighter-rouge">k+1</code> units. Can it cross the river?</li>
  <li><strong>Minimum Jumps with Cost:</strong> Each jump has a cost. Find the minimum cost path.</li>
</ol>

<h2 id="13-common-mistakes">13. Common Mistakes</h2>

<ul>
  <li><strong>Off-by-One:</strong> Iterating through the entire array including the last element (unnecessary).</li>
  <li><strong>Not Handling Single Element:</strong> <code class="language-plaintext highlighter-rouge">nums = [0]</code> should return <code class="language-plaintext highlighter-rouge">0</code> jumps.</li>
  <li><strong>Greedy Choice:</strong> Thinking we should always jump to the farthest position immediately (wrong! We should jump to the position that allows the farthest next jump).</li>
  <li><strong>BFS Optimization:</strong> Not using the “level-by-level” optimization, leading to O(N^2) instead of O(N).</li>
</ul>

<h2 id="14-performance-comparison">14. Performance Comparison</h2>

<p>``python
import time
import random</p>

<p>def benchmark():
 sizes = [100, 1000, 10000]</p>

<p>for size in sizes:
 nums = [random.randint(1, 10) for _ in range(size)]</p>

<p># Greedy
 start = time.time()
 # greedy_solution(nums)
 greedy_time = time.time() - start</p>

<p># DP
 start = time.time()
 # dp_solution(nums)
 dp_time = time.time() - start</p>

<p>print(f”Size {size}: Greedy={greedy_time:.6f}s, DP={dp_time:.6f}s”)</p>

<h1 id="expected-greedy-is-10-100x-faster-than-dp-for-large-inputs">Expected: Greedy is 10-100x faster than DP for large inputs.</h1>
<p>``</p>

<h2 id="15-deep-dive-jump-game-iv-bfs-with-hashmap">15. Deep Dive: Jump Game IV (BFS with HashMap)</h2>

<p><strong>Problem:</strong> Given an array <code class="language-plaintext highlighter-rouge">arr</code>, you can jump from index <code class="language-plaintext highlighter-rouge">i</code> to:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">i + 1</code></li>
  <li><code class="language-plaintext highlighter-rouge">i - 1</code></li>
  <li>Any index <code class="language-plaintext highlighter-rouge">j</code> where <code class="language-plaintext highlighter-rouge">arr[j] == arr[i]</code> and <code class="language-plaintext highlighter-rouge">i != j</code></li>
</ul>

<p>Find the minimum number of jumps to reach the last index.</p>

<p><strong>Example:</strong>
<code class="language-plaintext highlighter-rouge">
Input: arr = [100,-23,-23,404,100,23,23,23,3,404]
Output: 3
Explanation: 0 -&gt; 4 -&gt; 3 -&gt; 9
</code></p>

<p><strong>Algorithm (BFS with Optimization):</strong>
``python
from collections import deque, defaultdict</p>

<p>def minJumps(arr):
 n = len(arr)
 if n == 1:
 return 0</p>

<p># Build value -&gt; indices mapping
 graph = defaultdict(list)
 for i, val in enumerate(arr):
 graph[val].append(i)</p>

<p>queue = deque([0])
 visited = {0}
 steps = 0</p>

<p>while queue:
 size = len(queue)
 steps += 1</p>

<p>for _ in range(size):
 i = queue.popleft()</p>

<p># Try all three types of jumps
 # 1. i + 1
 if i + 1 &lt; n and i + 1 not in visited:
 if i + 1 == n - 1:
 return steps
 visited.add(i + 1)
 queue.append(i + 1)</p>

<p># 2. i - 1
 if i - 1 &gt;= 0 and i - 1 not in visited:
 visited.add(i - 1)
 queue.append(i - 1)</p>

<p># 3. Same value jumps
 for j in graph[arr[i]]:
 if j not in visited:
 if j == n - 1:
 return steps
 visited.add(j)
 queue.append(j)</p>

<p># CRITICAL: Clear the list to avoid revisiting
 graph[arr[i]].clear()</p>

<p>return steps
``</p>

<p><strong>Optimization:</strong> After visiting all indices with value <code class="language-plaintext highlighter-rouge">arr[i]</code>, we clear the list. This prevents revisiting the same value group multiple times.</p>

<p><strong>Complexity:</strong></p>
<ul>
  <li><strong>Time:</strong> O(N). Each index is visited at most once.</li>
  <li><strong>Space:</strong> O(N) for the graph and visited set.</li>
</ul>

<h2 id="16-deep-dive-frog-jump-dp-with-set">16. Deep Dive: Frog Jump (DP with Set)</h2>

<p><strong>Problem:</strong> A frog is crossing a river by jumping on stones. The frog can jump <code class="language-plaintext highlighter-rouge">k - 1</code>, <code class="language-plaintext highlighter-rouge">k</code>, or <code class="language-plaintext highlighter-rouge">k + 1</code> units where <code class="language-plaintext highlighter-rouge">k</code> is the last jump distance. Can the frog cross?</p>

<p><strong>Example:</strong>
<code class="language-plaintext highlighter-rouge">
Input: stones = [0,1,3,5,6,8,12,17]
Output: true
Explanation: 0 -&gt; 1 (1 unit) -&gt; 3 (2 units) -&gt; 5 (2 units) -&gt; 6 (1 unit) -&gt; 8 (2 units) -&gt; 12 (4 units) -&gt; 17 (5 units)
</code></p>

<p><strong>Algorithm (DP with HashMap):</strong>
``python
def canCross(stones):
 if stones[1] != 1:
 return False # First jump must be 1 unit</p>

<p>stone_set = set(stones)
 dp = {} # (position, last_jump) -&gt; bool</p>

<p>def dfs(pos, k):
 if pos == stones[-1]:
 return True
 if (pos, k) in dp:
 return dp[(pos, k)]</p>

<p>for next_k in [k - 1, k, k + 1]:
 if next_k &gt; 0:
 next_pos = pos + next_k
 if next_pos in stone_set:
 if dfs(next_pos, next_k):
 dp[(pos, k)] = True
 return True</p>

<p>dp[(pos, k)] = False
 return False</p>

<p>return dfs(1, 1)
``</p>

<p><strong>Complexity:</strong></p>
<ul>
  <li><strong>Time:</strong> O(N^2). At most <code class="language-plaintext highlighter-rouge">N</code> positions and <code class="language-plaintext highlighter-rouge">N</code> possible jump distances.</li>
  <li><strong>Space:</strong> O(N^2) for memoization.</li>
</ul>

<h2 id="17-production-application-route-optimization">17. Production Application: Route Optimization</h2>

<p><strong>Scenario:</strong> Delivery truck routing (Amazon, UPS).</p>

<p><strong>Problem:</strong> Given a list of delivery locations and the maximum distance the truck can travel from each location, find the minimum number of “hops” (refueling stops) to deliver all packages.</p>

<p><strong>Mapping to Jump Game:</strong></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">nums[i]</code> = maximum distance from location <code class="language-plaintext highlighter-rouge">i</code>.</li>
  <li>Goal: Reach the last location with minimum refueling stops.</li>
</ul>

<p><strong>Extensions:</strong></p>
<ul>
  <li><strong>Time Windows:</strong> Each location has a delivery time window.</li>
  <li><strong>Capacity Constraints:</strong> Truck has limited capacity.</li>
  <li><strong>Multiple Vehicles:</strong> Coordinate multiple trucks.</li>
</ul>

<p><strong>Algorithm:</strong> Jump Game II + Constraint Satisfaction.</p>

<h2 id="18-production-application-network-packet-routing">18. Production Application: Network Packet Routing</h2>

<p><strong>Scenario:</strong> Data packet routing in a network.</p>

<p><strong>Problem:</strong> A packet needs to travel from source to destination. Each router can forward the packet to routers within a certain “hop distance”. Find the minimum number of hops.</p>

<p><strong>Mapping:</strong></p>
<ul>
  <li>Nodes = routers.</li>
  <li><code class="language-plaintext highlighter-rouge">nums[i]</code> = maximum hop distance from router <code class="language-plaintext highlighter-rouge">i</code>.</li>
  <li>Goal: Minimum hops from source to destination.</li>
</ul>

<p><strong>Real-World Constraints:</strong></p>
<ul>
  <li><strong>Congestion:</strong> Some routers are overloaded (higher cost).</li>
  <li><strong>Latency:</strong> Each hop has a latency.</li>
  <li><strong>Reliability:</strong> Some links may fail.</li>
</ul>

<p><strong>Algorithm:</strong> Dijkstra’s Algorithm with dynamic weights.</p>

<h2 id="19-advanced-variant-jump-game-with-obstacles">19. Advanced Variant: Jump Game with Obstacles</h2>

<p><strong>Problem:</strong> Some positions are obstacles (cannot land on them). Find the minimum jumps.</p>

<p><strong>Algorithm (Modified BFS):</strong>
``python
def jumpWithObstacles(nums, obstacles):
 n = len(nums)
 obstacle_set = set(obstacles)</p>

<p>if 0 in obstacle_set or n - 1 in obstacle_set:
 return -1 # Can’t start or can’t finish</p>

<p>queue = deque([0])
 visited = {0}
 jumps = 0</p>

<p>while queue:
 size = len(queue)
 jumps += 1</p>

<p>for _ in range(size):
 i = queue.popleft()</p>

<p>for j in range(i + 1, min(i + nums[i] + 1, n)):
 if j in obstacle_set:
 continue # Skip obstacles
 if j == n - 1:
 return jumps
 if j not in visited:
 visited.add(j)
 queue.append(j)</p>

<p>return -1 # Can’t reach
``</p>

<h2 id="20-mathematical-analysis-expected-jumps">20. Mathematical Analysis: Expected Jumps</h2>

<p><strong>Question:</strong> If <code class="language-plaintext highlighter-rouge">nums[i]</code> is uniformly random in <code class="language-plaintext highlighter-rouge">[1, k]</code>, what is the expected number of jumps for an array of length <code class="language-plaintext highlighter-rouge">n</code>?</p>

<p><strong>Analysis:</strong></p>
<ul>
  <li>Average jump length: <code class="language-plaintext highlighter-rouge">\frac{k+1}{2}</code>.</li>
  <li>Expected number of jumps: <code class="language-plaintext highlighter-rouge">\approx \frac{n}{\frac{k+1}{2}} = \frac{2n}{k+1}</code>.</li>
</ul>

<p><strong>Example:</strong> <code class="language-plaintext highlighter-rouge">n = 100</code>, <code class="language-plaintext highlighter-rouge">k = 10</code>.</p>
<ul>
  <li>Expected jumps: <code class="language-plaintext highlighter-rouge">\frac{200}{11} \approx 18</code>.</li>
</ul>

<h2 id="21-parallel-algorithm-jump-game-on-gpu">21. Parallel Algorithm: Jump Game on GPU</h2>

<p><strong>Problem:</strong> Solve Jump Game II for millions of arrays in parallel (batch processing).</p>

<p><strong>Algorithm (CUDA):</strong></p>
<ol>
  <li><strong>Kernel:</strong> Each thread processes one array.</li>
  <li><strong>Shared Memory:</strong> Store the array in shared memory for fast access.</li>
  <li><strong>Reduction:</strong> Use parallel reduction to find the farthest reachable position.</li>
</ol>

<p><strong>Pseudocode:</strong>
``cuda
<strong>global</strong> void jumpGameKernel(int* arrays, int* results, int n, int batch_size) {
 int tid = blockIdx.x * blockDim.x + threadIdx.x;
 if (tid &gt;= batch_size) return;</p>

<p>int* nums = arrays + tid * n;
 int jumps = 0, current_end = 0, farthest = 0;</p>

<p>for (int i = 0; i &lt; n - 1; i++) {
 farthest = max(farthest, i + nums[i]);
 if (i == current_end) {
 jumps++;
 current_end = farthest;
 }
 }</p>

<p>results[tid] = jumps;
}
``</p>

<h2 id="22-interview-deep-dive-jump-game-v">22. Interview Deep Dive: Jump Game V</h2>

<p><strong>Problem:</strong> Given <code class="language-plaintext highlighter-rouge">arr</code> and <code class="language-plaintext highlighter-rouge">d</code>, you can jump at most <code class="language-plaintext highlighter-rouge">d</code> indices away. You can only jump to indices with smaller values. Find the maximum number of indices you can visit.</p>

<p><strong>Example:</strong>
<code class="language-plaintext highlighter-rouge">
Input: arr = [6,4,14,6,8,13,9,7,10,6,12], d = 2
Output: 4
Explanation: 6 -&gt; 4 -&gt; 8 -&gt; 6 (indices 0 -&gt; 1 -&gt; 4 -&gt; 3)
</code></p>

<p><strong>Algorithm (DP with Sorting):</strong>
``python
def maxJumps(arr, d):
 n = len(arr)
 dp = [1] * n # dp[i] = max visits starting from i</p>

<p># Sort indices by value (process smaller values first)
 indices = sorted(range(n), key=lambda i: arr[i])</p>

<p>for i in indices:
 # Try jumping left
 for j in range(i - 1, max(-1, i - d - 1), -1):
 if arr[j] &gt;= arr[i]:
 break # Can’t jump to taller
 dp[i] = max(dp[i], dp[j] + 1)</p>

<p># Try jumping right
 for j in range(i + 1, min(n, i + d + 1)):
 if arr[j] &gt;= arr[i]:
 break
 dp[i] = max(dp[i], dp[j] + 1)</p>

<p>return max(dp)
``</p>

<p><strong>Complexity:</strong> O(N \log N + N \cdot d).</p>

<h2 id="23-conclusion">23. Conclusion</h2>

<p>Jump Game II is a beautiful problem that teaches us the power of greedy algorithms. The key insight—that we can make locally optimal choices to achieve a globally optimal solution—is a recurring theme in algorithm design.</p>

<p><strong>Key Takeaways:</strong></p>
<ul>
  <li><strong>Greedy &gt; DP:</strong> For this problem, greedy is simpler and faster.</li>
  <li><strong>BFS Perspective:</strong> Thinking in terms of “levels” helps visualize the solution.</li>
  <li><strong>Proof Techniques:</strong> Exchange arguments are powerful for proving greedy correctness.</li>
  <li><strong>Real-World Applications:</strong> Routing, pathfinding, resource allocation.</li>
</ul>

<p>The variants (Jump Game I, III, IV, V, Frog Jump) test your ability to adapt the core algorithm to different constraints. Mastering these variations prepares you for a wide range of interview questions.</p>

<h2 id="24-advanced-variant-jump-game-vi-dp-with-deque">24. Advanced Variant: Jump Game VI (DP with Deque)</h2>

<p><strong>Problem:</strong> Given <code class="language-plaintext highlighter-rouge">nums</code> and <code class="language-plaintext highlighter-rouge">k</code>, you can jump at most <code class="language-plaintext highlighter-rouge">k</code> steps. Each position has a score. Maximize the total score.</p>

<p><strong>Example:</strong>
<code class="language-plaintext highlighter-rouge">
Input: nums = [1,-1,-2,4,-7,3], k = 2
Output: 7
Explanation: 0 -&gt; 3 -&gt; 5 (scores: 1 + 4 + 3 = 8, but we start at 1, so 1 + 4 + 3 = 8... actually the path is 0-&gt;3-&gt;5 with scores 1+4+3=8)
</code></p>

<p><strong>Algorithm (DP with Monotonic Deque):</strong>
``python
from collections import deque</p>

<p>def maxResult(nums, k):
 n = len(nums)
 dp = [float(‘-inf’)] * n
 dp[0] = nums[0]
 dq = deque([0]) # Stores indices</p>

<p>for i in range(1, n):
 # Remove indices that are out of range
 while dq and dq[0] &lt; i - k:
 dq.popleft()</p>

<p># dp[i] = max(dp[j]) + nums[i] for j in [i-k, i-1]
 dp[i] = dp[dq[0]] + nums[i]</p>

<p># Maintain decreasing deque
 while dq and dp[dq[-1]] &lt;= dp[i]:
 dq.pop()
 dq.append(i)</p>

<p>return dp[n - 1]
``</p>

<p><strong>Complexity:</strong> O(N) using monotonic deque.</p>

<h2 id="25-advanced-variant-jump-game-vii-string-with-constraints">25. Advanced Variant: Jump Game VII (String with Constraints)</h2>

<p><strong>Problem:</strong> Given a binary string <code class="language-plaintext highlighter-rouge">s</code> and integers <code class="language-plaintext highlighter-rouge">minJump</code> and <code class="language-plaintext highlighter-rouge">maxJump</code>. You start at index 0. You can jump to index <code class="language-plaintext highlighter-rouge">j</code> if:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">s[j] == '0'</code></li>
  <li><code class="language-plaintext highlighter-rouge">i + minJump &lt;= j &lt;= min(i + maxJump, n - 1)</code></li>
</ul>

<p>Can you reach the last index?</p>

<p><strong>Algorithm (BFS with Prefix Sum):</strong>
``python
from collections import deque</p>

<p>def canReach(s, minJump, maxJump):
 n = len(s)
 if s[-1] == ‘1’:
 return False</p>

<p>queue = deque([0])
 farthest = 0</p>

<p>while queue:
 i = queue.popleft()</p>

<p># Jump to range [i + minJump, i + maxJump]
 start = max(i + minJump, farthest + 1)
 end = min(i + maxJump, n - 1)</p>

<p>for j in range(start, end + 1):
 if s[j] == ‘0’:
 if j == n - 1:
 return True
 queue.append(j)</p>

<p>farthest = max(farthest, i + maxJump)</p>

<p>return False
``</p>

<p><strong>Optimization:</strong> Use a “visited” array to avoid revisiting indices.</p>

<h2 id="26-competitive-programming-jump-game-speedrun">26. Competitive Programming: Jump Game Speedrun</h2>

<p><strong>Problem:</strong> Given 1000 test cases, each with an array of length 10,000. Solve Jump Game II for all.</p>

<p><strong>Optimization Techniques:</strong></p>

<p><strong>1. Fast I/O:</strong>
``python
import sys
input = sys.stdin.readline</p>

<p>def solve():
 n = int(input())
 nums = list(map(int, input().split()))
 # … greedy solution
``</p>

<p><strong>2. Avoid Unnecessary Checks:</strong>
``python</p>
<h1 id="early-exit-if-we-can-already-reach-the-end">Early exit if we can already reach the end</h1>
<p>if current_end &gt;= n - 1:
 break
``</p>

<p><strong>3. Use Arrays Instead of Lists:</strong>
<code class="language-plaintext highlighter-rouge">python
import array
nums = array.array('i', map(int, input().split()))
</code></p>

<p><strong>4. Inline Functions:</strong>
``python</p>
<h1 id="instead-of-maxa-b-use">Instead of max(a, b), use:</h1>
<p>farthest = a if a &gt; b else b
``</p>

<h2 id="27-interview-strategy-recognizing-jump-game-patterns">27. Interview Strategy: Recognizing Jump Game Patterns</h2>

<p><strong>Pattern Recognition:</strong></p>
<ul>
  <li><strong>Greedy:</strong> If the problem asks for “minimum jumps” and you can jump anywhere within a range.</li>
  <li><strong>BFS:</strong> If the problem has constraints on where you can jump (e.g., only to specific values).</li>
  <li><strong>DP:</strong> If the problem asks for “maximum score” or “number of ways”.</li>
</ul>

<p><strong>Common Variations:</strong></p>
<ol>
  <li><strong>Can Reach?</strong> → Greedy (Jump Game I).</li>
  <li><strong>Minimum Jumps?</strong> → Greedy (Jump Game II).</li>
  <li><strong>Reach Specific Value?</strong> → BFS (Jump Game III).</li>
  <li><strong>Jump with Constraints?</strong> → BFS with HashMap (Jump Game IV).</li>
  <li><strong>Maximum Visits?</strong> → DP with Sorting (Jump Game V).</li>
  <li><strong>Maximum Score?</strong> → DP with Deque (Jump Game VI).</li>
</ol>

<h2 id="28-code-template-universal-jump-game-solver">28. Code Template: Universal Jump Game Solver</h2>

<p>``python
def jump_game_template(nums, target_condition, jump_rules):
 “””
 Universal template for Jump Game problems.</p>

<p>Args:
 nums: Input array
 target_condition: Function that checks if we’ve reached the goal
 jump_rules: Function that returns valid next positions
 “””
 from collections import deque</p>

<p>n = len(nums)
 queue = deque([0])
 visited = {0}
 steps = 0</p>

<p>while queue:
 size = len(queue)
 steps += 1</p>

<p>for _ in range(size):
 i = queue.popleft()</p>

<p>if target_condition(i, n):
 return steps - 1</p>

<p>for j in jump_rules(i, nums, n):
 if j not in visited:
 visited.add(j)
 queue.append(j)</p>

<p>return -1 # Can’t reach</p>

<h1 id="example-usage-for-jump-game-ii">Example usage for Jump Game II:</h1>
<p>def solve_jump_game_ii(nums):
 return jump_game_template(
 nums,
 target_condition=lambda i, n: i == n - 1,
 jump_rules=lambda i, nums, n: range(i + 1, min(i + nums[i] + 1, n))
 )
``</p>

<h2 id="29-testing-strategy">29. Testing Strategy</h2>

<p><strong>Test Cases:</strong></p>
<ol>
  <li><strong>Single Element:</strong> <code class="language-plaintext highlighter-rouge">[0]</code> → 0 jumps.</li>
  <li><strong>All Ones:</strong> <code class="language-plaintext highlighter-rouge">[1,1,1,1,1]</code> → 4 jumps.</li>
  <li><strong>Large Jump:</strong> <code class="language-plaintext highlighter-rouge">[10,1,1,1,1]</code> → 1 jump.</li>
  <li><strong>Optimal Path Not Obvious:</strong> <code class="language-plaintext highlighter-rouge">[2,3,1,1,4]</code> → 2 jumps.</li>
  <li><strong>Maximum Constraints:</strong> Array of length 10,000 with random values.</li>
</ol>

<p><strong>Edge Cases:</strong></p>
<ul>
  <li>Empty array (if allowed).</li>
  <li>Array with zeros in the middle (should still be reachable per problem statement).</li>
  <li>Very large jump values (e.g., <code class="language-plaintext highlighter-rouge">nums[0] = 10000</code>).</li>
</ul>

<h2 id="30-common-interview-follow-ups">30. Common Interview Follow-ups</h2>

<p><strong>Q1: What if we need to return the actual path, not just the number of jumps?</strong>
<strong>A:</strong> Modify the greedy algorithm to store the path.</p>

<p>``python
def jump_with_path(nums):
 n = len(nums)
 if n == 1:
 return 0, [0]</p>

<p>jumps = 0
 current_end = 0
 farthest = 0
 path = [0]</p>

<p>for i in range(n - 1):
 farthest = max(farthest, i + nums[i])</p>

<p>if i == current_end:
 jumps += 1
 current_end = farthest
 path.append(current_end)</p>

<p>if current_end &gt;= n - 1:
 path[-1] = n - 1
 break</p>

<p>return jumps, path
``</p>

<p><strong>Q2: What if some positions are blocked (obstacles)?</strong>
<strong>A:</strong> Use BFS and skip blocked positions.</p>

<p><strong>Q3: What if each jump has a cost, and we want to minimize total cost?</strong>
<strong>A:</strong> Use Dijkstra’s algorithm.</p>

<p><strong>Q4: What if we can jump backwards?</strong>
<strong>A:</strong> Use BFS (greedy won’t work).</p>

<h2 id="31-optimization-space-efficient-dp">31. Optimization: Space-Efficient DP</h2>

<p>For DP solutions, we often only need the last <code class="language-plaintext highlighter-rouge">k</code> values. Use a sliding window.</p>

<p>``python
def jump_game_dp_optimized(nums):
 n = len(nums)
 # Instead of dp = [inf] * n, use a deque of size k
 from collections import deque
 window = deque([0]) # dp[0] = 0</p>

<p>for i in range(1, n):
 # Remove old values outside the window
 while window and window[0][0] &lt; i - max_jump_distance:
 window.popleft()</p>

<p># dp[i] = min(window) + 1
 dp_i = window[0][1] + 1</p>

<p># Add to window
 while window and window[-1][1] &gt;= dp_i:
 window.pop()
 window.append((i, dp_i))</p>

<p>return window[-1][1]
``</p>

<h2 id="32-conclusion--summary">32. Conclusion &amp; Summary</h2>

<p>Jump Game II is more than just a coding problem—it’s a gateway to understanding greedy algorithms, graph traversal, and dynamic programming. The key insights:</p>

<ol>
  <li><strong>Greedy Works:</strong> When we can make locally optimal choices that lead to global optimality.</li>
  <li><strong>BFS is Versatile:</strong> Model as a graph and use level-order traversal.</li>
  <li><strong>DP for Variants:</strong> When we need to track scores or counts.</li>
  <li><strong>Proof Matters:</strong> Always verify that greedy is correct (exchange argument).</li>
</ol>

<p><strong>Mastery Checklist:</strong></p>
<ul class="task-list">
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Solve Jump Game I (Can Reach?)</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Solve Jump Game II (Minimum Jumps) in O(N) time, O(1) space</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Solve Jump Game III (Reach Zero)</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Solve Jump Game IV (BFS with HashMap)</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Solve Jump Game V (DP with Sorting)</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Solve Jump Game VI (DP with Deque)</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Solve Jump Game VII (String Constraints)</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Solve Frog Jump</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Explain why greedy works (proof)</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Implement the path reconstruction variant</li>
</ul>

<p><strong>Next Steps:</strong></p>
<ul>
  <li>Practice on LeetCode: Problems 45, 55, 1306, 1345, 1340, 1696, 1871, 403.</li>
  <li>Study related problems: Minimum Cost to Reach Destination, Cheapest Flights Within K Stops.</li>
  <li>Explore advanced topics: A* search, Bidirectional BFS.</li>
</ul>

<p>The journey from “Can I reach the end?” to “What’s the optimal path with constraints?” teaches us to think algorithmically and adapt solutions to new problems. This is the essence of problem-solving in computer science.</p>

<hr />

<p><strong>Originally published at:</strong> <a href="https://www.arunbaby.com/dsa/0041-jump-game-ii/">arunbaby.com/dsa/0041-jump-game-ii</a></p>

<p><em>If you found this helpful, consider sharing it with others who might benefit.</em></p>


        
      </section>

      <footer class="page__meta">
        
        
  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-tags" aria-hidden="true"></i> Tags: </strong>
    <span itemprop="keywords">
    
      <a href="/tags/#array" class="page__taxonomy-item p-category" rel="tag">array</a><span class="sep">, </span>
    
      <a href="/tags/#bfs" class="page__taxonomy-item p-category" rel="tag">bfs</a><span class="sep">, </span>
    
      <a href="/tags/#dynamic-programming" class="page__taxonomy-item p-category" rel="tag">dynamic-programming</a><span class="sep">, </span>
    
      <a href="/tags/#greedy" class="page__taxonomy-item p-category" rel="tag">greedy</a>
    
    </span>
  </p>




  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> Categories: </strong>
    <span itemprop="keywords">
    
      <a href="/categories/#dsa" class="page__taxonomy-item p-category" rel="tag">dsa</a>
    
    </span>
  </p>


        
      </footer>

      <div class="page__related page__related--full">
  <h2 class="page__related-title">Related across topics</h2>
  <style>
    /* Make section span full content width and use 2 equal columns */
    .page__related--full { float: inline-start; width: 100%; padding: 0; }
    .cross-related-grid { display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 2rem; }
    @media (max-width: 768px) { .cross-related-grid { grid-template-columns: 1fr; } }
    /* Ensure archive cards stretch nicely in the grid */
    .cross-related-grid .list__item, .cross-related-grid .grid__item { width: auto; float: none; margin: 0; }
  </style>
  <div class="cross-related-grid">
    



<div class="list__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/ml-system-design/0041-model-compression/" rel="permalink">Model Compression Techniques
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          8 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">“Fitting billion-parameter models into megabytes.”
</p>
  </article>
</div>




<div class="list__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/speech-tech/0041-speaker-diarization/" rel="permalink">Speaker Diarization
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          10 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">“Who spoke when? The art of untangling voices.”
</p>
  </article>
</div>




<div class="list__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/ai-agents/0041-world-models-for-agents/" rel="permalink">World Models for Agents
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          14 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">“Agents become reliable when they carry an internal model of reality: state, uncertainty, and predictions—not just chat history.”
</p>
  </article>
</div>

  </div>
</div>

      <section class="page__share">
  <h4 class="page__share-title">Share on</h4>

  <a href="https://twitter.com/intent/tweet?via=arunbaby0&text=Jump+Game+II%20https%3A%2F%2Fwww.arunbaby.com%2Fdsa%2F0041-jump-game-ii%2F" class="btn btn--twitter" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Twitter"><i class="fab fa-fw fa-twitter" aria-hidden="true"></i><span> Twitter</span></a>

  <a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fwww.arunbaby.com%2Fdsa%2F0041-jump-game-ii%2F" class="btn btn--facebook" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Facebook"><i class="fab fa-fw fa-facebook" aria-hidden="true"></i><span> Facebook</span></a>

  <a href="https://www.linkedin.com/shareArticle?mini=true&url=https://www.arunbaby.com/dsa/0041-jump-game-ii/" class="btn btn--linkedin" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on LinkedIn"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i><span> LinkedIn</span></a>
</section>


      
  <nav class="pagination">
    
      <a href="/dsa/0040-trapping-rain-water/" class="pagination--pager" title="Trapping Rain Water">Previous</a>
    
    
      <a href="/dsa/0042-merge-k-sorted-lists/" class="pagination--pager" title="Merge K Sorted Lists">Next</a>
    
  </nav>


    </div>

    
  </article>

  
  
</div>

      
    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';" role="search">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Enter your search term..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    

    
      
        
          <li><a href="https://twitter.com/arunbaby0" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-twitter-square" aria-hidden="true"></i> Twitter</a></li>
        
      
        
          <li><a href="https://github.com/arunbaby0" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
        
      
        
          <li><a href="https://www.linkedin.com/in/arunbaby0/" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i> LinkedIn</a></li>
        
      
        
          <li><a href="https://scholar.google.co.in/citations?user=6fSYWhkAAAAJ" rel="nofollow noopener noreferrer"><i class="fas fa-fw fa-graduation-cap" aria-hidden="true"></i> Google Scholar</a></li>
        
      
    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 1990 - 2143 <a href="https://www.arunbaby.com">Arun Baby</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>




  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-0JRJPEC9SS"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-0JRJPEC9SS', { 'anonymize_ip': false});
</script>








  </body>
</html>
