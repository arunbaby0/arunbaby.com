<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.26.2 by Michael Rose
  Copyright 2013-2024 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->

<html lang="en-US" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Jump Game II - Arun Baby</title>
<meta name="description" content="“Finding the optimal path through a sequence of choices.”">


  <meta name="author" content="Arun Baby">
  
  <meta property="article:author" content="Arun Baby">
  


<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="Arun Baby">
<meta property="og:title" content="Jump Game II">
<meta property="og:url" content="https://www.arunbaby.com/dsa/0041-jump-game-ii/">


  <meta property="og:description" content="“Finding the optimal path through a sequence of choices.”">



  <meta property="og:image" content="https://www.arunbaby.com/assets/images/profile-photo.png">



  <meta name="twitter:site" content="@arunbaby0">
  <meta name="twitter:title" content="Jump Game II">
  <meta name="twitter:description" content="“Finding the optimal path through a sequence of choices.”">
  <meta name="twitter:url" content="https://www.arunbaby.com/dsa/0041-jump-game-ii/">

  
    <meta name="twitter:card" content="summary">
    
      <meta name="twitter:image" content="https://www.arunbaby.com/assets/images/profile-photo.png">
    
  

  



  <meta property="article:published_time" content="2025-12-16T00:19:35+05:30">





  

  


<link rel="canonical" href="https://www.arunbaby.com/dsa/0041-jump-game-ii/">












<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Arun Baby Feed">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
  
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css"></noscript>



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--single" dir="ltr">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
           
          <span class="site-subtitle">Arun Baby</span>
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a
                href="/about/"
                
                
              >About</a>
            </li><li class="masthead__menu-item">
              <a
                href="/dsa/"
                
                
              >DSA</a>
            </li><li class="masthead__menu-item">
              <a
                href="/ml-system-design/"
                
                
              >ML Systems</a>
            </li><li class="masthead__menu-item">
              <a
                href="/speech-tech/"
                
                
              >Speech Tech</a>
            </li><li class="masthead__menu-item">
              <a
                href="/ai-agents/"
                
                
              >AI Agents</a>
            </li><li class="masthead__menu-item">
              <a
                href="/publications/"
                
                
              >Publications</a>
            </li><li class="masthead__menu-item">
              <a
                href="/statuses/"
                
                
              >Statuses</a>
            </li><li class="masthead__menu-item">
              <a
                href="/contact/"
                
                
              >Contact</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <i class="fas fa-search"></i>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      





<div id="main" role="main" class="no-author-sidebar">
  
  <div class="sidebar sticky">
  
  
  </div>



  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="Jump Game II">
    <meta itemprop="description" content="“Finding the optimal path through a sequence of choices.”">
    <meta itemprop="datePublished" content="2025-12-16T00:19:35+05:30">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">
            <a href="https://www.arunbaby.com/dsa/0041-jump-game-ii/" itemprop="url">Jump Game II
</a>
          </h1>
          

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          24 minute read
        
      </span>
    
  </p>


        </header>
      

      <section class="page__content" itemprop="text">
        
          <aside class="sidebar__right sticky">
            <nav class="toc">
              <header><h4 class="nav__title"><i class="fas fa-file-alt"></i> On this page</h4></header>
              <ul class="toc__menu"><li><a href="#1-problem-statement">1. Problem Statement</a></li><li><a href="#2-intuition">2. Intuition</a></li><li><a href="#3-approach-1-greedy-optimal">3. Approach 1: Greedy (Optimal)</a></li><li><a href="#4-approach-2-bfs-level-order-traversal">4. Approach 2: BFS (Level-Order Traversal)</a></li><li><a href="#5-approach-3-dynamic-programming">5. Approach 3: Dynamic Programming</a></li><li><a href="#6-deep-dive-why-greedy-works-proof">6. Deep Dive: Why Greedy Works (Proof)</a></li><li><a href="#7-detailed-walkthrough">7. Detailed Walkthrough</a></li><li><a href="#8-variant-jump-game-i-can-reach">8. Variant: Jump Game I (Can Reach?)</a></li><li><a href="#9-variant-jump-game-iii-reach-zero">9. Variant: Jump Game III (Reach Zero)</a></li><li><a href="#10-system-design-pathfinding-in-games">10. System Design: Pathfinding in Games</a></li><li><a href="#11-deep-dive-jump-game-with-costs">11. Deep Dive: Jump Game with Costs</a></li><li><a href="#12-interview-questions">12. Interview Questions</a></li><li><a href="#13-common-mistakes">13. Common Mistakes</a></li><li><a href="#14-performance-comparison">14. Performance Comparison</a></li><li><a href="#15-deep-dive-jump-game-iv-bfs-with-hashmap">15. Deep Dive: Jump Game IV (BFS with HashMap)</a></li><li><a href="#16-deep-dive-frog-jump-dp-with-set">16. Deep Dive: Frog Jump (DP with Set)</a></li><li><a href="#17-production-application-route-optimization">17. Production Application: Route Optimization</a></li><li><a href="#18-production-application-network-packet-routing">18. Production Application: Network Packet Routing</a></li><li><a href="#19-advanced-variant-jump-game-with-obstacles">19. Advanced Variant: Jump Game with Obstacles</a></li><li><a href="#20-mathematical-analysis-expected-jumps">20. Mathematical Analysis: Expected Jumps</a></li><li><a href="#21-parallel-algorithm-jump-game-on-gpu">21. Parallel Algorithm: Jump Game on GPU</a></li><li><a href="#22-interview-deep-dive-jump-game-v">22. Interview Deep Dive: Jump Game V</a></li><li><a href="#23-conclusion">23. Conclusion</a></li><li><a href="#24-advanced-variant-jump-game-vi-dp-with-deque">24. Advanced Variant: Jump Game VI (DP with Deque)</a></li><li><a href="#25-advanced-variant-jump-game-vii-string-with-constraints">25. Advanced Variant: Jump Game VII (String with Constraints)</a></li><li><a href="#26-competitive-programming-jump-game-speedrun">26. Competitive Programming: Jump Game Speedrun</a></li><li><a href="#27-interview-strategy-recognizing-jump-game-patterns">27. Interview Strategy: Recognizing Jump Game Patterns</a></li><li><a href="#28-code-template-universal-jump-game-solver">28. Code Template: Universal Jump Game Solver</a></li><li><a href="#29-testing-strategy">29. Testing Strategy</a></li><li><a href="#30-common-interview-follow-ups">30. Common Interview Follow-ups</a></li><li><a href="#31-optimization-space-efficient-dp">31. Optimization: Space-Efficient DP</a></li><li><a href="#32-conclusion--summary">32. Conclusion &amp; Summary</a></li></ul>
            </nav>
          </aside>
        
        <p><strong>“Finding the optimal path through a sequence of choices.”</strong></p>

<h2 id="1-problem-statement">1. Problem Statement</h2>

<p>You are given a <strong>0-indexed</strong> array of integers <code class="language-plaintext highlighter-rouge">nums</code> of length <code class="language-plaintext highlighter-rouge">n</code>. You are initially positioned at <code class="language-plaintext highlighter-rouge">nums[0]</code>.</p>

<p>Each element <code class="language-plaintext highlighter-rouge">nums[i]</code> represents the <strong>maximum</strong> length of a forward jump from index <code class="language-plaintext highlighter-rouge">i</code>. In other words, if you are at <code class="language-plaintext highlighter-rouge">nums[i]</code>, you can jump to any <code class="language-plaintext highlighter-rouge">nums[i + j]</code> where:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">0 &lt;= j &lt;= nums[i]</code></li>
  <li><code class="language-plaintext highlighter-rouge">i + j &lt; n</code></li>
</ul>

<p>Return the <strong>minimum number of jumps</strong> to reach <code class="language-plaintext highlighter-rouge">nums[n - 1]</code>. The test cases are generated such that you can reach <code class="language-plaintext highlighter-rouge">nums[n - 1]</code>.</p>

<p><strong>Example 1:</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [2,3,1,1,4]
Output: 2
Explanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.
</code></pre></div></div>

<p><strong>Example 2:</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [2,3,0,1,4]
Output: 2
</code></pre></div></div>

<p><strong>Constraints:</strong></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">1 &lt;= nums.length &lt;= 10^4</code></li>
  <li><code class="language-plaintext highlighter-rouge">0 &lt;= nums[i] &lt;= 1000</code></li>
  <li>It’s guaranteed that you can reach <code class="language-plaintext highlighter-rouge">nums[n-1]</code>.</li>
</ul>

<h2 id="2-intuition">2. Intuition</h2>

<p>This is a classic <strong>Greedy</strong> problem disguised as a graph traversal.</p>

<p><strong>Key Insight:</strong> At each position, we want to jump to the position that allows us to reach the farthest in the next jump. This is a <strong>local greedy choice</strong> that leads to a <strong>global optimal solution</strong>.</p>

<p>Think of it as BFS where each “level” represents the positions reachable with <code class="language-plaintext highlighter-rouge">k</code> jumps.</p>

<h2 id="3-approach-1-greedy-optimal">3. Approach 1: Greedy (Optimal)</h2>

<p><strong>Idea:</strong> We maintain the farthest position we can reach with the current number of jumps. When we exhaust the current range, we increment the jump count.</p>

<p><strong>Algorithm:</strong></p>
<ol>
  <li>Initialize <code class="language-plaintext highlighter-rouge">jumps = 0</code>, <code class="language-plaintext highlighter-rouge">current_end = 0</code> (end of current jump range), <code class="language-plaintext highlighter-rouge">farthest = 0</code> (farthest we can reach).</li>
  <li>Iterate through the array (except the last element, since we’re already there if we reach it).</li>
  <li>For each position <code class="language-plaintext highlighter-rouge">i</code>:
    <ul>
      <li>Update <code class="language-plaintext highlighter-rouge">farthest = max(farthest, i + nums[i])</code>.</li>
      <li>If <code class="language-plaintext highlighter-rouge">i == current_end</code> (we’ve exhausted the current jump range):
        <ul>
          <li>Increment <code class="language-plaintext highlighter-rouge">jumps</code>.</li>
          <li>Set <code class="language-plaintext highlighter-rouge">current_end = farthest</code> (start a new jump range).</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Return <code class="language-plaintext highlighter-rouge">jumps</code>.</li>
</ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">jump</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        
        <span class="n">jumps</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">current_end</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">farthest</span> <span class="o">=</span> <span class="mi">0</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>  <span class="c1"># Don't need to check the last element
</span>            <span class="n">farthest</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="n">farthest</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">current_end</span><span class="p">:</span>
                <span class="n">jumps</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">current_end</span> <span class="o">=</span> <span class="n">farthest</span>
                
                <span class="c1"># Early exit if we can already reach the end
</span>                <span class="k">if</span> <span class="n">current_end</span> <span class="o">&gt;=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">break</span>
                    
        <span class="k">return</span> <span class="n">jumps</span>
</code></pre></div></div>

<p><strong>Complexity:</strong></p>
<ul>
  <li><strong>Time:</strong> $O(N)$. Single pass through the array.</li>
  <li><strong>Space:</strong> $O(1)$. Constant extra space.</li>
</ul>

<h2 id="4-approach-2-bfs-level-order-traversal">4. Approach 2: BFS (Level-Order Traversal)</h2>

<p>We can model this as a graph where each index is a node, and there’s an edge from <code class="language-plaintext highlighter-rouge">i</code> to <code class="language-plaintext highlighter-rouge">j</code> if <code class="language-plaintext highlighter-rouge">j &lt;= i + nums[i]</code>.</p>

<p><strong>Algorithm:</strong></p>
<ol>
  <li>Use BFS. Each level represents positions reachable with <code class="language-plaintext highlighter-rouge">k</code> jumps.</li>
  <li>For each level, find the farthest position reachable.</li>
  <li>If the farthest position reaches or exceeds <code class="language-plaintext highlighter-rouge">n-1</code>, return the level count.</li>
</ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">deque</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">jump</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        
        <span class="n">queue</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">}</span>
        <span class="n">jumps</span> <span class="o">=</span> <span class="mi">0</span>
        
        <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span>
            <span class="n">jumps</span> <span class="o">+=</span> <span class="mi">1</span>
            
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="nf">popleft</span><span class="p">()</span>
                
                <span class="c1"># Try all possible jumps from position i
</span>                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nf">min</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">jumps</span>
                    <span class="k">if</span> <span class="n">j</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                        <span class="n">visited</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
                        <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
                        
        <span class="k">return</span> <span class="n">jumps</span>
</code></pre></div></div>

<p><strong>Complexity:</strong></p>
<ul>
  <li><strong>Time:</strong> $O(N^2)$ in worst case (e.g., <code class="language-plaintext highlighter-rouge">[1,1,1,1,1]</code>).</li>
  <li><strong>Space:</strong> $O(N)$ for the queue and visited set.</li>
</ul>

<h2 id="5-approach-3-dynamic-programming">5. Approach 3: Dynamic Programming</h2>

<p>Define <code class="language-plaintext highlighter-rouge">dp[i]</code> = minimum jumps to reach index <code class="language-plaintext highlighter-rouge">i</code>.</p>

<p><strong>Transition:</strong>
For each position <code class="language-plaintext highlighter-rouge">i</code>, we can jump to any position <code class="language-plaintext highlighter-rouge">j</code> where <code class="language-plaintext highlighter-rouge">i &lt; j &lt;= i + nums[i]</code>.
<code class="language-plaintext highlighter-rouge">dp[j] = min(dp[j], dp[i] + 1)</code>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">jump</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
        <span class="n">dp</span> <span class="o">=</span> <span class="p">[</span><span class="nf">float</span><span class="p">(</span><span class="sh">'</span><span class="s">inf</span><span class="sh">'</span><span class="p">)]</span> <span class="o">*</span> <span class="n">n</span>
        <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nf">min</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">)):</span>
                <span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nf">min</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                
        <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
</code></pre></div></div>

<p><strong>Complexity:</strong></p>
<ul>
  <li><strong>Time:</strong> $O(N \times M)$ where $M$ is the average jump length. Worst case $O(N^2)$.</li>
  <li><strong>Space:</strong> $O(N)$ for the DP array.</li>
</ul>

<h2 id="6-deep-dive-why-greedy-works-proof">6. Deep Dive: Why Greedy Works (Proof)</h2>

<p><strong>Claim:</strong> The greedy algorithm always finds the minimum number of jumps.</p>

<p><strong>Proof by Exchange Argument:</strong>
Suppose the greedy algorithm produces a solution with <code class="language-plaintext highlighter-rouge">k</code> jumps: $0 \to i_1 \to i_2 \to \dots \to i_k = n-1$.
Suppose there exists an optimal solution with fewer jumps: $0 \to j_1 \to j_2 \to \dots \to j_m = n-1$ where $m &lt; k$.</p>

<p>Consider the first position where the two solutions differ. Let’s say the greedy chooses $i_1$ and the optimal chooses $j_1$.
By the greedy choice, $i_1$ is the farthest position reachable from 0. Therefore, $j_1 \leq i_1$.</p>

<p>Now, from $j_1$, the optimal solution reaches $j_2$. But since $j_1 \leq i_1$, and the greedy algorithm considers all positions reachable from $i_1$, it must be that the greedy can also reach $j_2$ (or farther) in the next jump.</p>

<p>By induction, we can show that the greedy solution reaches at least as far as the optimal solution at each step. Since both reach $n-1$, and the greedy makes the farthest jump at each step, it cannot make more jumps than the optimal.</p>

<p><strong>Contradiction.</strong> Therefore, the greedy algorithm is optimal.</p>

<h2 id="7-detailed-walkthrough">7. Detailed Walkthrough</h2>

<p>Let’s trace <code class="language-plaintext highlighter-rouge">nums = [2, 3, 1, 1, 4]</code>.</p>

<p><strong>Initial State:</strong></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">jumps = 0</code>, <code class="language-plaintext highlighter-rouge">current_end = 0</code>, <code class="language-plaintext highlighter-rouge">farthest = 0</code>.</li>
</ul>

<p><strong>Iteration:</strong></p>
<ol>
  <li><code class="language-plaintext highlighter-rouge">i = 0</code>: <code class="language-plaintext highlighter-rouge">farthest = max(0, 0 + 2) = 2</code>. <code class="language-plaintext highlighter-rouge">i == current_end</code>, so <code class="language-plaintext highlighter-rouge">jumps = 1</code>, <code class="language-plaintext highlighter-rouge">current_end = 2</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">i = 1</code>: <code class="language-plaintext highlighter-rouge">farthest = max(2, 1 + 3) = 4</code>. <code class="language-plaintext highlighter-rouge">i &lt; current_end</code>, so no jump yet.</li>
  <li><code class="language-plaintext highlighter-rouge">i = 2</code>: <code class="language-plaintext highlighter-rouge">farthest = max(4, 2 + 1) = 4</code>. <code class="language-plaintext highlighter-rouge">i == current_end</code>, so <code class="language-plaintext highlighter-rouge">jumps = 2</code>, <code class="language-plaintext highlighter-rouge">current_end = 4</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">i = 3</code>: We’ve reached <code class="language-plaintext highlighter-rouge">n - 1 = 4</code> with <code class="language-plaintext highlighter-rouge">current_end = 4</code>, so we stop.</li>
</ol>

<p><strong>Result:</strong> <code class="language-plaintext highlighter-rouge">jumps = 2</code>.</p>

<p><strong>Path:</strong> $0 \to 1 \to 4$ (Jump to index 1, then jump to index 4).</p>

<h2 id="8-variant-jump-game-i-can-reach">8. Variant: Jump Game I (Can Reach?)</h2>

<p><strong>Problem:</strong> Given <code class="language-plaintext highlighter-rouge">nums</code>, return <code class="language-plaintext highlighter-rouge">true</code> if you can reach the last index.</p>

<p><strong>Greedy Solution:</strong></p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">canJump</span><span class="p">(</span><span class="n">nums</span><span class="p">):</span>
    <span class="n">farthest</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">farthest</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>  <span class="c1"># Can't reach position i
</span>        <span class="n">farthest</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="n">farthest</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">farthest</span> <span class="o">&gt;=</span> <span class="nf">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
    <span class="k">return</span> <span class="bp">True</span>
</code></pre></div></div>

<h2 id="9-variant-jump-game-iii-reach-zero">9. Variant: Jump Game III (Reach Zero)</h2>

<p><strong>Problem:</strong> Given <code class="language-plaintext highlighter-rouge">arr</code> and <code class="language-plaintext highlighter-rouge">start</code>, you can jump to <code class="language-plaintext highlighter-rouge">start + arr[start]</code> or <code class="language-plaintext highlighter-rouge">start - arr[start]</code>. Return <code class="language-plaintext highlighter-rouge">true</code> if you can reach any index with value 0.</p>

<p><strong>BFS Solution:</strong></p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">deque</span>

<span class="k">def</span> <span class="nf">canReach</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">start</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="n">queue</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">([</span><span class="n">start</span><span class="p">])</span>
    <span class="n">visited</span> <span class="o">=</span> <span class="p">{</span><span class="n">start</span><span class="p">}</span>
    
    <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="nf">popleft</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        
        <span class="k">for</span> <span class="n">next_i</span> <span class="ow">in</span> <span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span> <span class="o">-</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]]:</span>
            <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">next_i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="ow">and</span> <span class="n">next_i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                <span class="n">visited</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="n">next_i</span><span class="p">)</span>
                <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">next_i</span><span class="p">)</span>
                
    <span class="k">return</span> <span class="bp">False</span>
</code></pre></div></div>

<h2 id="10-system-design-pathfinding-in-games">10. System Design: Pathfinding in Games</h2>

<p>Jump Game II is essentially a simplified version of pathfinding algorithms used in game AI.</p>

<p><strong>Real-World Application: Platformer Games</strong></p>
<ul>
  <li><strong>Problem:</strong> Find the shortest sequence of jumps for a character to reach a goal.</li>
  <li><strong>Constraints:</strong> Jump height, gravity, obstacles.</li>
  <li><strong>Algorithm:</strong> A* search with heuristic = Manhattan distance to goal.</li>
</ul>

<p><strong>Optimization:</strong></p>
<ul>
  <li><strong>Precompute Reachability Graph:</strong> For static levels, precompute which platforms are reachable from each platform.</li>
  <li><strong>Caching:</strong> Cache optimal paths for frequently visited platform pairs.</li>
</ul>

<h2 id="11-deep-dive-jump-game-with-costs">11. Deep Dive: Jump Game with Costs</h2>

<p><strong>Problem:</strong> Each jump from <code class="language-plaintext highlighter-rouge">i</code> to <code class="language-plaintext highlighter-rouge">j</code> has a cost <code class="language-plaintext highlighter-rouge">cost[i][j]</code>. Find the minimum cost to reach the end.</p>

<p><strong>Algorithm:</strong> Dijkstra’s Algorithm.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">heapq</span>

<span class="k">def</span> <span class="nf">minCostJump</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">cost</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
    <span class="n">dist</span> <span class="o">=</span> <span class="p">[</span><span class="nf">float</span><span class="p">(</span><span class="sh">'</span><span class="s">inf</span><span class="sh">'</span><span class="p">)]</span> <span class="o">*</span> <span class="n">n</span>
    <span class="n">dist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">heap</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span>  <span class="c1"># (cost, index)
</span>    
    <span class="k">while</span> <span class="n">heap</span><span class="p">:</span>
        <span class="n">d</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="n">heapq</span><span class="p">.</span><span class="nf">heappop</span><span class="p">(</span><span class="n">heap</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">d</span>
        <span class="k">if</span> <span class="n">d</span> <span class="o">&gt;</span> <span class="n">dist</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="k">continue</span>
            
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nf">min</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">)):</span>
            <span class="n">new_cost</span> <span class="o">=</span> <span class="n">d</span> <span class="o">+</span> <span class="n">cost</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">new_cost</span> <span class="o">&lt;</span> <span class="n">dist</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                <span class="n">dist</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_cost</span>
                <span class="n">heapq</span><span class="p">.</span><span class="nf">heappush</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span> <span class="p">(</span><span class="n">new_cost</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>
                
    <span class="k">return</span> <span class="n">dist</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
</code></pre></div></div>

<h2 id="12-interview-questions">12. Interview Questions</h2>

<ol>
  <li><strong>Jump Game II (Classic):</strong> Solve in O(N) time and O(1) space.</li>
  <li><strong>Jump Game I:</strong> Can you reach the last index?</li>
  <li><strong>Jump Game III:</strong> Can you reach any index with value 0?</li>
  <li><strong>Jump Game IV:</strong> Given <code class="language-plaintext highlighter-rouge">arr</code>, you can jump to <code class="language-plaintext highlighter-rouge">i+1</code>, <code class="language-plaintext highlighter-rouge">i-1</code>, or any <code class="language-plaintext highlighter-rouge">j</code> where <code class="language-plaintext highlighter-rouge">arr[j] == arr[i]</code>. Find minimum jumps to reach the last index.</li>
  <li><strong>Frog Jump:</strong> A frog can jump <code class="language-plaintext highlighter-rouge">k-1</code>, <code class="language-plaintext highlighter-rouge">k</code>, or <code class="language-plaintext highlighter-rouge">k+1</code> units. Can it cross the river?</li>
  <li><strong>Minimum Jumps with Cost:</strong> Each jump has a cost. Find the minimum cost path.</li>
</ol>

<h2 id="13-common-mistakes">13. Common Mistakes</h2>

<ul>
  <li><strong>Off-by-One:</strong> Iterating through the entire array including the last element (unnecessary).</li>
  <li><strong>Not Handling Single Element:</strong> <code class="language-plaintext highlighter-rouge">nums = [0]</code> should return <code class="language-plaintext highlighter-rouge">0</code> jumps.</li>
  <li><strong>Greedy Choice:</strong> Thinking we should always jump to the farthest position immediately (wrong! We should jump to the position that allows the farthest next jump).</li>
  <li><strong>BFS Optimization:</strong> Not using the “level-by-level” optimization, leading to $O(N^2)$ instead of $O(N)$.</li>
</ul>

<h2 id="14-performance-comparison">14. Performance Comparison</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">time</span>
<span class="kn">import</span> <span class="n">random</span>

<span class="k">def</span> <span class="nf">benchmark</span><span class="p">():</span>
    <span class="n">sizes</span> <span class="o">=</span> <span class="p">[</span><span class="mi">100</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="mi">10000</span><span class="p">]</span>
    
    <span class="k">for</span> <span class="n">size</span> <span class="ow">in</span> <span class="n">sizes</span><span class="p">:</span>
        <span class="n">nums</span> <span class="o">=</span> <span class="p">[</span><span class="n">random</span><span class="p">.</span><span class="nf">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">size</span><span class="p">)]</span>
        
        <span class="c1"># Greedy
</span>        <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span>
        <span class="c1"># greedy_solution(nums)
</span>        <span class="n">greedy_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span>
        
        <span class="c1"># DP
</span>        <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span>
        <span class="c1"># dp_solution(nums)
</span>        <span class="n">dp_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span>
        
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Size </span><span class="si">{</span><span class="n">size</span><span class="si">}</span><span class="s">: Greedy=</span><span class="si">{</span><span class="n">greedy_time</span><span class="si">:</span><span class="p">.</span><span class="mi">6</span><span class="n">f</span><span class="si">}</span><span class="s">s, DP=</span><span class="si">{</span><span class="n">dp_time</span><span class="si">:</span><span class="p">.</span><span class="mi">6</span><span class="n">f</span><span class="si">}</span><span class="s">s</span><span class="sh">"</span><span class="p">)</span>

<span class="c1"># Expected: Greedy is 10-100x faster than DP for large inputs.
</span></code></pre></div></div>

<h2 id="15-deep-dive-jump-game-iv-bfs-with-hashmap">15. Deep Dive: Jump Game IV (BFS with HashMap)</h2>

<p><strong>Problem:</strong> Given an array <code class="language-plaintext highlighter-rouge">arr</code>, you can jump from index <code class="language-plaintext highlighter-rouge">i</code> to:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">i + 1</code></li>
  <li><code class="language-plaintext highlighter-rouge">i - 1</code></li>
  <li>Any index <code class="language-plaintext highlighter-rouge">j</code> where <code class="language-plaintext highlighter-rouge">arr[j] == arr[i]</code> and <code class="language-plaintext highlighter-rouge">i != j</code></li>
</ul>

<p>Find the minimum number of jumps to reach the last index.</p>

<p><strong>Example:</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: arr = [100,-23,-23,404,100,23,23,23,3,404]
Output: 3
Explanation: 0 -&gt; 4 -&gt; 3 -&gt; 9
</code></pre></div></div>

<p><strong>Algorithm (BFS with Optimization):</strong></p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">deque</span><span class="p">,</span> <span class="n">defaultdict</span>

<span class="k">def</span> <span class="nf">minJumps</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
    
    <span class="c1"># Build value -&gt; indices mapping
</span>    <span class="n">graph</span> <span class="o">=</span> <span class="nf">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
        <span class="n">graph</span><span class="p">[</span><span class="n">val</span><span class="p">].</span><span class="nf">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    
    <span class="n">queue</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">visited</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">}</span>
    <span class="n">steps</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
        <span class="n">size</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span>
        <span class="n">steps</span> <span class="o">+=</span> <span class="mi">1</span>
        
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="nf">popleft</span><span class="p">()</span>
            
            <span class="c1"># Try all three types of jumps
</span>            <span class="c1"># 1. i + 1
</span>            <span class="k">if</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">steps</span>
                <span class="n">visited</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            
            <span class="c1"># 2. i - 1
</span>            <span class="k">if</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                <span class="n">visited</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            
            <span class="c1"># 3. Same value jumps
</span>            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]]:</span>
                <span class="k">if</span> <span class="n">j</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">steps</span>
                    <span class="n">visited</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
                    <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
            
            <span class="c1"># CRITICAL: Clear the list to avoid revisiting
</span>            <span class="n">graph</span><span class="p">[</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]].</span><span class="nf">clear</span><span class="p">()</span>
    
    <span class="k">return</span> <span class="n">steps</span>
</code></pre></div></div>

<p><strong>Optimization:</strong> After visiting all indices with value <code class="language-plaintext highlighter-rouge">arr[i]</code>, we clear the list. This prevents revisiting the same value group multiple times.</p>

<p><strong>Complexity:</strong></p>
<ul>
  <li><strong>Time:</strong> $O(N)$. Each index is visited at most once.</li>
  <li><strong>Space:</strong> $O(N)$ for the graph and visited set.</li>
</ul>

<h2 id="16-deep-dive-frog-jump-dp-with-set">16. Deep Dive: Frog Jump (DP with Set)</h2>

<p><strong>Problem:</strong> A frog is crossing a river by jumping on stones. The frog can jump <code class="language-plaintext highlighter-rouge">k - 1</code>, <code class="language-plaintext highlighter-rouge">k</code>, or <code class="language-plaintext highlighter-rouge">k + 1</code> units where <code class="language-plaintext highlighter-rouge">k</code> is the last jump distance. Can the frog cross?</p>

<p><strong>Example:</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: stones = [0,1,3,5,6,8,12,17]
Output: true
Explanation: 0 -&gt; 1 (1 unit) -&gt; 3 (2 units) -&gt; 5 (2 units) -&gt; 6 (1 unit) -&gt; 8 (2 units) -&gt; 12 (4 units) -&gt; 17 (5 units)
</code></pre></div></div>

<p><strong>Algorithm (DP with HashMap):</strong></p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">canCross</span><span class="p">(</span><span class="n">stones</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">stones</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span>  <span class="c1"># First jump must be 1 unit
</span>    
    <span class="n">stone_set</span> <span class="o">=</span> <span class="nf">set</span><span class="p">(</span><span class="n">stones</span><span class="p">)</span>
    <span class="n">dp</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># (position, last_jump) -&gt; bool
</span>    
    <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">pos</span> <span class="o">==</span> <span class="n">stones</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="nf">if </span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="ow">in</span> <span class="n">dp</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">dp</span><span class="p">[(</span><span class="n">pos</span><span class="p">,</span> <span class="n">k</span><span class="p">)]</span>
        
        <span class="k">for</span> <span class="n">next_k</span> <span class="ow">in</span> <span class="p">[</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">next_k</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">next_pos</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">next_k</span>
                <span class="k">if</span> <span class="n">next_pos</span> <span class="ow">in</span> <span class="n">stone_set</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">next_pos</span><span class="p">,</span> <span class="n">next_k</span><span class="p">):</span>
                        <span class="n">dp</span><span class="p">[(</span><span class="n">pos</span><span class="p">,</span> <span class="n">k</span><span class="p">)]</span> <span class="o">=</span> <span class="bp">True</span>
                        <span class="k">return</span> <span class="bp">True</span>
        
        <span class="n">dp</span><span class="p">[(</span><span class="n">pos</span><span class="p">,</span> <span class="n">k</span><span class="p">)]</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">return</span> <span class="bp">False</span>
    
    <span class="k">return</span> <span class="nf">dfs</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</code></pre></div></div>

<p><strong>Complexity:</strong></p>
<ul>
  <li><strong>Time:</strong> $O(N^2)$. At most $N$ positions and $N$ possible jump distances.</li>
  <li><strong>Space:</strong> $O(N^2)$ for memoization.</li>
</ul>

<h2 id="17-production-application-route-optimization">17. Production Application: Route Optimization</h2>

<p><strong>Scenario:</strong> Delivery truck routing (Amazon, UPS).</p>

<p><strong>Problem:</strong> Given a list of delivery locations and the maximum distance the truck can travel from each location, find the minimum number of “hops” (refueling stops) to deliver all packages.</p>

<p><strong>Mapping to Jump Game:</strong></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">nums[i]</code> = maximum distance from location <code class="language-plaintext highlighter-rouge">i</code>.</li>
  <li>Goal: Reach the last location with minimum refueling stops.</li>
</ul>

<p><strong>Extensions:</strong></p>
<ul>
  <li><strong>Time Windows:</strong> Each location has a delivery time window.</li>
  <li><strong>Capacity Constraints:</strong> Truck has limited capacity.</li>
  <li><strong>Multiple Vehicles:</strong> Coordinate multiple trucks.</li>
</ul>

<p><strong>Algorithm:</strong> Jump Game II + Constraint Satisfaction.</p>

<h2 id="18-production-application-network-packet-routing">18. Production Application: Network Packet Routing</h2>

<p><strong>Scenario:</strong> Data packet routing in a network.</p>

<p><strong>Problem:</strong> A packet needs to travel from source to destination. Each router can forward the packet to routers within a certain “hop distance”. Find the minimum number of hops.</p>

<p><strong>Mapping:</strong></p>
<ul>
  <li>Nodes = routers.</li>
  <li><code class="language-plaintext highlighter-rouge">nums[i]</code> = maximum hop distance from router <code class="language-plaintext highlighter-rouge">i</code>.</li>
  <li>Goal: Minimum hops from source to destination.</li>
</ul>

<p><strong>Real-World Constraints:</strong></p>
<ul>
  <li><strong>Congestion:</strong> Some routers are overloaded (higher cost).</li>
  <li><strong>Latency:</strong> Each hop has a latency.</li>
  <li><strong>Reliability:</strong> Some links may fail.</li>
</ul>

<p><strong>Algorithm:</strong> Dijkstra’s Algorithm with dynamic weights.</p>

<h2 id="19-advanced-variant-jump-game-with-obstacles">19. Advanced Variant: Jump Game with Obstacles</h2>

<p><strong>Problem:</strong> Some positions are obstacles (cannot land on them). Find the minimum jumps.</p>

<p><strong>Algorithm (Modified BFS):</strong></p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">jumpWithObstacles</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">obstacles</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
    <span class="n">obstacle_set</span> <span class="o">=</span> <span class="nf">set</span><span class="p">(</span><span class="n">obstacles</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="mi">0</span> <span class="ow">in</span> <span class="n">obstacle_set</span> <span class="ow">or</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">in</span> <span class="n">obstacle_set</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>  <span class="c1"># Can't start or can't finish
</span>    
    <span class="n">queue</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">visited</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">}</span>
    <span class="n">jumps</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
        <span class="n">size</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span>
        <span class="n">jumps</span> <span class="o">+=</span> <span class="mi">1</span>
        
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="nf">popleft</span><span class="p">()</span>
            
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nf">min</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">obstacle_set</span><span class="p">:</span>
                    <span class="k">continue</span>  <span class="c1"># Skip obstacles
</span>                <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">jumps</span>
                <span class="k">if</span> <span class="n">j</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                    <span class="n">visited</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
                    <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>  <span class="c1"># Can't reach
</span></code></pre></div></div>

<h2 id="20-mathematical-analysis-expected-jumps">20. Mathematical Analysis: Expected Jumps</h2>

<p><strong>Question:</strong> If <code class="language-plaintext highlighter-rouge">nums[i]</code> is uniformly random in <code class="language-plaintext highlighter-rouge">[1, k]</code>, what is the expected number of jumps for an array of length <code class="language-plaintext highlighter-rouge">n</code>?</p>

<p><strong>Analysis:</strong></p>
<ul>
  <li>Average jump length: $\frac{k+1}{2}$.</li>
  <li>Expected number of jumps: $\approx \frac{n}{\frac{k+1}{2}} = \frac{2n}{k+1}$.</li>
</ul>

<p><strong>Example:</strong> $n = 100$, $k = 10$.</p>
<ul>
  <li>Expected jumps: $\frac{200}{11} \approx 18$.</li>
</ul>

<h2 id="21-parallel-algorithm-jump-game-on-gpu">21. Parallel Algorithm: Jump Game on GPU</h2>

<p><strong>Problem:</strong> Solve Jump Game II for millions of arrays in parallel (batch processing).</p>

<p><strong>Algorithm (CUDA):</strong></p>
<ol>
  <li><strong>Kernel:</strong> Each thread processes one array.</li>
  <li><strong>Shared Memory:</strong> Store the array in shared memory for fast access.</li>
  <li><strong>Reduction:</strong> Use parallel reduction to find the farthest reachable position.</li>
</ol>

<p><strong>Pseudocode:</strong></p>
<div class="language-cuda highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">__global__</span> <span class="kt">void</span> <span class="nf">jumpGameKernel</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">arrays</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">results</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">batch_size</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">tid</span> <span class="o">=</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">tid</span> <span class="o">&gt;=</span> <span class="n">batch_size</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
    
    <span class="kt">int</span><span class="o">*</span> <span class="n">nums</span> <span class="o">=</span> <span class="n">arrays</span> <span class="o">+</span> <span class="n">tid</span> <span class="o">*</span> <span class="n">n</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">jumps</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">current_end</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">farthest</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">farthest</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">farthest</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">current_end</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">jumps</span><span class="o">++</span><span class="p">;</span>
            <span class="n">current_end</span> <span class="o">=</span> <span class="n">farthest</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="n">results</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span> <span class="o">=</span> <span class="n">jumps</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="22-interview-deep-dive-jump-game-v">22. Interview Deep Dive: Jump Game V</h2>

<p><strong>Problem:</strong> Given <code class="language-plaintext highlighter-rouge">arr</code> and <code class="language-plaintext highlighter-rouge">d</code>, you can jump at most <code class="language-plaintext highlighter-rouge">d</code> indices away. You can only jump to indices with smaller values. Find the maximum number of indices you can visit.</p>

<p><strong>Example:</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: arr = [6,4,14,6,8,13,9,7,10,6,12], d = 2
Output: 4
Explanation: 6 -&gt; 4 -&gt; 8 -&gt; 6 (indices 0 -&gt; 1 -&gt; 4 -&gt; 3)
</code></pre></div></div>

<p><strong>Algorithm (DP with Sorting):</strong></p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">maxJumps</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="n">dp</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>  <span class="c1"># dp[i] = max visits starting from i
</span>    
    <span class="c1"># Sort indices by value (process smaller values first)
</span>    <span class="n">indices</span> <span class="o">=</span> <span class="nf">sorted</span><span class="p">(</span><span class="nf">range</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
        <span class="c1"># Try jumping left
</span>        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nf">max</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="n">d</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="k">break</span>  <span class="c1"># Can't jump to taller
</span>            <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        
        <span class="c1"># Try jumping right
</span>        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nf">min</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">d</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="k">break</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="nf">max</span><span class="p">(</span><span class="n">dp</span><span class="p">)</span>
</code></pre></div></div>

<p><strong>Complexity:</strong> $O(N \log N + N \cdot d)$.</p>

<h2 id="23-conclusion">23. Conclusion</h2>

<p>Jump Game II is a beautiful problem that teaches us the power of greedy algorithms. The key insight—that we can make locally optimal choices to achieve a globally optimal solution—is a recurring theme in algorithm design.</p>

<p><strong>Key Takeaways:</strong></p>
<ul>
  <li><strong>Greedy &gt; DP:</strong> For this problem, greedy is simpler and faster.</li>
  <li><strong>BFS Perspective:</strong> Thinking in terms of “levels” helps visualize the solution.</li>
  <li><strong>Proof Techniques:</strong> Exchange arguments are powerful for proving greedy correctness.</li>
  <li><strong>Real-World Applications:</strong> Routing, pathfinding, resource allocation.</li>
</ul>

<p>The variants (Jump Game I, III, IV, V, Frog Jump) test your ability to adapt the core algorithm to different constraints. Mastering these variations prepares you for a wide range of interview questions.</p>

<h2 id="24-advanced-variant-jump-game-vi-dp-with-deque">24. Advanced Variant: Jump Game VI (DP with Deque)</h2>

<p><strong>Problem:</strong> Given <code class="language-plaintext highlighter-rouge">nums</code> and <code class="language-plaintext highlighter-rouge">k</code>, you can jump at most <code class="language-plaintext highlighter-rouge">k</code> steps. Each position has a score. Maximize the total score.</p>

<p><strong>Example:</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1,-1,-2,4,-7,3], k = 2
Output: 7
Explanation: 0 -&gt; 3 -&gt; 5 (scores: 1 + 4 + 3 = 8, but we start at 1, so 1 + 4 + 3 = 8... actually the path is 0-&gt;3-&gt;5 with scores 1+4+3=8)
</code></pre></div></div>

<p><strong>Algorithm (DP with Monotonic Deque):</strong></p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">deque</span>

<span class="k">def</span> <span class="nf">maxResult</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
    <span class="n">dp</span> <span class="o">=</span> <span class="p">[</span><span class="nf">float</span><span class="p">(</span><span class="sh">'</span><span class="s">-inf</span><span class="sh">'</span><span class="p">)]</span> <span class="o">*</span> <span class="n">n</span>
    <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">dq</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># Stores indices
</span>    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="c1"># Remove indices that are out of range
</span>        <span class="k">while</span> <span class="n">dq</span> <span class="ow">and</span> <span class="n">dq</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">i</span> <span class="o">-</span> <span class="n">k</span><span class="p">:</span>
            <span class="n">dq</span><span class="p">.</span><span class="nf">popleft</span><span class="p">()</span>
        
        <span class="c1"># dp[i] = max(dp[j]) + nums[i] for j in [i-k, i-1]
</span>        <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">dq</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        
        <span class="c1"># Maintain decreasing deque
</span>        <span class="k">while</span> <span class="n">dq</span> <span class="ow">and</span> <span class="n">dp</span><span class="p">[</span><span class="n">dq</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">&lt;=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">dq</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
        <span class="n">dq</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
</code></pre></div></div>

<p><strong>Complexity:</strong> $O(N)$ using monotonic deque.</p>

<h2 id="25-advanced-variant-jump-game-vii-string-with-constraints">25. Advanced Variant: Jump Game VII (String with Constraints)</h2>

<p><strong>Problem:</strong> Given a binary string <code class="language-plaintext highlighter-rouge">s</code> and integers <code class="language-plaintext highlighter-rouge">minJump</code> and <code class="language-plaintext highlighter-rouge">maxJump</code>. You start at index 0. You can jump to index <code class="language-plaintext highlighter-rouge">j</code> if:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">s[j] == '0'</code></li>
  <li><code class="language-plaintext highlighter-rouge">i + minJump &lt;= j &lt;= min(i + maxJump, n - 1)</code></li>
</ul>

<p>Can you reach the last index?</p>

<p><strong>Algorithm (BFS with Prefix Sum):</strong></p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">deque</span>

<span class="k">def</span> <span class="nf">canReach</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">minJump</span><span class="p">,</span> <span class="n">maxJump</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sh">'</span><span class="s">1</span><span class="sh">'</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span>
    
    <span class="n">queue</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">farthest</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="nf">popleft</span><span class="p">()</span>
        
        <span class="c1"># Jump to range [i + minJump, i + maxJump]
</span>        <span class="n">start</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">minJump</span><span class="p">,</span> <span class="n">farthest</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">end</span> <span class="o">=</span> <span class="nf">min</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">maxJump</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="sh">'</span><span class="s">0</span><span class="sh">'</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">True</span>
                <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
        
        <span class="n">farthest</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="n">farthest</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">maxJump</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="bp">False</span>
</code></pre></div></div>

<p><strong>Optimization:</strong> Use a “visited” array to avoid revisiting indices.</p>

<h2 id="26-competitive-programming-jump-game-speedrun">26. Competitive Programming: Jump Game Speedrun</h2>

<p><strong>Problem:</strong> Given 1000 test cases, each with an array of length 10,000. Solve Jump Game II for all.</p>

<p><strong>Optimization Techniques:</strong></p>

<p><strong>1. Fast I/O:</strong></p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">sys</span>
<span class="nb">input</span> <span class="o">=</span> <span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span>

<span class="k">def</span> <span class="nf">solve</span><span class="p">():</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="nf">input</span><span class="p">())</span>
    <span class="n">nums</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="nf">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nf">input</span><span class="p">().</span><span class="nf">split</span><span class="p">()))</span>
    <span class="c1"># ... greedy solution
</span></code></pre></div></div>

<p><strong>2. Avoid Unnecessary Checks:</strong></p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Early exit if we can already reach the end
</span><span class="k">if</span> <span class="n">current_end</span> <span class="o">&gt;=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
    <span class="k">break</span>
</code></pre></div></div>

<p><strong>3. Use Arrays Instead of Lists:</strong></p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">array</span>
<span class="n">nums</span> <span class="o">=</span> <span class="n">array</span><span class="p">.</span><span class="nf">array</span><span class="p">(</span><span class="sh">'</span><span class="s">i</span><span class="sh">'</span><span class="p">,</span> <span class="nf">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nf">input</span><span class="p">().</span><span class="nf">split</span><span class="p">()))</span>
</code></pre></div></div>

<p><strong>4. Inline Functions:</strong></p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Instead of max(a, b), use:
</span><span class="n">farthest</span> <span class="o">=</span> <span class="n">a</span> <span class="k">if</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span> <span class="k">else</span> <span class="n">b</span>
</code></pre></div></div>

<h2 id="27-interview-strategy-recognizing-jump-game-patterns">27. Interview Strategy: Recognizing Jump Game Patterns</h2>

<p><strong>Pattern Recognition:</strong></p>
<ul>
  <li><strong>Greedy:</strong> If the problem asks for “minimum jumps” and you can jump anywhere within a range.</li>
  <li><strong>BFS:</strong> If the problem has constraints on where you can jump (e.g., only to specific values).</li>
  <li><strong>DP:</strong> If the problem asks for “maximum score” or “number of ways”.</li>
</ul>

<p><strong>Common Variations:</strong></p>
<ol>
  <li><strong>Can Reach?</strong> → Greedy (Jump Game I).</li>
  <li><strong>Minimum Jumps?</strong> → Greedy (Jump Game II).</li>
  <li><strong>Reach Specific Value?</strong> → BFS (Jump Game III).</li>
  <li><strong>Jump with Constraints?</strong> → BFS with HashMap (Jump Game IV).</li>
  <li><strong>Maximum Visits?</strong> → DP with Sorting (Jump Game V).</li>
  <li><strong>Maximum Score?</strong> → DP with Deque (Jump Game VI).</li>
</ol>

<h2 id="28-code-template-universal-jump-game-solver">28. Code Template: Universal Jump Game Solver</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">jump_game_template</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">target_condition</span><span class="p">,</span> <span class="n">jump_rules</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">
    Universal template for Jump Game problems.
    
    Args:
        nums: Input array
        target_condition: Function that checks if we</span><span class="sh">'</span><span class="s">ve reached the goal
        jump_rules: Function that returns valid next positions
    </span><span class="sh">"""</span>
    <span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">deque</span>
    
    <span class="n">n</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
    <span class="n">queue</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">visited</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">}</span>
    <span class="n">steps</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
        <span class="n">size</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span>
        <span class="n">steps</span> <span class="o">+=</span> <span class="mi">1</span>
        
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="nf">popleft</span><span class="p">()</span>
            
            <span class="k">if</span> <span class="nf">target_condition</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">steps</span> <span class="o">-</span> <span class="mi">1</span>
            
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">jump_rules</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">nums</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">j</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                    <span class="n">visited</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
                    <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>  <span class="c1"># Can't reach
</span>
<span class="c1"># Example usage for Jump Game II:
</span><span class="k">def</span> <span class="nf">solve_jump_game_ii</span><span class="p">(</span><span class="n">nums</span><span class="p">):</span>
    <span class="k">return</span> <span class="nf">jump_game_template</span><span class="p">(</span>
        <span class="n">nums</span><span class="p">,</span>
        <span class="n">target_condition</span><span class="o">=</span><span class="k">lambda</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="n">i</span> <span class="o">==</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">jump_rules</span><span class="o">=</span><span class="k">lambda</span> <span class="n">i</span><span class="p">,</span> <span class="n">nums</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nf">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nf">min</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
    <span class="p">)</span>
</code></pre></div></div>

<h2 id="29-testing-strategy">29. Testing Strategy</h2>

<p><strong>Test Cases:</strong></p>
<ol>
  <li><strong>Single Element:</strong> <code class="language-plaintext highlighter-rouge">[0]</code> → 0 jumps.</li>
  <li><strong>All Ones:</strong> <code class="language-plaintext highlighter-rouge">[1,1,1,1,1]</code> → 4 jumps.</li>
  <li><strong>Large Jump:</strong> <code class="language-plaintext highlighter-rouge">[10,1,1,1,1]</code> → 1 jump.</li>
  <li><strong>Optimal Path Not Obvious:</strong> <code class="language-plaintext highlighter-rouge">[2,3,1,1,4]</code> → 2 jumps.</li>
  <li><strong>Maximum Constraints:</strong> Array of length 10,000 with random values.</li>
</ol>

<p><strong>Edge Cases:</strong></p>
<ul>
  <li>Empty array (if allowed).</li>
  <li>Array with zeros in the middle (should still be reachable per problem statement).</li>
  <li>Very large jump values (e.g., <code class="language-plaintext highlighter-rouge">nums[0] = 10000</code>).</li>
</ul>

<h2 id="30-common-interview-follow-ups">30. Common Interview Follow-ups</h2>

<p><strong>Q1: What if we need to return the actual path, not just the number of jumps?</strong>
<strong>A:</strong> Modify the greedy algorithm to store the path.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">jump_with_path</span><span class="p">(</span><span class="n">nums</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="n">jumps</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">current_end</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">farthest</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">path</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">farthest</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="n">farthest</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">current_end</span><span class="p">:</span>
            <span class="n">jumps</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">current_end</span> <span class="o">=</span> <span class="n">farthest</span>
            <span class="n">path</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">current_end</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">current_end</span> <span class="o">&gt;=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">path</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="k">break</span>
    
    <span class="k">return</span> <span class="n">jumps</span><span class="p">,</span> <span class="n">path</span>
</code></pre></div></div>

<p><strong>Q2: What if some positions are blocked (obstacles)?</strong>
<strong>A:</strong> Use BFS and skip blocked positions.</p>

<p><strong>Q3: What if each jump has a cost, and we want to minimize total cost?</strong>
<strong>A:</strong> Use Dijkstra’s algorithm.</p>

<p><strong>Q4: What if we can jump backwards?</strong>
<strong>A:</strong> Use BFS (greedy won’t work).</p>

<h2 id="31-optimization-space-efficient-dp">31. Optimization: Space-Efficient DP</h2>

<p>For DP solutions, we often only need the last <code class="language-plaintext highlighter-rouge">k</code> values. Use a sliding window.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">jump_game_dp_optimized</span><span class="p">(</span><span class="n">nums</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
    <span class="c1"># Instead of dp = [inf] * n, use a deque of size k
</span>    <span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">deque</span>
    <span class="n">window</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># dp[0] = 0
</span>    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="c1"># Remove old values outside the window
</span>        <span class="k">while</span> <span class="n">window</span> <span class="ow">and</span> <span class="n">window</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">i</span> <span class="o">-</span> <span class="n">max_jump_distance</span><span class="p">:</span>
            <span class="n">window</span><span class="p">.</span><span class="nf">popleft</span><span class="p">()</span>
        
        <span class="c1"># dp[i] = min(window) + 1
</span>        <span class="n">dp_i</span> <span class="o">=</span> <span class="n">window</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
        
        <span class="c1"># Add to window
</span>        <span class="k">while</span> <span class="n">window</span> <span class="ow">and</span> <span class="n">window</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">dp_i</span><span class="p">:</span>
            <span class="n">window</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
        <span class="n">window</span><span class="p">.</span><span class="nf">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">dp_i</span><span class="p">))</span>
    
    <span class="k">return</span> <span class="n">window</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div></div>

<h2 id="32-conclusion--summary">32. Conclusion &amp; Summary</h2>

<p>Jump Game II is more than just a coding problem—it’s a gateway to understanding greedy algorithms, graph traversal, and dynamic programming. The key insights:</p>

<ol>
  <li><strong>Greedy Works:</strong> When we can make locally optimal choices that lead to global optimality.</li>
  <li><strong>BFS is Versatile:</strong> Model as a graph and use level-order traversal.</li>
  <li><strong>DP for Variants:</strong> When we need to track scores or counts.</li>
  <li><strong>Proof Matters:</strong> Always verify that greedy is correct (exchange argument).</li>
</ol>

<p><strong>Mastery Checklist:</strong></p>
<ul class="task-list">
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Solve Jump Game I (Can Reach?)</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Solve Jump Game II (Minimum Jumps) in O(N) time, O(1) space</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Solve Jump Game III (Reach Zero)</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Solve Jump Game IV (BFS with HashMap)</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Solve Jump Game V (DP with Sorting)</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Solve Jump Game VI (DP with Deque)</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Solve Jump Game VII (String Constraints)</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Solve Frog Jump</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Explain why greedy works (proof)</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Implement the path reconstruction variant</li>
</ul>

<p><strong>Next Steps:</strong></p>
<ul>
  <li>Practice on LeetCode: Problems 45, 55, 1306, 1345, 1340, 1696, 1871, 403.</li>
  <li>Study related problems: Minimum Cost to Reach Destination, Cheapest Flights Within K Stops.</li>
  <li>Explore advanced topics: A* search, Bidirectional BFS.</li>
</ul>

<p>The journey from “Can I reach the end?” to “What’s the optimal path with constraints?” teaches us to think algorithmically and adapt solutions to new problems. This is the essence of problem-solving in computer science.</p>


        
      </section>

      <footer class="page__meta">
        
        
  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-tags" aria-hidden="true"></i> Tags: </strong>
    <span itemprop="keywords">
    
      <a href="/tags/#array" class="page__taxonomy-item p-category" rel="tag">array</a><span class="sep">, </span>
    
      <a href="/tags/#bfs" class="page__taxonomy-item p-category" rel="tag">bfs</a><span class="sep">, </span>
    
      <a href="/tags/#dynamic-programming" class="page__taxonomy-item p-category" rel="tag">dynamic-programming</a><span class="sep">, </span>
    
      <a href="/tags/#greedy" class="page__taxonomy-item p-category" rel="tag">greedy</a>
    
    </span>
  </p>




  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> Categories: </strong>
    <span itemprop="keywords">
    
      <a href="/categories/#dsa" class="page__taxonomy-item p-category" rel="tag">dsa</a>
    
    </span>
  </p>


        
      </footer>

      

      <section class="page__share">
  <h4 class="page__share-title">Share on</h4>

  <a href="https://twitter.com/intent/tweet?via=arunbaby0&text=Jump+Game+II%20https%3A%2F%2Fwww.arunbaby.com%2Fdsa%2F0041-jump-game-ii%2F" class="btn btn--twitter" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Twitter"><i class="fab fa-fw fa-twitter" aria-hidden="true"></i><span> Twitter</span></a>

  <a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fwww.arunbaby.com%2Fdsa%2F0041-jump-game-ii%2F" class="btn btn--facebook" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Facebook"><i class="fab fa-fw fa-facebook" aria-hidden="true"></i><span> Facebook</span></a>

  <a href="https://www.linkedin.com/shareArticle?mini=true&url=https://www.arunbaby.com/dsa/0041-jump-game-ii/" class="btn btn--linkedin" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on LinkedIn"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i><span> LinkedIn</span></a>
</section>


      
  <nav class="pagination">
    
      <a href="/dsa/0040-trapping-rain-water/" class="pagination--pager" title="Trapping Rain Water">Previous</a>
    
    
      <a href="/dsa/0042-merge-k-sorted-lists/" class="pagination--pager" title="Merge K Sorted Lists">Next</a>
    
  </nav>


    </div>

    
  </article>

  
  
</div>

      
    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';" role="search">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Enter your search term..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    

    
      
        
          <li><a href="https://twitter.com/arunbaby0" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-twitter-square" aria-hidden="true"></i> Twitter</a></li>
        
      
        
          <li><a href="https://github.com/arunbaby0" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
        
      
        
          <li><a href="https://www.linkedin.com/in/arunbaby0/" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i> LinkedIn</a></li>
        
      
        
          <li><a href="https://scholar.google.co.in/citations?user=6fSYWhkAAAAJ" rel="nofollow noopener noreferrer"><i class="fas fa-fw fa-graduation-cap" aria-hidden="true"></i> Google Scholar</a></li>
        
      
    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 1990 - 2143 <a href="https://www.arunbaby.com">Arun Baby</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>




  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-0JRJPEC9SS"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-0JRJPEC9SS', { 'anonymize_ip': false});
</script>








  </body>
</html>
