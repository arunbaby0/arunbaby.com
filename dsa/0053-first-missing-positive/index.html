<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.26.2 by Michael Rose
  Copyright 2013-2024 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->

<html lang="en-US" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>First Missing Positive - Arun Baby</title>
<meta name="description" content="“The missing number is hiding in plain sight—use the array itself as the hash table.”">


  <meta name="author" content="Arun Baby">
  
  <meta property="article:author" content="Arun Baby">
  


<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="Arun Baby">
<meta property="og:title" content="First Missing Positive">
<meta property="og:url" content="https://www.arunbaby.com/dsa/0053-first-missing-positive/">


  <meta property="og:description" content="“The missing number is hiding in plain sight—use the array itself as the hash table.”">



  <meta property="og:image" content="https://www.arunbaby.com/assets/images/profile-photo.png">



  <meta name="twitter:site" content="@arunbaby0">
  <meta name="twitter:title" content="First Missing Positive">
  <meta name="twitter:description" content="“The missing number is hiding in plain sight—use the array itself as the hash table.”">
  <meta name="twitter:url" content="https://www.arunbaby.com/dsa/0053-first-missing-positive/">

  
    <meta name="twitter:card" content="summary">
    
      <meta name="twitter:image" content="https://www.arunbaby.com/assets/images/profile-photo.png">
    
  

  



  <meta property="article:published_time" content="2025-12-29T15:12:33+05:30">





  

  


<link rel="canonical" href="https://www.arunbaby.com/dsa/0053-first-missing-positive/">












<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Arun Baby Feed">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
  
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css"></noscript>



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--single" dir="ltr">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
           
          <span class="site-subtitle">Arun Baby</span>
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a
                href="/about/"
                
                
              >About</a>
            </li><li class="masthead__menu-item">
              <a
                href="/dsa/"
                
                
              >DSA</a>
            </li><li class="masthead__menu-item">
              <a
                href="/ml-system-design/"
                
                
              >ML Systems</a>
            </li><li class="masthead__menu-item">
              <a
                href="/speech-tech/"
                
                
              >Speech Tech</a>
            </li><li class="masthead__menu-item">
              <a
                href="/ai-agents/"
                
                
              >AI Agents</a>
            </li><li class="masthead__menu-item">
              <a
                href="/publications/"
                
                
              >Publications</a>
            </li><li class="masthead__menu-item">
              <a
                href="/statuses/"
                
                
              >Statuses</a>
            </li><li class="masthead__menu-item">
              <a
                href="/contact/"
                
                
              >Contact</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <i class="fas fa-search"></i>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      





<div id="main" role="main" class="no-author-sidebar">
  
  <div class="sidebar sticky">
  
  
  </div>



  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="First Missing Positive">
    <meta itemprop="description" content="“The missing number is hiding in plain sight—use the array itself as the hash table.”">
    <meta itemprop="datePublished" content="2025-12-29T15:12:33+05:30">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">
            <a href="https://www.arunbaby.com/dsa/0053-first-missing-positive/" itemprop="url">First Missing Positive
</a>
          </h1>
          

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          20 minute read
        
      </span>
    
  </p>


        </header>
      

      <section class="page__content" itemprop="text">
        
          <aside class="sidebar__right sticky">
            <nav class="toc">
              <header><h4 class="nav__title"><i class="fas fa-file-alt"></i> On this page</h4></header>
              <ul class="toc__menu"><li><a href="#1-problem-statement">1. Problem Statement</a><ul><li><a href="#11-constraints-the-hard-version">1.1 Constraints (The Hard Version)</a></li><li><a href="#12-examples-for-intuition">1.2 Examples for Intuition</a></li></ul></li><li><a href="#2-understanding-the-problem-deep-dive">2. Understanding the Problem: Deep Dive</a><ul><li><a href="#21-the-mathematical-bound-why-1-n1">2.1 The Mathematical Bound: Why [1, n+1]?</a></li><li><a href="#22-why-this-is-a-hard-problem">2.2 Why This is a “Hard” Problem</a></li><li><a href="#23-thematic-links-to-systems-engineering">2.3 Thematic Links to Systems Engineering</a></li></ul></li><li><a href="#3-approach-1-cyclic-placement-the-intuitive-swap">3. Approach 1: Cyclic Placement (The Intuitive Swap)</a><ul><li><a href="#31-the-core-logic">3.1 The Core Logic</a></li><li><a href="#32-step-by-step-visualization">3.2 Step-by-Step Visualization</a></li><li><a href="#33-complexity-analysis-of-cyclic-placement">3.3 Complexity Analysis of Cyclic Placement</a></li></ul></li><li><a href="#4-approach-2-sign-marking-the-compact-trick">4. Approach 2: Sign Marking (The Compact Trick)</a><ul><li><a href="#41-the-4-step-process">4.1 The 4-Step Process</a></li><li><a href="#42-why-this-works">4.2 Why This Works</a></li></ul></li><li><a href="#5-implementation-case-study-two-approaches">5. Implementation Case Study: Two Approaches</a><ul><li><a href="#51-cyclic-placement-the-swap-strategy">5.1 Cyclic Placement (The Swap Strategy)</a></li><li><a href="#52-sign-marking-the-encoding-strategy">5.2 Sign Marking (The Encoding Strategy)</a></li><li><a href="#53-comparative-analysis-which-is-better">5.3 Comparative Analysis: Which is better?</a></li></ul></li><li><a href="#6-implementation-deep-dive-line-by-line-breakdown">6. Implementation Deep Dive: Line-by-Line Breakdown</a><ul><li><a href="#51-the-duplicate-guard-explained">5.1 The “Duplicate Guard” Explained</a></li></ul></li><li><a href="#8-scaling-to-streaming-data-bitsets">8. Scaling to Streaming Data (BitSets)</a></li><li><a href="#9-parallel-scaling-distributed-mapreduce-worker">9. Parallel Scaling: Distributed MapReduce Worker</a></li><li><a href="#10-implementation-deep-dive-line-by-line-breakdown">10. Implementation Deep Dive: Line-by-Line Breakdown</a></li><li><a href="#9-connections-to-ml-systems">9. Connections to ML Systems</a><ul><li><a href="#91-data-validation-guardrails">9.1 Data Validation Guardrails</a></li><li><a href="#92-feature-hashing-vs-index-mapping">9.2 Feature Hashing vs. Index Mapping</a></li><li><a href="#93-speech-track-link-jitter-buffers">9.3 Speech Track Link: Jitter Buffers</a></li></ul></li><li><a href="#10-interview-strategy-how-to-ace-the-hard">10. Interview Strategy: How to Ace the “Hard”</a></li><li><a href="#11-key-takeaways">11. Key Takeaways</a></li><li><a href="#12-advanced-scaling-the-simd-and-branch-prediction-edge">12. Advanced Scaling: The SIMD and Branch Prediction Edge</a></li><li><a href="#13-distributed-data-validation-the-mapreduce-approach">13. Distributed Data Validation: The MapReduce Approach</a></li><li><a href="#14-history-the-evolution-of-in-place-algorithms">14. History: The Evolution of In-Place Algorithms</a></li><li><a href="#15-advanced-follow-up-finding-all-missing-positives">15. Advanced Follow-up: Finding ALL Missing Positives</a></li><li><a href="#16-the-future-probabilistic-missing-positive-detection">16. The Future: Probabilistic Missing Positive Detection</a></li><li><a href="#17-real-world-engineering-case-study-linux-kernel-memory-management">17. Real-world Engineering Case Study: Linux Kernel Memory Management</a></li><li><a href="#18-coding-best-practices-for-in-place-algorithms">18. Coding Best Practices for In-Place Algorithms</a></li></ul>
            </nav>
          </aside>
        
        <p><strong>“The missing number is hiding in plain sight—use the array itself as the hash table.”</strong></p>

<h2 id="1-problem-statement">1. Problem Statement</h2>

<p>Given an unsorted integer array <code class="language-plaintext highlighter-rouge">nums</code>, find the smallest missing positive integer.</p>

<h3 id="11-constraints-the-hard-version">1.1 Constraints (The Hard Version)</h3>
<p>To satisfy the requirements of high-performance system design, you must adhere to the following constraints:</p>
<ul>
  <li><strong>Time Complexity</strong>: You must run in <strong>O(N)</strong> time. The algorithm should scale linearly with the input size.</li>
  <li><strong>Space Complexity</strong>: You must use <strong>O(1)</strong> extra space. You cannot allocate new data structures like sets or additional arrays proportional to the input size.</li>
</ul>

<h3 id="12-examples-for-intuition">1.2 Examples for Intuition</h3>
<p><strong>Example 1</strong></p>
<ul>
  <li><strong>Input</strong>: <code class="language-plaintext highlighter-rouge">nums = [1, 2, 0]</code></li>
  <li><strong>Output</strong>: <code class="language-plaintext highlighter-rouge">3</code></li>
  <li><strong>Reasoning</strong>: 1 and 2 are present. The next positive integer is 3.</li>
</ul>

<p><strong>Example 2</strong></p>
<ul>
  <li><strong>Input</strong>: <code class="language-plaintext highlighter-rouge">nums = [3, 4, -1, 1]</code></li>
  <li><strong>Output</strong>: <code class="language-plaintext highlighter-rouge">2</code></li>
  <li><strong>Reasoning</strong>: 1 is present, but 2 is missing.</li>
</ul>

<p><strong>Example 3</strong></p>
<ul>
  <li><strong>Input</strong>: <code class="language-plaintext highlighter-rouge">nums = [7, 8, 9, 11, 12]</code></li>
  <li><strong>Output</strong>: <code class="language-plaintext highlighter-rouge">1</code></li>
  <li><strong>Reasoning</strong>: 1 is the smallest positive integer, and it is missing.</li>
</ul>

<hr />

<h2 id="2-understanding-the-problem-deep-dive">2. Understanding the Problem: Deep Dive</h2>

<h3 id="21-the-mathematical-bound-why-1-n1">2.1 The Mathematical Bound: Why [1, n+1]?</h3>
<p>The most critical insight for this problem is the search space. Many candidates start by looking for any positive integer from 1 to infinity. However, with an array of length $n$, the smallest missing positive integer <strong>must</strong> fall within the range $[1, n+1]$.</p>

<p><strong>The “Pigeonhole Principle” Proof</strong>:
Imagine you have $n$ slots in your array.</p>
<ul>
  <li>If you fill those $n$ slots with the numbers $1, 2, 3, \dots, n$, then the first missing positive is $n+1$.</li>
  <li>If you replace any of those numbers (say, replace $2$ with $100$ or $-5$), then a number in the range $[1, n]$ becomes missing.</li>
  <li>Therefore, the answer can never be larger than $n+1$.</li>
</ul>

<p>This realization transforms the problem from an infinite search into a bounded search. Once the search is bounded to the size of the input array, the possibility of using the array itself as a storage mechanism emerges.</p>

<h3 id="22-why-this-is-a-hard-problem">2.2 Why This is a “Hard” Problem</h3>
<p>If we relax the constraints, the problem becomes trivial:</p>
<ol>
  <li><strong>HashSet Solution</strong>: Add all numbers to a set, then iterate from 1 to $n+1$. This is $O(N)$ time and $O(N)$ space.</li>
  <li><strong>Sorting Solution</strong>: Sort the array and scan for gaps. This is $O(N \log N)$ time and $O(1)$ space.</li>
</ol>

<p>The “Hard” designation comes from the requirement to achieve <strong>both</strong> $O(N)$ time and $O(1)$ space. This requires a specific class of algorithms known as <strong>In-Place Index Mapping</strong>.</p>

<h3 id="23-thematic-links-to-systems-engineering">2.3 Thematic Links to Systems Engineering</h3>
<p>This problem isn’t just a brain teaser; it represents a core pattern in low-level systems engineering:</p>
<ul>
  <li><strong>Data Integrity</strong>: Filtering out “noise” (negatives, zeros, large numbers) is the first step in any robust data pipeline.</li>
  <li><strong>Memory Efficiency</strong>: In high-throughput systems (like network packet processors), you cannot afford to allocate memory for every packet. You must process the data “in-flight” within the buffer it arrived in.</li>
  <li><strong>Normalization</strong>: Mapping a messy, wide-range input into a canonical, narrow-range domain is a fundamental pre-processing step in both ML and Speech Tech.</li>
</ul>

<hr />

<h2 id="3-approach-1-cyclic-placement-the-intuitive-swap">3. Approach 1: Cyclic Placement (The Intuitive Swap)</h2>

<p>The “Cyclic Placement” algorithm is based on the idea of a “permuted array.” In a perfect world, our array of size $n$ would contain the value $i+1$ at index $i$. Our goal is to rearrange the array to match this ideal state as much as possible.</p>

<h3 id="31-the-core-logic">3.1 The Core Logic</h3>
<p>We iterate through the array starting from the first index. For each element, we ask: “Does this value belong here?”</p>
<ul>
  <li>If the value $v$ is in the range $[1, n]$ AND it is not at its correct index ($v-1$), we swap it with the element currently at $v-1$.</li>
  <li>We continue swapping the “new” element at our current index until it is either out of range or correctly placed.</li>
</ul>

<h3 id="32-step-by-step-visualization">3.2 Step-by-Step Visualization</h3>
<p>Let’s trace <code class="language-plaintext highlighter-rouge">nums = [3, 4, -1, 1]</code> where $n=4$.</p>

<ol>
  <li><strong>Index 0 (Value 3)</strong>:
    <ul>
      <li>Does 3 belong at index 0? No, it belongs at index 2 ($3-1$).</li>
      <li>Swap <code class="language-plaintext highlighter-rouge">nums[0]</code> (3) with <code class="language-plaintext highlighter-rouge">nums[2]</code> (-1).</li>
      <li>Array becomes: <code class="language-plaintext highlighter-rouge">[-1, 4, 3, 1]</code></li>
      <li>Now, does <code class="language-plaintext highlighter-rouge">nums[0]</code> (-1) belong here? No, it’s out of range. Move to index 1.</li>
    </ul>
  </li>
  <li><strong>Index 1 (Value 4)</strong>:
    <ul>
      <li>Does 4 belong at index 1? No, it belongs at index 3 ($4-1$).</li>
      <li>Swap <code class="language-plaintext highlighter-rouge">nums[1]</code> (4) with <code class="language-plaintext highlighter-rouge">nums[3]</code> (1).</li>
      <li>Array becomes: <code class="language-plaintext highlighter-rouge">[-1, 1, 3, 4]</code></li>
      <li>Now, does <code class="language-plaintext highlighter-rouge">nums[1]</code> (1) belong at index 1? No, it belongs at index 0 ($1-1$).</li>
      <li>Swap <code class="language-plaintext highlighter-rouge">nums[1]</code> (1) with <code class="language-plaintext highlighter-rouge">nums[0]</code> (-1).</li>
      <li>Array becomes: <code class="language-plaintext highlighter-rouge">[1, -1, 3, 4]</code></li>
      <li>Now, does <code class="language-plaintext highlighter-rouge">nums[1]</code> (-1) belong here? No, out of range. Move to index 2.</li>
    </ul>
  </li>
  <li><strong>Index 2 (Value 3)</strong>:
    <ul>
      <li>Does 3 belong here? Yes (index 2 contains 3). Move to index 3.</li>
    </ul>
  </li>
  <li><strong>Index 3 (Value 4)</strong>:
    <ul>
      <li>Does 4 belong here? Yes. End of loop.</li>
    </ul>
  </li>
</ol>

<p><strong>Final Scan</strong>:</p>
<ul>
  <li>Index 0: Has 1 (Correct)</li>
  <li>Index 1: Has -1 (Wait! Expected 2. Found the “hole”!)</li>
  <li><strong>Result: 2</strong></li>
</ul>

<h3 id="33-complexity-analysis-of-cyclic-placement">3.3 Complexity Analysis of Cyclic Placement</h3>
<ul>
  <li><strong>Time</strong>: $O(N)$. Although there’s a <code class="language-plaintext highlighter-rouge">while</code> loop inside a <code class="language-plaintext highlighter-rouge">for</code> loop, each swap operation places at least one number in its correct final position. Since there are only $n$ positions, there can be at most $n$ successful swaps across the entire execution. This is known as <strong>Amortized Analysis</strong>.</li>
  <li><strong>Space</strong>: $O(1)$. We only used a few pointer variables.</li>
</ul>

<hr />

<h2 id="4-approach-2-sign-marking-the-compact-trick">4. Approach 2: Sign Marking (The Compact Trick)</h2>

<p>Sign Marking is a more subtle technique often used in bit manipulation and low-level C programming. It relies on the fact that we can store one bit of extra information (the sign bit) without changing the absolute value of the number (mostly).</p>

<h3 id="41-the-4-step-process">4.1 The 4-Step Process</h3>
<ol>
  <li><strong>Sanity Check</strong>: Does 1 even exist in the array? If not, the answer is 1.</li>
  <li><strong>Normalization</strong>: Replace all numbers $\le 0$ or $&gt; n$ with the value 1. Now the array only contains values in $[1, n]$.</li>
  <li><strong>Presence Encoding</strong>: For each value $v$ in the array, find the index $(abs(v) - 1)$ and make the value at that index <strong>negative</strong>.</li>
  <li><strong>The Search</strong>: Scan the array. The first index $i$ that contains a <strong>positive</strong> value means that the number $i+1$ was never seen in the array.</li>
</ol>

<h3 id="42-why-this-works">4.2 Why This Works</h3>
<p>The sign bit acts as a boolean “seen” flag. Because we normalized everything to be positive in step 2, we can safely use the negative sign to mean “this index has been visited.”</p>

<hr />

<hr />

<h2 id="5-implementation-case-study-two-approaches">5. Implementation Case Study: Two Approaches</h2>

<p>In this section, we provide the complete implementations for both the <strong>Cyclic Placement</strong> (swapping) and <strong>Sign Marking</strong> (encoding) strategies. While both are $O(N)$ time and $O(1)$ space, their cache behavior and mutation patterns differ.</p>

<h3 id="51-cyclic-placement-the-swap-strategy">5.1 Cyclic Placement (The Swap Strategy)</h3>

<p>This approach is highly favored in interviews because it demonstrates an “in-place sorting” logic.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">List</span>

<span class="k">def</span> <span class="nf">first_missing_positive_swap</span><span class="p">(</span><span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">
    Finds the first missing positive integer using the cyclic placement pattern.
    
    Time: O(N) - Each number is placed in its correct position at most once.
    Space: O(1) - No extra allocations proportional to input size.
    </span><span class="sh">"""</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
    
    <span class="c1"># Phase 1: In-place Swapping
</span>    <span class="c1"># We move through the array and try to place each number 'v' in index 'v-1'.
</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">while</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="ow">and</span> <span class="n">nums</span><span class="p">[</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="c1"># Python's tuple unpacking makes in-place swapping safe and concise.
</span>            <span class="c1"># We must swap nums[i] with the element at its 'home' index (nums[i] - 1).
</span>            <span class="c1"># Note: The order matters here for the unpacking to work correctly.
</span>            <span class="n">correct_idx</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">correct_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">correct_idx</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            
    <span class="c1"># Phase 2: Search for the first mismatch
</span>    <span class="c1"># After the swaps, a correct array should look like [1, 2, 3, ..., n].
</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
            
    <span class="c1"># If all positions are correct, the missing number is n + 1.
</span>    <span class="k">return</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span>
</code></pre></div></div>

<h3 id="52-sign-marking-the-encoding-strategy">5.2 Sign Marking (The Encoding Strategy)</h3>

<p>This approach is often used in performance-critical C systems because it avoids the overhead of repeated swapping and uses simple sign-bit toggling.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">first_missing_positive_encoding</span><span class="p">(</span><span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">
    Finds the first missing positive using the index-as-storage pattern.
    
    Steps:
    1. Check for 1</span><span class="sh">'</span><span class="s">s presence.
    2. Normalize: remove noisy negatives and large numbers.
    3. Hash via sign bits: mark indices of seen values.
    4. Scan for the first positive index.
    </span><span class="sh">"""</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
    
    <span class="c1"># 1. Edge Case: Is 1 present?
</span>    <span class="n">has_one</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">has_one</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">break</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">has_one</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span>
        
    <span class="c1"># 2. Normalization: Replace negatives and &gt;n with 1
</span>    <span class="c1"># Since we know 1 is present, we can safely overwrite noise with 1.
</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">n</span><span class="p">:</span>
            <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            
    <span class="c1"># 3. Presence Encoding via Sign Bits
</span>    <span class="c1"># For a value 'v', we treat nums[v-1] as the bucket for 'v'.
</span>    <span class="c1"># We negate the value at index v-1 to mark 'v' as 'seen'.
</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">val</span> <span class="o">=</span> <span class="nf">abs</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="c1"># Find index for this value
</span>        <span class="n">idx</span> <span class="o">=</span> <span class="n">val</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="c1"># If the number at idx is positive, negate it.
</span>        <span class="c1"># We use abs() to avoid flipping a negative back to positive.
</span>        <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">nums</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">nums</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            
    <span class="c1"># 4. Search
</span>    <span class="c1"># The first index that remains positive was never 'seen'.
</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
            
    <span class="k">return</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span>
</code></pre></div></div>

<h3 id="53-comparative-analysis-which-is-better">5.3 Comparative Analysis: Which is better?</h3>

<table>
  <thead>
    <tr>
      <th style="text-align: left">Feature</th>
      <th style="text-align: left">Swap Strategy</th>
      <th style="text-align: left">Sign Marking</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left"><strong>Logic</strong></td>
      <td style="text-align: left">Intuitive</td>
      <td style="text-align: left">Subtle (two-pass)</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>Mutation</strong></td>
      <td style="text-align: left">Heavy (many swaps)</td>
      <td style="text-align: left">Low (one write per idx)</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>Edge Cases</strong></td>
      <td style="text-align: left">Duplicates are tricky</td>
      <td style="text-align: left">Handled naturally</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>Best For</strong></td>
      <td style="text-align: left">Interviews</td>
      <td style="text-align: left">Systems with expensive writes</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="6-implementation-deep-dive-line-by-line-breakdown">6. Implementation Deep Dive: Line-by-Line Breakdown</h2>

<h3 id="51-the-duplicate-guard-explained">5.1 The “Duplicate Guard” Explained</h3>
<p>Interviewer: “What happens if the input is <code class="language-plaintext highlighter-rouge">[1, 1]</code>?”
Me:</p>
<ul>
  <li>At <code class="language-plaintext highlighter-rouge">i=0</code>, <code class="language-plaintext highlighter-rouge">val=1</code>, <code class="language-plaintext highlighter-rouge">target_idx=0</code>. Since <code class="language-plaintext highlighter-rouge">nums[0] == nums[0]</code>, the <code class="language-plaintext highlighter-rouge">if</code> condition fails. <code class="language-plaintext highlighter-rouge">i</code> becomes 1.</li>
  <li>At <code class="language-plaintext highlighter-rouge">i=1</code>, <code class="language-plaintext highlighter-rouge">val=1</code>, <code class="language-plaintext highlighter-rouge">target_idx=0</code>. Now, <code class="language-plaintext highlighter-rouge">nums[1]</code> (1) is equal to <code class="language-plaintext highlighter-rouge">nums[0]</code> (1). If we swapped, we would just be putting a 1 where a 1 already is. We would never make progress and would loop forever.</li>
  <li>The condition <code class="language-plaintext highlighter-rouge">nums[i] != nums[target_idx]</code> is the “Duplicate Guard” that ensures terminate in the presence of repeated values.</li>
</ul>

<hr />

<h2 id="8-scaling-to-streaming-data-bitsets">8. Scaling to Streaming Data (BitSets)</h2>

<p>What if the numbers are coming from a live sensor? We use a <strong>BitSet</strong> for $O(N)$ space in bits (extremely compact).</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">array</span>

<span class="k">class</span> <span class="nc">BitSetValidator</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">
    A memory-efficient BitSet for checking occurrences in large streams.
    Requires ~1MB for 8 million possible positive integers.
    </span><span class="sh">"""</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="c1"># We use an 'I' (unsigned int) array to store bits.
</span>        <span class="c1"># Each int has 32 bits.
</span>        <span class="n">self</span><span class="p">.</span><span class="n">bits</span> <span class="o">=</span> <span class="n">array</span><span class="p">.</span><span class="nf">array</span><span class="p">(</span><span class="sh">'</span><span class="s">I</span><span class="sh">'</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">size</span> <span class="o">//</span> <span class="mi">32</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        
    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">bits</span><span class="p">)</span> <span class="o">*</span> <span class="mi">32</span><span class="p">):</span>
            <span class="k">return</span>
        <span class="c1"># Locate which integer and which bit within that int
</span>        <span class="n">int_idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">32</span>
        <span class="n">bit_pos</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">32</span>
        <span class="c1"># Set the bit
</span>        <span class="n">self</span><span class="p">.</span><span class="n">bits</span><span class="p">[</span><span class="n">int_idx</span><span class="p">]</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">bit_pos</span><span class="p">)</span>
        
    <span class="k">def</span> <span class="nf">find_first_missing</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">block</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">bits</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">block</span> <span class="o">==</span> <span class="mh">0xFFFFFFFF</span><span class="p">:</span>
                <span class="k">continue</span> <span class="c1"># All 32 bits are 1
</span>            <span class="c1"># Find the first 0 bit in this block
</span>            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">32</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">block</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">b</span><span class="p">)):</span>
                    <span class="n">potential</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">32</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="k">return</span> <span class="n">potential</span>
        <span class="k">return</span> <span class="mi">1</span>
</code></pre></div></div>

<h2 id="9-parallel-scaling-distributed-mapreduce-worker">9. Parallel Scaling: Distributed MapReduce Worker</h2>

<p>For Petabyte-scale data validation, we use a distributed worker strategy. Each worker processes a chunk and emits a local frequency bitmap.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Simplified Distributed Worker Pattern (PySpark-like)
</span><span class="k">def</span> <span class="nf">map_partition_to_bits</span><span class="p">(</span><span class="n">iterator</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">
    Processes a partition of numbers and returns a local bit-array.
    </span><span class="sh">"""</span>
    <span class="n">local_bits</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1"># Process only numbers in a specific range [1, R]
</span>    <span class="n">R</span> <span class="o">=</span> <span class="mi">1000000</span> 
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">iterator</span><span class="p">:</span>
        <span class="k">if</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">R</span><span class="p">:</span>
            <span class="c1"># Shift 1 to the 'x-1'th position and OR it
</span>            <span class="n">local_bits</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
    <span class="k">yield</span> <span class="n">local_bits</span>

<span class="k">def</span> <span class="nf">reduce_bitmaps</span><span class="p">(</span><span class="n">bit1</span><span class="p">,</span> <span class="n">bit2</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">
    Merges two bitmaps using a bitwise OR.
    </span><span class="sh">"""</span>
    <span class="k">return</span> <span class="n">bit1</span> <span class="o">|</span> <span class="n">bit2</span>

<span class="c1"># Resulting 'merged_bits' is searched for the first 0-bit.
</span></code></pre></div></div>

<hr />

<h2 id="10-implementation-deep-dive-line-by-line-breakdown">10. Implementation Deep Dive: Line-by-Line Breakdown</h2>

<p>Let’s dissect the <strong>Cyclic Placement</strong> (swapping) code line-by-line:</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">while i &lt; n:</code>: We use a <code class="language-plaintext highlighter-rouge">while</code> loop instead of a <code class="language-plaintext highlighter-rouge">for</code> loop because we might need to re-evaluate the same index <code class="language-plaintext highlighter-rouge">i</code> multiple times if a swap brings a “new” number into <code class="language-plaintext highlighter-rouge">nums[i]</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">1 &lt;= val &lt;= n</code>: We only care about numbers that <em>could</em> be our answer. Negatives, zeros, and numbers larger than the array size are “noise” that we ignore.</li>
  <li><code class="language-plaintext highlighter-rouge">nums[i] != nums[target_idx]</code>: This is the <strong>most important line</strong>. It prevents infinite loops if the array contains duplicates (e.g., <code class="language-plaintext highlighter-rouge">[1, 1]</code>). If the value at <code class="language-plaintext highlighter-rouge">i</code> is already present at its correct home <code class="language-plaintext highlighter-rouge">target_idx</code>, we don’t swap.</li>
  <li><code class="language-plaintext highlighter-rouge">nums[i], nums[target_idx] = nums[target_idx], nums[i]</code>: This Pythonic idiom handles the three-step swap process (temp variable) atomically and correctly.</li>
  <li><code class="language-plaintext highlighter-rouge">for i in range(n): if nums[i] != i + 1: return i + 1</code>: This final pass is the “verification” phase. The first index that doesn’t hold its expected value reveals the smallest missing positive.</li>
</ol>

<hr />

<h2 id="9-connections-to-ml-systems">9. Connections to ML Systems</h2>

<h3 id="91-data-validation-guardrails">9.1 Data Validation Guardrails</h3>
<p>In any ML production pipeline, “Data Quality” is the primary barrier to reliability. Before feeding data into a model:</p>
<ul>
  <li>You must validate that the indices and IDs fall within expected ranges.</li>
  <li>You must detect “Gaps” in the data that might indicate a sensor failure or a network dropout.
This algorithm is the most efficient way to detect the first “missing link” in a sequence of events.</li>
</ul>

<h3 id="92-feature-hashing-vs-index-mapping">9.2 Feature Hashing vs. Index Mapping</h3>
<p>In ML feature engineering, we often use <strong>Feature Hashing (the hashing trick)</strong> to map high-cardinality features into a fixed-size vector. This algorithm uses the opposite principle: <strong>Index Mapping</strong>. Instead of a hash function, we use the value itself as its own address. This is the ultimate form of “Perfect Hashing” where collisions are impossible because each value has exactly one home.</p>

<h3 id="93-speech-track-link-jitter-buffers">9.3 Speech Track Link: Jitter Buffers</h3>
<p>In Speech Technology (VoIP, live transcription), audio packets arrive out of order or go missing. A <strong>Jitter Buffer</strong> reorders packets based on their sequence numbers. If sequence numbers are missing, the system must decide whether to wait or to perform <strong>Packet Loss Concealment (PLC)</strong>. Finding the “first missing sequence number” is exactly the First Missing Positive problem.</p>

<hr />

<h2 id="10-interview-strategy-how-to-ace-the-hard">10. Interview Strategy: How to Ace the “Hard”</h2>

<ol>
  <li><strong>Clarify Constraints Early</strong>: Confirm “Am I allowed to mutate the input?” and “Is it guaranteed to fit in memory?”. This shows you understand the trade-offs of in-place algorithms.</li>
  <li><strong>Start with the Bound</strong>: Narrating the [1, n+1] range bound is the “aha!” moment that proves you have the right intuition.</li>
  <li><strong>The Duplicate Trap</strong>: Explicitly mention that you are handling duplicates. It’s the #1 reason an “optimal” solution fails a hidden test case.</li>
  <li><strong>Complexity Proof</strong>: Don’t just say $O(N)$. Explain <strong>why</strong> the nested <code class="language-plaintext highlighter-rouge">while</code> loop is $O(N)$ (amortized analysis).</li>
</ol>

<hr />

<h2 id="11-key-takeaways">11. Key Takeaways</h2>

<ol>
  <li><strong>Bounded Domain → Perfect Storage</strong>: If you know the range of your data, you can use the structure itself as metadata storage.</li>
  <li><strong>Amortized Efficiency</strong>: Nested loops do not always mean $O(N^2)$. If each operation does permanent, non-repeating work, the algorithm remains linear.</li>
  <li><strong>Systems Mindset</strong>: $O(1)$ space isn’t just a gimmick; it’s about cache locality, GC pressure, and the principles of Zero-Copy engineering.</li>
</ol>

<hr />

<h2 id="12-advanced-scaling-the-simd-and-branch-prediction-edge">12. Advanced Scaling: The SIMD and Branch Prediction Edge</h2>

<p>In high-performance C++ or Rust implementations of this algorithm, we can leverage <strong>SIMD (Single Instruction, Multiple Data)</strong> to accelerate the normalization and final scan phases.</p>
<ul>
  <li><strong>Normalization</strong>: Instead of checking each number one by one to see if it’s in <code class="language-plaintext highlighter-rouge">[1, n]</code>, you can load 8 or 16 integers into a SIMD register and compare them all in a single CPU cycle.</li>
  <li><strong>Branch Prediction</strong>: The <code class="language-plaintext highlighter-rouge">if 1 &lt;= val &lt;= n</code> check can be tricky for the CPU’s branch predictor if the data is highly randomized. To avoid “Branch Misprediction” penalties, senior engineers often use <strong>Bit-Twiddling</strong> to create a branchless mask. This keeps the CPU’s instruction pipeline full and flowing at maximum speed.</li>
</ul>

<h2 id="13-distributed-data-validation-the-mapreduce-approach">13. Distributed Data Validation: The MapReduce Approach</h2>

<p>What if your data is measured in Petabytes and spread across a thousand machines (e.g., in a Hadoop or Spark cluster)?</p>
<ul>
  <li><strong>Step 1 (Map)</strong>: Each worker processes its local chunk and emits a “Local BitSet” of $n$ bits. A bit is 1 if the number was seen.</li>
  <li><strong>Step 2 (Shuffle)</strong>: The BitSets are aggregated.</li>
  <li><strong>Step 3 (Reduce)</strong>: The reducer performs a bitwise <code class="language-plaintext highlighter-rouge">OR</code> on all BitSets. The first 0-bit in the final BitSet is the missing positive.
This allows you to find the missing positive for billions of IDs in seconds by parallelizing the computation across a cluster.</li>
</ul>

<h2 id="14-history-the-evolution-of-in-place-algorithms">14. History: The Evolution of In-Place Algorithms</h2>

<p>The study of in-place algorithms dates back to the early days of computing (1950s and 60s) when a computer might only have 4KB of RAM.</p>
<ul>
  <li><strong>Quicksort</strong>: Developed by Tony Hoare in 1959, it’s the most famous in-place algorithm.</li>
  <li><strong>In-Place Mergesort</strong>: A notoriously difficult variation that avoids the extra work of standard merge.</li>
  <li><strong>Heapsort</strong>: Another $O(N \log N)$ in-place sorting algorithm.</li>
</ul>

<p>Our Index Mapping technique is part of this long lineage of “Memory-Conscious Design.” It echoes the era when programmers had to be extremely clever about every single byte, a skill that is becoming relevant again in the world of IoT and Edge Computing.</p>

<h2 id="15-advanced-follow-up-finding-all-missing-positives">15. Advanced Follow-up: Finding ALL Missing Positives</h2>

<p>What if the question was: “Find ALL missing numbers in the range <code class="language-plaintext highlighter-rouge">[1, n]</code>”?</p>
<ul>
  <li>The cyclic placement algorithm works exactly the same!</li>
  <li>After the swap phase, instead of returning at the first mismatch, you collect all indices <code class="language-plaintext highlighter-rouge">i</code> where <code class="language-plaintext highlighter-rouge">nums[i] != i + 1</code> and return the list <code class="language-plaintext highlighter-rouge">[i+1 for each mismatching i]</code>.</li>
  <li>This is the foundation of <strong>Missing Value Imputation</strong> in data science, where you need to identify and fill gaps in your datasets before training a model.</li>
</ul>

<h2 id="16-the-future-probabilistic-missing-positive-detection">16. The Future: Probabilistic Missing Positive Detection</h2>

<p>In the future of “Big Data,” we might not even need exact answers.</p>
<ul>
  <li><strong>HyperLogLog</strong>: Can estimate the number of <em>distinct</em> elements in a stream using almost zero memory.</li>
  <li><strong>Quotient Filters</strong>: A more space-efficient alternative to Bloom Filters that allows for “merging” and “deleting” items.
These probabilistic structures allow us to monitor the “health” of massive data streams without ever storing the numbers themselves.</li>
</ul>

<hr />

<h2 id="17-real-world-engineering-case-study-linux-kernel-memory-management">17. Real-world Engineering Case Study: Linux Kernel Memory Management</h2>

<p>The principles behind the “First Missing Positive” algorithm are remarkably similar to how the Linux Kernel manages its physical memory pages.</p>
<ul>
  <li><strong>The Problem</strong>: The kernel needs to find a free “Page Frame” (a chunk of RAM) to assign to a process.</li>
  <li><strong>The Solution (Bitmaps)</strong>: The kernel maintains a <code class="language-plaintext highlighter-rouge">free_area</code> structure which is essentially a BitMap. Each bit represents a page.</li>
  <li><strong>The Search</strong>: To find a free page, the kernel performs a “find first zero bit” operation. This is conceptually the same as finding the “First Missing Positive” in a sequence of occupied page indices.</li>
  <li><strong>Optimization</strong>: By using specialized CPU instructions like <code class="language-plaintext highlighter-rouge">CLZ</code> (Count Leading Zeros) or <code class="language-plaintext highlighter-rouge">BSR</code> (Bit Scan Reverse), the kernel can perform this search in just a few nanoseconds.</li>
</ul>

<p>This illustrates a broader truth: <strong>The most fundamental problems in computer science are often solved using the simplest, most memory-efficient indexing tricks.</strong></p>

<h2 id="18-coding-best-practices-for-in-place-algorithms">18. Coding Best Practices for In-Place Algorithms</h2>

<p>When you decide to implement an in-place algorithm in a production codebase, follow these safety guidelines:</p>
<ol>
  <li><strong>Implicit vs. Explicit Mutation</strong>: If your language supports it, mark the parameter as <code class="language-plaintext highlighter-rouge">mutable</code>. In Python, you can’t do this, so you MUST add a docstring: <code class="language-plaintext highlighter-rouge">WARNING: This function mutates the 'nums' list in-place.</code></li>
  <li><strong>Defensive Copying</strong>: If you are not 100% sure that the caller expects mutation, perform a shallow copy at the start: <code class="language-plaintext highlighter-rouge">nums = nums[:]</code>. While this violates $O(1)$ space, it prevents catastrophic side effects in complex systems.</li>
  <li><strong>In-Place as an Internal Detail</strong>: Often, the best pattern is to have a “wrapper” function that is pure (not mutating), which then calls a private “in-place” helper to do the heavy lifting. This gives you the performance of in-place with the safety of immutability.</li>
</ol>

<hr />

<p><strong>Originally published at:</strong> <a href="https://www.arunbaby.com/dsa/0053-first-missing-positive/">arunbaby.com/dsa/0053-first-missing-positive</a></p>

<p><em>If you found this helpful, consider sharing it with others who might benefit.</em></p>

        
      </section>

      <footer class="page__meta">
        
        
  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-tags" aria-hidden="true"></i> Tags: </strong>
    <span itemprop="keywords">
    
      <a href="/tags/#arrays" class="page__taxonomy-item p-category" rel="tag">arrays</a><span class="sep">, </span>
    
      <a href="/tags/#edge-cases" class="page__taxonomy-item p-category" rel="tag">edge-cases</a><span class="sep">, </span>
    
      <a href="/tags/#hard" class="page__taxonomy-item p-category" rel="tag">hard</a><span class="sep">, </span>
    
      <a href="/tags/#in-place" class="page__taxonomy-item p-category" rel="tag">in-place</a><span class="sep">, </span>
    
      <a href="/tags/#index-mapping" class="page__taxonomy-item p-category" rel="tag">index-mapping</a><span class="sep">, </span>
    
      <a href="/tags/#pattern-recognition" class="page__taxonomy-item p-category" rel="tag">pattern-recognition</a>
    
    </span>
  </p>




  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> Categories: </strong>
    <span itemprop="keywords">
    
      <a href="/categories/#dsa" class="page__taxonomy-item p-category" rel="tag">dsa</a>
    
    </span>
  </p>


        
      </footer>

      <div class="page__related page__related--full">
  <h2 class="page__related-title">Related across topics</h2>
  <style>
    /* Make section span full content width and use 2 equal columns */
    .page__related--full { float: inline-start; width: 100%; padding: 0; }
    .cross-related-grid { display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 2rem; }
    @media (max-width: 768px) { .cross-related-grid { grid-template-columns: 1fr; } }
    /* Ensure archive cards stretch nicely in the grid */
    .cross-related-grid .list__item, .cross-related-grid .grid__item { width: auto; float: none; margin: 0; }
  </style>
  <div class="cross-related-grid">
    



<div class="list__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/ml-system-design/0053-data-validation/" rel="permalink">Data Validation
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          24 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">“Most ML failures aren’t model bugs—they’re invalid data quietly passing through.”
</p>
  </article>
</div>




<div class="list__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/speech-tech/0053-audio-quality-validation/" rel="permalink">Audio Quality Validation
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          20 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">“If you don’t validate audio, you’ll debug ‘model regressions’ that are really microphone bugs.”
</p>
  </article>
</div>




<div class="list__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/ai-agents/0053-agent-deployment-patterns/" rel="permalink">Agent Deployment Patterns
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          21 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">“The hardest part of agents isn’t reasoning—it’s deploying them safely when the world is messy.”
</p>
  </article>
</div>

  </div>
</div>

      <section class="page__share">
  <h4 class="page__share-title">Share on</h4>

  <a href="https://twitter.com/intent/tweet?via=arunbaby0&text=First+Missing+Positive%20https%3A%2F%2Fwww.arunbaby.com%2Fdsa%2F0053-first-missing-positive%2F" class="btn btn--twitter" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Twitter"><i class="fab fa-fw fa-twitter" aria-hidden="true"></i><span> Twitter</span></a>

  <a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fwww.arunbaby.com%2Fdsa%2F0053-first-missing-positive%2F" class="btn btn--facebook" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Facebook"><i class="fab fa-fw fa-facebook" aria-hidden="true"></i><span> Facebook</span></a>

  <a href="https://www.linkedin.com/shareArticle?mini=true&url=https://www.arunbaby.com/dsa/0053-first-missing-positive/" class="btn btn--linkedin" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on LinkedIn"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i><span> LinkedIn</span></a>
</section>


      
  <nav class="pagination">
    
      <a href="/dsa/0052-trapping-rain-water/" class="pagination--pager" title="Trapping Rain Water">Previous</a>
    
    
      <a href="/dsa/0054-wildcard-matching/" class="pagination--pager" title="Wildcard Matching">Next</a>
    
  </nav>


    </div>

    
  </article>

  
  
</div>

      
    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';" role="search">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Enter your search term..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    

    
      
        
          <li><a href="https://twitter.com/arunbaby0" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-twitter-square" aria-hidden="true"></i> Twitter</a></li>
        
      
        
          <li><a href="https://github.com/arunbaby0" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
        
      
        
          <li><a href="https://www.linkedin.com/in/arunbaby0/" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i> LinkedIn</a></li>
        
      
        
          <li><a href="https://scholar.google.co.in/citations?user=6fSYWhkAAAAJ" rel="nofollow noopener noreferrer"><i class="fas fa-fw fa-graduation-cap" aria-hidden="true"></i> Google Scholar</a></li>
        
      
    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 1990 - 2143 <a href="https://www.arunbaby.com">Arun Baby</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>




  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-0JRJPEC9SS"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-0JRJPEC9SS', { 'anonymize_ip': false});
</script>








  </body>
</html>
