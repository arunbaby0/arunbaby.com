<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.26.2 by Michael Rose
  Copyright 2013-2024 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->

<html lang="en-US" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Kth Smallest Element in a BST - Arun Baby</title>
<meta name="description" content="Finding the median or the 99th percentile is easy in a sorted array. Can we do it in a tree?">


  <meta name="author" content="Arun Baby">
  
  <meta property="article:author" content="Arun Baby">
  


<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="Arun Baby">
<meta property="og:title" content="Kth Smallest Element in a BST">
<meta property="og:url" content="https://www.arunbaby.com/dsa/0028-kth-smallest-in-bst/">


  <meta property="og:description" content="Finding the median or the 99th percentile is easy in a sorted array. Can we do it in a tree?">



  <meta property="og:image" content="https://www.arunbaby.com/assets/images/profile-photo.png">



  <meta name="twitter:site" content="@arunbaby0">
  <meta name="twitter:title" content="Kth Smallest Element in a BST">
  <meta name="twitter:description" content="Finding the median or the 99th percentile is easy in a sorted array. Can we do it in a tree?">
  <meta name="twitter:url" content="https://www.arunbaby.com/dsa/0028-kth-smallest-in-bst/">

  
    <meta name="twitter:card" content="summary">
    
      <meta name="twitter:image" content="https://www.arunbaby.com/assets/images/profile-photo.png">
    
  

  



  <meta property="article:published_time" content="2025-12-05T20:36:26+05:30">





  

  


<link rel="canonical" href="https://www.arunbaby.com/dsa/0028-kth-smallest-in-bst/">












<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Arun Baby Feed">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
  
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css"></noscript>



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--single" dir="ltr">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
           
          <span class="site-subtitle">Arun Baby</span>
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a
                href="/about/"
                
                
              >About</a>
            </li><li class="masthead__menu-item">
              <a
                href="/dsa/"
                
                
              >DSA</a>
            </li><li class="masthead__menu-item">
              <a
                href="/ml-system-design/"
                
                
              >ML Systems</a>
            </li><li class="masthead__menu-item">
              <a
                href="/speech-tech/"
                
                
              >Speech Tech</a>
            </li><li class="masthead__menu-item">
              <a
                href="/publications/"
                
                
              >Publications</a>
            </li><li class="masthead__menu-item">
              <a
                href="/statuses/"
                
                
              >Statuses</a>
            </li><li class="masthead__menu-item">
              <a
                href="/contact/"
                
                
              >Contact</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <i class="fas fa-search"></i>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      





<div id="main" role="main" class="no-author-sidebar">
  
  <div class="sidebar sticky">
  
  
  </div>



  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="Kth Smallest Element in a BST">
    <meta itemprop="description" content="Finding the median or the 99th percentile is easy in a sorted array. Can we do it in a tree?">
    <meta itemprop="datePublished" content="2025-12-05T20:36:26+05:30">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">
            <a href="https://www.arunbaby.com/dsa/0028-kth-smallest-in-bst/" itemprop="url">Kth Smallest Element in a BST
</a>
          </h1>
          

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          23 minute read
        
      </span>
    
  </p>


        </header>
      

      <section class="page__content" itemprop="text">
        
          <aside class="sidebar__right sticky">
            <nav class="toc">
              <header><h4 class="nav__title"><i class="fas fa-file-alt"></i> On this page</h4></header>
              <ul class="toc__menu"><li><a href="#problem-statement">Problem Statement</a></li><li><a href="#intuition">Intuition</a></li><li><a href="#approach-1-recursive-inorder-traversal">Approach 1: Recursive Inorder Traversal</a></li><li><a href="#approach-2-iterative-inorder-optimal">Approach 2: Iterative Inorder (Optimal)</a></li><li><a href="#follow-up-frequent-insertsdeletes">Follow-up: Frequent Inserts/Deletes</a></li><li><a href="#real-world-application-database-indexing">Real-World Application: Database Indexing</a></li><li><a href="#connections-to-ml-systems">Connections to ML Systems</a></li><li><a href="#approach-3-morris-traversal-o1-space">Approach 3: Morris Traversal (O(1) Space)</a></li><li><a href="#deep-dive-augmented-bst-implementation">Deep Dive: Augmented BST Implementation</a></li><li><a href="#comparison-with-other-data-structures">Comparison with Other Data Structures</a></li><li><a href="#real-world-application-order-statistics-trees">Real-World Application: Order Statistics Trees</a></li><li><a href="#implementation-in-c">Implementation in C++</a></li><li><a href="#top-interview-questions">Top Interview Questions</a></li><li><a href="#deep-dive-the-iterator-pattern">Deep Dive: The Iterator Pattern</a></li><li><a href="#deep-dive-handling-dynamic-updates-rebalancing">Deep Dive: Handling Dynamic Updates (Rebalancing)</a></li><li><a href="#deep-dive-python-generators-for-inorder">Deep Dive: Python Generators for Inorder</a></li><li><a href="#deep-dive-bst-vs-b-tree-database-indexing">Deep Dive: BST vs B-Tree (Database Indexing)</a></li><li><a href="#deep-dive-threaded-binary-trees">Deep Dive: Threaded Binary Trees</a></li><li><a href="#deep-dive-why-not-a-segment-tree">Deep Dive: Why not a Segment Tree?</a></li><li><a href="#deep-dive-python-generators-for-inorder-1">Deep Dive: Python Generators for Inorder</a></li><li><a href="#deep-dive-bst-vs-b-tree-database-indexing-1">Deep Dive: BST vs B-Tree (Database Indexing)</a></li><li><a href="#deep-dive-threaded-binary-trees-1">Deep Dive: Threaded Binary Trees</a></li><li><a href="#deep-dive-why-not-a-segment-tree-1">Deep Dive: Why not a Segment Tree?</a></li><li><a href="#deep-dive-python-generators-for-inorder-2">Deep Dive: Python Generators for Inorder</a></li><li><a href="#deep-dive-bst-vs-b-tree-database-indexing-2">Deep Dive: BST vs B-Tree (Database Indexing)</a></li><li><a href="#deep-dive-threaded-binary-trees-2">Deep Dive: Threaded Binary Trees</a></li><li><a href="#deep-dive-why-not-a-segment-tree-2">Deep Dive: Why not a Segment Tree?</a></li><li><a href="#deep-dive-python-generators-for-inorder-3">Deep Dive: Python Generators for Inorder</a></li><li><a href="#deep-dive-bst-vs-b-tree-database-indexing-3">Deep Dive: BST vs B-Tree (Database Indexing)</a></li><li><a href="#deep-dive-threaded-binary-trees-3">Deep Dive: Threaded Binary Trees</a></li><li><a href="#deep-dive-why-not-a-segment-tree-3">Deep Dive: Why not a Segment Tree?</a></li><li><a href="#deep-dive-python-generators-for-inorder-4">Deep Dive: Python Generators for Inorder</a></li><li><a href="#deep-dive-bst-vs-b-tree-database-indexing-4">Deep Dive: BST vs B-Tree (Database Indexing)</a></li><li><a href="#deep-dive-threaded-binary-trees-4">Deep Dive: Threaded Binary Trees</a></li><li><a href="#deep-dive-why-not-a-segment-tree-4">Deep Dive: Why not a Segment Tree?</a></li><li><a href="#deep-dive-time-and-space-complexity-analysis">Deep Dive: Time and Space Complexity Analysis</a></li><li><a href="#deep-dive-why-inorder-a-proof">Deep Dive: Why Inorder? (A Proof)</a></li><li><a href="#implementation-in-java">Implementation in Java</a></li><li><a href="#key-takeaways">Key Takeaways</a></li></ul>
            </nav>
          </aside>
        
        <p><strong>Finding the median or the 99th percentile is easy in a sorted array. Can we do it in a tree?</strong></p>

<h2 id="problem-statement">Problem Statement</h2>

<p>Given the <code class="language-plaintext highlighter-rouge">root</code> of a Binary Search Tree (BST) and an integer <code class="language-plaintext highlighter-rouge">k</code>, return the <code class="language-plaintext highlighter-rouge">k</code>th smallest value (1-indexed) of all the values of the nodes in the tree.</p>

<p><strong>Example 1:</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   3
  / \
 1   4
  \
   2
</code></pre></div></div>
<p><strong>Input:</strong> <code class="language-plaintext highlighter-rouge">root = [3,1,4,null,2]</code>, <code class="language-plaintext highlighter-rouge">k = 1</code>
<strong>Output:</strong> <code class="language-plaintext highlighter-rouge">1</code></p>

<p><strong>Example 2:</strong>
<strong>Input:</strong> <code class="language-plaintext highlighter-rouge">root = [5,3,6,2,4,null,null,1]</code>, <code class="language-plaintext highlighter-rouge">k = 3</code>
<strong>Output:</strong> <code class="language-plaintext highlighter-rouge">3</code></p>

<p><strong>Constraints:</strong></p>
<ul>
  <li>The number of nodes in the tree is <code class="language-plaintext highlighter-rouge">n</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">1 &lt;= k &lt;= n &lt;= 10^4</code></li>
  <li><code class="language-plaintext highlighter-rouge">0 &lt;= Node.val &lt;= 10^4</code></li>
</ul>

<h2 id="intuition">Intuition</h2>

<p>The defining property of a BST is:</p>
<blockquote>
  <p>Left Subtree &lt; Root &lt; Right Subtree</p>
</blockquote>

<p>If we perform an <strong>Inorder Traversal</strong> (Left -&gt; Root -&gt; Right), we visit the nodes in <strong>sorted ascending order</strong>.
So, the problem reduces to: “Perform an Inorder traversal and stop at the <code class="language-plaintext highlighter-rouge">k</code>th node.”</p>

<h2 id="approach-1-recursive-inorder-traversal">Approach 1: Recursive Inorder Traversal</h2>

<p>We can traverse the entire tree, store the elements in a list, and return <code class="language-plaintext highlighter-rouge">list[k-1]</code>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">kthSmallest</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">],</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">self</span><span class="p">.</span><span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="k">def</span> <span class="nf">inorder</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="p">:</span> <span class="k">return</span>
            <span class="nf">inorder</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
            <span class="n">self</span><span class="p">.</span><span class="n">result</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
            <span class="nf">inorder</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
            
        <span class="nf">inorder</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">result</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div></div>

<p><strong>Complexity:</strong></p>
<ul>
  <li><strong>Time:</strong> (O(N)). We visit every node.</li>
  <li><strong>Space:</strong> (O(N)). We store every node.</li>
</ul>

<h2 id="approach-2-iterative-inorder-optimal">Approach 2: Iterative Inorder (Optimal)</h2>

<p>We don’t need to visit the whole tree. We can stop as soon as we find the <code class="language-plaintext highlighter-rouge">k</code>th element.
Using a Stack, we can simulate the recursion and return early.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">kthSmallest</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">],</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="n">root</span>
        
        <span class="k">while</span> <span class="n">stack</span> <span class="ow">or</span> <span class="n">curr</span><span class="p">:</span>
            <span class="c1"># 1. Go as left as possible
</span>            <span class="k">while</span> <span class="n">curr</span><span class="p">:</span>
                <span class="n">stack</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">curr</span><span class="p">)</span>
                <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="p">.</span><span class="n">left</span>
            
            <span class="c1"># 2. Process node
</span>            <span class="n">curr</span> <span class="o">=</span> <span class="n">stack</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
            <span class="n">k</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">curr</span><span class="p">.</span><span class="n">val</span>
            
            <span class="c1"># 3. Go right
</span>            <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="p">.</span><span class="n">right</span>
            
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span> <span class="c1"># Should not reach here
</span></code></pre></div></div>

<p><strong>Complexity:</strong></p>
<ul>
  <li><strong>Time:</strong> (O(H + k)). We go down the height (H) to reach the leftmost node, then process (k) nodes.</li>
  <li><strong>Space:</strong> (O(H)) for the stack.</li>
</ul>

<h2 id="follow-up-frequent-insertsdeletes">Follow-up: Frequent Inserts/Deletes</h2>

<p><strong>Question:</strong> What if the BST is modified often (insert/delete operations) and you need to find the kth smallest frequently? How would you optimize the <code class="language-plaintext highlighter-rouge">kthSmallest</code> operation?</p>

<p><strong>Answer:</strong>
The (O(H+k)) approach is too slow if (k) is large (e.g., (N/2)).
We can optimize this to (O(H)) by <strong>Augmenting the BST</strong>.
Each node should store a new field: <code class="language-plaintext highlighter-rouge">count</code> (size of the subtree rooted at this node).</p>

<p><strong>Algorithm:</strong>
Let <code class="language-plaintext highlighter-rouge">left_count = node.left.count</code> (or 0 if null).</p>
<ol>
  <li>If <code class="language-plaintext highlighter-rouge">k == left_count + 1</code>: The current node is the answer.</li>
  <li>If <code class="language-plaintext highlighter-rouge">k &lt;= left_count</code>: The answer is in the left subtree. Recurse <code class="language-plaintext highlighter-rouge">left</code> with <code class="language-plaintext highlighter-rouge">k</code>.</li>
  <li>If <code class="language-plaintext highlighter-rouge">k &gt; left_count + 1</code>: The answer is in the right subtree. Recurse <code class="language-plaintext highlighter-rouge">right</code> with <code class="language-plaintext highlighter-rouge">k - (left_count + 1)</code>.</li>
</ol>

<p><strong>Complexity:</strong></p>
<ul>
  <li><strong>Time:</strong> (O(H)) (Logarithmic).</li>
  <li><strong>Space:</strong> (O(N)) to store the counts.</li>
</ul>

<h2 id="real-world-application-database-indexing">Real-World Application: Database Indexing</h2>

<p>This is exactly how databases (like PostgreSQL or MySQL) implement <code class="language-plaintext highlighter-rouge">OFFSET</code> and <code class="language-plaintext highlighter-rouge">LIMIT</code>.</p>
<ul>
  <li>B-Trees store counts in internal nodes.</li>
  <li><code class="language-plaintext highlighter-rouge">SELECT * FROM users ORDER BY age LIMIT 1 OFFSET 1000</code> doesn’t scan 1000 rows. It traverses the B-Tree using the counts to jump directly to the 1001st entry.</li>
</ul>

<h2 id="connections-to-ml-systems">Connections to ML Systems</h2>

<p>In <strong>Ranking Systems</strong> (Day 28 ML), we often need to retrieve the “Top K” items.
While we usually use Heaps for “Top K”, BSTs (or Balanced BSTs) are useful when we need to support dynamic updates and arbitrary rank queries (e.g., “What is the rank of this item?”).</p>

<h2 id="approach-3-morris-traversal-o1-space">Approach 3: Morris Traversal (O(1) Space)</h2>

<p>Can we do this without a stack or recursion? Yes, using <strong>Morris Traversal</strong>.
This algorithm modifies the tree structure temporarily (threading) to traverse it, then restores it.</p>

<p><strong>Algorithm:</strong></p>
<ol>
  <li>Initialize <code class="language-plaintext highlighter-rouge">curr</code> as <code class="language-plaintext highlighter-rouge">root</code>.</li>
  <li>While <code class="language-plaintext highlighter-rouge">curr</code> is not NULL:
    <ul>
      <li>If <code class="language-plaintext highlighter-rouge">curr.left</code> is NULL:
        <ul>
          <li><strong>Visit(curr)</strong> (Increment count).</li>
          <li>If count == k, return <code class="language-plaintext highlighter-rouge">curr.val</code>.</li>
          <li><code class="language-plaintext highlighter-rouge">curr = curr.right</code></li>
        </ul>
      </li>
      <li>Else:
        <ul>
          <li>Find the <strong>predecessor</strong> (rightmost node in left subtree).</li>
          <li>If <code class="language-plaintext highlighter-rouge">predecessor.right</code> is NULL:
            <ul>
              <li>Make <code class="language-plaintext highlighter-rouge">predecessor.right = curr</code> (Create thread).</li>
              <li><code class="language-plaintext highlighter-rouge">curr = curr.left</code></li>
            </ul>
          </li>
          <li>Else (<code class="language-plaintext highlighter-rouge">predecessor.right == curr</code>):
            <ul>
              <li><code class="language-plaintext highlighter-rouge">predecessor.right = NULL</code> (Remove thread).</li>
              <li><strong>Visit(curr)</strong>.</li>
              <li>If count == k, return <code class="language-plaintext highlighter-rouge">curr.val</code>.</li>
              <li><code class="language-plaintext highlighter-rouge">curr = curr.right</code></li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">kthSmallest</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">],</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="n">root</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        
        <span class="k">while</span> <span class="n">curr</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">curr</span><span class="p">.</span><span class="n">left</span><span class="p">:</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">count</span> <span class="o">==</span> <span class="n">k</span><span class="p">:</span> <span class="k">return</span> <span class="n">curr</span><span class="p">.</span><span class="n">val</span>
                <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="p">.</span><span class="n">right</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pre</span> <span class="o">=</span> <span class="n">curr</span><span class="p">.</span><span class="n">left</span>
                <span class="k">while</span> <span class="n">pre</span><span class="p">.</span><span class="n">right</span> <span class="ow">and</span> <span class="n">pre</span><span class="p">.</span><span class="n">right</span> <span class="o">!=</span> <span class="n">curr</span><span class="p">:</span>
                    <span class="n">pre</span> <span class="o">=</span> <span class="n">pre</span><span class="p">.</span><span class="n">right</span>
                
                <span class="k">if</span> <span class="ow">not</span> <span class="n">pre</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
                    <span class="n">pre</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">curr</span>
                    <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="p">.</span><span class="n">left</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">pre</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="bp">None</span>
                    <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="n">count</span> <span class="o">==</span> <span class="n">k</span><span class="p">:</span> <span class="k">return</span> <span class="n">curr</span><span class="p">.</span><span class="n">val</span>
                    <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="p">.</span><span class="n">right</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
</code></pre></div></div>

<p><strong>Complexity:</strong></p>
<ul>
  <li><strong>Time:</strong> (O(N)). Each edge is traversed at most 3 times.</li>
  <li><strong>Space:</strong> (O(1)). No stack, no recursion.</li>
</ul>

<h2 id="deep-dive-augmented-bst-implementation">Deep Dive: Augmented BST Implementation</h2>

<p>The (O(H)) approach requires maintaining the <code class="language-plaintext highlighter-rouge">count</code> field.
Here is how you would implement the <code class="language-plaintext highlighter-rouge">insert</code> operation to maintain this invariant.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">TreeNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="n">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">self</span><span class="p">.</span><span class="n">count</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># Size of subtree
</span>
<span class="k">class</span> <span class="nc">BST</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">val</span> <span class="o">&lt;</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">:</span>
            <span class="n">root</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">insert</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">root</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">insert</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
            
        <span class="c1"># Update count after insertion
</span>        <span class="n">root</span><span class="p">.</span><span class="n">count</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">self</span><span class="p">.</span><span class="nf">getSize</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span> <span class="o">+</span> <span class="n">self</span><span class="p">.</span><span class="nf">getSize</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">root</span>

    <span class="k">def</span> <span class="nf">getSize</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">node</span><span class="p">.</span><span class="n">count</span> <span class="k">if</span> <span class="n">node</span> <span class="k">else</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">kthSmallest</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="n">left_count</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">getSize</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="n">left_count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span>
        <span class="k">elif</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">left_count</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">kthSmallest</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">kthSmallest</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">,</span> <span class="n">k</span> <span class="o">-</span> <span class="n">left_count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</code></pre></div></div>

<p><strong>Trade-off:</strong></p>
<ul>
  <li><strong>Pros:</strong> (O(\log N)) query time.</li>
  <li><strong>Cons:</strong> Insertion/Deletion becomes slightly slower (constant factor) due to updating counts.</li>
  <li><strong>Cons:</strong> Extra (O(N)) space for the <code class="language-plaintext highlighter-rouge">count</code> field.</li>
</ul>

<h2 id="comparison-with-other-data-structures">Comparison with Other Data Structures</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: left">Data Structure</th>
      <th style="text-align: left">Kth Smallest Time</th>
      <th style="text-align: left">Update Time</th>
      <th style="text-align: left">Space</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left"><strong>Sorted Array</strong></td>
      <td style="text-align: left">(O(1))</td>
      <td style="text-align: left">(O(N))</td>
      <td style="text-align: left">(O(N))</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>Min Heap</strong></td>
      <td style="text-align: left">(O(K \log N))</td>
      <td style="text-align: left">(O(\log N))</td>
      <td style="text-align: left">(O(N))</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>Standard BST</strong></td>
      <td style="text-align: left">(O(N))</td>
      <td style="text-align: left">(O(H))</td>
      <td style="text-align: left">(O(N))</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>Augmented BST</strong></td>
      <td style="text-align: left">(O(H))</td>
      <td style="text-align: left">(O(H))</td>
      <td style="text-align: left">(O(N))</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>Segment Tree</strong></td>
      <td style="text-align: left">(O(\log N))</td>
      <td style="text-align: left">(O(\log N))</td>
      <td style="text-align: left">(O(N))</td>
    </tr>
  </tbody>
</table>

<p><strong>Why not a Heap?</strong>
A Min-Heap gives access to the minimum in (O(1)). To find the Kth smallest, we must pop K times. This destroys the heap (or requires copying it). Complexity: (O(K \log N)).
If (K \approx N), this is (O(N \log N)), which is worse than the BST’s (O(N)).</p>

<h2 id="real-world-application-order-statistics-trees">Real-World Application: Order Statistics Trees</h2>

<p>In <strong>Trading Systems</strong>, we often need the “Median Price” of the last 1000 trades.</p>
<ul>
  <li>An Augmented BST (Order Statistic Tree) allows us to insert new trades and query the median in (O(\log N)).</li>
  <li>Python’s <code class="language-plaintext highlighter-rouge">sortedcontainers</code> library implements this efficiently.</li>
</ul>

<h2 id="implementation-in-c">Implementation in C++</h2>

<p>C++ <code class="language-plaintext highlighter-rouge">std::set</code> is usually a Red-Black Tree, but it doesn’t expose the subtree size.
However, the GCC Policy-Based Data Structures (PBDS) library does!</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;ext/pb_ds/assoc_container.hpp&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;ext/pb_ds/tree_policy.hpp&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">__gnu_pbds</span><span class="p">;</span>

<span class="k">typedef</span> <span class="n">tree</span><span class="o">&lt;</span>
    <span class="kt">int</span><span class="p">,</span>
    <span class="n">null_type</span><span class="p">,</span>
    <span class="n">less</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">rb_tree_tag</span><span class="p">,</span>
    <span class="n">tree_order_statistics_node_update</span><span class="o">&gt;</span>
    <span class="n">ordered_set</span><span class="p">;</span>

<span class="c1">// Usage:</span>
<span class="n">ordered_set</span> <span class="n">os</span><span class="p">;</span>
<span class="n">os</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<span class="n">os</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
<span class="n">os</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>

<span class="c1">// find_by_order returns iterator to kth element (0-indexed)</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">os</span><span class="p">.</span><span class="n">find_by_order</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// Output: 10</span>
</code></pre></div></div>

<h2 id="top-interview-questions">Top Interview Questions</h2>

<p><strong>Q1: What if K is invalid (k &lt; 1 or k &gt; N)?</strong>
<em>Answer:</em> The problem constraints say (1 \le k \le N), so it’s always valid. In a real system, we should throw an exception or return an error code.</p>

<p><strong>Q2: How does the Augmented BST handle duplicates?</strong>
<em>Answer:</em>
Standard BSTs don’t allow duplicates.
If we need duplicates, we can:</p>
<ol>
  <li>Store a <code class="language-plaintext highlighter-rouge">frequency</code> count in each node.</li>
  <li>Use <code class="language-plaintext highlighter-rouge">less_equal</code> logic (put equal values to the right).
The <code class="language-plaintext highlighter-rouge">kthSmallest</code> logic needs to be adjusted to account for <code class="language-plaintext highlighter-rouge">frequency</code>.</li>
</ol>

<p><strong>Q3: Can we optimize the Iterative approach if we run it multiple times?</strong>
<em>Answer:</em>
If the tree structure is static, we can cache the Inorder traversal in an array.
If the tree changes, we are back to the Augmented BST solution.</p>

<h2 id="deep-dive-the-iterator-pattern">Deep Dive: The Iterator Pattern</h2>

<p>The Iterative approach essentially implements a <strong>BST Iterator</strong>.
This is a common design pattern. Instead of finding the Kth element, we might want to iterate through the tree one by one.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">BSTIterator</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">]):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">self</span><span class="p">.</span><span class="nf">_push_left</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_push_left</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">while</span> <span class="n">node</span><span class="p">:</span>
            <span class="n">self</span><span class="p">.</span><span class="n">stack</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span>

    <span class="k">def</span> <span class="nf">next</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">stack</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
        <span class="n">self</span><span class="p">.</span><span class="nf">_push_left</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">node</span><span class="p">.</span><span class="n">val</span>

    <span class="k">def</span> <span class="nf">hasNext</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="nf">len</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">stack</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>

<span class="c1"># Usage for Kth Smallest:
# iterator = BSTIterator(root)
# for _ in range(k):
#     val = iterator.next()
# return val
</span></code></pre></div></div>

<p><strong>Why is this better?</strong></p>
<ul>
  <li><strong>Memory Efficiency:</strong> It only stores (O(H)) nodes.</li>
  <li><strong>Lazy Evaluation:</strong> It computes the next node only when asked. If we stop at (K), we don’t process the rest of the tree (unlike the Recursive approach which might visit everything if not careful).</li>
  <li><strong>Composability:</strong> We can pass this iterator to other functions (e.g., “Merge two BSTs”).</li>
</ul>

<h2 id="deep-dive-handling-dynamic-updates-rebalancing">Deep Dive: Handling Dynamic Updates (Rebalancing)</h2>

<p>In the Augmented BST approach, we maintain <code class="language-plaintext highlighter-rouge">count</code>.
But what if the tree becomes skewed?</p>
<ul>
  <li>Insert <code class="language-plaintext highlighter-rouge">1, 2, 3, 4, 5</code>.</li>
  <li>Tree becomes a linked list.</li>
  <li>Height (H = N).</li>
  <li>Query time becomes (O(N)).</li>
</ul>

<p><strong>Solution:</strong> Use a <strong>Self-Balancing BST</strong> (AVL Tree or Red-Black Tree).
When we rotate nodes to rebalance, we must update the <code class="language-plaintext highlighter-rouge">count</code> fields.</p>

<p><strong>Rotation Logic:</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    y          x
   / \        / \
  x   C  &lt;-&gt; A   y
 / \            / \
A   B          B   C
</code></pre></div></div>
<p>When rotating Right (y -&gt; x):</p>
<ol>
  <li><code class="language-plaintext highlighter-rouge">x.count = y.count</code> (x takes y’s place, so it has the same total size).</li>
  <li><code class="language-plaintext highlighter-rouge">y.count = 1 + size(B) + size(C)</code> (y is now root of B and C).</li>
</ol>

<p>This ensures that even with frequent updates, the height remains (O(\log N)), and our Kth Smallest query remains (O(\log N)).</p>

<h2 id="deep-dive-python-generators-for-inorder">Deep Dive: Python Generators for Inorder</h2>

<p>Python’s <code class="language-plaintext highlighter-rouge">yield</code> keyword makes writing the iterator trivial.
This is arguably the most “Pythonic” way to solve the problem.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">kthSmallest</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">],</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">inorder_gen</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="p">:</span> <span class="k">return</span>
            <span class="k">yield</span> <span class="k">from</span> <span class="nf">inorder_gen</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">node</span><span class="p">.</span><span class="n">val</span>
            <span class="k">yield</span> <span class="k">from</span> <span class="nf">inorder_gen</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
            
        <span class="n">gen</span> <span class="o">=</span> <span class="nf">inorder_gen</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
            <span class="n">val</span> <span class="o">=</span> <span class="nf">next</span><span class="p">(</span><span class="n">gen</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">val</span>
</code></pre></div></div>

<p><strong>Under the Hood:</strong>
Python handles the stack frames for us. <code class="language-plaintext highlighter-rouge">yield from</code> delegates to a sub-generator.
<strong>Performance:</strong> Slightly slower than the manual stack due to generator overhead, but much cleaner code.</p>

<h2 id="deep-dive-bst-vs-b-tree-database-indexing">Deep Dive: BST vs B-Tree (Database Indexing)</h2>

<p>We mentioned databases use B-Trees. Why not BSTs?</p>
<ol>
  <li><strong>Disk I/O:</strong> BST nodes are scattered in memory. B-Tree nodes contain thousands of keys in a single block (Page).</li>
  <li><strong>Height:</strong> A BST with (N=10^9) has height (\approx 30). A B-Tree with branching factor (B=1000) has height (\approx 3).</li>
  <li><strong>Locality:</strong> B-Trees are cache-friendly.</li>
</ol>

<p><strong>Relevance to Kth Smallest:</strong>
In a B-Tree, each internal node stores the count of keys in its subtrees.
The logic is identical to our Augmented BST, just with (M) children instead of 2.</p>

<h2 id="deep-dive-threaded-binary-trees">Deep Dive: Threaded Binary Trees</h2>

<p>Morris Traversal is based on the concept of <strong>Threaded Binary Trees</strong>.
In a standard BST, (N+1) pointers are NULL (the leaves). This is wasted space.
<strong>Idea:</strong> Use the NULL right pointers to point to the <strong>Inorder Successor</strong>.
<strong>Idea:</strong> Use the NULL left pointers to point to the <strong>Inorder Predecessor</strong>.</p>

<p><strong>Benefits:</strong></p>
<ul>
  <li>Traversals become purely iterative (no stack needed).</li>
  <li>Finding the successor is (O(1)) (mostly).</li>
</ul>

<p><strong>Drawbacks:</strong></p>
<ul>
  <li>Insertion/Deletion is more complex (need to update threads).</li>
  <li>We need a bit flag to distinguish between a “Child Pointer” and a “Thread”.</li>
</ul>

<h2 id="deep-dive-why-not-a-segment-tree">Deep Dive: Why not a Segment Tree?</h2>

<p>A Segment Tree can also solve “Kth Smallest” in (O(\log N)).</p>
<ul>
  <li><strong>Setup:</strong> Map the value range ([0, 10^4]) to the leaves of the segment tree.</li>
  <li><strong>Node Value:</strong> Count of elements in the range ([L, R]).</li>
  <li><strong>Query:</strong> Similar to Augmented BST. If <code class="language-plaintext highlighter-rouge">left_child.count &gt;= k</code>, go left. Else go right.</li>
</ul>

<p><strong>Comparison:</strong></p>
<ul>
  <li><strong>Segment Tree:</strong> Good if the <em>range of values</em> is small and fixed. Bad if values are sparse or floats.</li>
  <li><strong>Augmented BST:</strong> Good for arbitrary values. Space depends on number of elements, not value range.</li>
</ul>

<h2 id="deep-dive-python-generators-for-inorder-1">Deep Dive: Python Generators for Inorder</h2>

<p>Python’s <code class="language-plaintext highlighter-rouge">yield</code> keyword makes writing the iterator trivial.
This is arguably the most “Pythonic” way to solve the problem.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">kthSmallest</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">],</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">inorder_gen</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="p">:</span> <span class="k">return</span>
            <span class="k">yield</span> <span class="k">from</span> <span class="nf">inorder_gen</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">node</span><span class="p">.</span><span class="n">val</span>
            <span class="k">yield</span> <span class="k">from</span> <span class="nf">inorder_gen</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
            
        <span class="n">gen</span> <span class="o">=</span> <span class="nf">inorder_gen</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
            <span class="n">val</span> <span class="o">=</span> <span class="nf">next</span><span class="p">(</span><span class="n">gen</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">val</span>
</code></pre></div></div>

<p><strong>Under the Hood:</strong>
Python handles the stack frames for us. <code class="language-plaintext highlighter-rouge">yield from</code> delegates to a sub-generator.
<strong>Performance:</strong> Slightly slower than the manual stack due to generator overhead, but much cleaner code.</p>

<h2 id="deep-dive-bst-vs-b-tree-database-indexing-1">Deep Dive: BST vs B-Tree (Database Indexing)</h2>

<p>We mentioned databases use B-Trees. Why not BSTs?</p>
<ol>
  <li><strong>Disk I/O:</strong> BST nodes are scattered in memory. B-Tree nodes contain thousands of keys in a single block (Page).</li>
  <li><strong>Height:</strong> A BST with (N=10^9) has height (\approx 30). A B-Tree with branching factor (B=1000) has height (\approx 3).</li>
  <li><strong>Locality:</strong> B-Trees are cache-friendly.</li>
</ol>

<p><strong>Relevance to Kth Smallest:</strong>
In a B-Tree, each internal node stores the count of keys in its subtrees.
The logic is identical to our Augmented BST, just with (M) children instead of 2.</p>

<h2 id="deep-dive-threaded-binary-trees-1">Deep Dive: Threaded Binary Trees</h2>

<p>Morris Traversal is based on the concept of <strong>Threaded Binary Trees</strong>.
In a standard BST, (N+1) pointers are NULL (the leaves). This is wasted space.
<strong>Idea:</strong> Use the NULL right pointers to point to the <strong>Inorder Successor</strong>.
<strong>Idea:</strong> Use the NULL left pointers to point to the <strong>Inorder Predecessor</strong>.</p>

<p><strong>Benefits:</strong></p>
<ul>
  <li>Traversals become purely iterative (no stack needed).</li>
  <li>Finding the successor is (O(1)) (mostly).</li>
</ul>

<p><strong>Drawbacks:</strong></p>
<ul>
  <li>Insertion/Deletion is more complex (need to update threads).</li>
  <li>We need a bit flag to distinguish between a “Child Pointer” and a “Thread”.</li>
</ul>

<h2 id="deep-dive-why-not-a-segment-tree-1">Deep Dive: Why not a Segment Tree?</h2>

<p>A Segment Tree can also solve “Kth Smallest” in (O(\log N)).</p>
<ul>
  <li><strong>Setup:</strong> Map the value range ([0, 10^4]) to the leaves of the segment tree.</li>
  <li><strong>Node Value:</strong> Count of elements in the range ([L, R]).</li>
  <li><strong>Query:</strong> Similar to Augmented BST. If <code class="language-plaintext highlighter-rouge">left_child.count &gt;= k</code>, go left. Else go right.</li>
</ul>

<p><strong>Comparison:</strong></p>
<ul>
  <li><strong>Segment Tree:</strong> Good if the <em>range of values</em> is small and fixed. Bad if values are sparse or floats.</li>
  <li><strong>Augmented BST:</strong> Good for arbitrary values. Space depends on number of elements, not value range.</li>
</ul>

<h2 id="deep-dive-python-generators-for-inorder-2">Deep Dive: Python Generators for Inorder</h2>

<p>Python’s <code class="language-plaintext highlighter-rouge">yield</code> keyword makes writing the iterator trivial.
This is arguably the most “Pythonic” way to solve the problem.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">kthSmallest</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">],</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">inorder_gen</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="p">:</span> <span class="k">return</span>
            <span class="k">yield</span> <span class="k">from</span> <span class="nf">inorder_gen</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">node</span><span class="p">.</span><span class="n">val</span>
            <span class="k">yield</span> <span class="k">from</span> <span class="nf">inorder_gen</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
            
        <span class="n">gen</span> <span class="o">=</span> <span class="nf">inorder_gen</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
            <span class="n">val</span> <span class="o">=</span> <span class="nf">next</span><span class="p">(</span><span class="n">gen</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">val</span>
</code></pre></div></div>

<p><strong>Under the Hood:</strong>
Python handles the stack frames for us. <code class="language-plaintext highlighter-rouge">yield from</code> delegates to a sub-generator.
<strong>Performance:</strong> Slightly slower than the manual stack due to generator overhead, but much cleaner code.</p>

<h2 id="deep-dive-bst-vs-b-tree-database-indexing-2">Deep Dive: BST vs B-Tree (Database Indexing)</h2>

<p>We mentioned databases use B-Trees. Why not BSTs?</p>
<ol>
  <li><strong>Disk I/O:</strong> BST nodes are scattered in memory. B-Tree nodes contain thousands of keys in a single block (Page).</li>
  <li><strong>Height:</strong> A BST with (N=10^9) has height (\approx 30). A B-Tree with branching factor (B=1000) has height (\approx 3).</li>
  <li><strong>Locality:</strong> B-Trees are cache-friendly.</li>
</ol>

<p><strong>Relevance to Kth Smallest:</strong>
In a B-Tree, each internal node stores the count of keys in its subtrees.
The logic is identical to our Augmented BST, just with (M) children instead of 2.</p>

<h2 id="deep-dive-threaded-binary-trees-2">Deep Dive: Threaded Binary Trees</h2>

<p>Morris Traversal is based on the concept of <strong>Threaded Binary Trees</strong>.
In a standard BST, (N+1) pointers are NULL (the leaves). This is wasted space.
<strong>Idea:</strong> Use the NULL right pointers to point to the <strong>Inorder Successor</strong>.
<strong>Idea:</strong> Use the NULL left pointers to point to the <strong>Inorder Predecessor</strong>.</p>

<p><strong>Benefits:</strong></p>
<ul>
  <li>Traversals become purely iterative (no stack needed).</li>
  <li>Finding the successor is (O(1)) (mostly).</li>
</ul>

<p><strong>Drawbacks:</strong></p>
<ul>
  <li>Insertion/Deletion is more complex (need to update threads).</li>
  <li>We need a bit flag to distinguish between a “Child Pointer” and a “Thread”.</li>
</ul>

<h2 id="deep-dive-why-not-a-segment-tree-2">Deep Dive: Why not a Segment Tree?</h2>

<p>A Segment Tree can also solve “Kth Smallest” in (O(\log N)).</p>
<ul>
  <li><strong>Setup:</strong> Map the value range ([0, 10^4]) to the leaves of the segment tree.</li>
  <li><strong>Node Value:</strong> Count of elements in the range ([L, R]).</li>
  <li><strong>Query:</strong> Similar to Augmented BST. If <code class="language-plaintext highlighter-rouge">left_child.count &gt;= k</code>, go left. Else go right.</li>
</ul>

<p><strong>Comparison:</strong></p>
<ul>
  <li><strong>Segment Tree:</strong> Good if the <em>range of values</em> is small and fixed. Bad if values are sparse or floats.</li>
  <li><strong>Augmented BST:</strong> Good for arbitrary values. Space depends on number of elements, not value range.</li>
</ul>

<h2 id="deep-dive-python-generators-for-inorder-3">Deep Dive: Python Generators for Inorder</h2>

<p>Python’s <code class="language-plaintext highlighter-rouge">yield</code> keyword makes writing the iterator trivial.
This is arguably the most “Pythonic” way to solve the problem.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">kthSmallest</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">],</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">inorder_gen</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="p">:</span> <span class="k">return</span>
            <span class="k">yield</span> <span class="k">from</span> <span class="nf">inorder_gen</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">node</span><span class="p">.</span><span class="n">val</span>
            <span class="k">yield</span> <span class="k">from</span> <span class="nf">inorder_gen</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
            
        <span class="n">gen</span> <span class="o">=</span> <span class="nf">inorder_gen</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
            <span class="n">val</span> <span class="o">=</span> <span class="nf">next</span><span class="p">(</span><span class="n">gen</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">val</span>
</code></pre></div></div>

<p><strong>Under the Hood:</strong>
Python handles the stack frames for us. <code class="language-plaintext highlighter-rouge">yield from</code> delegates to a sub-generator.
<strong>Performance:</strong> Slightly slower than the manual stack due to generator overhead, but much cleaner code.</p>

<h2 id="deep-dive-bst-vs-b-tree-database-indexing-3">Deep Dive: BST vs B-Tree (Database Indexing)</h2>

<p>We mentioned databases use B-Trees. Why not BSTs?</p>
<ol>
  <li><strong>Disk I/O:</strong> BST nodes are scattered in memory. B-Tree nodes contain thousands of keys in a single block (Page).</li>
  <li><strong>Height:</strong> A BST with (N=10^9) has height (\approx 30). A B-Tree with branching factor (B=1000) has height (\approx 3).</li>
  <li><strong>Locality:</strong> B-Trees are cache-friendly.</li>
</ol>

<p><strong>Relevance to Kth Smallest:</strong>
In a B-Tree, each internal node stores the count of keys in its subtrees.
The logic is identical to our Augmented BST, just with (M) children instead of 2.</p>

<h2 id="deep-dive-threaded-binary-trees-3">Deep Dive: Threaded Binary Trees</h2>

<p>Morris Traversal is based on the concept of <strong>Threaded Binary Trees</strong>.
In a standard BST, (N+1) pointers are NULL (the leaves). This is wasted space.
<strong>Idea:</strong> Use the NULL right pointers to point to the <strong>Inorder Successor</strong>.
<strong>Idea:</strong> Use the NULL left pointers to point to the <strong>Inorder Predecessor</strong>.</p>

<p><strong>Benefits:</strong></p>
<ul>
  <li>Traversals become purely iterative (no stack needed).</li>
  <li>Finding the successor is (O(1)) (mostly).</li>
</ul>

<p><strong>Drawbacks:</strong></p>
<ul>
  <li>Insertion/Deletion is more complex (need to update threads).</li>
  <li>We need a bit flag to distinguish between a “Child Pointer” and a “Thread”.</li>
</ul>

<h2 id="deep-dive-why-not-a-segment-tree-3">Deep Dive: Why not a Segment Tree?</h2>

<p>A Segment Tree can also solve “Kth Smallest” in (O(\log N)).</p>
<ul>
  <li><strong>Setup:</strong> Map the value range ([0, 10^4]) to the leaves of the segment tree.</li>
  <li><strong>Node Value:</strong> Count of elements in the range ([L, R]).</li>
  <li><strong>Query:</strong> Similar to Augmented BST. If <code class="language-plaintext highlighter-rouge">left_child.count &gt;= k</code>, go left. Else go right.</li>
</ul>

<p><strong>Comparison:</strong></p>
<ul>
  <li><strong>Segment Tree:</strong> Good if the <em>range of values</em> is small and fixed. Bad if values are sparse or floats.</li>
  <li><strong>Augmented BST:</strong> Good for arbitrary values. Space depends on number of elements, not value range.</li>
</ul>

<h2 id="deep-dive-python-generators-for-inorder-4">Deep Dive: Python Generators for Inorder</h2>

<p>Python’s <code class="language-plaintext highlighter-rouge">yield</code> keyword makes writing the iterator trivial.
This is arguably the most “Pythonic” way to solve the problem.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">kthSmallest</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">],</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">inorder_gen</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="p">:</span> <span class="k">return</span>
            <span class="k">yield</span> <span class="k">from</span> <span class="nf">inorder_gen</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">node</span><span class="p">.</span><span class="n">val</span>
            <span class="k">yield</span> <span class="k">from</span> <span class="nf">inorder_gen</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
            
        <span class="n">gen</span> <span class="o">=</span> <span class="nf">inorder_gen</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
            <span class="n">val</span> <span class="o">=</span> <span class="nf">next</span><span class="p">(</span><span class="n">gen</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">val</span>
</code></pre></div></div>

<p><strong>Under the Hood:</strong>
Python handles the stack frames for us. <code class="language-plaintext highlighter-rouge">yield from</code> delegates to a sub-generator.
<strong>Performance:</strong> Slightly slower than the manual stack due to generator overhead, but much cleaner code.</p>

<h2 id="deep-dive-bst-vs-b-tree-database-indexing-4">Deep Dive: BST vs B-Tree (Database Indexing)</h2>

<p>We mentioned databases use B-Trees. Why not BSTs?</p>
<ol>
  <li><strong>Disk I/O:</strong> BST nodes are scattered in memory. B-Tree nodes contain thousands of keys in a single block (Page).</li>
  <li><strong>Height:</strong> A BST with (N=10^9) has height (\approx 30). A B-Tree with branching factor (B=1000) has height (\approx 3).</li>
  <li><strong>Locality:</strong> B-Trees are cache-friendly.</li>
</ol>

<p><strong>Relevance to Kth Smallest:</strong>
In a B-Tree, each internal node stores the count of keys in its subtrees.
The logic is identical to our Augmented BST, just with (M) children instead of 2.</p>

<h2 id="deep-dive-threaded-binary-trees-4">Deep Dive: Threaded Binary Trees</h2>

<p>Morris Traversal is based on the concept of <strong>Threaded Binary Trees</strong>.
In a standard BST, (N+1) pointers are NULL (the leaves). This is wasted space.
<strong>Idea:</strong> Use the NULL right pointers to point to the <strong>Inorder Successor</strong>.
<strong>Idea:</strong> Use the NULL left pointers to point to the <strong>Inorder Predecessor</strong>.</p>

<p><strong>Benefits:</strong></p>
<ul>
  <li>Traversals become purely iterative (no stack needed).</li>
  <li>Finding the successor is (O(1)) (mostly).</li>
</ul>

<p><strong>Drawbacks:</strong></p>
<ul>
  <li>Insertion/Deletion is more complex (need to update threads).</li>
  <li>We need a bit flag to distinguish between a “Child Pointer” and a “Thread”.</li>
</ul>

<h2 id="deep-dive-why-not-a-segment-tree-4">Deep Dive: Why not a Segment Tree?</h2>

<p>A Segment Tree can also solve “Kth Smallest” in (O(\log N)).</p>
<ul>
  <li><strong>Setup:</strong> Map the value range ([0, 10^4]) to the leaves of the segment tree.</li>
  <li><strong>Node Value:</strong> Count of elements in the range ([L, R]).</li>
  <li><strong>Query:</strong> Similar to Augmented BST. If <code class="language-plaintext highlighter-rouge">left_child.count &gt;= k</code>, go left. Else go right.</li>
</ul>

<p><strong>Comparison:</strong></p>
<ul>
  <li><strong>Segment Tree:</strong> Good if the <em>range of values</em> is small and fixed. Bad if values are sparse or floats.</li>
  <li><strong>Augmented BST:</strong> Good for arbitrary values. Space depends on number of elements, not value range.</li>
</ul>

<h2 id="deep-dive-time-and-space-complexity-analysis">Deep Dive: Time and Space Complexity Analysis</h2>

<p>Let’s rigorously analyze the complexity.</p>

<p><strong>Recursive Approach:</strong></p>
<ul>
  <li><strong>Time:</strong> We visit nodes until we hit <code class="language-plaintext highlighter-rouge">k</code>.
    <ul>
      <li>Best Case (k=1): (O(1)) (if we are lucky and root has no left child).</li>
      <li>Worst Case (k=N): (O(N)).</li>
      <li>Average Case: (O(N)).</li>
    </ul>
  </li>
  <li><strong>Space:</strong> Recursion stack.
    <ul>
      <li>Balanced Tree: (O(\log N)).</li>
      <li>Skewed Tree: (O(N)).</li>
    </ul>
  </li>
</ul>

<p><strong>Iterative Approach:</strong></p>
<ul>
  <li><strong>Time:</strong> (O(H + k)).
    <ul>
      <li>We traverse down to the leftmost node: (O(H)).</li>
      <li>We then pop <code class="language-plaintext highlighter-rouge">k</code> times. Each pop might involve pushing right children.</li>
      <li>Amortized cost of <code class="language-plaintext highlighter-rouge">next()</code> is (O(1)).</li>
      <li>Total: (O(H + k)).</li>
    </ul>
  </li>
  <li><strong>Space:</strong> (O(H)).</li>
</ul>

<p><strong>Augmented BST:</strong></p>
<ul>
  <li><strong>Time:</strong> (O(H)).
    <ul>
      <li>At each step, we go down one level.</li>
      <li>We perform constant work (comparisons).</li>
      <li>Total steps = Height.</li>
    </ul>
  </li>
  <li><strong>Space:</strong> (O(N)) to store the <code class="language-plaintext highlighter-rouge">count</code> in every node.</li>
</ul>

<h2 id="deep-dive-why-inorder-a-proof">Deep Dive: Why Inorder? (A Proof)</h2>

<p>Why does Inorder traversal yield sorted values?
<strong>Theorem:</strong> For any BST, Inorder traversal visits nodes in non-decreasing order.</p>

<p><strong>Proof (by Induction):</strong></p>
<ol>
  <li><strong>Base Case:</strong> Empty tree. Sequence is empty (sorted).</li>
  <li><strong>Inductive Step:</strong>
    <ul>
      <li>Assume true for subtrees of height (h).</li>
      <li>Consider tree of height (h+1) with root (R), left subtree (L), right subtree (R_{ight}).</li>
      <li><strong>BST Property:</strong> (\forall x \in L, x &lt; R). (\forall y \in R_{ight}, y &gt; R).</li>
      <li><strong>Inorder:</strong> <code class="language-plaintext highlighter-rouge">Inorder(L) + [R] + Inorder(R_{ight})</code>.</li>
      <li>By hypothesis, <code class="language-plaintext highlighter-rouge">Inorder(L)</code> is sorted. <code class="language-plaintext highlighter-rouge">Inorder(R_{ight})</code> is sorted.</li>
      <li>Since all elements in (L) are smaller than (R), and all elements in (R_{ight}) are larger than (R), the concatenation is sorted.</li>
    </ul>
  </li>
</ol>

<h2 id="implementation-in-java">Implementation in Java</h2>

<p>Java’s <code class="language-plaintext highlighter-rouge">Stack</code> class is legacy. Use <code class="language-plaintext highlighter-rouge">Deque</code> (ArrayDeque).</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">kthSmallest</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Deque</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayDeque</span><span class="o">&lt;&gt;();</span>
        <span class="nc">TreeNode</span> <span class="n">curr</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span>
        
        <span class="k">while</span> <span class="o">(</span><span class="n">curr</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">||</span> <span class="o">!</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">curr</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">curr</span><span class="o">);</span>
                <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
            <span class="o">}</span>
            
            <span class="n">curr</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
            <span class="n">k</span><span class="o">--;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">curr</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
            <span class="o">}</span>
            
            <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="key-takeaways">Key Takeaways</h2>

<ul>
  <li><strong>Inorder Traversal</strong> of a BST gives sorted order.</li>
  <li><strong>Iterative Traversal</strong> allows early exit, saving time.</li>
  <li><strong>Augmented Trees</strong> allow (O(\log N)) selection, at the cost of complex maintenance during inserts/deletes.</li>
</ul>

<hr />

<p><strong>Originally published at:</strong> <a href="https://www.arunbaby.com/dsa/0028-kth-smallest-in-bst/">arunbaby.com/dsa/0028-kth-smallest-in-bst</a></p>

<p><em>If you found this helpful, consider sharing it with others who might benefit.</em></p>


        
      </section>

      <footer class="page__meta">
        
        
  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-tags" aria-hidden="true"></i> Tags: </strong>
    <span itemprop="keywords">
    
      <a href="/tags/#bst" class="page__taxonomy-item p-category" rel="tag">bst</a><span class="sep">, </span>
    
      <a href="/tags/#medium" class="page__taxonomy-item p-category" rel="tag">medium</a><span class="sep">, </span>
    
      <a href="/tags/#recursion" class="page__taxonomy-item p-category" rel="tag">recursion</a><span class="sep">, </span>
    
      <a href="/tags/#stack" class="page__taxonomy-item p-category" rel="tag">stack</a>
    
    </span>
  </p>




  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> Categories: </strong>
    <span itemprop="keywords">
    
      <a href="/categories/#dsa" class="page__taxonomy-item p-category" rel="tag">dsa</a>
    
    </span>
  </p>


        
      </footer>

      <div class="page__related page__related--full">
  <h2 class="page__related-title">Related across topics</h2>
  <style>
    /* Make section span full content width and use 2 equal columns */
    .page__related--full { float: inline-start; width: 100%; padding: 0; }
    .cross-related-grid { display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 2rem; }
    @media (max-width: 768px) { .cross-related-grid { grid-template-columns: 1fr; } }
    /* Ensure archive cards stretch nicely in the grid */
    .cross-related-grid .list__item, .cross-related-grid .grid__item { width: auto; float: none; margin: 0; }
  </style>
  <div class="cross-related-grid">
    



<div class="list__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/ml-system-design/0028-ranking-systems-at-scale/" rel="permalink">Ranking Systems at Scale
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          22 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">How does Google search 50 billion pages in 0.1 seconds? The answer is the “Ranking Funnel”.
</p>
  </article>
</div>




<div class="list__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/speech-tech/0028-voice-search-ranking/" rel="permalink">Voice Search Ranking
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          19 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">“Play Call Me Maybe”. Did you mean the song, the video, or the contact named ‘Maybe’?
</p>
  </article>
</div>

  </div>
</div>

      <section class="page__share">
  <h4 class="page__share-title">Share on</h4>

  <a href="https://twitter.com/intent/tweet?via=arunbaby0&text=Kth+Smallest+Element+in+a+BST%20https%3A%2F%2Fwww.arunbaby.com%2Fdsa%2F0028-kth-smallest-in-bst%2F" class="btn btn--twitter" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Twitter"><i class="fab fa-fw fa-twitter" aria-hidden="true"></i><span> Twitter</span></a>

  <a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fwww.arunbaby.com%2Fdsa%2F0028-kth-smallest-in-bst%2F" class="btn btn--facebook" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Facebook"><i class="fab fa-fw fa-facebook" aria-hidden="true"></i><span> Facebook</span></a>

  <a href="https://www.linkedin.com/shareArticle?mini=true&url=https://www.arunbaby.com/dsa/0028-kth-smallest-in-bst/" class="btn btn--linkedin" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on LinkedIn"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i><span> LinkedIn</span></a>
</section>


      
  <nav class="pagination">
    
      <a href="/dsa/0027-construct-binary-tree/" class="pagination--pager" title="Construct Binary Tree from Preorder and Inorder Traversal">Previous</a>
    
    
      <a href="/dsa/0029-lowest-common-ancestor/" class="pagination--pager" title="Lowest Common Ancestor of a Binary Tree">Next</a>
    
  </nav>


    </div>

    
  </article>

  
  
</div>

      
    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';" role="search">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Enter your search term..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    

    
      
        
          <li><a href="https://twitter.com/arunbaby0" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-twitter-square" aria-hidden="true"></i> Twitter</a></li>
        
      
        
          <li><a href="https://github.com/arunbaby0" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
        
      
        
          <li><a href="https://www.linkedin.com/in/arunbaby0/" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i> LinkedIn</a></li>
        
      
        
          <li><a href="https://scholar.google.co.in/citations?user=6fSYWhkAAAAJ" rel="nofollow noopener noreferrer"><i class="fas fa-fw fa-graduation-cap" aria-hidden="true"></i> Google Scholar</a></li>
        
      
    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 1990 - 2143 <a href="https://www.arunbaby.com">Arun Baby</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>




  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-0JRJPEC9SS"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-0JRJPEC9SS', { 'anonymize_ip': false});
</script>








  </body>
</html>
