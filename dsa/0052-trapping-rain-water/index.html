<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.26.2 by Michael Rose
  Copyright 2013-2024 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->

<html lang="en-US" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Trapping Rain Water - Arun Baby</title>
<meta name="description" content="“Water doesn’t care about every bar—only the highest walls to the left and right.”">


  <meta name="author" content="Arun Baby">
  
  <meta property="article:author" content="Arun Baby">
  


<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="Arun Baby">
<meta property="og:title" content="Trapping Rain Water">
<meta property="og:url" content="https://www.arunbaby.com/dsa/0052-trapping-rain-water/">


  <meta property="og:description" content="“Water doesn’t care about every bar—only the highest walls to the left and right.”">



  <meta property="og:image" content="https://www.arunbaby.com/assets/images/profile-photo.png">



  <meta name="twitter:site" content="@arunbaby0">
  <meta name="twitter:title" content="Trapping Rain Water">
  <meta name="twitter:description" content="“Water doesn’t care about every bar—only the highest walls to the left and right.”">
  <meta name="twitter:url" content="https://www.arunbaby.com/dsa/0052-trapping-rain-water/">

  
    <meta name="twitter:card" content="summary">
    
      <meta name="twitter:image" content="https://www.arunbaby.com/assets/images/profile-photo.png">
    
  

  



  <meta property="article:published_time" content="2025-12-29T13:14:56+05:30">





  

  


<link rel="canonical" href="https://www.arunbaby.com/dsa/0052-trapping-rain-water/">












<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Arun Baby Feed">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
  
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css"></noscript>



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--single" dir="ltr">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
           
          <span class="site-subtitle">Arun Baby</span>
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a
                href="/about/"
                
                
              >About</a>
            </li><li class="masthead__menu-item">
              <a
                href="/dsa/"
                
                
              >DSA</a>
            </li><li class="masthead__menu-item">
              <a
                href="/ml-system-design/"
                
                
              >ML Systems</a>
            </li><li class="masthead__menu-item">
              <a
                href="/speech-tech/"
                
                
              >Speech Tech</a>
            </li><li class="masthead__menu-item">
              <a
                href="/ai-agents/"
                
                
              >AI Agents</a>
            </li><li class="masthead__menu-item">
              <a
                href="/publications/"
                
                
              >Publications</a>
            </li><li class="masthead__menu-item">
              <a
                href="/statuses/"
                
                
              >Statuses</a>
            </li><li class="masthead__menu-item">
              <a
                href="/contact/"
                
                
              >Contact</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <i class="fas fa-search"></i>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      





<div id="main" role="main" class="no-author-sidebar">
  
  <div class="sidebar sticky">
  
  
  </div>



  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="Trapping Rain Water">
    <meta itemprop="description" content="“Water doesn’t care about every bar—only the highest walls to the left and right.”">
    <meta itemprop="datePublished" content="2025-12-29T13:14:56+05:30">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">
            <a href="https://www.arunbaby.com/dsa/0052-trapping-rain-water/" itemprop="url">Trapping Rain Water
</a>
          </h1>
          

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          22 minute read
        
      </span>
    
  </p>


        </header>
      

      <section class="page__content" itemprop="text">
        
          <aside class="sidebar__right sticky">
            <nav class="toc">
              <header><h4 class="nav__title"><i class="fas fa-file-alt"></i> On this page</h4></header>
              <ul class="toc__menu"><li><a href="#1-problem-statement">1. Problem Statement</a></li><li><a href="#2-understanding-the-problem">2. Understanding the Problem</a><ul><li><a href="#21-the-local-rule-water-at-one-index">2.1 The local rule (water at one index)</a></li><li><a href="#22-why-this-is-a-pattern-recognition-question">2.2 Why this is a “pattern recognition” question</a></li><li><a href="#23-visual-intuition-why-valleys-matter-not-slopes">2.3 Visual intuition (why valleys matter, not slopes)</a></li><li><a href="#24-why-the-minimum-of-two-maxima-is-inevitable">2.4 Why the minimum of two maxima is inevitable</a></li></ul></li><li><a href="#3-approach-1-brute-force-scan-left-and-right-for-each-index">3. Approach 1: Brute Force (Scan Left and Right for Each Index)</a><ul><li><a href="#31-idea">3.1 Idea</a></li><li><a href="#32-complexity">3.2 Complexity</a></li><li><a href="#33-when-its-still-useful">3.3 When it’s still useful</a></li><li><a href="#34-brute-force-implementation-for-completeness">3.4 Brute force implementation (for completeness)</a></li></ul></li><li><a href="#4-approach-2-precompute-prefixsuffix-max-dp">4. Approach 2: Precompute Prefix/Suffix Max (DP)</a><ul><li><a href="#41-idea">4.1 Idea</a></li><li><a href="#42-complexity">4.2 Complexity</a></li><li><a href="#43-implementation-clear-and-interview-safe">4.3 Implementation (clear and interview-safe)</a></li><li><a href="#44-space-optimization-note">4.4 Space optimization note</a></li></ul></li><li><a href="#5-approach-3-optimal-two-pointers-o1-space">5. Approach 3: Optimal Two Pointers (O(1) Space)</a><ul><li><a href="#51-core-insight">5.1 Core insight</a></li><li><a href="#52-why-it-works-invariant-explanation">5.2 Why it works (invariant explanation)</a></li><li><a href="#53-alternative-formulation-compare-boundary-maxima-directly">5.3 Alternative formulation (compare boundary maxima directly)</a></li><li><a href="#54-common-off-by-one--tie-handling-guidance">5.4 Common off-by-one / tie-handling guidance</a></li><li><a href="#55-complexity">5.5 Complexity</a></li><li><a href="#56-step-by-step-dry-run-build-confidence">5.6 Step-by-step dry run (build confidence)</a></li><li><a href="#57-implementation-recommended">5.7 Implementation (recommended)</a></li></ul></li><li><a href="#6-approach-4-optional-monotonic-stack">6. Approach 4 (Optional): Monotonic Stack</a><ul><li><a href="#61-idea">6.1 Idea</a></li><li><a href="#611-how-the-stack-computes-water-width--bounded-height">6.1.1 How the stack computes water (width × bounded height)</a></li><li><a href="#612-quick-dry-run-stack-intuition">6.1.2 Quick dry run (stack intuition)</a></li><li><a href="#62-implementation-stack">6.2 Implementation (stack)</a></li><li><a href="#63-when-to-prefer-stack-vs-two-pointers">6.3 When to prefer stack vs two pointers</a></li></ul></li><li><a href="#7-testing-edge-cases-included">7. Testing (Edge Cases Included)</a><ul><li><a href="#71-basic-tests">7.1 Basic tests</a></li><li><a href="#72-monotonic-arrays">7.2 Monotonic arrays</a></li><li><a href="#73-plateaus-and-duplicates">7.3 Plateaus and duplicates</a></li><li><a href="#74-provided-examples">7.4 Provided examples</a></li><li><a href="#75-differential-testing-production">7.5 Differential testing (production)</a></li><li><a href="#76-quick-randomized-differential-test">7.6 Quick randomized differential test</a></li></ul></li><li><a href="#8-complexity-analysis">8. Complexity Analysis</a></li><li><a href="#9-production-considerations">9. Production Considerations</a><ul><li><a href="#91-what-this-pattern-teaches">9.1 What this pattern teaches</a></li><li><a href="#92-numerical-stability-and-data-types">9.2 Numerical stability and data types</a></li><li><a href="#93-visual-debugging-tip">9.3 Visual debugging tip</a></li><li><a href="#94-a-proof-style-intuition-why-finalize-one-side-is-safe">9.4 A proof-style intuition (why “finalize one side” is safe)</a></li><li><a href="#95-follow-up-2d-trapping-rain-water-what-changes">9.5 Follow-up: 2D trapping rain water (what changes)</a></li><li><a href="#96-engineering-checklist-if-you-were-reviewing-this-code">9.6 Engineering checklist (if you were reviewing this code)</a></li><li><a href="#97-relationship-to-monotonic-stack-problems">9.7 Relationship to “monotonic stack” problems</a></li></ul></li><li><a href="#10-connections-to-ml-systems">10. Connections to ML Systems</a></li><li><a href="#11-interview-strategy">11. Interview Strategy</a><ul><li><a href="#111-the-explain-like-im-debugging-move">11.1 The “explain like I’m debugging” move</a></li><li><a href="#112-common-follow-ups">11.2 Common follow-ups</a></li></ul></li><li><a href="#12-key-takeaways">12. Key Takeaways</a><ul><li><a href="#121-one-sentence-invariant">12.1 One-sentence invariant</a></li><li><a href="#122-appendix-a-compact-cheat-sheet-what-to-remember">12.2 Appendix: a compact cheat sheet (what to remember)</a></li><li><a href="#123-appendix-practice-variants-that-reuse-the-same-ideas">12.3 Appendix: practice variants that reuse the same ideas</a></li><li><a href="#124-appendix-what-to-say-if-asked-why-not-simulate">12.4 Appendix: what to say if asked “why not simulate?”</a></li><li><a href="#125-appendix-sketch-of-the-2d-solution-what-youd-say-in-an-interview">12.5 Appendix: sketch of the 2D solution (what you’d say in an interview)</a></li><li><a href="#126-appendix-choosing-between-two-pointers-and-stack-how-to-decide">12.6 Appendix: choosing between two pointers and stack (how to decide)</a></li><li><a href="#127-appendix-rapid-fire-interview-qa">12.7 Appendix: rapid-fire interview Q&amp;A</a></li><li><a href="#128-appendix-the-one-mistake-to-avoid">12.8 Appendix: the one mistake to avoid</a></li><li><a href="#129-appendix-quick-complexity-intuition-why-on-is-optimal">12.9 Appendix: quick complexity intuition (why O(N) is optimal)</a></li><li><a href="#1210-appendix-explain-it-to-production-in-one-paragraph">12.10 Appendix: “explain it to production” in one paragraph</a></li><li><a href="#1211-appendix-micro-optimizations-rarely-needed-but-good-to-know">12.11 Appendix: micro-optimizations (rarely needed, but good to know)</a></li><li><a href="#1212-appendix-one-more-way-to-sanity-check-results">12.12 Appendix: one more way to sanity-check results</a></li></ul></li></ul>
            </nav>
          </aside>
        
        <p><strong>“Water doesn’t care about every bar—only the highest walls to the left and right.”</strong></p>

<h2 id="1-problem-statement">1. Problem Statement</h2>

<p>You are given an array <code class="language-plaintext highlighter-rouge">height</code> where <code class="language-plaintext highlighter-rouge">height[i]</code> represents the height of a bar at position <code class="language-plaintext highlighter-rouge">i</code>. Imagine rain falls, and the bars form a histogram. Return how many units of water can be trapped after raining.</p>

<p><strong>Example 1</strong></p>
<ul>
  <li>Input: <code class="language-plaintext highlighter-rouge">height = [0,1,0,2,1,0,1,3,2,1,2,1]</code></li>
  <li>Output: <code class="language-plaintext highlighter-rouge">6</code></li>
</ul>

<p><strong>Example 2</strong></p>
<ul>
  <li>Input: <code class="language-plaintext highlighter-rouge">height = [4,2,0,3,2,5]</code></li>
  <li>Output: <code class="language-plaintext highlighter-rouge">9</code></li>
</ul>

<p><strong>Key constraints</strong></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">0 &lt;= height[i]</code></li>
  <li>We want an efficient solution: ideally <strong>O(N)</strong>.</li>
</ul>

<hr />

<h2 id="2-understanding-the-problem">2. Understanding the Problem</h2>

<h3 id="21-the-local-rule-water-at-one-index">2.1 The local rule (water at one index)</h3>

<p>At index <code class="language-plaintext highlighter-rouge">i</code>, the water level is limited by the highest wall to the left and right:</p>

<p>[
water[i] = \max\left(0,\ \min(\maxLeft[i],\maxRight[i]) - height[i]\right)
]</p>

<p>Where:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">maxLeft[i]</code> = maximum height in <code class="language-plaintext highlighter-rouge">height[0..i]</code></li>
  <li><code class="language-plaintext highlighter-rouge">maxRight[i]</code> = maximum height in <code class="language-plaintext highlighter-rouge">height[i..n-1]</code></li>
</ul>

<p>This formula is the whole problem. Every solution is just a different way to compute <code class="language-plaintext highlighter-rouge">maxLeft</code> and <code class="language-plaintext highlighter-rouge">maxRight</code> efficiently.</p>

<h3 id="22-why-this-is-a-pattern-recognition-question">2.2 Why this is a “pattern recognition” question</h3>

<p>The trap: you might think you need to simulate water “filling” across the bars. You don’t.
Water at position <code class="language-plaintext highlighter-rouge">i</code> is determined by two boundaries (left/right maxima), not by global simulation.</p>

<p>This “boundary thinking” shows up everywhere:</p>
<ul>
  <li>in anomaly detection you don’t inspect every raw event; you look for boundary violations of normal patterns</li>
  <li>in long-context agents you can’t keep everything; you keep boundaries (summaries, constraints, invariants) that preserve correctness</li>
</ul>

<h3 id="23-visual-intuition-why-valleys-matter-not-slopes">2.3 Visual intuition (why valleys matter, not slopes)</h3>

<p>A useful mental picture:</p>
<ul>
  <li>water collects only where there exists a higher wall on both sides</li>
  <li>the amount depends on the <em>lower</em> of the two walls</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>heights:  3       3
          |       |
          |   1   |
          | _ _ _ |
index:    0 1 2 3 4
</code></pre></div></div>

<p>At index 2:</p>
<ul>
  <li>left max = 3, right max = 3</li>
  <li>water = 3 - 1 = 2</li>
</ul>

<p>The important lesson: you can compute the final trapped water purely from boundaries.</p>

<h3 id="24-why-the-minimum-of-two-maxima-is-inevitable">2.4 Why the minimum of two maxima is inevitable</h3>

<p>If left boundary is 10 and right boundary is 3, water leaks at 3.
So the left wall being 10 doesn’t help beyond 3.
That’s why the formula uses:
[
\min(\maxLeft[i],\maxRight[i])
]</p>

<p>This exact “lower boundary dominates” idea appears in:</p>
<ul>
  <li>“Container With Most Water” (area limited by the shorter line)</li>
  <li>“Trapping Rain Water” (level limited by the shorter wall)</li>
</ul>

<hr />

<h2 id="3-approach-1-brute-force-scan-left-and-right-for-each-index">3. Approach 1: Brute Force (Scan Left and Right for Each Index)</h2>

<h3 id="31-idea">3.1 Idea</h3>
<p>For each <code class="language-plaintext highlighter-rouge">i</code>:</p>
<ul>
  <li>scan left to find <code class="language-plaintext highlighter-rouge">left_max</code></li>
  <li>scan right to find <code class="language-plaintext highlighter-rouge">right_max</code></li>
  <li>add <code class="language-plaintext highlighter-rouge">min(left_max, right_max) - height[i]</code> if positive</li>
</ul>

<h3 id="32-complexity">3.2 Complexity</h3>
<ul>
  <li><strong>Time</strong>: (O(N^2)) (because each index does two scans)</li>
  <li><strong>Space</strong>: (O(1))</li>
</ul>

<h3 id="33-when-its-still-useful">3.3 When it’s still useful</h3>
<p>It’s a great way to derive the formula and validate understanding.
But it’s too slow for large <code class="language-plaintext highlighter-rouge">N</code>.</p>

<h3 id="34-brute-force-implementation-for-completeness">3.4 Brute force implementation (for completeness)</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">List</span>


<span class="k">class</span> <span class="nc">SolutionBrute</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">trap</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">height</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">height</span><span class="p">)</span>
        <span class="n">water</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">left_max</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">left_max</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="n">left_max</span><span class="p">,</span> <span class="n">height</span><span class="p">[</span><span class="n">l</span><span class="p">])</span>
            <span class="n">right_max</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
                <span class="n">right_max</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="n">right_max</span><span class="p">,</span> <span class="n">height</span><span class="p">[</span><span class="n">r</span><span class="p">])</span>
            <span class="n">water</span> <span class="o">+=</span> <span class="nf">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nf">min</span><span class="p">(</span><span class="n">left_max</span><span class="p">,</span> <span class="n">right_max</span><span class="p">)</span> <span class="o">-</span> <span class="n">height</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">water</span>
</code></pre></div></div>

<p>This is slow but “obviously correct”, which makes it valuable for validating optimized approaches.</p>

<hr />

<h2 id="4-approach-2-precompute-prefixsuffix-max-dp">4. Approach 2: Precompute Prefix/Suffix Max (DP)</h2>

<h3 id="41-idea">4.1 Idea</h3>
<p>Build:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">left_max[i] = max(height[0..i])</code></li>
  <li><code class="language-plaintext highlighter-rouge">right_max[i] = max(height[i..n-1])</code></li>
</ul>

<p>Then compute trapped water using the formula from section 2.</p>

<h3 id="42-complexity">4.2 Complexity</h3>
<ul>
  <li><strong>Time</strong>: (O(N))</li>
  <li><strong>Space</strong>: (O(N)) for the two arrays</li>
</ul>

<h3 id="43-implementation-clear-and-interview-safe">4.3 Implementation (clear and interview-safe)</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">List</span>


<span class="k">class</span> <span class="nc">SolutionDP</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">trap</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">height</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">height</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="n">left_max</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>
        <span class="n">right_max</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>

        <span class="n">left_max</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">height</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
            <span class="n">left_max</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="n">left_max</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">height</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="n">right_max</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">height</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">right_max</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="n">right_max</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">height</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="n">water</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">water</span> <span class="o">+=</span> <span class="nf">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nf">min</span><span class="p">(</span><span class="n">left_max</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">right_max</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">-</span> <span class="n">height</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">water</span>
</code></pre></div></div>

<p>This solution is easy to reason about and is often acceptable if memory is not a concern.</p>

<h3 id="44-space-optimization-note">4.4 Space optimization note</h3>

<p>You can reduce memory by computing one side first (e.g., <code class="language-plaintext highlighter-rouge">right_max</code>), then scanning while maintaining the other side (<code class="language-plaintext highlighter-rouge">left_max</code>) on the fly.
In interviews, the more meaningful memory optimization is usually the next approach: <strong>two pointers</strong> with truly O(1) extra space.</p>

<hr />

<h2 id="5-approach-3-optimal-two-pointers-o1-space">5. Approach 3: Optimal Two Pointers (O(1) Space)</h2>

<h3 id="51-core-insight">5.1 Core insight</h3>

<p>We don’t actually need the full <code class="language-plaintext highlighter-rouge">left_max[]</code> and <code class="language-plaintext highlighter-rouge">right_max[]</code> arrays.
As we move inward with two pointers (<code class="language-plaintext highlighter-rouge">l</code>, <code class="language-plaintext highlighter-rouge">r</code>), we maintain:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">left_max = max(height[0..l])</code></li>
  <li><code class="language-plaintext highlighter-rouge">right_max = max(height[r..n-1])</code></li>
</ul>

<p>Then:</p>
<ul>
  <li>If <code class="language-plaintext highlighter-rouge">left_max &lt;= right_max</code>, water at <code class="language-plaintext highlighter-rouge">l</code> is fully determined by <code class="language-plaintext highlighter-rouge">left_max</code> (because the right side has a boundary at least as tall).
    <ul>
      <li>Add <code class="language-plaintext highlighter-rouge">left_max - height[l]</code>, move <code class="language-plaintext highlighter-rouge">l</code>.</li>
    </ul>
  </li>
  <li>Else, water at <code class="language-plaintext highlighter-rouge">r</code> is determined by <code class="language-plaintext highlighter-rouge">right_max</code>.
    <ul>
      <li>Add <code class="language-plaintext highlighter-rouge">right_max - height[r]</code>, move <code class="language-plaintext highlighter-rouge">r</code>.</li>
    </ul>
  </li>
</ul>

<p>This is the crucial invariant:</p>
<blockquote>
  <p>The smaller boundary decides the water level for the pointer on that side.</p>
</blockquote>

<h3 id="52-why-it-works-invariant-explanation">5.2 Why it works (invariant explanation)</h3>

<p>Suppose <code class="language-plaintext highlighter-rouge">left_max &lt;= right_max</code>.
For index <code class="language-plaintext highlighter-rouge">l</code>, the right boundary is <strong>at least</strong> <code class="language-plaintext highlighter-rouge">right_max</code>, and since <code class="language-plaintext highlighter-rouge">right_max &gt;= left_max</code>, the limiting height is <code class="language-plaintext highlighter-rouge">left_max</code>.
So <code class="language-plaintext highlighter-rouge">water[l] = left_max - height[l]</code> (if positive), and it’s safe to finalize <code class="language-plaintext highlighter-rouge">l</code> without knowing future right details.</p>

<p>Symmetrically for the right side.</p>

<h3 id="53-alternative-formulation-compare-boundary-maxima-directly">5.3 Alternative formulation (compare boundary maxima directly)</h3>

<p>Some implementations use:</p>
<ul>
  <li>if <code class="language-plaintext highlighter-rouge">left_max &lt;= right_max</code>, process left</li>
  <li>else process right</li>
</ul>

<p>This is equivalent in spirit, and sometimes feels cleaner because it matches the proof statement.
Pseudo-logic:</p>
<ul>
  <li>update <code class="language-plaintext highlighter-rouge">left_max</code> and <code class="language-plaintext highlighter-rouge">right_max</code> as you move pointers</li>
  <li>whichever side has smaller max is the bottleneck, finalize that side</li>
</ul>

<p>Why it’s equivalent:</p>
<ul>
  <li>the algorithm’s correctness hinges on “smaller boundary decides”</li>
  <li>whether you compare the current bars or the running maxima, you’re still choosing the side that is guaranteed to be bounded by its own max</li>
</ul>

<h3 id="54-common-off-by-one--tie-handling-guidance">5.4 Common off-by-one / tie-handling guidance</h3>

<p>Two-pointer algorithms often fail due to tie handling.
Practical rules:</p>
<ul>
  <li>it’s safe to treat ties (<code class="language-plaintext highlighter-rouge">height[l] == height[r]</code>) as “process left” (or consistently process one side)</li>
  <li>update the boundary max <strong>before</strong> adding trapped water on that index</li>
</ul>

<p>If you are consistent, both tie strategies work; inconsistency causes subtle bugs.</p>

<h3 id="55-complexity">5.5 Complexity</h3>
<ul>
  <li><strong>Time</strong>: (O(N))</li>
  <li><strong>Space</strong>: (O(1))</li>
</ul>

<h3 id="56-step-by-step-dry-run-build-confidence">5.6 Step-by-step dry run (build confidence)</h3>

<p>Example: <code class="language-plaintext highlighter-rouge">height = [4,2,0,3,2,5]</code></p>

<p>Start:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">l=0 (4)</code>, <code class="language-plaintext highlighter-rouge">r=5 (5)</code></li>
  <li><code class="language-plaintext highlighter-rouge">left_max=0</code>, <code class="language-plaintext highlighter-rouge">right_max=0</code>, <code class="language-plaintext highlighter-rouge">water=0</code></li>
</ul>

<p>Since <code class="language-plaintext highlighter-rouge">height[l] &lt;= height[r]</code>, finalize left:</p>
<ul>
  <li>update <code class="language-plaintext highlighter-rouge">left_max=4</code>, move <code class="language-plaintext highlighter-rouge">l=1</code></li>
</ul>

<p><code class="language-plaintext highlighter-rouge">l=1 (2)</code>:</p>
<ul>
  <li>add <code class="language-plaintext highlighter-rouge">4-2=2</code> → <code class="language-plaintext highlighter-rouge">water=2</code>, move <code class="language-plaintext highlighter-rouge">l=2</code></li>
</ul>

<p><code class="language-plaintext highlighter-rouge">l=2 (0)</code>:</p>
<ul>
  <li>add <code class="language-plaintext highlighter-rouge">4-0=4</code> → <code class="language-plaintext highlighter-rouge">water=6</code>, move <code class="language-plaintext highlighter-rouge">l=3</code></li>
</ul>

<p><code class="language-plaintext highlighter-rouge">l=3 (3)</code>:</p>
<ul>
  <li>add <code class="language-plaintext highlighter-rouge">4-3=1</code> → <code class="language-plaintext highlighter-rouge">water=7</code>, move <code class="language-plaintext highlighter-rouge">l=4</code></li>
</ul>

<p><code class="language-plaintext highlighter-rouge">l=4 (2)</code>:</p>
<ul>
  <li>add <code class="language-plaintext highlighter-rouge">4-2=2</code> → <code class="language-plaintext highlighter-rouge">water=9</code>, move <code class="language-plaintext highlighter-rouge">l=5</code>, stop.</li>
</ul>

<p>This trace is a great interview sanity check because it shows the algorithm is “finalizing one side” rather than guessing.</p>

<h3 id="57-implementation-recommended">5.7 Implementation (recommended)</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">List</span>


<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">trap</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">height</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">height</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="n">l</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">left_max</span><span class="p">,</span> <span class="n">right_max</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
        <span class="n">water</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">while</span> <span class="n">l</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">height</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">height</span><span class="p">[</span><span class="n">r</span><span class="p">]:</span>
                <span class="c1"># Left side is the limiting boundary (or tied).
</span>                <span class="k">if</span> <span class="n">height</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">left_max</span><span class="p">:</span>
                    <span class="n">left_max</span> <span class="o">=</span> <span class="n">height</span><span class="p">[</span><span class="n">l</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">water</span> <span class="o">+=</span> <span class="n">left_max</span> <span class="o">-</span> <span class="n">height</span><span class="p">[</span><span class="n">l</span><span class="p">]</span>
                <span class="n">l</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Right side is the limiting boundary.
</span>                <span class="k">if</span> <span class="n">height</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">right_max</span><span class="p">:</span>
                    <span class="n">right_max</span> <span class="o">=</span> <span class="n">height</span><span class="p">[</span><span class="n">r</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">water</span> <span class="o">+=</span> <span class="n">right_max</span> <span class="o">-</span> <span class="n">height</span><span class="p">[</span><span class="n">r</span><span class="p">]</span>
                <span class="n">r</span> <span class="o">-=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">water</span>
</code></pre></div></div>

<p>Note: some implementations compare <code class="language-plaintext highlighter-rouge">left_max</code> vs <code class="language-plaintext highlighter-rouge">right_max</code>; others compare <code class="language-plaintext highlighter-rouge">height[l]</code> vs <code class="language-plaintext highlighter-rouge">height[r]</code>. Both can be correct if invariants are maintained consistently.</p>

<hr />

<h2 id="6-approach-4-optional-monotonic-stack">6. Approach 4 (Optional): Monotonic Stack</h2>

<h3 id="61-idea">6.1 Idea</h3>
<p>Use a stack to keep indices of bars in decreasing height order.
When you find a bar taller than the stack top, you can “close a container” and compute trapped water for the valley.</p>

<p>This approach is also (O(N)) but uses (O(N)) space.
It’s useful when you want to compute water in terms of “basins”.</p>

<h3 id="611-how-the-stack-computes-water-width--bounded-height">6.1.1 How the stack computes water (width × bounded height)</h3>

<p>When the current bar at <code class="language-plaintext highlighter-rouge">i</code> is higher than the bar at the stack top, you’ve found a right boundary that can “close” a basin.</p>

<p>Terminology in the code:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">bottom</code>: the valley bar index we just popped</li>
  <li><code class="language-plaintext highlighter-rouge">left</code>: the new stack top after popping (<code class="language-plaintext highlighter-rouge">left</code> boundary)</li>
  <li><code class="language-plaintext highlighter-rouge">i</code>: the current index (right boundary)</li>
</ul>

<p>Then:</p>
<ul>
  <li><strong>width</strong> of trapped region is <code class="language-plaintext highlighter-rouge">i - left - 1</code>
    <ul>
      <li>everything between <code class="language-plaintext highlighter-rouge">left</code> and <code class="language-plaintext highlighter-rouge">i</code> is inside the basin</li>
    </ul>
  </li>
  <li><strong>bounded height</strong> is <code class="language-plaintext highlighter-rouge">min(height[left], height[i]) - height[bottom]</code>
    <ul>
      <li>the water level is limited by the shorter boundary</li>
      <li>subtract the valley floor (<code class="language-plaintext highlighter-rouge">bottom</code>) height</li>
    </ul>
  </li>
</ul>

<p>So trapped water for that basin segment:
[
water += width \times bounded_height
]</p>

<p>Why it’s still O(N):</p>
<ul>
  <li>every index is pushed once</li>
  <li>every index is popped at most once</li>
</ul>

<h3 id="612-quick-dry-run-stack-intuition">6.1.2 Quick dry run (stack intuition)</h3>

<p>Example: <code class="language-plaintext highlighter-rouge">[2,0,2]</code></p>
<ul>
  <li>i=0, stack=[0]</li>
  <li>i=1 (0), stack=[0,1]</li>
  <li>i=2 (2), height[1] &lt; 2 → pop bottom=1
    <ul>
      <li>left=0, width=2-0-1=1</li>
      <li>bounded_height=min(2,2)-0=2</li>
      <li>water += 1*2 = 2</li>
    </ul>
  </li>
</ul>

<p>This is the same answer as two pointers, just computed via “closing basins” rather than “finalizing sides”.</p>

<h3 id="62-implementation-stack">6.2 Implementation (stack)</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">List</span>


<span class="k">class</span> <span class="nc">SolutionStack</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">trap</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">height</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">water</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">h</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">height</span><span class="p">):</span>
            <span class="k">while</span> <span class="n">stack</span> <span class="ow">and</span> <span class="n">height</span><span class="p">[</span><span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">&lt;</span> <span class="n">h</span><span class="p">:</span>
                <span class="n">bottom</span> <span class="o">=</span> <span class="n">stack</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">stack</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">width</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="n">left</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">bounded_height</span> <span class="o">=</span> <span class="nf">min</span><span class="p">(</span><span class="n">height</span><span class="p">[</span><span class="n">left</span><span class="p">],</span> <span class="n">h</span><span class="p">)</span> <span class="o">-</span> <span class="n">height</span><span class="p">[</span><span class="n">bottom</span><span class="p">]</span>
                <span class="n">water</span> <span class="o">+=</span> <span class="n">width</span> <span class="o">*</span> <span class="n">bounded_height</span>
            <span class="n">stack</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">water</span>
</code></pre></div></div>

<h3 id="63-when-to-prefer-stack-vs-two-pointers">6.3 When to prefer stack vs two pointers</h3>

<ul>
  <li><strong>Two pointers</strong>: simplest invariant, minimal memory; best default.</li>
  <li><strong>Stack</strong>: basin-based view; very reusable for histogram-style problems.</li>
</ul>

<hr />

<h2 id="7-testing-edge-cases-included">7. Testing (Edge Cases Included)</h2>

<h3 id="71-basic-tests">7.1 Basic tests</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">[]</code> → <code class="language-plaintext highlighter-rouge">0</code></li>
  <li><code class="language-plaintext highlighter-rouge">[0]</code> → <code class="language-plaintext highlighter-rouge">0</code></li>
  <li><code class="language-plaintext highlighter-rouge">[1,0,1]</code> → <code class="language-plaintext highlighter-rouge">1</code></li>
  <li><code class="language-plaintext highlighter-rouge">[2,0,2]</code> → <code class="language-plaintext highlighter-rouge">2</code></li>
</ul>

<h3 id="72-monotonic-arrays">7.2 Monotonic arrays</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">[0,1,2,3]</code> → <code class="language-plaintext highlighter-rouge">0</code> (no right boundary for valleys)</li>
  <li><code class="language-plaintext highlighter-rouge">[3,2,1,0]</code> → <code class="language-plaintext highlighter-rouge">0</code> (no left boundary)</li>
</ul>

<h3 id="73-plateaus-and-duplicates">7.3 Plateaus and duplicates</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">[3,3,3]</code> → <code class="language-plaintext highlighter-rouge">0</code></li>
  <li><code class="language-plaintext highlighter-rouge">[3,0,0,3]</code> → <code class="language-plaintext highlighter-rouge">6</code></li>
</ul>

<h3 id="74-provided-examples">7.4 Provided examples</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">[0,1,0,2,1,0,1,3,2,1,2,1]</code> → <code class="language-plaintext highlighter-rouge">6</code></li>
  <li><code class="language-plaintext highlighter-rouge">[4,2,0,3,2,5]</code> → <code class="language-plaintext highlighter-rouge">9</code></li>
</ul>

<h3 id="75-differential-testing-production">7.5 Differential testing (production)</h3>
<p>Compare:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Solution().trap(height)</code> (two pointers)</li>
  <li><code class="language-plaintext highlighter-rouge">SolutionDP().trap(height)</code> (prefix/suffix)
on randomized arrays.</li>
</ul>

<h3 id="76-quick-randomized-differential-test">7.6 Quick randomized differential test</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">random</span>


<span class="k">def</span> <span class="nf">randomized_test</span><span class="p">(</span><span class="n">trials</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">200</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="n">fast</span> <span class="o">=</span> <span class="nc">Solution</span><span class="p">()</span>
    <span class="n">slow</span> <span class="o">=</span> <span class="nc">SolutionDP</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">trials</span><span class="p">):</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="nf">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="p">[</span><span class="n">random</span><span class="p">.</span><span class="nf">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">fast</span><span class="p">.</span><span class="nf">trap</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">!=</span> <span class="n">slow</span><span class="p">.</span><span class="nf">trap</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
            <span class="k">raise</span> <span class="nc">AssertionError</span><span class="p">((</span><span class="n">arr</span><span class="p">,</span> <span class="n">fast</span><span class="p">.</span><span class="nf">trap</span><span class="p">(</span><span class="n">arr</span><span class="p">),</span> <span class="n">slow</span><span class="p">.</span><span class="nf">trap</span><span class="p">(</span><span class="n">arr</span><span class="p">)))</span>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="sh">"</span><span class="s">__main__</span><span class="sh">"</span><span class="p">:</span>
    <span class="nf">randomized_test</span><span class="p">()</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">OK</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<hr />

<h2 id="8-complexity-analysis">8. Complexity Analysis</h2>

<p>Let (N = len(height)).</p>

<ul>
  <li><strong>Brute force</strong>: (O(N^2)) time, (O(1)) space</li>
  <li><strong>Prefix/suffix DP</strong>: (O(N)) time, (O(N)) space</li>
  <li><strong>Two pointers</strong>: (O(N)) time, (O(1)) space</li>
  <li><strong>Monotonic stack</strong>: (O(N)) time, (O(N)) space</li>
</ul>

<hr />

<h2 id="9-production-considerations">9. Production Considerations</h2>

<h3 id="91-what-this-pattern-teaches">9.1 What this pattern teaches</h3>

<p>The two-pointer solution is about maintaining a small set of invariants while shrinking the search space:</p>
<ul>
  <li>left boundary maximum</li>
  <li>right boundary maximum</li>
  <li>and a rule that lets you finalize one side each step</li>
</ul>

<p>That “finalize safely with partial information” mindset is exactly what you want in high-scale systems:</p>
<ul>
  <li>streaming computations</li>
  <li>anomaly detection thresholds (finalize alerts based on safe bounds)</li>
  <li>long-context agents (finalize summaries and constraints, keep bounded state)</li>
</ul>

<h3 id="92-numerical-stability-and-data-types">9.2 Numerical stability and data types</h3>
<p>If heights are large, use a type that won’t overflow in languages like Java/C++ (use 64-bit).
In Python you’re safe.</p>

<h3 id="93-visual-debugging-tip">9.3 Visual debugging tip</h3>
<p>If you’re debugging, plot the array and track <code class="language-plaintext highlighter-rouge">(l, r, left_max, right_max)</code> each step.
Most bugs are “wrong invariant update”.</p>

<h3 id="94-a-proof-style-intuition-why-finalize-one-side-is-safe">9.4 A proof-style intuition (why “finalize one side” is safe)</h3>

<p>The two-pointer algorithm feels almost magical until you internalize the proof idea:</p>

<ul>
  <li>When <code class="language-plaintext highlighter-rouge">height[l] &lt;= height[r]</code>, there exists a right boundary at least as tall as <code class="language-plaintext highlighter-rouge">height[l]</code> (the bar at <code class="language-plaintext highlighter-rouge">r</code> itself).</li>
  <li>But the <em>actual</em> limiting boundary for <code class="language-plaintext highlighter-rouge">l</code> is the maximum on the left, <code class="language-plaintext highlighter-rouge">left_max</code>, compared against the best available boundary on the right.</li>
  <li>If we move left-to-right maintaining <code class="language-plaintext highlighter-rouge">left_max</code>, and we know the right side has “enough wall” to not be the bottleneck (because <code class="language-plaintext highlighter-rouge">height[r]</code> is already &gt;= <code class="language-plaintext highlighter-rouge">height[l]</code>), then any future right walls can only be higher; they cannot reduce the amount of water <code class="language-plaintext highlighter-rouge">l</code> can hold.</li>
</ul>

<p>So water at <code class="language-plaintext highlighter-rouge">l</code> can be computed immediately as:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">left_max - height[l]</code> if positive</li>
</ul>

<p>Symmetrically, when <code class="language-plaintext highlighter-rouge">height[r] &lt; height[l]</code>, finalize the right side with <code class="language-plaintext highlighter-rouge">right_max</code>.</p>

<p>This is a common proof pattern:</p>
<blockquote>
  <p>If you can show the unknown future cannot reduce your computed value, you are safe to finalize now.</p>
</blockquote>

<h3 id="95-follow-up-2d-trapping-rain-water-what-changes">9.5 Follow-up: 2D trapping rain water (what changes)</h3>

<p>Interviewers sometimes ask about the 2D variant (“Trapping Rain Water II”).
The core change:</p>
<ul>
  <li>boundaries are not just left/right; they are in 4 directions</li>
  <li>the right tool becomes a <strong>min-heap (priority queue)</strong> seeded with boundary cells</li>
  <li>you expand inward like Dijkstra:
    <ul>
      <li>the current boundary height determines how much water a neighbor can hold</li>
    </ul>
  </li>
</ul>

<p>The shared theme is still boundary invariants:</p>
<ul>
  <li>in 1D you maintain two boundary maxima</li>
  <li>in 2D you maintain the minimum boundary around the explored region via a heap</li>
</ul>

<p>Mentioning this shows you understand the deeper principle, not just the 1D trick.</p>

<h3 id="96-engineering-checklist-if-you-were-reviewing-this-code">9.6 Engineering checklist (if you were reviewing this code)</h3>

<p>If this logic is in a production code path (analytics, simulation, or interview platform), review:</p>

<ul>
  <li><strong>Inputs</strong>
    <ul>
      <li>empty list returns 0</li>
      <li>non-negative heights (if negatives allowed, define behavior explicitly)</li>
    </ul>
  </li>
  <li><strong>Invariants</strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">left_max</code> is updated before accumulating water at <code class="language-plaintext highlighter-rouge">l</code></li>
      <li><code class="language-plaintext highlighter-rouge">right_max</code> is updated before accumulating water at <code class="language-plaintext highlighter-rouge">r</code></li>
      <li>pointer movement is consistent on ties</li>
    </ul>
  </li>
  <li><strong>Complexity</strong>
    <ul>
      <li>one pass only (no nested loops accidentally introduced)</li>
      <li>constant extra memory</li>
    </ul>
  </li>
  <li><strong>Correctness sanity</strong>
    <ul>
      <li>water is never negative</li>
      <li>output fits in 64-bit for worst-case constraints in typed languages</li>
    </ul>
  </li>
</ul>

<p>This is a good practice for any invariant-heavy algorithm: write down the invariants you rely on and ensure the code matches them.</p>

<h3 id="97-relationship-to-monotonic-stack-problems">9.7 Relationship to “monotonic stack” problems</h3>

<p>It’s worth recognizing that “Trapping Rain Water” sits in a family:</p>
<ul>
  <li><strong>Largest Rectangle in Histogram</strong>: stack to find nearest smaller bars</li>
  <li><strong>Next Greater Element</strong>: stack for boundary discovery</li>
  <li><strong>Trapping Rain Water</strong>: stack for basin closure</li>
</ul>

<p>Learning these together is efficient because the same stack invariants reappear.</p>

<hr />

<h2 id="10-connections-to-ml-systems">10. Connections to ML Systems</h2>

<p>Today’s shared theme is <strong>pattern recognition</strong>:</p>
<ul>
  <li>Here, the “pattern” is the boundary rule that determines water.</li>
  <li>In anomaly detection, the “pattern” is normal behavior and deviations.</li>
  <li>In speech anomaly detection, the “pattern” is stable acoustics; anomalies are dropouts, clipping, or distribution shifts.</li>
  <li>In long-context agent strategies, the “pattern” is which information remains relevant over long horizons (summaries + constraints) and which can be compressed.</li>
</ul>

<p>If you can solve “Trapping Rain Water” cleanly, it’s usually a sign you’re good at:</p>
<ul>
  <li>identifying invariants</li>
  <li>avoiding unnecessary simulation</li>
  <li>reducing a problem to a small boundary state</li>
</ul>

<hr />

<h2 id="11-interview-strategy">11. Interview Strategy</h2>

<ol>
  <li>Start from the per-index formula with <code class="language-plaintext highlighter-rouge">maxLeft</code> and <code class="language-plaintext highlighter-rouge">maxRight</code>.</li>
  <li>Offer the DP precompute solution quickly.</li>
  <li>Then derive why two pointers can finalize one side at a time (the key invariant).</li>
  <li>Mention monotonic stack as an alternative (O(N)) approach.</li>
</ol>

<p>Common mistakes:</p>
<ul>
  <li>mixing conditions (<code class="language-plaintext highlighter-rouge">height[l] &lt;= height[r]</code> vs <code class="language-plaintext highlighter-rouge">left_max &lt;= right_max</code>) without consistent updates</li>
  <li>forgetting to update <code class="language-plaintext highlighter-rouge">left_max/right_max</code> before computing trapped water</li>
  <li>off-by-one in stack width calculations</li>
</ul>

<h3 id="111-the-explain-like-im-debugging-move">11.1 The “explain like I’m debugging” move</h3>

<p>If the interviewer pushes on correctness, don’t hand-wave.
Use the boundary argument:</p>
<ul>
  <li>“When I move the left pointer, I’m asserting the right boundary is not the bottleneck.”</li>
  <li>“So the only thing that matters is the best left boundary so far (<code class="language-plaintext highlighter-rouge">left_max</code>).”</li>
  <li>“That’s why I can finalize water at this position and never revisit it.”</li>
</ul>

<p>This style of explanation is often what differentiates a correct solution from an excellent interview performance.</p>

<h3 id="112-common-follow-ups">11.2 Common follow-ups</h3>

<ul>
  <li><strong>“Can you do it in one pass without extra arrays?”</strong>
    <ul>
      <li>Yes: the two-pointer approach you implemented.</li>
    </ul>
  </li>
  <li><strong>“How would you extend this to 2D?”</strong>
    <ul>
      <li>Use a min-heap seeded with boundary cells; expand inward (Dijkstra-like).</li>
    </ul>
  </li>
  <li><strong>“What’s the relationship to monotonic stacks?”</strong>
    <ul>
      <li>Both find boundaries efficiently; the stack explicitly finds “basins”.</li>
    </ul>
  </li>
</ul>

<hr />

<h2 id="12-key-takeaways">12. Key Takeaways</h2>

<ol>
  <li><strong>Water at i is bounded by left/right maxima</strong>: the formula is everything.</li>
  <li><strong>Two pointers work because the smaller boundary decides</strong>: finalize one side safely.</li>
  <li><strong>This is invariant-based thinking</strong>: compress a global phenomenon into a tiny state machine.</li>
</ol>

<h3 id="121-one-sentence-invariant">12.1 One-sentence invariant</h3>

<p>At every step:</p>
<ul>
  <li>maintain <code class="language-plaintext highlighter-rouge">left_max</code> and <code class="language-plaintext highlighter-rouge">right_max</code> as boundary maxima</li>
  <li>compute water on the side with the smaller boundary</li>
  <li>move that pointer inward</li>
</ul>

<p>That’s the whole algorithm.</p>

<h3 id="122-appendix-a-compact-cheat-sheet-what-to-remember">12.2 Appendix: a compact cheat sheet (what to remember)</h3>

<p>If you want a quick “mental card” for this problem:</p>

<ul>
  <li><strong>Core formula</strong>
    <ul>
      <li>(water[i] = \max(0, \min(maxLeft[i], maxRight[i]) - height[i]))</li>
    </ul>
  </li>
  <li><strong>DP arrays</strong>
    <ul>
      <li>compute <code class="language-plaintext highlighter-rouge">left_max[]</code> prefix maxima</li>
      <li>compute <code class="language-plaintext highlighter-rouge">right_max[]</code> suffix maxima</li>
      <li>single pass to sum water</li>
    </ul>
  </li>
  <li><strong>Two pointers</strong>
    <ul>
      <li>maintain <code class="language-plaintext highlighter-rouge">left_max</code>, <code class="language-plaintext highlighter-rouge">right_max</code></li>
      <li>move the pointer on the side that is guaranteed to be bounded</li>
      <li>finalize water for that pointer immediately</li>
    </ul>
  </li>
  <li><strong>Monotonic stack</strong>
    <ul>
      <li>maintain decreasing stack of indices</li>
      <li>when you see a higher bar, pop “bottom” and compute:
        <ul>
          <li>width = <code class="language-plaintext highlighter-rouge">i - left - 1</code></li>
          <li>bounded_height = <code class="language-plaintext highlighter-rouge">min(height[left], height[i]) - height[bottom]</code></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="123-appendix-practice-variants-that-reuse-the-same-ideas">12.3 Appendix: practice variants that reuse the same ideas</h3>

<p>These problems reuse the same “boundary/invariant” thinking:</p>
<ul>
  <li>“Container With Most Water” (two pointers, lower boundary dominates)</li>
  <li>“Largest Rectangle in Histogram” (monotonic stack, boundary discovery)</li>
  <li>“Trapping Rain Water II” (min-heap boundary expansion in 2D)</li>
</ul>

<p>If you learn them as a group, you build a reusable toolkit:</p>
<ul>
  <li>boundary maxima</li>
  <li>monotonic stacks</li>
  <li>priority-queue boundary expansion</li>
</ul>

<h3 id="124-appendix-what-to-say-if-asked-why-not-simulate">12.4 Appendix: what to say if asked “why not simulate?”</h3>

<p>A crisp answer:</p>
<blockquote>
  <p>Simulation is expensive and unnecessary. The final water level is determined by boundaries; once you know the boundaries, you can compute the result directly.</p>
</blockquote>

<p>That’s the same mindset that scales in systems engineering:</p>
<ul>
  <li>compute summaries and invariants</li>
  <li>avoid materializing everything</li>
  <li>finalize results when future information can’t change them</li>
</ul>

<h3 id="125-appendix-sketch-of-the-2d-solution-what-youd-say-in-an-interview">12.5 Appendix: sketch of the 2D solution (what you’d say in an interview)</h3>

<p>For the 2D variant (“Trapping Rain Water II”), left/right maxima don’t apply.
Instead, you treat the outer boundary as the initial “wall” and expand inward:</p>

<ol>
  <li>Push all boundary cells into a <strong>min-heap</strong> keyed by height.</li>
  <li>Mark them visited.</li>
  <li>Pop the smallest boundary cell.</li>
  <li>For each neighbor not visited:
    <ul>
      <li>if neighbor height is lower, it holds <code class="language-plaintext highlighter-rouge">boundary_height - neighbor_height</code> water</li>
      <li>push neighbor with effective height <code class="language-plaintext highlighter-rouge">max(neighbor_height, boundary_height)</code></li>
    </ul>
  </li>
  <li>Repeat until all cells are visited.</li>
</ol>

<p>Why it works:</p>
<ul>
  <li>you always expand from the currently lowest boundary, so you never “miss” a leak path</li>
  <li>the heap stores the best known boundary height for the frontier</li>
</ul>

<p>Complexity:</p>
<ul>
  <li>(O(MN \log(MN))) time for an (M \times N) grid</li>
  <li>(O(MN)) space for visited + heap</li>
</ul>

<h3 id="126-appendix-choosing-between-two-pointers-and-stack-how-to-decide">12.6 Appendix: choosing between two pointers and stack (how to decide)</h3>

<p>If you’re writing production code:</p>
<ul>
  <li>choose <strong>two pointers</strong> for simplicity and minimal memory</li>
  <li>choose <strong>stack</strong> if you also need explicit basin boundaries for downstream logic</li>
</ul>

<p>In interviews:</p>
<ul>
  <li>two pointers is usually the best default answer</li>
  <li>stack is a strong “alternative” mention that shows breadth</li>
</ul>

<h3 id="127-appendix-rapid-fire-interview-qa">12.7 Appendix: rapid-fire interview Q&amp;A</h3>

<ul>
  <li>
    <p><strong>Q: Why is the time O(N) for the two-pointer method?</strong><br />
<strong>A:</strong> Each pointer moves inward at most <code class="language-plaintext highlighter-rouge">N</code> times total; no index is revisited.</p>
  </li>
  <li>
    <p><strong>Q: Why do we only need the smaller boundary?</strong><br />
<strong>A:</strong> Water level is capped by the minimum of left and right boundaries; if one side is already the bottleneck, the other side’s exact future cannot reduce the computed water.</p>
  </li>
  <li>
    <p><strong>Q: What happens with flat plateaus?</strong><br />
<strong>A:</strong> Plateaus are fine. The algorithm treats equal heights consistently; choose a tie rule and stick to it.</p>
  </li>
  <li>
    <p><strong>Q: Can heights be negative?</strong><br />
<strong>A:</strong> The classic problem assumes non-negative. If negatives are allowed, you must define semantics (negative bars imply “below ground”), and the formula still works, but test expectations must be clarified.</p>
  </li>
  <li>
    <p><strong>Q: When would you prefer DP arrays?</strong><br />
<strong>A:</strong> When code clarity matters more than memory (small <code class="language-plaintext highlighter-rouge">N</code>, or memory is cheap), or when you want explicit <code class="language-plaintext highlighter-rouge">left_max/right_max</code> arrays for debugging/visualization.</p>
  </li>
</ul>

<h3 id="128-appendix-the-one-mistake-to-avoid">12.8 Appendix: the one mistake to avoid</h3>

<p>The most common bug in two pointers is updating the max after adding water (wrong order).
Always:</p>
<ul>
  <li>update the boundary max first</li>
  <li>then accumulate <code class="language-plaintext highlighter-rouge">max - height[i]</code> if positive</li>
</ul>

<p>If you follow that ordering, the algorithm becomes hard to break.</p>

<h3 id="129-appendix-quick-complexity-intuition-why-on-is-optimal">12.9 Appendix: quick complexity intuition (why O(N) is optimal)</h3>

<p>In the comparison model, you must at least look at each bar once to know whether it contributes to trapped water.
So (\Omega(N)) is a natural lower bound.</p>

<p>Two pointers (and stack) reach this lower bound:</p>
<ul>
  <li>each index is processed a constant number of times</li>
  <li>no nested scanning</li>
</ul>

<p>This is another reason the problem is popular:
it rewards the ability to transform a naive (O(N^2)) process (“scan left and right for every i”) into an optimal linear pass by recognizing the right invariant.</p>

<h3 id="1210-appendix-explain-it-to-production-in-one-paragraph">12.10 Appendix: “explain it to production” in one paragraph</h3>

<p>If someone asks why this algorithm is safe in production:</p>
<ul>
  <li>It processes each input element once (linear time), so it scales to large arrays.</li>
  <li>It uses constant extra memory, so it behaves well under memory pressure.</li>
  <li>The correctness is driven by explicit invariants (<code class="language-plaintext highlighter-rouge">left_max</code>, <code class="language-plaintext highlighter-rouge">right_max</code> and “smaller boundary decides”), which are easy to test and reason about.</li>
  <li>It’s also easy to validate via differential testing against the DP baseline on randomized inputs, which catches subtle bugs quickly.</li>
</ul>

<p>This is exactly the kind of algorithm you want in real systems: predictable, bounded, and testable.</p>

<h3 id="1211-appendix-micro-optimizations-rarely-needed-but-good-to-know">12.11 Appendix: micro-optimizations (rarely needed, but good to know)</h3>

<p>In Python, this is already fast enough for typical constraints. In lower-level languages or extremely hot loops:</p>
<ul>
  <li>use integer types with enough headroom (64-bit for the accumulator)</li>
  <li>avoid repeated min/max computations inside tight loops where possible</li>
  <li>prefer simple branching over complex conditionals for branch predictability</li>
</ul>

<p>Most of the time, the “optimization” that matters is algorithmic:
choosing O(N) two pointers over O(N^2) scanning.</p>

<h3 id="1212-appendix-one-more-way-to-sanity-check-results">12.12 Appendix: one more way to sanity-check results</h3>

<p>A simple correctness sanity check:</p>
<ul>
  <li>If you reverse the array, the trapped water should be the same.</li>
</ul>

<p>Reason:
the physics and boundary logic are symmetric under reversal.</p>

<p>So in testing, you can assert:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">trap(height) == trap(list(reversed(height)))</code></li>
</ul>

<p>This isn’t a proof, but it’s a strong “cheap invariant” that catches some implementation bugs.</p>

<hr />

<p><strong>Originally published at:</strong> <a href="https://www.arunbaby.com/dsa/0052-trapping-rain-water/">arunbaby.com/dsa/0052-trapping-rain-water</a></p>

<p><em>If you found this helpful, consider sharing it with others who might benefit.</em></p>


        
      </section>

      <footer class="page__meta">
        
        
  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-tags" aria-hidden="true"></i> Tags: </strong>
    <span itemprop="keywords">
    
      <a href="/tags/#arrays" class="page__taxonomy-item p-category" rel="tag">arrays</a><span class="sep">, </span>
    
      <a href="/tags/#hard" class="page__taxonomy-item p-category" rel="tag">hard</a><span class="sep">, </span>
    
      <a href="/tags/#monotonic-stack" class="page__taxonomy-item p-category" rel="tag">monotonic-stack</a><span class="sep">, </span>
    
      <a href="/tags/#pattern-recognition" class="page__taxonomy-item p-category" rel="tag">pattern-recognition</a><span class="sep">, </span>
    
      <a href="/tags/#prefix-max" class="page__taxonomy-item p-category" rel="tag">prefix-max</a><span class="sep">, </span>
    
      <a href="/tags/#two-pointers" class="page__taxonomy-item p-category" rel="tag">two-pointers</a>
    
    </span>
  </p>




  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> Categories: </strong>
    <span itemprop="keywords">
    
      <a href="/categories/#dsa" class="page__taxonomy-item p-category" rel="tag">dsa</a>
    
    </span>
  </p>


        
      </footer>

      <div class="page__related page__related--full">
  <h2 class="page__related-title">Related across topics</h2>
  <style>
    /* Make section span full content width and use 2 equal columns */
    .page__related--full { float: inline-start; width: 100%; padding: 0; }
    .cross-related-grid { display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 2rem; }
    @media (max-width: 768px) { .cross-related-grid { grid-template-columns: 1fr; } }
    /* Ensure archive cards stretch nicely in the grid */
    .cross-related-grid .list__item, .cross-related-grid .grid__item { width: auto; float: none; margin: 0; }
  </style>
  <div class="cross-related-grid">
    



<div class="list__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/dsa/0052-trapping-rain-water/" rel="permalink">Trapping Rain Water
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          22 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">“Water doesn’t care about every bar—only the highest walls to the left and right.”
</p>
  </article>
</div>




<div class="list__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/ml-system-design/0052-anomaly-detection/" rel="permalink">Anomaly Detection
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          22 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">“Anomaly detection is trapping rain water for metrics: find the boundaries of ‘normal’ and measure what overflows.”
</p>
  </article>
</div>




<div class="list__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/speech-tech/0052-speech-anomaly-detection/" rel="permalink">Speech Anomaly Detection
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          22 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">“If ASR is the brain, anomaly detection is the nervous system—it tells you when the audio reality changed.”
</p>
  </article>
</div>




<div class="list__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/ai-agents/0052-long-context-agent-strategies/" rel="permalink">Long-Context Agent Strategies
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          22 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">“Long context isn’t ‘more tokens’—it’s a strategy for keeping the right boundaries of information.”
</p>
  </article>
</div>

  </div>
</div>

      <section class="page__share">
  <h4 class="page__share-title">Share on</h4>

  <a href="https://twitter.com/intent/tweet?via=arunbaby0&text=Trapping+Rain+Water%20https%3A%2F%2Fwww.arunbaby.com%2Fdsa%2F0052-trapping-rain-water%2F" class="btn btn--twitter" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Twitter"><i class="fab fa-fw fa-twitter" aria-hidden="true"></i><span> Twitter</span></a>

  <a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fwww.arunbaby.com%2Fdsa%2F0052-trapping-rain-water%2F" class="btn btn--facebook" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Facebook"><i class="fab fa-fw fa-facebook" aria-hidden="true"></i><span> Facebook</span></a>

  <a href="https://www.linkedin.com/shareArticle?mini=true&url=https://www.arunbaby.com/dsa/0052-trapping-rain-water/" class="btn btn--linkedin" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on LinkedIn"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i><span> LinkedIn</span></a>
</section>


      
  <nav class="pagination">
    
      <a href="/dsa/0051-median-of-two-sorted-arrays/" class="pagination--pager" title="Median of Two Sorted Arrays">Previous</a>
    
    
      <a href="/dsa/0053-first-missing-positive/" class="pagination--pager" title="First Missing Positive">Next</a>
    
  </nav>


    </div>

    
  </article>

  
  
</div>

      
    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';" role="search">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Enter your search term..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    

    
      
        
          <li><a href="https://twitter.com/arunbaby0" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-twitter-square" aria-hidden="true"></i> Twitter</a></li>
        
      
        
          <li><a href="https://github.com/arunbaby0" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
        
      
        
          <li><a href="https://www.linkedin.com/in/arunbaby0/" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i> LinkedIn</a></li>
        
      
        
          <li><a href="https://scholar.google.co.in/citations?user=6fSYWhkAAAAJ" rel="nofollow noopener noreferrer"><i class="fas fa-fw fa-graduation-cap" aria-hidden="true"></i> Google Scholar</a></li>
        
      
    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 1990 - 2143 <a href="https://www.arunbaby.com">Arun Baby</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>




  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-0JRJPEC9SS"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-0JRJPEC9SS', { 'anonymize_ip': false});
</script>








  </body>
</html>
