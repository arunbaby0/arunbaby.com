<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.26.2 by Michael Rose
  Copyright 2013-2024 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->

<html lang="en-US" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Longest Increasing Subsequence (LIS) - Arun Baby</title>
<meta name="description" content="“Finding the longest upward trend in chaos.”">


  <meta name="author" content="Arun Baby">
  
  <meta property="article:author" content="Arun Baby">
  


<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="Arun Baby">
<meta property="og:title" content="Longest Increasing Subsequence (LIS)">
<meta property="og:url" content="https://www.arunbaby.com/dsa/0037-longest-increasing-subsequence/">


  <meta property="og:description" content="“Finding the longest upward trend in chaos.”">



  <meta property="og:image" content="https://www.arunbaby.com/assets/images/profile-photo.png">



  <meta name="twitter:site" content="@arunbaby0">
  <meta name="twitter:title" content="Longest Increasing Subsequence (LIS)">
  <meta name="twitter:description" content="“Finding the longest upward trend in chaos.”">
  <meta name="twitter:url" content="https://www.arunbaby.com/dsa/0037-longest-increasing-subsequence/">

  
    <meta name="twitter:card" content="summary">
    
      <meta name="twitter:image" content="https://www.arunbaby.com/assets/images/profile-photo.png">
    
  

  



  <meta property="article:published_time" content="2025-12-31T09:51:02+05:30">





  

  


<link rel="canonical" href="https://www.arunbaby.com/dsa/0037-longest-increasing-subsequence/">












<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Arun Baby Feed">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
  
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css"></noscript>



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--single" dir="ltr">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
           
          <span class="site-subtitle">Arun Baby</span>
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a
                href="/about/"
                
                
              >About</a>
            </li><li class="masthead__menu-item">
              <a
                href="/dsa/"
                
                
              >DSA</a>
            </li><li class="masthead__menu-item">
              <a
                href="/ml-system-design/"
                
                
              >ML Systems</a>
            </li><li class="masthead__menu-item">
              <a
                href="/speech-tech/"
                
                
              >Speech Tech</a>
            </li><li class="masthead__menu-item">
              <a
                href="/ai-agents/"
                
                
              >AI Agents</a>
            </li><li class="masthead__menu-item">
              <a
                href="/publications/"
                
                
              >Publications</a>
            </li><li class="masthead__menu-item">
              <a
                href="/statuses/"
                
                
              >Statuses</a>
            </li><li class="masthead__menu-item">
              <a
                href="/contact/"
                
                
              >Contact</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <i class="fas fa-search"></i>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      





<div id="main" role="main" class="no-author-sidebar">
  
  <div class="sidebar sticky">
  
  
  </div>



  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="Longest Increasing Subsequence (LIS)">
    <meta itemprop="description" content="“Finding the longest upward trend in chaos.”">
    <meta itemprop="datePublished" content="2025-12-31T09:51:02+05:30">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">
            <a href="https://www.arunbaby.com/dsa/0037-longest-increasing-subsequence/" itemprop="url">Longest Increasing Subsequence (LIS)
</a>
          </h1>
          

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          17 minute read
        
      </span>
    
  </p>


        </header>
      

      <section class="page__content" itemprop="text">
        
          <aside class="sidebar__right sticky">
            <nav class="toc">
              <header><h4 class="nav__title"><i class="fas fa-file-alt"></i> On this page</h4></header>
              <ul class="toc__menu"><li><a href="#1-problem-statement">1. Problem Statement</a></li><li><a href="#2-approach-1-dynamic-programming-on2">2. Approach 1: Dynamic Programming O(N^2)</a></li><li><a href="#3-approach-2-binary-search--greedy-on-log-n">3. Approach 2: Binary Search + Greedy O(N \log N)</a></li><li><a href="#4-deep-dive-patience-sorting">4. Deep Dive: Patience Sorting</a></li><li><a href="#5-reconstructing-the-lis">5. Reconstructing the LIS</a></li><li><a href="#6-variations">6. Variations</a></li><li><a href="#7-summary">7. Summary</a></li><li><a href="#8-deep-dive-why-binary-search-works">8. Deep Dive: Why Binary Search Works</a></li><li><a href="#9-deep-dive-longest-decreasing-subsequence">9. Deep Dive: Longest Decreasing Subsequence</a></li><li><a href="#10-deep-dive-number-of-lis-leetcode-673">10. Deep Dive: Number of LIS (LeetCode 673)</a></li><li><a href="#11-deep-dive-russian-doll-envelopes-leetcode-354">11. Deep Dive: Russian Doll Envelopes (LeetCode 354)</a></li><li><a href="#12-deep-dive-lis-with-segment-tree">12. Deep Dive: LIS with Segment Tree</a></li><li><a href="#13-real-world-applications">13. Real-World Applications</a><ul><li><a href="#1-version-control-git">1. Version Control (Git)</a></li><li><a href="#2-stock-trading">2. Stock Trading</a></li><li><a href="#3-bioinformatics">3. Bioinformatics</a></li></ul></li><li><a href="#14-code-lis-with-all-solutions">14. Code: LIS with All Solutions</a></li><li><a href="#15-interview-pro-tips">15. Interview Pro Tips</a></li><li><a href="#16-performance-comparison">16. Performance Comparison</a></li><li><a href="#17-deep-dive-connection-to-longest-common-subsequence-lcs">17. Deep Dive: Connection to Longest Common Subsequence (LCS)</a></li><li><a href="#18-deep-dive-dilworths-theorem-and-chain-decomposition">18. Deep Dive: Dilworth’s Theorem and Chain Decomposition</a></li><li><a href="#19-advanced-lis-in-on-log-log-n">19. Advanced: LIS in O(N \log \log N)</a></li><li><a href="#20-case-study-dna-sequence-alignment">20. Case Study: DNA Sequence Alignment</a></li><li><a href="#21-system-design-real-time-anomaly-detection">21. System Design: Real-Time Anomaly Detection</a></li><li><a href="#22-common-mistakes-and-pitfalls">22. Common Mistakes and Pitfalls</a></li><li><a href="#23-ethical-considerations">23. Ethical Considerations</a></li><li><a href="#24-production-optimization-lis-at-scale">24. Production Optimization: LIS at Scale</a></li><li><a href="#25-advanced-variants-and-extensions">25. Advanced Variants and Extensions</a></li><li><a href="#26-complexity-analysis-deep-dive">26. Complexity Analysis Deep Dive</a></li><li><a href="#27-further-reading">27. Further Reading</a></li><li><a href="#28-conclusion">28. Conclusion</a></li><li><a href="#29-summary">29. Summary</a></li></ul>
            </nav>
          </aside>
        
        <p><strong>“Finding the longest upward trend in chaos.”</strong></p>

<h2 id="1-problem-statement">1. Problem Statement</h2>

<p>Given an integer array <code class="language-plaintext highlighter-rouge">nums</code>, return the length of the longest strictly increasing subsequence.</p>

<p>A <strong>subsequence</strong> is a sequence derived from an array by deleting some or no elements without changing the order of the remaining elements.</p>

<p><strong>Example 1:</strong>
<code class="language-plaintext highlighter-rouge">
Input: nums = [10, 9, 2, 5, 3, 7, 101, 18]
Output: 4
Explanation: The longest increasing subsequence is [2, 3, 7, 101], length = 4.
</code></p>

<p><strong>Example 2:</strong>
<code class="language-plaintext highlighter-rouge">
Input: nums = [0, 1, 0, 3, 2, 3]
Output: 4
Explanation: [0, 1, 2, 3]
</code></p>

<h2 id="2-approach-1-dynamic-programming-on2">2. Approach 1: Dynamic Programming O(N^2)</h2>

<p><strong>Intuition:</strong></p>
<ul>
  <li>Let <code class="language-plaintext highlighter-rouge">dp[i]</code> = length of LIS ending at index <code class="language-plaintext highlighter-rouge">i</code>.</li>
  <li>For each <code class="language-plaintext highlighter-rouge">i</code>, look at all previous elements <code class="language-plaintext highlighter-rouge">j &lt; i</code>.</li>
  <li>If <code class="language-plaintext highlighter-rouge">nums[j] &lt; nums[i]</code>, we can extend the LIS ending at <code class="language-plaintext highlighter-rouge">j</code> by including <code class="language-plaintext highlighter-rouge">nums[i]</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">dp[i] = max(dp[j] + 1)</code> for all valid <code class="language-plaintext highlighter-rouge">j</code>.</li>
</ul>

<p>``python
class Solution:
 def lengthOfLIS(self, nums: List[int]) -&gt; int:
 if not nums: return 0
 n = len(nums)
 dp = [1] * n # Every element is an LIS of length 1</p>

<p>for i in range(1, n):
 for j in range(i):
 if nums[j] &lt; nums[i]:
 dp[i] = max(dp[i], dp[j] + 1)</p>

<p>return max(dp)
``</p>

<p><strong>Complexity:</strong></p>
<ul>
  <li><strong>Time:</strong> O(N^2)</li>
  <li><strong>Space:</strong> O(N)</li>
</ul>

<h2 id="3-approach-2-binary-search--greedy-on-log-n">3. Approach 2: Binary Search + Greedy O(N \log N)</h2>

<p><strong>Key Insight:</strong></p>
<ul>
  <li>Maintain an array <code class="language-plaintext highlighter-rouge">tails</code> where <code class="language-plaintext highlighter-rouge">tails[i]</code> is the smallest tail element of all increasing subsequences of length <code class="language-plaintext highlighter-rouge">i+1</code>.</li>
  <li>For each new number, use binary search to find where it fits.</li>
</ul>

<p><strong>Why does this work?</strong></p>
<ul>
  <li>If we want to build a longer LIS, we should keep the tail as small as possible.</li>
  <li>Example: <code class="language-plaintext highlighter-rouge">[4, 5, 6, 3]</code></li>
  <li>After processing <code class="language-plaintext highlighter-rouge">[4, 5, 6]</code>, <code class="language-plaintext highlighter-rouge">tails = [4, 5, 6]</code>.</li>
  <li>When we see <code class="language-plaintext highlighter-rouge">3</code>, we replace <code class="language-plaintext highlighter-rouge">4</code> with <code class="language-plaintext highlighter-rouge">3</code> → <code class="language-plaintext highlighter-rouge">tails = [3, 5, 6]</code>.</li>
  <li>Now if we see <code class="language-plaintext highlighter-rouge">[3, 4, 7]</code>, we can build <code class="language-plaintext highlighter-rouge">[3, 4, 7]</code> (length 3), which wouldn’t be possible if we kept <code class="language-plaintext highlighter-rouge">4</code>.</li>
</ul>

<p>``python
import bisect</p>

<p>class Solution:
 def lengthOfLIS(self, nums: List[int]) -&gt; int:
 tails = []</p>

<p>for num in nums:
 # Find the leftmost position where num can be placed
 pos = bisect.bisect_left(tails, num)</p>

<p>if pos == len(tails):
 tails.append(num) # Extend the LIS
 else:
 tails[pos] = num # Replace to keep tail small</p>

<p>return len(tails)
``</p>

<p><strong>Complexity:</strong></p>
<ul>
  <li><strong>Time:</strong> O(N \log N)</li>
  <li><strong>Space:</strong> O(N)</li>
</ul>

<h2 id="4-deep-dive-patience-sorting">4. Deep Dive: Patience Sorting</h2>

<p>The binary search approach is actually <strong>Patience Sorting</strong>, a card game strategy.</p>

<p><strong>Game Rules:</strong></p>
<ol>
  <li>Deal cards one by one.</li>
  <li>Place each card on the leftmost pile where it’s smaller than the top card.</li>
  <li>If no such pile exists, start a new pile.</li>
</ol>

<p><strong>Connection to LIS:</strong></p>
<ul>
  <li>Number of piles = Length of LIS.</li>
  <li>The cards in each pile form a decreasing sequence (top to bottom).</li>
  <li>The top cards of all piles form an increasing sequence.</li>
</ul>

<h2 id="5-reconstructing-the-lis">5. Reconstructing the LIS</h2>

<p>The binary search approach only gives the <strong>length</strong>. To get the actual sequence:</p>

<p>``python
def findLIS(nums):
 n = len(nums)
 tails = []
 parent = [-1] * n # Track predecessor
 tail_indices = [] # Track which index contributes to each tail</p>

<p>for i, num in enumerate(nums):
 pos = bisect.bisect_left(tails, num)</p>

<p>if pos == len(tails):
 tails.append(num)
 tail_indices.append(i)
 else:
 tails[pos] = num
 tail_indices[pos] = i</p>

<p># Set parent
 if pos &gt; 0:
 parent[i] = tail_indices[pos - 1]</p>

<p># Backtrack to reconstruct LIS
 lis = []
 k = tail_indices[-1]
 while k != -1:
 lis.append(nums[k])
 k = parent[k]</p>

<p>return lis[::-1]
``</p>

<h2 id="6-variations">6. Variations</h2>

<p><strong>1. Number of LIS (LeetCode 673)</strong></p>
<ul>
  <li>Count how many LIS exist.</li>
  <li>Modify DP to track <code class="language-plaintext highlighter-rouge">count[i]</code> = number of LIS ending at <code class="language-plaintext highlighter-rouge">i</code>.</li>
</ul>

<p><strong>2. Longest Divisible Subset (LeetCode 368)</strong></p>
<ul>
  <li>Same DP, but condition is <code class="language-plaintext highlighter-rouge">nums[i] % nums[j] == 0</code>.</li>
</ul>

<p><strong>3. Russian Doll Envelopes (LeetCode 354)</strong></p>
<ul>
  <li>2D LIS. Sort by width, then find LIS by height.</li>
</ul>

<h2 id="7-summary">7. Summary</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: left">Approach</th>
      <th style="text-align: left">Time</th>
      <th style="text-align: left">Space</th>
      <th style="text-align: left">Notes</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left"><strong>DP</strong></td>
      <td style="text-align: left">O(N^2)</td>
      <td style="text-align: left">O(N)</td>
      <td style="text-align: left">Simple, easy to extend</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>Binary Search</strong></td>
      <td style="text-align: left">O(N \log N)</td>
      <td style="text-align: left">O(N)</td>
      <td style="text-align: left">Optimal for length only</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>Patience Sort</strong></td>
      <td style="text-align: left">O(N \log N)</td>
      <td style="text-align: left">O(N)</td>
      <td style="text-align: left">Same as Binary Search</td>
    </tr>
  </tbody>
</table>

<h2 id="8-deep-dive-why-binary-search-works">8. Deep Dive: Why Binary Search Works</h2>

<p>The <code class="language-plaintext highlighter-rouge">tails</code> array has a crucial property: <strong>it is always sorted</strong>.</p>

<p><strong>Proof by Induction:</strong></p>
<ol>
  <li><strong>Base Case:</strong> After first element, <code class="language-plaintext highlighter-rouge">tails = [nums[0]]</code>. Sorted ✓</li>
  <li><strong>Inductive Step:</strong> Assume <code class="language-plaintext highlighter-rouge">tails</code> is sorted before processing <code class="language-plaintext highlighter-rouge">nums[i]</code>.
    <ul>
      <li>We find position <code class="language-plaintext highlighter-rouge">pos</code> using <code class="language-plaintext highlighter-rouge">bisect_left</code>.</li>
      <li>If <code class="language-plaintext highlighter-rouge">pos == len(tails)</code>, we append (still sorted).</li>
      <li>If <code class="language-plaintext highlighter-rouge">pos &lt; len(tails)</code>, we replace <code class="language-plaintext highlighter-rouge">tails[pos]</code> with <code class="language-plaintext highlighter-rouge">nums[i]</code>.</li>
      <li>Since <code class="language-plaintext highlighter-rouge">bisect_left</code> finds the leftmost position where <code class="language-plaintext highlighter-rouge">nums[i]</code> fits, we have:</li>
      <li><code class="language-plaintext highlighter-rouge">tails[pos-1] &lt; nums[i]</code> (if <code class="language-plaintext highlighter-rouge">pos &gt; 0</code>)</li>
      <li><code class="language-plaintext highlighter-rouge">tails[pos] &gt;= nums[i]</code></li>
      <li>After replacement: <code class="language-plaintext highlighter-rouge">tails[pos-1] &lt; nums[i] &lt;= tails[pos+1]</code></li>
      <li>Still sorted ✓</li>
    </ul>
  </li>
</ol>

<h2 id="9-deep-dive-longest-decreasing-subsequence">9. Deep Dive: Longest Decreasing Subsequence</h2>

<p><strong>Problem:</strong> Find the longest <strong>decreasing</strong> subsequence.</p>

<p><strong>Solution 1:</strong> Reverse the condition in DP.
<code class="language-plaintext highlighter-rouge">python
for i in range(1, n):
 for j in range(i):
 if nums[j] &gt; nums[i]: # Changed from &lt;
 dp[i] = max(dp[i], dp[j] + 1)
</code></p>

<p><strong>Solution 2:</strong> Negate all numbers and find LIS.</p>
<ul>
  <li>LIS of <code class="language-plaintext highlighter-rouge">[-10, -9, -2, -5]</code> is the LDS of <code class="language-plaintext highlighter-rouge">[10, 9, 2, 5]</code>.</li>
</ul>

<h2 id="10-deep-dive-number-of-lis-leetcode-673">10. Deep Dive: Number of LIS (LeetCode 673)</h2>

<p><strong>Problem:</strong> Count how many different LIS exist.</p>

<p><strong>Approach:</strong> Extend DP to track counts.
``python
def findNumberOfLIS(nums):
 n = len(nums)
 dp = [1] * n # Length of LIS ending at i
 count = [1] * n # Number of LIS ending at i</p>

<p>for i in range(1, n):
 for j in range(i):
 if nums[j] &lt; nums[i]:
 if dp[j] + 1 &gt; dp[i]:
 # Found a longer LIS
 dp[i] = dp[j] + 1
 count[i] = count[j]
 elif dp[j] + 1 == dp[i]:
 # Found another LIS of same length
 count[i] += count[j]</p>

<p>max_len = max(dp)
 return sum(c for l, c in zip(dp, count) if l == max_len)
``</p>

<h2 id="11-deep-dive-russian-doll-envelopes-leetcode-354">11. Deep Dive: Russian Doll Envelopes (LeetCode 354)</h2>

<p><strong>Problem:</strong> You have envelopes <code class="language-plaintext highlighter-rouge">(w, h)</code>. An envelope can fit into another if both width and height are strictly greater. Find max nesting.</p>

<p><strong>Insight:</strong> This is 2D LIS.</p>
<ol>
  <li>Sort by width ascending, height <strong>descending</strong> (crucial!).</li>
  <li>Find LIS on heights.</li>
</ol>

<p><strong>Why descending height?</strong></p>
<ul>
  <li>If two envelopes have the same width, they can’t nest.</li>
  <li>By sorting height descending, we ensure they won’t be in the same LIS.</li>
</ul>

<p>``python
def maxEnvelopes(envelopes):
 # Sort by width asc, height desc
 envelopes.sort(key=lambda x: (x[0], -x[1]))</p>

<p># Extract heights
 heights = [h for w, h in envelopes]</p>

<p># Find LIS on heights
 return lengthOfLIS(heights)
``</p>

<h2 id="12-deep-dive-lis-with-segment-tree">12. Deep Dive: LIS with Segment Tree</h2>

<p>For advanced problems, we might need to query “What’s the longest LIS in range <code class="language-plaintext highlighter-rouge">[L, R]</code>?”</p>

<p><strong>Data Structure:</strong> Segment Tree where each node stores the LIS length for its range.</p>

<p><strong>Update:</strong> When adding a new element, update all affected nodes.</p>

<p><strong>Complexity:</strong> O(N \log N) per update.</p>

<h2 id="13-real-world-applications">13. Real-World Applications</h2>

<h3 id="1-version-control-git">1. Version Control (Git)</h3>
<ul>
  <li><strong>Longest Common Subsequence (LCS)</strong> is related to LIS.</li>
  <li>Git uses LCS to find minimal diffs between file versions.</li>
</ul>

<h3 id="2-stock-trading">2. Stock Trading</h3>
<ul>
  <li>Find the longest period of increasing stock prices.</li>
  <li>Helps identify bull markets.</li>
</ul>

<h3 id="3-bioinformatics">3. Bioinformatics</h3>
<ul>
  <li>DNA sequence alignment.</li>
  <li>Find longest matching subsequence between two genomes.</li>
</ul>

<h2 id="14-code-lis-with-all-solutions">14. Code: LIS with All Solutions</h2>

<p>Sometimes we need all possible LIS, not just one.</p>

<p>``python
def allLIS(nums):
 n = len(nums)
 dp = [1] * n</p>

<p># Find LIS length
 for i in range(1, n):
 for j in range(i):
 if nums[j] &lt; nums[i]:
 dp[i] = max(dp[i], dp[j] + 1)</p>

<p>max_len = max(dp)</p>

<p># Backtrack to find all LIS
 def backtrack(index, current_lis, last_val):
 if len(current_lis) == max_len:
 result.append(current_lis[:])
 return</p>

<p>for i in range(index, n):
 if nums[i] &gt; last_val and dp[i] == max_len - len(current_lis):
 current_lis.append(nums[i])
 backtrack(i + 1, current_lis, nums[i])
 current_lis.pop()</p>

<p>result = []
 backtrack(0, [], float(‘-inf’))
 return result
``</p>

<h2 id="15-interview-pro-tips">15. Interview Pro Tips</h2>

<ol>
  <li><strong>Recognize the Pattern:</strong> “Longest”, “Increasing”, “Subsequence” → Think LIS.</li>
  <li><strong>Start with DP:</strong> Always explain the O(N^2) solution first.</li>
  <li><strong>Optimize:</strong> Mention binary search for O(N \log N).</li>
  <li><strong>Variants:</strong> Be ready to adapt (decreasing, 2D, count).</li>
  <li><strong>Reconstruction:</strong> Know how to print the actual sequence.</li>
</ol>

<h2 id="16-performance-comparison">16. Performance Comparison</h2>

<p><strong>Benchmark:</strong> <code class="language-plaintext highlighter-rouge">N = 10,000</code> random integers.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">Approach</th>
      <th style="text-align: left">Python Time</th>
      <th style="text-align: left">C++ Time</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left"><strong>DP O(N^2)</strong></td>
      <td style="text-align: left">2.5s</td>
      <td style="text-align: left">150ms</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>Binary Search</strong></td>
      <td style="text-align: left">15ms</td>
      <td style="text-align: left">2ms</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>Segment Tree</strong></td>
      <td style="text-align: left">50ms</td>
      <td style="text-align: left">8ms</td>
    </tr>
  </tbody>
</table>

<p><strong>Takeaway:</strong> Binary search is the clear winner for standard LIS.</p>

<h2 id="17-deep-dive-connection-to-longest-common-subsequence-lcs">17. Deep Dive: Connection to Longest Common Subsequence (LCS)</h2>

<p><strong>Insight:</strong> LIS can be reduced to LCS.</p>

<p><strong>Algorithm:</strong></p>
<ol>
  <li>Make a copy of <code class="language-plaintext highlighter-rouge">nums</code> and sort it: <code class="language-plaintext highlighter-rouge">sorted_nums</code>.</li>
  <li>Remove duplicates from <code class="language-plaintext highlighter-rouge">sorted_nums</code>.</li>
  <li>Find the <strong>Longest Common Subsequence</strong> between <code class="language-plaintext highlighter-rouge">nums</code> and <code class="language-plaintext highlighter-rouge">sorted_nums</code>.</li>
</ol>

<p><strong>Why?</strong></p>
<ul>
  <li>LCS finds the longest sequence that appears in both arrays in the same relative order.</li>
  <li>Since <code class="language-plaintext highlighter-rouge">sorted_nums</code> is strictly increasing, any common subsequence must also be strictly increasing.</li>
  <li>Thus, LCS(<code class="language-plaintext highlighter-rouge">nums</code>, <code class="language-plaintext highlighter-rouge">sorted_nums</code>) == LIS(<code class="language-plaintext highlighter-rouge">nums</code>).</li>
</ul>

<p><strong>Complexity:</strong></p>
<ul>
  <li>Sorting: O(N \log N).</li>
  <li>LCS: O(N^2).</li>
  <li>Total: O(N^2).</li>
  <li><strong>Note:</strong> This is slower than the Binary Search approach (O(N \log N)), but it’s a powerful theoretical connection.</li>
</ul>

<h2 id="18-deep-dive-dilworths-theorem-and-chain-decomposition">18. Deep Dive: Dilworth’s Theorem and Chain Decomposition</h2>

<p><strong>Concept:</strong></p>
<ul>
  <li><strong>Chain:</strong> A subset of elements where every pair is comparable (e.g., an increasing subsequence).</li>
  <li><strong>Antichain:</strong> A subset where <em>no</em> pair is comparable (e.g., a decreasing subsequence, if we define order as increasing).</li>
</ul>

<p><strong>Dilworth’s Theorem:</strong>
“The minimum number of chains needed to cover a partially ordered set is equal to the maximum size of an antichain.”</p>

<p><strong>Application to LIS:</strong></p>
<ul>
  <li>The length of the <strong>Longest Increasing Subsequence</strong> is equal to the minimum number of <strong>Decreasing Subsequences</strong> needed to cover the array.</li>
</ul>

<p><strong>Example:</strong> <code class="language-plaintext highlighter-rouge">[10, 9, 2, 5, 3, 7, 101, 18]</code></p>
<ul>
  <li>LIS: <code class="language-plaintext highlighter-rouge">[2, 3, 7, 18]</code> (Length 4).</li>
  <li>Decreasing Subsequences Cover:
    <ol>
      <li><code class="language-plaintext highlighter-rouge">[10, 9, 5, 3]</code></li>
      <li><code class="language-plaintext highlighter-rouge">[2]</code></li>
      <li><code class="language-plaintext highlighter-rouge">[7]</code></li>
      <li><code class="language-plaintext highlighter-rouge">[101, 18]</code></li>
    </ol>
  </li>
  <li>We needed 4 decreasing subsequences.</li>
</ul>

<p><strong>Algorithm (Patience Sorting again!):</strong></p>
<ul>
  <li>When we place a card on a pile in Patience Sorting, we are essentially extending a decreasing subsequence (the pile).</li>
  <li>The number of piles is the length of the LIS.</li>
  <li>This is a constructive proof of the dual of Dilworth’s Theorem for sequences.</li>
</ul>

<h2 id="19-advanced-lis-in-on-log-log-n">19. Advanced: LIS in O(N \log \log N)</h2>

<p>Can we beat O(N \log N)?</p>
<ul>
  <li>In the comparison model, NO. Lower bound is <code class="language-plaintext highlighter-rouge">\Omega(N \log N)</code>.</li>
  <li>But if numbers are integers in range <code class="language-plaintext highlighter-rouge">[1, U]</code>, we can use <strong>Van Emde Boas Trees</strong>.</li>
</ul>

<p><strong>Algorithm:</strong></p>
<ol>
  <li>Replace the Binary Search (which takes O(\log N)) with a vEB Tree predecessor query.</li>
  <li>vEB Tree supports <code class="language-plaintext highlighter-rouge">predecessor</code> in O(\log \log U).</li>
  <li>Total Time: O(N \log \log U).</li>
</ol>

<p><strong>Practicality:</strong></p>
<ul>
  <li>vEB trees have huge constant factors and memory overhead.</li>
  <li>Only useful if <code class="language-plaintext highlighter-rouge">U</code> is huge but fits in machine word.</li>
  <li>For standard competitive programming, O(N \log N) is sufficient.</li>
</ul>

<h2 id="20-case-study-dna-sequence-alignment">20. Case Study: DNA Sequence Alignment</h2>

<p><strong>Problem:</strong> Align two DNA sequences <code class="language-plaintext highlighter-rouge">A</code> and <code class="language-plaintext highlighter-rouge">B</code> to find regions of similarity.</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">A = ACGTCG</code></li>
  <li><code class="language-plaintext highlighter-rouge">B = ATCG</code></li>
</ul>

<p><strong>MUMmer (Maximal Unique Matches):</strong></p>
<ul>
  <li>A popular bioinformatics tool uses LIS to align genomes.
    <ol>
      <li>Find all <strong>Maximal Unique Matches</strong> (substrings that appear exactly once in both A and B).</li>
      <li>Each match can be represented as a point <code class="language-plaintext highlighter-rouge">(pos_A, pos_B)</code>.</li>
      <li>We want to find the largest subset of matches that are “consistent” (appear in the same order).</li>
      <li>This is exactly finding the <strong>LIS</strong> of the <code class="language-plaintext highlighter-rouge">pos_B</code> coordinates when sorted by <code class="language-plaintext highlighter-rouge">pos_A</code>.</li>
    </ol>
  </li>
</ul>

<p><strong>Scale:</strong></p>
<ul>
  <li>Genomes have billions of base pairs.</li>
  <li>O(N^2) is impossible.</li>
  <li>O(N \log N) LIS is critical for aligning human genomes.</li>
</ul>

<h2 id="21-system-design-real-time-anomaly-detection">21. System Design: Real-Time Anomaly Detection</h2>

<p><strong>Scenario:</strong> Monitoring server CPU usage.</p>
<ul>
  <li>Stream: <code class="language-plaintext highlighter-rouge">[10%, 12%, 15%, 80%, 85%, 90%...]</code></li>
  <li>Goal: Detect a “sustained upward trend” (LIS length &gt; <code class="language-plaintext highlighter-rouge">K</code>) in a sliding window.</li>
</ul>

<p><strong>Naive Approach:</strong></p>
<ul>
  <li>Run O(N \log N) LIS on every window.</li>
  <li>Window size <code class="language-plaintext highlighter-rouge">W=1000</code>.</li>
  <li>Cost: O(W \log W) per new data point. Expensive.</li>
</ul>

<p><strong>Optimized Approach (Incremental LIS):</strong></p>
<ul>
  <li>Maintain the <code class="language-plaintext highlighter-rouge">tails</code> array.</li>
  <li>When a new element arrives, update <code class="language-plaintext highlighter-rouge">tails</code> (O(\log W)).</li>
  <li>When an old element leaves, it’s harder (deletion from LIS is tricky).</li>
  <li><strong>Approximation:</strong> Use <strong>Trend Filtering</strong> (e.g., Hodrick-Prescott filter) or simple exponential moving average, but LIS provides a robust, non-parametric metric for “monotonicity”.</li>
</ul>

<h2 id="22-common-mistakes-and-pitfalls">22. Common Mistakes and Pitfalls</h2>

<p><strong>1. Confusing Subsequence with Subarray:</strong></p>
<ul>
  <li><strong>Subarray:</strong> Contiguous (e.g., <code class="language-plaintext highlighter-rouge">[2, 5, 3]</code> in <code class="language-plaintext highlighter-rouge">[1, 2, 5, 3, 7]</code>).</li>
  <li><strong>Subsequence:</strong> Non-contiguous (e.g., <code class="language-plaintext highlighter-rouge">[2, 3, 7]</code>).</li>
  <li><strong>Fix:</strong> Clarify with interviewer immediately.</li>
</ul>

<p><strong>2. Incorrect Reconstruction:</strong></p>
<ul>
  <li><em>Mistake:</em> Just printing the <code class="language-plaintext highlighter-rouge">tails</code> array.</li>
  <li><em>Fact:</em> <code class="language-plaintext highlighter-rouge">tails</code> is NOT the LIS. It stores the <em>smallest tail</em> for each length.</li>
  <li><em>Example:</em> <code class="language-plaintext highlighter-rouge">[1, 5, 2]</code>. <code class="language-plaintext highlighter-rouge">tails</code> becomes <code class="language-plaintext highlighter-rouge">[1, 2]</code>. Real LIS is <code class="language-plaintext highlighter-rouge">[1, 5]</code> or <code class="language-plaintext highlighter-rouge">[1, 2]</code>. But if input is <code class="language-plaintext highlighter-rouge">[1, 5, 2, 3]</code>, <code class="language-plaintext highlighter-rouge">tails</code> is <code class="language-plaintext highlighter-rouge">[1, 2, 3]</code>. The <code class="language-plaintext highlighter-rouge">2</code> overwrote <code class="language-plaintext highlighter-rouge">5</code>.</li>
  <li><em>Fix:</em> Use the <code class="language-plaintext highlighter-rouge">parent</code> array backtracking method.</li>
</ul>

<p><strong>3. Not Handling Duplicates:</strong></p>
<ul>
  <li>“Strictly increasing” vs “Non-decreasing”.</li>
  <li>Strictly: <code class="language-plaintext highlighter-rouge">nums[j] &lt; nums[i]</code>.</li>
  <li>Non-decreasing: <code class="language-plaintext highlighter-rouge">nums[j] &lt;= nums[i]</code>.</li>
  <li>Binary Search: Use <code class="language-plaintext highlighter-rouge">bisect_right</code> for non-decreasing.</li>
</ul>

<p><strong>4. 2D LIS Sorting Order:</strong></p>
<ul>
  <li>For envelopes <code class="language-plaintext highlighter-rouge">(w, h)</code>, sorting <code class="language-plaintext highlighter-rouge">w</code> ascending and <code class="language-plaintext highlighter-rouge">h</code> <strong>ascending</strong> is wrong.</li>
  <li><em>Why?</em> <code class="language-plaintext highlighter-rouge">[2, 3]</code> and <code class="language-plaintext highlighter-rouge">[2, 4]</code>. If sorted ascending, we might pick both. But <code class="language-plaintext highlighter-rouge">[2, 3]</code> cannot fit into <code class="language-plaintext highlighter-rouge">[2, 4]</code> (width must be strictly greater).</li>
  <li><em>Fix:</em> Sort <code class="language-plaintext highlighter-rouge">w</code> ascending, <code class="language-plaintext highlighter-rouge">h</code> <strong>descending</strong>.</li>
</ul>

<h2 id="23-ethical-considerations">23. Ethical Considerations</h2>

<p><strong>1. Algorithmic Trading:</strong></p>
<ul>
  <li>HFT firms use LIS-like algorithms to detect micro-trends.</li>
  <li><strong>Risk:</strong> Flash crashes caused by automated feedback loops.</li>
  <li><strong>Regulation:</strong> Circuit breakers in stock exchanges.</li>
</ul>

<p><strong>2. Genomic Privacy:</strong></p>
<ul>
  <li>Fast alignment (using LIS) enables rapid DNA identification.</li>
  <li><strong>Risk:</strong> Re-identifying individuals from “anonymized” genetic data.</li>
  <li><strong>Policy:</strong> Strict access controls on biobanks.</li>
</ul>

<h2 id="24-production-optimization-lis-at-scale">24. Production Optimization: LIS at Scale</h2>

<p><strong>Scenario:</strong> Process 1 billion stock price sequences to find longest upward trends.</p>

<p><strong>Challenges:</strong></p>
<ol>
  <li><strong>Memory:</strong> Cannot store 1B sequences in RAM.</li>
  <li><strong>Latency:</strong> Need results in real-time for trading decisions.</li>
</ol>

<p><strong>Architecture:</strong></p>

<p><strong>1. Streaming LIS:</strong>
``python
class StreamingLIS:
 def <strong>init</strong>(self):
 self.tails = []
 self.max_length = 0</p>

<p>def add(self, num):
 “"”Add number to stream and update LIS”””
 pos = bisect.bisect_left(self.tails, num)</p>

<p>if pos == len(self.tails):
 self.tails.append(num)
 self.max_length = len(self.tails)
 else:
 self.tails[pos] = num</p>

<p>return self.max_length</p>

<p>def reset(self):
 “"”Reset for new sequence”””
 self.tails = []
 self.max_length = 0
``</p>

<p><strong>2. Batch Processing with MapReduce:</strong>
``python
from multiprocessing import Pool</p>

<p>def compute_lis_parallel(sequences):
 “"”Process multiple sequences in parallel”””
 with Pool() as pool:
 results = pool.map(lengthOfLIS, sequences)
 return results</p>

<h1 id="usage">Usage</h1>
<p>sequences = [
 [10, 9, 2, 5, 3, 7, 101, 18],
 [0, 1, 0, 3, 2, 3],
 # … millions more
]
lengths = compute_lis_parallel(sequences)
``</p>

<p><strong>3. GPU Acceleration (CUDA):</strong>
``cpp
<strong>global</strong> void lis_kernel(int* sequences, int* results, int n_seq, int seq_len) {
 int idx = blockIdx.x * blockDim.x + threadIdx.x;
 if (idx &gt;= n_seq) return;</p>

<p>int* seq = sequences + idx * seq_len;
 int tails[1000]; // Max LIS length
 int len = 0;</p>

<p>for (int i = 0; i &lt; seq_len; i++) {
 // Binary search
 int left = 0, right = len;
 while (left &lt; right) {
 int mid = (left + right) / 2;
 if (tails[mid] &lt; seq[i]) left = mid + 1;
 else right = mid;
 }</p>

<p>tails[left] = seq[i];
 if (left == len) len++;
 }</p>

<p>results[idx] = len;
}
``</p>

<h2 id="25-advanced-variants-and-extensions">25. Advanced Variants and Extensions</h2>

<p><strong>1. Longest Bitonic Subsequence:</strong></p>
<ul>
  <li>A sequence that first increases, then decreases.</li>
  <li>Example: <code class="language-plaintext highlighter-rouge">[1, 11, 2, 10, 4, 5, 2, 1]</code> → <code class="language-plaintext highlighter-rouge">[1, 2, 10, 4, 2, 1]</code> (length 6).</li>
</ul>

<p><strong>Algorithm:</strong>
``python
def longestBitonicSubsequence(nums):
 n = len(nums)</p>

<p># LIS ending at i
 lis = [1] * n
 for i in range(1, n):
 for j in range(i):
 if nums[j] &lt; nums[i]:
 lis[i] = max(lis[i], lis[j] + 1)</p>

<p># LDS starting at i
 lds = [1] * n
 for i in range(n - 2, -1, -1):
 for j in range(i + 1, n):
 if nums[j] &lt; nums[i]:
 lds[i] = max(lds[i], lds[j] + 1)</p>

<p># Max of lis[i] + lds[i] - 1
 return max(lis[i] + lds[i] - 1 for i in range(n))
``</p>

<p><strong>2. Longest Alternating Subsequence:</strong></p>
<ul>
  <li>Elements alternate between increasing and decreasing.</li>
  <li>Example: <code class="language-plaintext highlighter-rouge">[1, 5, 3, 8, 6, 9]</code> → <code class="language-plaintext highlighter-rouge">[1, 5, 3, 8, 6, 9]</code> (length 6).</li>
</ul>

<p><strong>3. K-Increasing Subsequence:</strong></p>
<ul>
  <li>Find <code class="language-plaintext highlighter-rouge">k</code> disjoint increasing subsequences that cover the array.</li>
  <li>This is equivalent to partitioning into <code class="language-plaintext highlighter-rouge">k</code> chains (Dilworth’s Theorem).</li>
</ul>

<p><strong>4. Weighted LIS:</strong></p>
<ul>
  <li>Each element has a value and weight.</li>
  <li>Maximize sum of values in an increasing subsequence.</li>
</ul>

<p>``python
def weightedLIS(nums, weights):
 n = len(nums)
 dp = [0] * n # Max weight ending at i</p>

<p>for i in range(n):
 dp[i] = weights[i] # At least include itself
 for j in range(i):
 if nums[j] &lt; nums[i]:
 dp[i] = max(dp[i], dp[j] + weights[i])</p>

<p>return max(dp)
``</p>

<h2 id="26-complexity-analysis-deep-dive">26. Complexity Analysis Deep Dive</h2>

<p><strong>Why is Binary Search O(N \log N) optimal?</strong></p>

<p><strong>Lower Bound Proof (Comparison Model):</strong></p>
<ul>
  <li>Any comparison-based algorithm must distinguish between <code class="language-plaintext highlighter-rouge">2^N</code> possible permutations.</li>
  <li>Decision tree has <code class="language-plaintext highlighter-rouge">2^N</code> leaves.</li>
  <li>Height of tree is <code class="language-plaintext highlighter-rouge">\Omega(N \log N)</code>.</li>
  <li><strong>BUT:</strong> LIS doesn’t need to sort, so this doesn’t directly apply.</li>
</ul>

<p><strong>Actual Lower Bound:</strong></p>
<ul>
  <li>Fredman (1975) proved <code class="language-plaintext highlighter-rouge">\Omega(N \log \log N)</code> lower bound for LIS in comparison model.</li>
  <li>No known algorithm achieves this.</li>
  <li>O(N \log N) is the best known.</li>
</ul>

<p><strong>Integer LIS (when values are bounded):</strong></p>
<ul>
  <li>If values are in <code class="language-plaintext highlighter-rouge">[1, U]</code>, we can use <strong>Van Emde Boas trees</strong>.</li>
  <li>Complexity: O(N \log \log U).</li>
  <li>Practical only for small <code class="language-plaintext highlighter-rouge">U</code>.</li>
</ul>

<h2 id="27-further-reading">27. Further Reading</h2>

<ol>
  <li><strong>“Introduction to Algorithms” (CLRS):</strong> Chapter on Dynamic Programming.</li>
  <li><strong>“Patience Sorting” (Wikipedia):</strong> The card game connection.</li>
  <li><strong>“Hunt-Szymanski Algorithm”:</strong> <code class="language-plaintext highlighter-rouge">O((R+N) \log N)</code> algorithm for LCS, which uses LIS.</li>
  <li><strong>“Dilworth’s Theorem”:</strong> Order theory foundations.</li>
</ol>

<h2 id="28-conclusion">28. Conclusion</h2>

<p>Longest Increasing Subsequence is a gem of a problem. It starts as a standard DP exercise (O(N^2)), transforms into a greedy binary search puzzle (O(N \log N)), connects to card games (Patience Sorting), and finds applications in everything from reading DNA to predicting stock markets. Mastering LIS means understanding the trade-off between <strong>optimality</strong> (DP) and <strong>efficiency</strong> (Greedy+Binary Search), a core skill for any systems engineer.</p>

<h2 id="29-summary">29. Summary</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: left">Approach</th>
      <th style="text-align: left">Time</th>
      <th style="text-align: left">Space</th>
      <th style="text-align: left">Notes</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left"><strong>DP</strong></td>
      <td style="text-align: left">O(N^2)</td>
      <td style="text-align: left">O(N)</td>
      <td style="text-align: left">Simple, easy to extend</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>Binary Search</strong></td>
      <td style="text-align: left">O(N \log N)</td>
      <td style="text-align: left">O(N)</td>
      <td style="text-align: left">Optimal for length only</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>Patience Sort</strong></td>
      <td style="text-align: left">O(N \log N)</td>
      <td style="text-align: left">O(N)</td>
      <td style="text-align: left">Same as Binary Search</td>
    </tr>
  </tbody>
</table>

<hr />

<p><strong>Originally published at:</strong> <a href="https://www.arunbaby.com/dsa/0037-longest-increasing-subsequence/">arunbaby.com/dsa/0037-longest-increasing-subsequence</a></p>

        
      </section>

      <footer class="page__meta">
        
        
  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-tags" aria-hidden="true"></i> Tags: </strong>
    <span itemprop="keywords">
    
      <a href="/tags/#binary-search" class="page__taxonomy-item p-category" rel="tag">binary-search</a><span class="sep">, </span>
    
      <a href="/tags/#dynamic-programming" class="page__taxonomy-item p-category" rel="tag">dynamic-programming</a><span class="sep">, </span>
    
      <a href="/tags/#greedy" class="page__taxonomy-item p-category" rel="tag">greedy</a><span class="sep">, </span>
    
      <a href="/tags/#patience-sorting" class="page__taxonomy-item p-category" rel="tag">patience-sorting</a>
    
    </span>
  </p>




  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> Categories: </strong>
    <span itemprop="keywords">
    
      <a href="/categories/#dsa" class="page__taxonomy-item p-category" rel="tag">dsa</a>
    
    </span>
  </p>


        
      </footer>

      <div class="page__related page__related--full">
  <h2 class="page__related-title">Related across topics</h2>
  <style>
    /* Make section span full content width and use 2 equal columns */
    .page__related--full { float: inline-start; width: 100%; padding: 0; }
    .cross-related-grid { display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 2rem; }
    @media (max-width: 768px) { .cross-related-grid { grid-template-columns: 1fr; } }
    /* Ensure archive cards stretch nicely in the grid */
    .cross-related-grid .list__item, .cross-related-grid .grid__item { width: auto; float: none; margin: 0; }
  </style>
  <div class="cross-related-grid">
    



<div class="list__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/ml-system-design/0037-sequence-modeling/" rel="permalink">Sequence Modeling in ML
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          16 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">“Predicting the next word, the next stock price, the next frame.”
</p>
  </article>
</div>




<div class="list__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/speech-tech/0037-sequence-to-sequence-speech/" rel="permalink">Sequence-to-Sequence Speech Models
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          18 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">“From waveforms to words, and back again.”
</p>
  </article>
</div>




<div class="list__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/ai-agents/0037-code-execution-agents/" rel="permalink">Code Execution Agents
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          18 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">“Let agents run code safely: sandbox execution, cap damage, and verify outputs like a production system.”
</p>
  </article>
</div>

  </div>
</div>

      <section class="page__share">
  <h4 class="page__share-title">Share on</h4>

  <a href="https://twitter.com/intent/tweet?via=arunbaby0&text=Longest+Increasing+Subsequence+%28LIS%29%20https%3A%2F%2Fwww.arunbaby.com%2Fdsa%2F0037-longest-increasing-subsequence%2F" class="btn btn--twitter" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Twitter"><i class="fab fa-fw fa-twitter" aria-hidden="true"></i><span> Twitter</span></a>

  <a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fwww.arunbaby.com%2Fdsa%2F0037-longest-increasing-subsequence%2F" class="btn btn--facebook" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Facebook"><i class="fab fa-fw fa-facebook" aria-hidden="true"></i><span> Facebook</span></a>

  <a href="https://www.linkedin.com/shareArticle?mini=true&url=https://www.arunbaby.com/dsa/0037-longest-increasing-subsequence/" class="btn btn--linkedin" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on LinkedIn"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i><span> LinkedIn</span></a>
</section>


      
  <nav class="pagination">
    
      <a href="/dsa/0036-partition-equal-subset-sum/" class="pagination--pager" title="Partition Equal Subset Sum">Previous</a>
    
    
      <a href="/dsa/0038-coin-change/" class="pagination--pager" title="Coin Change (Unbounded Knapsack)">Next</a>
    
  </nav>


    </div>

    
  </article>

  
  
</div>

      
    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';" role="search">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Enter your search term..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    

    
      
        
          <li><a href="https://twitter.com/arunbaby0" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-twitter-square" aria-hidden="true"></i> Twitter</a></li>
        
      
        
          <li><a href="https://github.com/arunbaby0" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
        
      
        
          <li><a href="https://www.linkedin.com/in/arunbaby0/" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i> LinkedIn</a></li>
        
      
        
          <li><a href="https://scholar.google.co.in/citations?user=6fSYWhkAAAAJ" rel="nofollow noopener noreferrer"><i class="fas fa-fw fa-graduation-cap" aria-hidden="true"></i> Google Scholar</a></li>
        
      
    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 1990 - 2143 <a href="https://www.arunbaby.com">Arun Baby</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>




  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-0JRJPEC9SS"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-0JRJPEC9SS', { 'anonymize_ip': false});
</script>








  </body>
</html>
