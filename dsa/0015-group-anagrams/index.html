<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.26.2 by Michael Rose
  Copyright 2013-2024 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->

<html lang="en-US" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Group Anagrams - Arun Baby</title>
<meta name="description" content="Master hash-based grouping to solve anagramsâ€”the foundation of clustering systems and speaker diarization in production ML.">


  <meta name="author" content="Arun Baby">
  
  <meta property="article:author" content="Arun Baby">
  


<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="Arun Baby">
<meta property="og:title" content="Group Anagrams">
<meta property="og:url" content="https://www.arunbaby.com/dsa/0015-group-anagrams/">


  <meta property="og:description" content="Master hash-based grouping to solve anagramsâ€”the foundation of clustering systems and speaker diarization in production ML.">



  <meta property="og:image" content="https://www.arunbaby.com/assets/images/profile-photo.png">



  <meta name="twitter:site" content="@arunbaby0">
  <meta name="twitter:title" content="Group Anagrams">
  <meta name="twitter:description" content="Master hash-based grouping to solve anagramsâ€”the foundation of clustering systems and speaker diarization in production ML.">
  <meta name="twitter:url" content="https://www.arunbaby.com/dsa/0015-group-anagrams/">

  
    <meta name="twitter:card" content="summary">
    
      <meta name="twitter:image" content="https://www.arunbaby.com/assets/images/profile-photo.png">
    
  

  



  <meta property="article:published_time" content="2025-12-31T10:08:45+05:30">





  

  


<link rel="canonical" href="https://www.arunbaby.com/dsa/0015-group-anagrams/">












<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Arun Baby Feed">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
  
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css"></noscript>



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--single" dir="ltr">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
           
          <span class="site-subtitle">Arun Baby</span>
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a
                href="/about/"
                
                
              >About</a>
            </li><li class="masthead__menu-item">
              <a
                href="/dsa/"
                
                
              >DSA</a>
            </li><li class="masthead__menu-item">
              <a
                href="/ml-system-design/"
                
                
              >ML Systems</a>
            </li><li class="masthead__menu-item">
              <a
                href="/speech-tech/"
                
                
              >Speech Tech</a>
            </li><li class="masthead__menu-item">
              <a
                href="/ai-agents/"
                
                
              >AI Agents</a>
            </li><li class="masthead__menu-item">
              <a
                href="/publications/"
                
                
              >Publications</a>
            </li><li class="masthead__menu-item">
              <a
                href="/statuses/"
                
                
              >Statuses</a>
            </li><li class="masthead__menu-item">
              <a
                href="/contact/"
                
                
              >Contact</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <i class="fas fa-search"></i>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      





<div id="main" role="main" class="no-author-sidebar">
  
  <div class="sidebar sticky">
  
  
  </div>



  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="Group Anagrams">
    <meta itemprop="description" content="Master hash-based grouping to solve anagramsâ€”the foundation of clustering systems and speaker diarization in production ML.">
    <meta itemprop="datePublished" content="2025-12-31T10:08:45+05:30">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">
            <a href="https://www.arunbaby.com/dsa/0015-group-anagrams/" itemprop="url">Group Anagrams
</a>
          </h1>
          

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          24 minute read
        
      </span>
    
  </p>


        </header>
      

      <section class="page__content" itemprop="text">
        
          <aside class="sidebar__right sticky">
            <nav class="toc">
              <header><h4 class="nav__title"><i class="fas fa-file-alt"></i> On this page</h4></header>
              <ul class="toc__menu"><li><a href="#problem-statement">Problem Statement</a><ul><li><a href="#examples">Examples</a></li><li><a href="#constraints">Constraints</a></li></ul></li><li><a href="#understanding-the-problem">Understanding the Problem</a><ul><li><a href="#what-are-anagrams">What Are Anagrams?</a></li><li><a href="#key-insight">Key Insight</a></li><li><a href="#why-this-problem-matters">Why This Problem Matters</a></li><li><a href="#the-clustering-connection">The Clustering Connection</a></li></ul></li><li><a href="#approach-1-brute-force---compare-all-pairs">Approach 1: Brute Force - Compare All Pairs</a><ul><li><a href="#intuition">Intuition</a></li><li><a href="#implementation">Implementation</a></li><li><a href="#analysis">Analysis</a></li></ul></li><li><a href="#approach-2-sorting-as-hash-key-standard-solution">Approach 2: Sorting as Hash Key (Standard Solution)</a><ul><li><a href="#the-key-insight">The Key Insight</a></li><li><a href="#implementation-1">Implementation</a></li><li><a href="#step-by-step-visualization">Step-by-Step Visualization</a></li></ul></li><li><a href="#approach-3-character-count-as-hash-key-optimal-for-large-k">Approach 3: Character Count as Hash Key (Optimal for Large K)</a><ul><li><a href="#alternative-hash-key">Alternative Hash Key</a></li><li><a href="#implementation-2">Implementation</a></li><li><a href="#character-count-visualization">Character Count Visualization</a></li></ul></li><li><a href="#implementation-production-grade-solution">Implementation: Production-Grade Solution</a></li><li><a href="#testing">Testing</a><ul><li><a href="#comprehensive-test-suite">Comprehensive Test Suite</a></li></ul></li><li><a href="#complexity-analysis">Complexity Analysis</a><ul><li><a href="#sorting-approach">Sorting Approach</a></li><li><a href="#character-count-approach">Character Count Approach</a></li><li><a href="#comparison">Comparison</a></li></ul></li><li><a href="#production-considerations">Production Considerations</a><ul><li><a href="#1-unicode-support">1. Unicode Support</a></li><li><a href="#2-case-insensitive-grouping">2. Case-Insensitive Grouping</a></li><li><a href="#3-streaming--online-grouping">3. Streaming / Online Grouping</a></li><li><a href="#4-performance-monitoring">4. Performance Monitoring</a></li></ul></li><li><a href="#connections-to-ml-systems">Connections to ML Systems</a><ul><li><a href="#1-clustering-systems">1. Clustering Systems</a></li><li><a href="#2-duplicate-detection">2. Duplicate Detection</a></li><li><a href="#3-feature-hashing">3. Feature Hashing</a></li><li><a href="#key-parallels">Key Parallels</a></li></ul></li><li><a href="#interview-strategy">Interview Strategy</a><ul><li><a href="#how-to-approach-in-an-interview">How to Approach in an Interview</a></li><li><a href="#common-mistakes">Common Mistakes</a></li><li><a href="#follow-up-questions">Follow-up Questions</a></li></ul></li><li><a href="#key-takeaways">Key Takeaways</a><ul><li><a href="#mental-model">Mental Model</a></li></ul></li><li><a href="#additional-practice--variants">Additional Practice &amp; Variants</a></li></ul>
            </nav>
          </aside>
        
        <p><strong>Master hash-based grouping to solve anagramsâ€”the foundation of clustering systems and speaker diarization in production ML.</strong></p>

<h2 id="problem-statement">Problem Statement</h2>

<p>Given an array of strings <code class="language-plaintext highlighter-rouge">strs</code>, group the <strong>anagrams</strong> together. You can return the answer in <strong>any order</strong>.</p>

<p>An <strong>anagram</strong> is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.</p>

<h3 id="examples">Examples</h3>

<p><strong>Example 1:</strong>
<code class="language-plaintext highlighter-rouge">
Input: strs = ["eat","tea","tan","ate","nat","bat"]
Output: [["bat"],["nat","tan"],["ate","eat","tea"]]
</code></p>

<p><strong>Example 2:</strong>
<code class="language-plaintext highlighter-rouge">
Input: strs = [""]
Output: [[""]]
</code></p>

<p><strong>Example 3:</strong>
<code class="language-plaintext highlighter-rouge">
Input: strs = ["a"]
Output: [["a"]]
</code></p>

<h3 id="constraints">Constraints</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">1 &lt;= strs.length &lt;= 10^4</code></li>
  <li><code class="language-plaintext highlighter-rouge">0 &lt;= strs[i].length &lt;= 100</code></li>
  <li><code class="language-plaintext highlighter-rouge">strs[i]</code> consists of lowercase English letters</li>
</ul>

<h2 id="understanding-the-problem">Understanding the Problem</h2>

<p>This is a <strong>fundamental grouping problem</strong> that teaches us:</p>
<ol>
  <li><strong>How to identify similar items</strong> (anagrams share same characters)</li>
  <li><strong>How to use hash tables for efficient grouping</strong></li>
  <li><strong>How to design good hash keys</strong> for complex objects</li>
  <li><strong>Pattern recognition</strong> for clustering algorithms</li>
</ol>

<h3 id="what-are-anagrams">What Are Anagrams?</h3>

<p>Two strings are anagrams if they contain the <strong>same characters with the same frequencies</strong>, just in different order.</p>

<p><strong>Examples:</strong></p>
<ul>
  <li>â€œlistenâ€ and â€œsilentâ€ â†’ anagrams (same letters: e,i,l,n,s,t)</li>
  <li>â€œeatâ€, â€œteaâ€, â€œateâ€ â†’ all anagrams</li>
  <li>â€œcatâ€ and â€œratâ€ â†’ NOT anagrams (different letters)</li>
</ul>

<h3 id="key-insight">Key Insight</h3>

<p>Anagrams share a <strong>unique signature</strong>:</p>
<ul>
  <li>Sorted characters: â€œeatâ€ â†’ â€œaetâ€, â€œteaâ€ â†’ â€œaetâ€</li>
  <li>Character count: both have {a:1, e:1, t:1}</li>
</ul>

<p>We can use this signature as a <strong>hash key</strong> to group anagrams together.</p>

<h3 id="why-this-problem-matters">Why This Problem Matters</h3>

<ol>
  <li><strong>Hash table mastery:</strong> Learn to design effective hash keys</li>
  <li><strong>Grouping pattern:</strong> Fundamental for clustering algorithms</li>
  <li><strong>String manipulation:</strong> Common in text processing</li>
  <li><strong>Real-world applications:</strong>
    <ul>
      <li>Text deduplication</li>
      <li>Spam detection (similar messages)</li>
      <li>DNA sequence analysis</li>
      <li>Document clustering</li>
      <li>Speaker identification (similar voice characteristics)</li>
    </ul>
  </li>
</ol>

<h3 id="the-clustering-connection">The Clustering Connection</h3>

<p>The grouping pattern in this problem is <strong>identical</strong> to clustering in ML:</p>

<table>
  <thead>
    <tr>
      <th>Group Anagrams</th>
      <th>Clustering Systems</th>
      <th>Speaker Diarization</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Group strings by characters</td>
      <td>Group data points by features</td>
      <td>Group speech by speaker</td>
    </tr>
    <tr>
      <td>Hash key: sorted string</td>
      <td>Cluster ID: centroid</td>
      <td>Speaker ID: voice embedding</td>
    </tr>
    <tr>
      <td>O(NK log K) grouping</td>
      <td>O(N Ã— K) clustering</td>
      <td>O(N Ã— M) diarization</td>
    </tr>
  </tbody>
</table>

<p>All three use <strong>hash-based or similarity-based grouping</strong> to organize items.</p>

<h2 id="approach-1-brute-force---compare-all-pairs">Approach 1: Brute Force - Compare All Pairs</h2>

<h3 id="intuition">Intuition</h3>

<p>Compare every pair of strings to check if theyâ€™re anagrams, then group them.</p>

<h3 id="implementation">Implementation</h3>

<p>``python
from typing import List
from collections import defaultdict</p>

<p>def groupAnagrams_bruteforce(strs: List[str]) -&gt; List[List[str]]:
 â€œâ€â€
 Brute force: compare all pairs.</p>

<p>Time: O(N^2 Ã— K) where N = number of strings, K = max string length
 Space: O(NK)</p>

<p>Why this approach?</p>
<ul>
  <li>Simple to understand</li>
  <li>Shows the naive solution</li>
  <li>Demonstrates need for optimization</li>
</ul>

<p>Problem:</p>
<ul>
  <li>Too slow for large inputs</li>
  <li>Redundant comparisons
 â€œâ€â€
 def are_anagrams(s1: str, s2: str) -&gt; bool:
 â€œ"â€Check if two strings are anagrams.â€â€â€
 if len(s1) != len(s2):
 return False</li>
</ul>

<p># Count characters in each string
 from collections import Counter
 return Counter(s1) == Counter(s2)</p>

<p># Track which strings have been grouped
 grouped = [False] * len(strs)
 result = []</p>

<p>for i in range(len(strs)):
 if grouped[i]:
 continue</p>

<p># Start new group with current string
 group = [strs[i]]
 grouped[i] = True</p>

<p># Find all anagrams of current string
 for j in range(i + 1, len(strs)):
 if not grouped[j] and are_anagrams(strs[i], strs[j]):
 group.append(strs[j])
 grouped[j] = True</p>

<p>result.append(group)</p>

<p>return result</p>

<h1 id="test">Test</h1>
<p>test_input = [â€œeatâ€,â€teaâ€,â€tanâ€,â€ateâ€,â€natâ€,â€batâ€]
print(groupAnagrams_bruteforce(test_input))</p>
<h1 id="output-eat-tea-ate-tan-nat-bat">Output: [[â€˜eatâ€™, â€˜teaâ€™, â€˜ateâ€™], [â€˜tanâ€™, â€˜natâ€™], [â€˜batâ€™]]</h1>
<p>``</p>

<h3 id="analysis">Analysis</h3>

<p><strong>Time Complexity: O(NÂ² Ã— K)</strong></p>
<ul>
  <li>NÂ² pairs to compare</li>
  <li>Each comparison: O(K) to count characters</li>
</ul>

<p><strong>Space Complexity: O(NK)</strong></p>
<ul>
  <li>Store all strings in result</li>
</ul>

<p><strong>For N=10,000, K=100:</strong></p>
<ul>
  <li>Operations: 10,000Â² Ã— 100 = 10 billion</li>
  <li>Too slow!</li>
</ul>

<h2 id="approach-2-sorting-as-hash-key-standard-solution">Approach 2: Sorting as Hash Key (Standard Solution)</h2>

<h3 id="the-key-insight">The Key Insight</h3>

<p><strong>Anagrams become identical when sorted!</strong></p>

<ul>
  <li>â€œeatâ€ â†’ sort â†’ â€œaetâ€</li>
  <li>â€œteaâ€ â†’ sort â†’ â€œaetâ€</li>
  <li>â€œateâ€ â†’ sort â†’ â€œaetâ€</li>
</ul>

<p>We can use the <strong>sorted string as a hash key</strong> to group anagrams.</p>

<h3 id="implementation-1">Implementation</h3>

<p>``python
from collections import defaultdict
from typing import List</p>

<p>def groupAnagrams(strs: List[str]) -&gt; List[List[str]]:
 â€œâ€â€
 Optimal solution using sorted string as hash key.</p>

<p>Time: O(N Ã— K log K) where N = number of strings, K = max string length
 Space: O(NK)</p>

<p>Algorithm:</p>
<ol>
  <li>For each string, create hash key by sorting it</li>
  <li>Use hash table to group strings with same key</li>
  <li>Return groups as list</li>
</ol>

<p>Why this works:</p>
<ul>
  <li>Sorting is canonical representation of anagram</li>
  <li>Hash table provides O(1) lookup</li>
  <li>Single pass through all strings
 â€œâ€â€
 # Hash table: sorted_string -&gt; list of original strings
 anagram_map = defaultdict(list)</li>
</ul>

<p>for s in strs:
 # Sort the string to create hash key
 # â€œeatâ€ -&gt; [â€˜aâ€™, â€˜eâ€™, â€˜tâ€™] -&gt; â€œaetâ€
 sorted_str = â€˜â€˜.join(sorted(s))</p>

<p># Group by sorted key
 anagram_map[sorted_str].append(s)</p>

<p># Return all groups
 return list(anagram_map.values())</p>

<h1 id="test-cases">Test cases</h1>
<p>test_cases = [
 [â€œeatâ€,â€teaâ€,â€tanâ€,â€ateâ€,â€natâ€,â€batâ€],
 [â€â€],
 [â€œaâ€],
 [â€œabcâ€, â€œbcaâ€, â€œcabâ€, â€œxyzâ€, â€œzyxâ€, â€œyxzâ€],
]</p>

<p>for test in test_cases:
 result = groupAnagrams(test)
 print(fâ€Input: {test}â€)
 print(fâ€Output: {result}\nâ€)
``</p>

<h3 id="step-by-step-visualization">Step-by-Step Visualization</h3>

<p>``
Input: [â€œeatâ€,â€teaâ€,â€tanâ€,â€ateâ€,â€natâ€,â€batâ€]</p>

<p>Step 1: Process â€œeatâ€
 sorted(â€œeatâ€) = â€œaetâ€
 anagram_map = {â€œaetâ€: [â€œeatâ€]}</p>

<p>Step 2: Process â€œteaâ€
 sorted(â€œteaâ€) = â€œaetâ€
 anagram_map = {â€œaetâ€: [â€œeatâ€, â€œteaâ€]}</p>

<p>Step 3: Process â€œtanâ€
 sorted(â€œtanâ€) = â€œantâ€
 anagram_map = {â€œaetâ€: [â€œeatâ€, â€œteaâ€], â€œantâ€: [â€œtanâ€]}</p>

<p>Step 4: Process â€œateâ€
 sorted(â€œateâ€) = â€œaetâ€
 anagram_map = {â€œaetâ€: [â€œeatâ€, â€œteaâ€, â€œateâ€], â€œantâ€: [â€œtanâ€]}</p>

<p>Step 5: Process â€œnatâ€
 sorted(â€œnatâ€) = â€œantâ€
 anagram_map = {â€œaetâ€: [â€œeatâ€, â€œteaâ€, â€œateâ€], â€œantâ€: [â€œtanâ€, â€œnatâ€]}</p>

<p>Step 6: Process â€œbatâ€
 sorted(â€œbatâ€) = â€œabtâ€
 anagram_map = {
 â€œaetâ€: [â€œeatâ€, â€œteaâ€, â€œateâ€],
 â€œantâ€: [â€œtanâ€, â€œnatâ€],
 â€œabtâ€: [â€œbatâ€]
 }</p>

<p>Output: [[â€œeatâ€,â€teaâ€,â€ateâ€], [â€œtanâ€,â€natâ€], [â€œbatâ€]]
``</p>

<h2 id="approach-3-character-count-as-hash-key-optimal-for-large-k">Approach 3: Character Count as Hash Key (Optimal for Large K)</h2>

<h3 id="alternative-hash-key">Alternative Hash Key</h3>

<p>Instead of sorting, we can use <strong>character frequencies</strong> as the hash key.</p>

<p><strong>Why?</strong> When strings are very long (KÂ Â» 26), counting is faster than sorting.</p>

<h3 id="implementation-2">Implementation</h3>

<p>``python
from collections import defaultdict
from typing import List</p>

<p>def groupAnagrams_count(strs: List[str]) -&gt; List[List[str]]:
 â€œâ€â€
 Use character count as hash key.</p>

<p>Time: O(NK) where N = number of strings, K = max string length
 Space: O(NK)</p>

<p>Advantage over sorting:</p>
<ul>
  <li>O(K) instead of O(K log K) per string</li>
  <li>Better for very long strings</li>
</ul>

<p>Hash key format:</p>
<ul>
  <li>Tuple of 26 integers (a-z counts)</li>
  <li>e.g., â€œaabâ€ -&gt; (2, 1, 0, 0, â€¦, 0)
 â€œâ€â€
 anagram_map = defaultdict(list)</li>
</ul>

<p>for s in strs:
 # Count characters (a-z)
 count = [0] * 26</p>

<p>for char in s:
 count[ord(char) - ord(â€˜aâ€™)] += 1</p>

<p># Use tuple as hash key (lists arenâ€™t hashable)
 key = tuple(count)</p>

<p>anagram_map[key].append(s)</p>

<p>return list(anagram_map.values())</p>

<h1 id="test-1">Test</h1>
<p>test = [â€œeatâ€,â€teaâ€,â€tanâ€,â€ateâ€,â€natâ€,â€batâ€]
result = groupAnagrams_count(test)
print(fâ€Result: {result}â€)
``</p>

<h3 id="character-count-visualization">Character Count Visualization</h3>

<p>``
â€œeatâ€ -&gt; count array:
Index: 0 1 2 3 4 5 â€¦ 19 20 21 â€¦
Char: a b c d e f â€¦ t u v â€¦
Count: [1, 0, 0, 0, 1, 0, â€¦ 1, 0, 0, â€¦]
 (a=1, e=1, t=1)</p>

<p>Key = (1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0)</p>

<p>â€œteaâ€ -&gt; same count array -&gt; same key!
â€œtanâ€ -&gt; different count array -&gt; different key
``</p>

<h2 id="implementation-production-grade-solution">Implementation: Production-Grade Solution</h2>

<p>``python
from collections import defaultdict
from typing import List, Dict, Optional
import logging
from enum import Enum</p>

<p>class GroupingStrategy(Enum):
 â€œ"â€Strategy for creating hash keys.â€â€â€
 SORTED = â€œsortedâ€
 COUNT = â€œcountâ€
 PRIME = â€œprimeâ€ # Advanced: prime number hash</p>

<p>class AnagramGrouper:
 â€œâ€â€
 Production-ready anagram grouper with multiple strategies.</p>

<p>Features:</p>
<ul>
  <li>Multiple grouping strategies</li>
  <li>Input validation</li>
  <li>Performance metrics</li>
  <li>Detailed logging
 â€œâ€â€</li>
</ul>

<p>def <strong>init</strong>(self, strategy: GroupingStrategy = GroupingStrategy.SORTED):
 â€œâ€â€
 Initialize grouper.</p>

<p>Args:
 strategy: Grouping strategy to use
 â€œâ€â€
 self.strategy = strategy
 self.logger = logging.getLogger(<strong>name</strong>)</p>

<p># Metrics
 self.comparisons = 0
 self.groups_created = 0</p>

<p>def group_anagrams(self, strs: List[str]) -&gt; List[List[str]]:
 â€œâ€â€
 Group anagrams using selected strategy.</p>

<p>Args:
 strs: List of strings to group</p>

<p>Returns:
 List of groups (each group is a list of anagrams)</p>

<p>Raises:
 ValueError: If input is invalid
 â€œâ€â€
 # Validate input
 if not isinstance(strs, list):
 raise ValueError(â€œInput must be a list of stringsâ€)</p>

<p>if not all(isinstance(s, str) for s in strs):
 raise ValueError(â€œAll elements must be stringsâ€)</p>

<p># Reset metrics
 self.comparisons = 0
 self.groups_created = 0</p>

<p># Choose strategy
 if self.strategy == GroupingStrategy.SORTED:
 result = self._group_by_sorted(strs)
 elif self.strategy == GroupingStrategy.COUNT:
 result = self._group_by_count(strs)
 elif self.strategy == GroupingStrategy.PRIME:
 result = self._group_by_prime(strs)
 else:
 raise ValueError(fâ€Unknown strategy: {self.strategy}â€)</p>

<p>self.groups_created = len(result)</p>

<p>self.logger.info(
 fâ€Grouped {len(strs)} strings into {self.groups_created} groups â€œ
 fâ€using {self.strategy.value} strategyâ€
 )</p>

<p>return result</p>

<p>def _group_by_sorted(self, strs: List[str]) -&gt; List[List[str]]:
 â€œ"â€Group using sorted string as key.â€â€â€
 anagram_map = defaultdict(list)</p>

<p>for s in strs:
 key = â€˜â€˜.join(sorted(s))
 anagram_map[key].append(s)
 self.comparisons += 1</p>

<p>return list(anagram_map.values())</p>

<p>def _group_by_count(self, strs: List[str]) -&gt; List[List[str]]:
 â€œ"â€Group using character count as key.â€â€â€
 anagram_map = defaultdict(list)</p>

<p>for s in strs:
 # Count characters
 count = [0] * 26
 for char in s:
 if â€˜aâ€™ &lt;= char &lt;= â€˜zâ€™:
 count[ord(char) - ord(â€˜aâ€™)] += 1
 else:
 # Handle uppercase or non-alphabetic
 char_lower = char.lower()
 if â€˜aâ€™ &lt;= char_lower &lt;= â€˜zâ€™:
 count[ord(char_lower) - ord(â€˜aâ€™)] += 1</p>

<p>key = tuple(count)
 anagram_map[key].append(s)
 self.comparisons += 1</p>

<p>return list(anagram_map.values())</p>

<p>def _group_by_prime(self, strs: List[str]) -&gt; List[List[str]]:
 â€œâ€â€
 Group using prime number hash.</p>

<p>Assign each letter a prime number:
 a=2, b=3, c=5, d=7, e=11, â€¦</p>

<p>Hash = product of primes for each character.</p>

<p>Advantage: Unique hash for each anagram group
 Disadvantage: Can overflow for long strings
 â€œâ€â€
 # Prime numbers for a-z
 primes = [
 2, 3, 5, 7, 11, 13, 17, 19, 23, 29,
 31, 37, 41, 43, 47, 53, 59, 61, 67, 71,
 73, 79, 83, 89, 97, 101
 ]</p>

<p>anagram_map = defaultdict(list)</p>

<p>for s in strs:
 # Calculate prime product
 hash_value = 1</p>

<p>for char in s:
 if â€˜aâ€™ &lt;= char &lt;= â€˜zâ€™:
 hash_value *= primes[ord(char) - ord(â€˜aâ€™)]</p>

<p>anagram_map[hash_value].append(s)
 self.comparisons += 1</p>

<p>return list(anagram_map.values())</p>

<p>def find_anagrams_of(self, target: str, strs: List[str]) -&gt; List[str]:
 â€œâ€â€
 Find all anagrams of a target string in a list.</p>

<p>Args:
 target: Target string
 strs: List of strings to search</p>

<p>Returns:
 List of strings that are anagrams of target
 â€œâ€â€
 # Get hash key for target
 if self.strategy == GroupingStrategy.SORTED:
 target_key = â€˜â€˜.join(sorted(target))
 elif self.strategy == GroupingStrategy.COUNT:
 count = [0] * 26
 for char in target:
 if â€˜aâ€™ &lt;= char &lt;= â€˜zâ€™:
 count[ord(char) - ord(â€˜aâ€™)] += 1
 target_key = tuple(count)
 else:
 target_key = None</p>

<p># Find matching strings
 result = []</p>

<p>for s in strs:
 if self.strategy == GroupingStrategy.SORTED:
 key = â€˜â€˜.join(sorted(s))
 elif self.strategy == GroupingStrategy.COUNT:
 count = [0] * 26
 for char in s:
 if â€˜aâ€™ &lt;= char &lt;= â€˜zâ€™:
 count[ord(char) - ord(â€˜aâ€™)] += 1
 key = tuple(count)</p>

<p>if key == target_key:
 result.append(s)</p>

<p>return result</p>

<p>def get_stats(self) -&gt; Dict:
 â€œ"â€Get performance statistics.â€â€â€
 return {
 â€œstrategyâ€: self.strategy.value,
 â€œcomparisonsâ€: self.comparisons,
 â€œgroups_createdâ€: self.groups_created,
 }</p>

<h1 id="example-usage">Example usage</h1>
<p>if <strong>name</strong> == â€œ<strong>main</strong>â€:
 logging.basicConfig(level=logging.INFO)</p>

<p># Test data
 test_strs = [â€œeatâ€,â€teaâ€,â€tanâ€,â€ateâ€,â€natâ€,â€batâ€]</p>

<p># Test different strategies
 for strategy in GroupingStrategy:
 print(fâ€\n=== Testing {strategy.value} strategy ===â€)</p>

<p>grouper = AnagramGrouper(strategy=strategy)
 result = grouper.group_anagrams(test_strs)</p>

<p>print(fâ€Result: {result}â€)
 print(fâ€Stats: {grouper.get_stats()}â€)</p>

<p># Test finding anagrams
 anagrams_of_eat = grouper.find_anagrams_of(â€œeatâ€, test_strs)
 print(fâ€Anagrams of â€˜eatâ€™: {anagrams_of_eat}â€)
``</p>

<h2 id="testing">Testing</h2>

<h3 id="comprehensive-test-suite">Comprehensive Test Suite</h3>

<p>``python
import pytest
from typing import List</p>

<p>class TestAnagramGrouper:
 â€œ"â€Comprehensive test suite for anagram grouping.â€â€â€</p>

<p>@pytest.fixture
 def grouper(self):
 return AnagramGrouper(strategy=GroupingStrategy.SORTED)</p>

<p>def test_basic_examples(self, grouper):
 â€œ"â€Test basic examples from problem.â€â€â€
 # Example 1
 result = grouper.group_anagrams([â€œeatâ€,â€teaâ€,â€tanâ€,â€ateâ€,â€natâ€,â€batâ€])</p>

<p># Convert to sets for comparison (order doesnâ€™t matter)
 result_sets = [set(group) for group in result]
 expected_sets = [
 {â€œeatâ€, â€œteaâ€, â€œateâ€},
 {â€œtanâ€, â€œnatâ€},
 {â€œbatâ€}
 ]</p>

<p>assert len(result_sets) == len(expected_sets)
 for expected in expected_sets:
 assert expected in result_sets</p>

<p>def test_empty_string(self, grouper):
 â€œ"â€Test with empty string.â€â€â€
 result = grouper.group_anagrams([â€â€])
 assert result == [[â€â€]]</p>

<p>def test_single_string(self, grouper):
 â€œ"â€Test with single string.â€â€â€
 result = grouper.group_anagrams([â€œaâ€])
 assert result == [[â€œaâ€]]</p>

<p>def test_no_anagrams(self, grouper):
 â€œ"â€Test when no strings are anagrams.â€â€â€
 result = grouper.group_anagrams([â€œabcâ€, â€œdefâ€, â€œghiâ€])
 assert len(result) == 3
 assert all(len(group) == 1 for group in result)</p>

<p>def test_all_anagrams(self, grouper):
 â€œ"â€Test when all strings are anagrams.â€â€â€
 result = grouper.group_anagrams([â€œabcâ€, â€œbcaâ€, â€œcabâ€, â€œacbâ€])
 assert len(result) == 1
 assert len(result[0]) == 4</p>

<p>def test_long_strings(self, grouper):
 â€œ"â€Test with long strings.â€â€â€
 long1 = â€œaâ€ * 100
 long2 = â€œaâ€ * 100
 long3 = â€œbâ€ * 100</p>

<p>result = grouper.group_anagrams([long1, long2, long3])
 assert len(result) == 2</p>

<p>def test_strategy_equivalence(self):
 â€œ"â€Test that all strategies produce equivalent results.â€â€â€
 test_input = [â€œeatâ€,â€teaâ€,â€tanâ€,â€ateâ€,â€natâ€,â€batâ€]</p>

<p>results = {}</p>

<p>for strategy in GroupingStrategy:
 grouper = AnagramGrouper(strategy=strategy)
 result = grouper.group_anagrams(test_input)</p>

<p># Convert to frozensets for comparison
 result_sets = frozenset(
 frozenset(group) for group in result
 )
 results[strategy] = result_sets</p>

<p># All strategies should produce same groupings
 assert len(set(results.values())) == 1</p>

<p>def test_case_insensitive(self):
 â€œ"â€Test case handling.â€â€â€
 grouper = AnagramGrouper(strategy=GroupingStrategy.COUNT)
 result = grouper.group_anagrams([â€œEatâ€, â€œTeaâ€, â€œeatâ€])</p>

<p># Should group regardless of case
 assert len(result) &lt;= 2 # Depends on implementation</p>

<p>def test_invalid_input(self, grouper):
 â€œ"â€Test input validation.â€â€â€
 with pytest.raises(ValueError):
 grouper.group_anagrams(â€œnot a listâ€)</p>

<p>with pytest.raises(ValueError):
 grouper.group_anagrams([1, 2, 3])</p>

<p>def test_find_anagrams(self, grouper):
 â€œ"â€Test finding specific anagrams.â€â€â€
 strs = [â€œeatâ€,â€teaâ€,â€tanâ€,â€ateâ€,â€natâ€,â€batâ€]</p>

<p>anagrams = grouper.find_anagrams_of(â€œeatâ€, strs)
 assert set(anagrams) == {â€œeatâ€, â€œteaâ€, â€œateâ€}</p>

<p>anagrams = grouper.find_anagrams_of(â€œtanâ€, strs)
 assert set(anagrams) == {â€œtanâ€, â€œnatâ€}</p>

<h1 id="run-tests">Run tests</h1>
<p>if <strong>name</strong> == â€œ<strong>main</strong>â€:
 pytest.main([<strong>file</strong>, â€œ-vâ€])
``</p>

<h2 id="complexity-analysis">Complexity Analysis</h2>

<h3 id="sorting-approach">Sorting Approach</h3>

<p><strong>Time Complexity: O(N Ã— K log K)</strong></p>
<ul>
  <li>N strings to process</li>
  <li>Each string of length K needs sorting: O(K log K)</li>
  <li>Hash table operations: O(1) average</li>
</ul>

<p><strong>Space Complexity: O(NK)</strong></p>
<ul>
  <li>Store all strings in hash table: O(NK)</li>
  <li>Hash keys: O(NK)</li>
</ul>

<h3 id="character-count-approach">Character Count Approach</h3>

<p><strong>Time Complexity: O(NK)</strong></p>
<ul>
  <li>N strings to process</li>
  <li>Each string of length K needs counting: O(K)</li>
  <li>Better than sorting for large K!</li>
</ul>

<p><strong>Space Complexity: O(NK)</strong></p>
<ul>
  <li>Store all strings: O(NK)</li>
  <li>Hash keys (26-element tuples): O(N)</li>
</ul>

<h3 id="comparison">Comparison</h3>

<table>
  <thead>
    <tr>
      <th>Approach</th>
      <th>Time</th>
      <th>Space</th>
      <th>Best For</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Brute Force</td>
      <td>O(NÂ²K)</td>
      <td>O(NK)</td>
      <td>Never (too slow)</td>
    </tr>
    <tr>
      <td>Sorting</td>
      <td>O(NK log K)</td>
      <td>O(NK)</td>
      <td>Short to medium strings</td>
    </tr>
    <tr>
      <td>Count</td>
      <td>O(NK)</td>
      <td>O(NK)</td>
      <td>Long strings (KÂ Â» 26)</td>
    </tr>
    <tr>
      <td>Prime</td>
      <td>O(NK)</td>
      <td>O(NK)</td>
      <td>Theoretical interest</td>
    </tr>
  </tbody>
</table>

<p><strong>When K is small (â‰¤100):</strong> Sorting is simpler and sufficient.
<strong>When K is large (&gt;1000):</strong> Character count is faster.</p>

<h2 id="production-considerations">Production Considerations</h2>

<h3 id="1-unicode-support">1. Unicode Support</h3>

<p>``python
def group_anagrams_unicode(strs: List[str]) -&gt; List[List[str]]:
 â€œâ€â€
 Group anagrams with full Unicode support.</p>

<p>Handles:</p>
<ul>
  <li>Non-ASCII characters</li>
  <li>Emojis</li>
  <li>Accented characters
 â€œâ€â€
 from collections import Counter</li>
</ul>

<p>anagram_map = defaultdict(list)</p>

<p>for s in strs:
 # Use Counter for Unicode-safe counting
 # Convert to frozenset of items for hashing
 key = tuple(sorted(Counter(s).items()))
 anagram_map[key].append(s)</p>

<p>return list(anagram_map.values())</p>

<h1 id="test-with-unicode">Test with Unicode</h1>
<p>unicode_strs = [â€œcafÃ©â€, â€œÃ©facâ€, â€œhelloâ€, â€œà¤¹à¥‡à¤²à¥‹â€, â€œğŸ˜€ğŸ˜â€, â€œğŸ˜ğŸ˜€â€]
result = group_anagrams_unicode(unicode_strs)
print(result)
``</p>

<h3 id="2-case-insensitive-grouping">2. Case-Insensitive Grouping</h3>

<p>``python
def group_anagrams_case_insensitive(strs: List[str]) -&gt; List[List[str]]:
 â€œ"â€Group anagrams ignoring case.â€â€â€
 anagram_map = defaultdict(list)</p>

<p>for s in strs:
 # Normalize to lowercase before sorting
 key = â€˜â€˜.join(sorted(s.lower()))
 anagram_map[key].append(s)</p>

<p>return list(anagram_map.values())</p>

<h1 id="test-2">Test</h1>
<p>result = group_anagrams_case_insensitive([â€œEatâ€, â€œTeaâ€, â€œeatâ€, â€œteaâ€])
print(result) # All in one group
``</p>

<h3 id="3-streaming--online-grouping">3. Streaming / Online Grouping</h3>

<p>``python
class StreamingAnagramGrouper:
 â€œâ€â€
 Group anagrams in streaming fashion.</p>

<p>Useful when:</p>
<ul>
  <li>Data doesnâ€™t fit in memory</li>
  <li>Processing real-time stream</li>
  <li>Need incremental results
 â€œâ€â€</li>
</ul>

<p>def <strong>init</strong>(self):
 self.groups = defaultdict(list)
 self.group_ids = {}
 self.next_id = 0</p>

<p>def add_string(self, s: str) -&gt; int:
 â€œâ€â€
 Add string to grouping.</p>

<p>Returns:
 Group ID for this string
 â€œâ€â€
 key = â€˜â€˜.join(sorted(s))</p>

<p>if key not in self.group_ids:
 self.group_ids[key] = self.next_id
 self.next_id += 1</p>

<p>group_id = self.group_ids[key]
 self.groups[group_id].append(s)</p>

<p>return group_id</p>

<p>def get_group(self, group_id: int) -&gt; List[str]:
 â€œ"â€Get strings in a specific group.â€â€â€
 return self.groups.get(group_id, [])</p>

<p>def get_all_groups(self) -&gt; List[List[str]]:
 â€œ"â€Get all groups.â€â€â€
 return list(self.groups.values())</p>

<h1 id="usage">Usage</h1>
<p>streamer = StreamingAnagramGrouper()</p>

<p>for word in [â€œeatâ€, â€œteaâ€, â€œtanâ€, â€œateâ€]:
 group_id = streamer.add_string(word)
 print(fâ€â€˜{word}â€™ -&gt; group {group_id}â€)</p>

<p>print(fâ€Final groups: {streamer.get_all_groups()}â€)
``</p>

<h3 id="4-performance-monitoring">4. Performance Monitoring</h3>

<p>``python
import time
from dataclasses import dataclass</p>

<p>@dataclass
class PerformanceMetrics:
 â€œ"â€Performance metrics for grouping operation.â€â€â€
 total_strings: int
 total_groups: int
 execution_time_ms: float
 avg_group_size: float
 largest_group_size: int</p>

<p>def <strong>str</strong>(self):
 return (
 fâ€Performance Metrics:\nâ€
 fâ€ Strings processed: {self.total_strings}\nâ€
 fâ€ Groups created: {self.total_groups}\nâ€
 fâ€ Execution time: {self.execution_time_ms:.2f}ms\nâ€
 fâ€ Avg group size: {self.avg_group_size:.2f}\nâ€
 fâ€ Largest group: {self.largest_group_size}â€
 )</p>

<p>def group_anagrams_with_metrics(strs: List[str]) -&gt; tuple[List[List[str]], PerformanceMetrics]:
 â€œ"â€Group anagrams and return performance metrics.â€â€â€
 start_time = time.perf_counter()</p>

<p># Group anagrams
 anagram_map = defaultdict(list)
 for s in strs:
 key = â€˜â€˜.join(sorted(s))
 anagram_map[key].append(s)</p>

<p>result = list(anagram_map.values())</p>

<p># Calculate metrics
 execution_time = (time.perf_counter() - start_time) * 1000</p>

<p>group_sizes = [len(group) for group in result]</p>

<p>metrics = PerformanceMetrics(
 total_strings=len(strs),
 total_groups=len(result),
 execution_time_ms=execution_time,
 avg_group_size=sum(group_sizes) / len(group_sizes) if group_sizes else 0,
 largest_group_size=max(group_sizes) if group_sizes else 0
 )</p>

<p>return result, metrics
``</p>

<h2 id="connections-to-ml-systems">Connections to ML Systems</h2>

<p>The <strong>hash-based grouping</strong> pattern from this problem is fundamental to clustering systems:</p>

<h3 id="1-clustering-systems">1. Clustering Systems</h3>

<p><strong>Similarity to Group Anagrams:</strong></p>
<ul>
  <li><strong>Anagrams:</strong> Group strings by character composition</li>
  <li><strong>Clustering:</strong> Group data points by feature similarity</li>
</ul>

<p>``python
import numpy as np
from collections import defaultdict</p>

<p>class SimpleClusterer:
 â€œâ€â€
 Simple clustering using hash-based grouping.</p>

<p>Similar to anagram grouping:</p>
<ul>
  <li>Hash key: quantized feature vector</li>
  <li>Grouping: points with same hash go to same cluster
 â€œâ€â€</li>
</ul>

<p>def <strong>init</strong>(self, num_bins: int = 10):
 self.num_bins = num_bins</p>

<p>def cluster(self, points: np.ndarray) -&gt; List[List[int]]:
 â€œâ€â€
 Cluster points using locality-sensitive hashing.</p>

<p>Args:
 points: Array of shape (n_samples, n_features)</p>

<p>Returns:
 List of clusters (each cluster is list of point indices)
 â€œâ€â€
 clusters = defaultdict(list)</p>

<p>for idx, point in enumerate(points):
 # Create hash key by quantizing features
 # (similar to sorting characters in anagram)
 hash_key = tuple(
 int(feature * self.num_bins) for feature in point
 )</p>

<p>clusters[hash_key].append(idx)</p>

<p>return list(clusters.values())</p>

<h1 id="example-cluster-2d-points">Example: Cluster 2D points</h1>
<p>points = np.array([
 [0.1, 0.1], # Cluster 1
 [0.12, 0.11], # Cluster 1
 [0.8, 0.9], # Cluster 2
 [0.82, 0.88], # Cluster 2
])</p>

<p>clusterer = SimpleClusterer(num_bins=10)
clusters = clusterer.cluster(points)
print(fâ€Clusters: {clusters}â€)
``</p>

<h3 id="2-duplicate-detection">2. Duplicate Detection</h3>

<p>``python
class DocumentDeduplicator:
 â€œâ€â€
 Detect duplicate or near-duplicate documents.</p>

<p>Uses same pattern as anagram grouping:</p>
<ul>
  <li>Hash key: document signature</li>
  <li>Grouping: similar documents
 â€œâ€â€</li>
</ul>

<p>def <strong>init</strong>(self):
 self.doc_groups = defaultdict(list)</p>

<p>def add_document(self, doc_id: str, text: str):
 â€œ"â€Add document to deduplication system.â€â€â€
 # Create signature (like anagram key)
 signature = self._create_signature(text)
 self.doc_groups[signature].append(doc_id)</p>

<p>def _create_signature(self, text: str) -&gt; str:
 â€œâ€â€
 Create document signature.</p>

<p>Methods:</p>
<ol>
  <li>Word frequency (like character count)</li>
  <li>N-gram hashing</li>
  <li>MinHash
 â€œâ€â€
 # Simple: use sorted bag of words
 words = text.lower().split()
 return â€˜ â€˜.join(sorted(words))</li>
</ol>

<p>def find_duplicates(self) -&gt; List[List[str]]:
 â€œ"â€Find groups of duplicate documents.â€â€â€
 return [
 group for group in self.doc_groups.values()
 if len(group) &gt; 1
 ]</p>

<h1 id="usage-1">Usage</h1>
<p>dedup = DocumentDeduplicator()
dedup.add_document(â€œdoc1â€, â€œthe quick brown foxâ€)
dedup.add_document(â€œdoc2â€, â€œquick brown fox theâ€) # Duplicate!
dedup.add_document(â€œdoc3â€, â€œhello worldâ€)</p>

<p>duplicates = dedup.find_duplicates()
print(fâ€Duplicate groups: {duplicates}â€)
``</p>

<h3 id="3-feature-hashing">3. Feature Hashing</h3>

<p>``python
class FeatureHasher:
 â€œâ€â€
 Hash high-dimensional features to lower dimensions.</p>

<p>Similar to anagram grouping:</p>
<ul>
  <li>Hash collisions group similar features</li>
  <li>Dimensionality reduction via hashing
 â€œâ€â€</li>
</ul>

<p>def <strong>init</strong>(self, n_features: int = 100):
 self.n_features = n_features</p>

<p>def transform(self, feature_dict: Dict[str, float]) -&gt; np.ndarray:
 â€œâ€â€
 Transform feature dictionary to fixed-size vector.</p>

<p>Args:
 feature_dict: {feature_name: value}</p>

<p>Returns:
 Dense feature vector
 â€œâ€â€
 # Initialize vector
 vector = np.zeros(self.n_features)</p>

<p># Hash each feature to a bin
 for feature_name, value in feature_dict.items():
 # Hash feature name to index
 # (like sorting string to create key)
 hash_idx = hash(feature_name) % self.n_features
 vector[hash_idx] += value</p>

<p>return vector</p>

<h1 id="example-text-features">Example: Text features</h1>
<p>hasher = FeatureHasher(n_features=10)</p>

<p>doc1_features = {â€œword_catâ€: 2, â€œword_dogâ€: 1, â€œword_houseâ€: 1}
doc2_features = {â€œword_catâ€: 1, â€œword_dogâ€: 2, â€œword_carâ€: 1}</p>

<p>vec1 = hasher.transform(doc1_features)
vec2 = hasher.transform(doc2_features)</p>

<p>print(fâ€Vector 1: {vec1}â€)
print(fâ€Vector 2: {vec2}â€)
print(fâ€Similarity: {np.dot(vec1, vec2) / (np.linalg.norm(vec1) * np.linalg.norm(vec2))}â€)
``</p>

<h3 id="key-parallels">Key Parallels</h3>

<table>
  <thead>
    <tr>
      <th>Group Anagrams</th>
      <th>Clustering/ML</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Sorted string as hash key</td>
      <td>Feature signature as hash key</td>
    </tr>
    <tr>
      <td>Group identical keys</td>
      <td>Group similar signatures</td>
    </tr>
    <tr>
      <td>O(1) hash lookup</td>
      <td>O(1) hash lookup</td>
    </tr>
    <tr>
      <td>Character frequency</td>
      <td>Feature frequency</td>
    </tr>
    <tr>
      <td>String similarity</td>
      <td>Data point similarity</td>
    </tr>
  </tbody>
</table>

<h2 id="interview-strategy">Interview Strategy</h2>

<h3 id="how-to-approach-in-an-interview">How to Approach in an Interview</h3>

<p><strong>1. Clarify (1 min)</strong>
``</p>
<ul>
  <li>Are all strings lowercase? (Yes, per constraints)</li>
  <li>Can strings be empty? (Yes)</li>
  <li>Does order of output matter? (No)</li>
  <li>Memory constraints? (Reasonable for N â‰¤ 10^4)
``</li>
</ul>

<p><strong>2. Explain Intuition (2 min)</strong>
<code class="language-plaintext highlighter-rouge">
"Anagrams have the same characters, just rearranged. If we sort
each string, anagrams become identical. We can use this sorted
string as a hash key to group them together in O(1) time per lookup."
</code></p>

<p><strong>3. Discuss Approaches (2 min)</strong>
``</p>
<ol>
  <li>Brute force: Compare all pairs - O(NÂ²K)</li>
  <li>Sorting as key: Sort each string - O(NK log K)</li>
  <li>Count as key: Count characters - O(NK)</li>
</ol>

<p>Iâ€™ll implement approach 2 (sorting) as itâ€™s simpler and efficient
enough for the constraints.
``</p>

<p><strong>4. Code (10 min)</strong></p>
<ul>
  <li>Clear variable names</li>
  <li>Add comments</li>
  <li>Handle edge cases</li>
</ul>

<p><strong>5. Test (3 min)</strong></p>
<ul>
  <li>Walk through example</li>
  <li>Edge cases: empty string, single string</li>
</ul>

<p><strong>6. Optimize (2 min)</strong></p>
<ul>
  <li>Discuss count approach for very long strings</li>
</ul>

<h3 id="common-mistakes">Common Mistakes</h3>

<ol>
  <li><strong>Forgetting to handle empty strings</strong>
 ``python
 # Wrong: crashes on empty string
 key = sorted(s)[0]</li>
</ol>

<p># Correct: works for empty
 key = â€˜â€˜.join(sorted(s))
 ``</p>

<ol>
  <li><strong>Using list as hash key</strong>
 ``python
 # Wrong: lists arenâ€™t hashable
 key = sorted(s) # Returns list</li>
</ol>

<p># Correct: convert to string or tuple
 key = â€˜â€˜.join(sorted(s))
 key = tuple(sorted(s))
 ``</p>

<ol>
  <li><strong>Not considering case sensitivity</strong>
    <ul>
      <li>Problem says lowercase only, but clarify in interview</li>
    </ul>
  </li>
  <li><strong>Inefficient anagram checking in brute force</strong>
 ``python
 # Inefficient
 def are_anagrams(s1, s2):
 return sorted(s1) == sorted(s2)</li>
</ol>

<p># Better: use Counter
 from collections import Counter
 return Counter(s1) == Counter(s2)
 ``</p>

<h3 id="follow-up-questions">Follow-up Questions</h3>

<p><strong>Q1: How would you find the largest group of anagrams?</strong>
``python
def find_largest_anagram_group(strs: List[str]) -&gt; List[str]:
 â€œ"â€Find the group with most anagrams.â€â€â€
 anagram_map = defaultdict(list)</p>

<p>for s in strs:
 key = â€˜â€˜.join(sorted(s))
 anagram_map[key].append(s)</p>

<p># Return largest group
 return max(anagram_map.values(), key=len)
``</p>

<p><strong>Q2: Can you do this without sorting?</strong></p>

<p>Yes! Use character count (shown in Approach 3).</p>

<p><strong>Q3: How would you handle very large datasets?</strong>
``python
â€œâ€â€
For datasets that donâ€™t fit in memory:</p>
<ol>
  <li>Use external sorting / MapReduce</li>
  <li>Process in batches</li>
  <li>Use database with hash index</li>
  <li>Stream processing with approximate grouping
â€œâ€â€</li>
</ol>

<p>def group_anagrams_distributed(strs_iterator):
 â€œâ€â€
 Process large dataset in streaming fashion.</p>

<p>MapReduce approach:</p>
<ul>
  <li>Map: (string -&gt; (sorted_key, string))</li>
  <li>Reduce: Group by sorted_key
 â€œâ€â€
 pass
``</li>
</ul>

<p><strong>Q4: What if we want fuzzy matching (allow 1-2 character differences)?</strong>
``python
def group_similar_strings(strs: List[str], max_diff: int = 1) -&gt; List[List[str]]:
 â€œâ€â€
 Group strings that are similar (not exact anagrams).</p>

<p>This requires different approach:</p>
<ul>
  <li>Locality-sensitive hashing</li>
  <li>Edit distance clustering</li>
  <li>N-gram similarity
 â€œâ€â€
 # More complex - would need LSH or edit distance
 pass
``</li>
</ul>

<h2 id="key-takeaways">Key Takeaways</h2>

<p>âœ… <strong>Hash tables are perfect for grouping</strong> - O(1) lookup and insertion</p>

<p>âœ… <strong>Good hash keys are canonical</strong> - sorted string represents all anagrams</p>

<p>âœ… <strong>Two main approaches:</strong> Sorting O(NK log K) vs Counting O(NK)</p>

<p>âœ… <strong>Character count is faster</strong> for very long strings (KÂ Â» 26)</p>

<p>âœ… <strong>Pattern applies broadly:</strong> Document clustering, duplicate detection, feature hashing</p>

<p>âœ… <strong>Production considerations:</strong> Unicode support, case-insensitivity, streaming</p>

<p>âœ… <strong>Same pattern in clustering:</strong> Hash key = feature signature, grouping = clustering</p>

<p>âœ… <strong>Same pattern in speaker diarization:</strong> Hash key = voice embedding, grouping = speaker clusters</p>

<p>âœ… <strong>Defaultdict is cleaner</strong> than manually checking key existence</p>

<p>âœ… <strong>Testing is crucial:</strong> Edge cases (empty strings, single string, all anagrams)</p>

<h3 id="mental-model">Mental Model</h3>

<p>Think of this problem as:</p>
<ul>
  <li><strong>Anagrams:</strong> Hash-based string grouping</li>
  <li><strong>Clustering:</strong> Hash-based data point grouping</li>
  <li><strong>Speaker Diarization:</strong> Hash-based audio segment grouping</li>
</ul>

<p>All use the same pattern: <strong>create signature â†’ hash â†’ group by signature</strong></p>

<h2 id="additional-practice--variants">Additional Practice &amp; Variants</h2>

<p>If you want to deepen your understanding and move closer to production use cases, here are some structured follow-ups:</p>

<ul>
  <li><strong>Variant 1 â€“ Top-K Anagram Groups:</strong></li>
  <li>Given a list of words, return only the <strong>K largest</strong> anagram groups.</li>
  <li>Forces you to combine grouping with <strong>heap / sorting</strong> logic.</li>
  <li>
    <p>Think about how to stream this when the vocabulary is huge.</p>
  </li>
  <li><strong>Variant 2 â€“ Online Anagram Service:</strong></li>
  <li>Build an HTTP service with two endpoints:</li>
  <li><code class="language-plaintext highlighter-rouge">POST /word</code> to insert a new word into the system.</li>
  <li><code class="language-plaintext highlighter-rouge">GET /anagrams?word=...</code> to retrieve all known anagrams of a given word.</li>
  <li>Internally, you still use the same <strong>signature â†’ list-of-words</strong> hash map,
 but now you must think about:</li>
  <li>Concurrency (multiple writers/readers),</li>
  <li>Persistence (Redis / database),</li>
  <li>
    <p>Eviction or TTLs if memory is constrained.</p>
  </li>
  <li><strong>Variant 3 â€“ Fuzzy Anagrams:</strong></li>
  <li>Allow up to 1 character insertion/deletion/substitution (edit distance 1).</li>
  <li>You can still start from the exact-anagram hash grouping,
 but now you need a <strong>secondary similarity check</strong> inside each bucket.</li>
  <li>This parallels approximate matching in search systems and LSH in clustering.</li>
</ul>

<p>Beyond interviews, this problem is a good mental model for any system where you:</p>
<ol>
  <li>Define a <strong>signature</strong> for items (exact or approximate),</li>
  <li>Use that signature as a <strong>hash key or index</strong>,</li>
  <li>Group or retrieve items efficiently based on that signature.</li>
</ol>

<p>Once you can explain and implement this pattern fluently, you are in a good place
to reason about higher-level systems like feature stores, deduplication pipelines,
and similarity-based retrieval engines.</p>

<hr />

<p><strong>Originally published at:</strong> <a href="https://www.arunbaby.com/dsa/0015-group-anagrams/">arunbaby.com/dsa/0015-group-anagrams</a></p>

<p><em>If you found this helpful, consider sharing it with others who might benefit.</em></p>


        
      </section>

      <footer class="page__meta">
        
        
  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-tags" aria-hidden="true"></i> Tags: </strong>
    <span itemprop="keywords">
    
      <a href="/tags/#anagrams" class="page__taxonomy-item p-category" rel="tag">anagrams</a><span class="sep">, </span>
    
      <a href="/tags/#grouping" class="page__taxonomy-item p-category" rel="tag">grouping</a><span class="sep">, </span>
    
      <a href="/tags/#hash-table" class="page__taxonomy-item p-category" rel="tag">hash-table</a><span class="sep">, </span>
    
      <a href="/tags/#medium-easy" class="page__taxonomy-item p-category" rel="tag">medium-easy</a><span class="sep">, </span>
    
      <a href="/tags/#sorting" class="page__taxonomy-item p-category" rel="tag">sorting</a><span class="sep">, </span>
    
      <a href="/tags/#string" class="page__taxonomy-item p-category" rel="tag">string</a>
    
    </span>
  </p>




  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> Categories: </strong>
    <span itemprop="keywords">
    
      <a href="/categories/#dsa" class="page__taxonomy-item p-category" rel="tag">dsa</a>
    
    </span>
  </p>


        
      </footer>

      <div class="page__related page__related--full">
  <h2 class="page__related-title">Related across topics</h2>
  <style>
    /* Make section span full content width and use 2 equal columns */
    .page__related--full { float: inline-start; width: 100%; padding: 0; }
    .cross-related-grid { display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 2rem; }
    @media (max-width: 768px) { .cross-related-grid { grid-template-columns: 1fr; } }
    /* Ensure archive cards stretch nicely in the grid */
    .cross-related-grid .list__item, .cross-related-grid .grid__item { width: auto; float: none; margin: 0; }
  </style>
  <div class="cross-related-grid">
    



<div class="list__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/ml-system-design/0015-clustering-systems/" rel="permalink">Clustering Systems
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          23 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">Design production clustering systems that group similar items using hash-based and distance-based approaches for recommendations, search, and analytics.
</p>
  </article>
</div>




<div class="list__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/speech-tech/0015-speaker-clustering-diarization/" rel="permalink">Speaker Clustering (Diarization)
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          16 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">Build production speaker diarization systems that cluster audio segments by speaker using embedding-based similarity and hash-based grouping.
</p>
  </article>
</div>




<div class="list__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/ai-agents/0015-planning-and-decomposition/" rel="permalink">Planning and Decomposition
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          7 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">â€œIf you fail to plan, you are planning to fail (and burn tokens).â€
</p>
  </article>
</div>

  </div>
</div>

      <section class="page__share">
  <h4 class="page__share-title">Share on</h4>

  <a href="https://twitter.com/intent/tweet?via=arunbaby0&text=Group+Anagrams%20https%3A%2F%2Fwww.arunbaby.com%2Fdsa%2F0015-group-anagrams%2F" class="btn btn--twitter" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Twitter"><i class="fab fa-fw fa-twitter" aria-hidden="true"></i><span> Twitter</span></a>

  <a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fwww.arunbaby.com%2Fdsa%2F0015-group-anagrams%2F" class="btn btn--facebook" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Facebook"><i class="fab fa-fw fa-facebook" aria-hidden="true"></i><span> Facebook</span></a>

  <a href="https://www.linkedin.com/shareArticle?mini=true&url=https://www.arunbaby.com/dsa/0015-group-anagrams/" class="btn btn--linkedin" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on LinkedIn"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i><span> LinkedIn</span></a>
</section>


      
  <nav class="pagination">
    
      <a href="/dsa/0014-generate-parentheses/" class="pagination--pager" title="Generate Parentheses">Previous</a>
    
    
      <a href="/dsa/0016-merge-intervals/" class="pagination--pager" title="Merge Intervals">Next</a>
    
  </nav>


    </div>

    
  </article>

  
  
</div>

      
    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';" role="search">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Enter your search term..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    

    
      
        
          <li><a href="https://twitter.com/arunbaby0" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-twitter-square" aria-hidden="true"></i> Twitter</a></li>
        
      
        
          <li><a href="https://github.com/arunbaby0" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
        
      
        
          <li><a href="https://www.linkedin.com/in/arunbaby0/" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i> LinkedIn</a></li>
        
      
        
          <li><a href="https://scholar.google.co.in/citations?user=6fSYWhkAAAAJ" rel="nofollow noopener noreferrer"><i class="fas fa-fw fa-graduation-cap" aria-hidden="true"></i> Google Scholar</a></li>
        
      
    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 1990 - 2143 <a href="https://www.arunbaby.com">Arun Baby</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>




  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-0JRJPEC9SS"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-0JRJPEC9SS', { 'anonymize_ip': false});
</script>








  </body>
</html>
