<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.26.2 by Michael Rose
  Copyright 2013-2024 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->

<html lang="en-US" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Group Anagrams - Arun Baby</title>
<meta name="description" content="Master hash-based grouping to solve anagrams—the foundation of clustering systems and speaker diarization in production ML.">


  <meta name="author" content="Arun Baby">
  
  <meta property="article:author" content="Arun Baby">
  


<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="Arun Baby">
<meta property="og:title" content="Group Anagrams">
<meta property="og:url" content="https://www.arunbaby.com/dsa/0015-group-anagrams/">


  <meta property="og:description" content="Master hash-based grouping to solve anagrams—the foundation of clustering systems and speaker diarization in production ML.">



  <meta property="og:image" content="https://www.arunbaby.com/assets/images/profile-photo.png">



  <meta name="twitter:site" content="@arunbaby0">
  <meta name="twitter:title" content="Group Anagrams">
  <meta name="twitter:description" content="Master hash-based grouping to solve anagrams—the foundation of clustering systems and speaker diarization in production ML.">
  <meta name="twitter:url" content="https://www.arunbaby.com/dsa/0015-group-anagrams/">

  
    <meta name="twitter:card" content="summary">
    
      <meta name="twitter:image" content="https://www.arunbaby.com/assets/images/profile-photo.png">
    
  

  



  <meta property="article:published_time" content="2025-12-13T22:45:49+05:30">





  

  


<link rel="canonical" href="https://www.arunbaby.com/dsa/0015-group-anagrams/">












<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Arun Baby Feed">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
  
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css"></noscript>



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--single" dir="ltr">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
           
          <span class="site-subtitle">Arun Baby</span>
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a
                href="/about/"
                
                
              >About</a>
            </li><li class="masthead__menu-item">
              <a
                href="/dsa/"
                
                
              >DSA</a>
            </li><li class="masthead__menu-item">
              <a
                href="/ml-system-design/"
                
                
              >ML Systems</a>
            </li><li class="masthead__menu-item">
              <a
                href="/speech-tech/"
                
                
              >Speech Tech</a>
            </li><li class="masthead__menu-item">
              <a
                href="/publications/"
                
                
              >Publications</a>
            </li><li class="masthead__menu-item">
              <a
                href="/statuses/"
                
                
              >Statuses</a>
            </li><li class="masthead__menu-item">
              <a
                href="/contact/"
                
                
              >Contact</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <i class="fas fa-search"></i>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      





<div id="main" role="main" class="no-author-sidebar">
  
  <div class="sidebar sticky">
  
  
  </div>



  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="Group Anagrams">
    <meta itemprop="description" content="Master hash-based grouping to solve anagrams—the foundation of clustering systems and speaker diarization in production ML.">
    <meta itemprop="datePublished" content="2025-12-13T22:45:49+05:30">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">
            <a href="https://www.arunbaby.com/dsa/0015-group-anagrams/" itemprop="url">Group Anagrams
</a>
          </h1>
          

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          24 minute read
        
      </span>
    
  </p>


        </header>
      

      <section class="page__content" itemprop="text">
        
          <aside class="sidebar__right sticky">
            <nav class="toc">
              <header><h4 class="nav__title"><i class="fas fa-file-alt"></i> On this page</h4></header>
              <ul class="toc__menu"><li><a href="#problem-statement">Problem Statement</a><ul><li><a href="#examples">Examples</a></li><li><a href="#constraints">Constraints</a></li></ul></li><li><a href="#understanding-the-problem">Understanding the Problem</a><ul><li><a href="#what-are-anagrams">What Are Anagrams?</a></li><li><a href="#key-insight">Key Insight</a></li><li><a href="#why-this-problem-matters">Why This Problem Matters</a></li><li><a href="#the-clustering-connection">The Clustering Connection</a></li></ul></li><li><a href="#approach-1-brute-force---compare-all-pairs">Approach 1: Brute Force - Compare All Pairs</a><ul><li><a href="#intuition">Intuition</a></li><li><a href="#implementation">Implementation</a></li><li><a href="#analysis">Analysis</a></li></ul></li><li><a href="#approach-2-sorting-as-hash-key-standard-solution">Approach 2: Sorting as Hash Key (Standard Solution)</a><ul><li><a href="#the-key-insight">The Key Insight</a></li><li><a href="#implementation-1">Implementation</a></li><li><a href="#step-by-step-visualization">Step-by-Step Visualization</a></li></ul></li><li><a href="#approach-3-character-count-as-hash-key-optimal-for-large-k">Approach 3: Character Count as Hash Key (Optimal for Large K)</a><ul><li><a href="#alternative-hash-key">Alternative Hash Key</a></li><li><a href="#implementation-2">Implementation</a></li><li><a href="#character-count-visualization">Character Count Visualization</a></li></ul></li><li><a href="#implementation-production-grade-solution">Implementation: Production-Grade Solution</a></li><li><a href="#testing">Testing</a><ul><li><a href="#comprehensive-test-suite">Comprehensive Test Suite</a></li></ul></li><li><a href="#complexity-analysis">Complexity Analysis</a><ul><li><a href="#sorting-approach">Sorting Approach</a></li><li><a href="#character-count-approach">Character Count Approach</a></li><li><a href="#comparison">Comparison</a></li></ul></li><li><a href="#production-considerations">Production Considerations</a><ul><li><a href="#1-unicode-support">1. Unicode Support</a></li><li><a href="#2-case-insensitive-grouping">2. Case-Insensitive Grouping</a></li><li><a href="#3-streaming--online-grouping">3. Streaming / Online Grouping</a></li><li><a href="#4-performance-monitoring">4. Performance Monitoring</a></li></ul></li><li><a href="#connections-to-ml-systems">Connections to ML Systems</a><ul><li><a href="#1-clustering-systems">1. Clustering Systems</a></li><li><a href="#2-duplicate-detection">2. Duplicate Detection</a></li><li><a href="#3-feature-hashing">3. Feature Hashing</a></li><li><a href="#key-parallels">Key Parallels</a></li></ul></li><li><a href="#interview-strategy">Interview Strategy</a><ul><li><a href="#how-to-approach-in-an-interview">How to Approach in an Interview</a></li><li><a href="#common-mistakes">Common Mistakes</a></li><li><a href="#follow-up-questions">Follow-up Questions</a></li></ul></li><li><a href="#key-takeaways">Key Takeaways</a><ul><li><a href="#mental-model">Mental Model</a></li></ul></li><li><a href="#additional-practice--variants">Additional Practice &amp; Variants</a></li></ul>
            </nav>
          </aside>
        
        <p><strong>Master hash-based grouping to solve anagrams—the foundation of clustering systems and speaker diarization in production ML.</strong></p>

<h2 id="problem-statement">Problem Statement</h2>

<p>Given an array of strings <code class="language-plaintext highlighter-rouge">strs</code>, group the <strong>anagrams</strong> together. You can return the answer in <strong>any order</strong>.</p>

<p>An <strong>anagram</strong> is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.</p>

<h3 id="examples">Examples</h3>

<p><strong>Example 1:</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: strs = ["eat","tea","tan","ate","nat","bat"]
Output: [["bat"],["nat","tan"],["ate","eat","tea"]]
</code></pre></div></div>

<p><strong>Example 2:</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: strs = [""]
Output: [[""]]
</code></pre></div></div>

<p><strong>Example 3:</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: strs = ["a"]
Output: [["a"]]
</code></pre></div></div>

<h3 id="constraints">Constraints</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">1 &lt;= strs.length &lt;= 10^4</code></li>
  <li><code class="language-plaintext highlighter-rouge">0 &lt;= strs[i].length &lt;= 100</code></li>
  <li><code class="language-plaintext highlighter-rouge">strs[i]</code> consists of lowercase English letters</li>
</ul>

<h2 id="understanding-the-problem">Understanding the Problem</h2>

<p>This is a <strong>fundamental grouping problem</strong> that teaches us:</p>
<ol>
  <li><strong>How to identify similar items</strong> (anagrams share same characters)</li>
  <li><strong>How to use hash tables for efficient grouping</strong></li>
  <li><strong>How to design good hash keys</strong> for complex objects</li>
  <li><strong>Pattern recognition</strong> for clustering algorithms</li>
</ol>

<h3 id="what-are-anagrams">What Are Anagrams?</h3>

<p>Two strings are anagrams if they contain the <strong>same characters with the same frequencies</strong>, just in different order.</p>

<p><strong>Examples:</strong></p>
<ul>
  <li>“listen” and “silent” → anagrams (same letters: e,i,l,n,s,t)</li>
  <li>“eat”, “tea”, “ate” → all anagrams</li>
  <li>“cat” and “rat” → NOT anagrams (different letters)</li>
</ul>

<h3 id="key-insight">Key Insight</h3>

<p>Anagrams share a <strong>unique signature</strong>:</p>
<ul>
  <li>Sorted characters: “eat” → “aet”, “tea” → “aet”</li>
  <li>Character count: both have {a:1, e:1, t:1}</li>
</ul>

<p>We can use this signature as a <strong>hash key</strong> to group anagrams together.</p>

<h3 id="why-this-problem-matters">Why This Problem Matters</h3>

<ol>
  <li><strong>Hash table mastery:</strong> Learn to design effective hash keys</li>
  <li><strong>Grouping pattern:</strong> Fundamental for clustering algorithms</li>
  <li><strong>String manipulation:</strong> Common in text processing</li>
  <li><strong>Real-world applications:</strong>
    <ul>
      <li>Text deduplication</li>
      <li>Spam detection (similar messages)</li>
      <li>DNA sequence analysis</li>
      <li>Document clustering</li>
      <li>Speaker identification (similar voice characteristics)</li>
    </ul>
  </li>
</ol>

<h3 id="the-clustering-connection">The Clustering Connection</h3>

<p>The grouping pattern in this problem is <strong>identical</strong> to clustering in ML:</p>

<table>
  <thead>
    <tr>
      <th>Group Anagrams</th>
      <th>Clustering Systems</th>
      <th>Speaker Diarization</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Group strings by characters</td>
      <td>Group data points by features</td>
      <td>Group speech by speaker</td>
    </tr>
    <tr>
      <td>Hash key: sorted string</td>
      <td>Cluster ID: centroid</td>
      <td>Speaker ID: voice embedding</td>
    </tr>
    <tr>
      <td>O(NK log K) grouping</td>
      <td>O(N × K) clustering</td>
      <td>O(N × M) diarization</td>
    </tr>
  </tbody>
</table>

<p>All three use <strong>hash-based or similarity-based grouping</strong> to organize items.</p>

<h2 id="approach-1-brute-force---compare-all-pairs">Approach 1: Brute Force - Compare All Pairs</h2>

<h3 id="intuition">Intuition</h3>

<p>Compare every pair of strings to check if they’re anagrams, then group them.</p>

<h3 id="implementation">Implementation</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">List</span>
<span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>

<span class="k">def</span> <span class="nf">groupAnagrams_bruteforce</span><span class="p">(</span><span class="n">strs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
    <span class="sh">"""</span><span class="s">
    Brute force: compare all pairs.
    
    Time: O(N^2 × K) where N = number of strings, K = max string length
    Space: O(NK)
    
    Why this approach?
    - Simple to understand
    - Shows the naive solution
    - Demonstrates need for optimization
    
    Problem:
    - Too slow for large inputs
    - Redundant comparisons
    </span><span class="sh">"""</span>
    <span class="k">def</span> <span class="nf">are_anagrams</span><span class="p">(</span><span class="n">s1</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">s2</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sh">"""</span><span class="s">Check if two strings are anagrams.</span><span class="sh">"""</span>
        <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span> <span class="o">!=</span> <span class="nf">len</span><span class="p">(</span><span class="n">s2</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">False</span>
        
        <span class="c1"># Count characters in each string
</span>        <span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">Counter</span>
        <span class="k">return</span> <span class="nc">Counter</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span> <span class="o">==</span> <span class="nc">Counter</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span>
    
    <span class="c1"># Track which strings have been grouped
</span>    <span class="n">grouped</span> <span class="o">=</span> <span class="p">[</span><span class="bp">False</span><span class="p">]</span> <span class="o">*</span> <span class="nf">len</span><span class="p">(</span><span class="n">strs</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">strs</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">grouped</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="k">continue</span>
        
        <span class="c1"># Start new group with current string
</span>        <span class="n">group</span> <span class="o">=</span> <span class="p">[</span><span class="n">strs</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
        <span class="n">grouped</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
        
        <span class="c1"># Find all anagrams of current string
</span>        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">strs</span><span class="p">)):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">grouped</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="ow">and</span> <span class="nf">are_anagrams</span><span class="p">(</span><span class="n">strs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">strs</span><span class="p">[</span><span class="n">j</span><span class="p">]):</span>
                <span class="n">group</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">strs</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                <span class="n">grouped</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
        
        <span class="n">result</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">result</span>


<span class="c1"># Test
</span><span class="n">test_input</span> <span class="o">=</span> <span class="p">[</span><span class="sh">"</span><span class="s">eat</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">tea</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">tan</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">ate</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">nat</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">bat</span><span class="sh">"</span><span class="p">]</span>
<span class="nf">print</span><span class="p">(</span><span class="nf">groupAnagrams_bruteforce</span><span class="p">(</span><span class="n">test_input</span><span class="p">))</span>
<span class="c1"># Output: [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']]
</span></code></pre></div></div>

<h3 id="analysis">Analysis</h3>

<p><strong>Time Complexity: O(N² × K)</strong></p>
<ul>
  <li>N² pairs to compare</li>
  <li>Each comparison: O(K) to count characters</li>
</ul>

<p><strong>Space Complexity: O(NK)</strong></p>
<ul>
  <li>Store all strings in result</li>
</ul>

<p><strong>For N=10,000, K=100:</strong></p>
<ul>
  <li>Operations: 10,000² × 100 = 10 billion</li>
  <li>Too slow!</li>
</ul>

<h2 id="approach-2-sorting-as-hash-key-standard-solution">Approach 2: Sorting as Hash Key (Standard Solution)</h2>

<h3 id="the-key-insight">The Key Insight</h3>

<p><strong>Anagrams become identical when sorted!</strong></p>

<ul>
  <li>“eat” → sort → “aet”</li>
  <li>“tea” → sort → “aet”</li>
  <li>“ate” → sort → “aet”</li>
</ul>

<p>We can use the <strong>sorted string as a hash key</strong> to group anagrams.</p>

<h3 id="implementation-1">Implementation</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">List</span>

<span class="k">def</span> <span class="nf">groupAnagrams</span><span class="p">(</span><span class="n">strs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
    <span class="sh">"""</span><span class="s">
    Optimal solution using sorted string as hash key.
    
    Time: O(N × K log K) where N = number of strings, K = max string length
    Space: O(NK)
    
    Algorithm:
    1. For each string, create hash key by sorting it
    2. Use hash table to group strings with same key
    3. Return groups as list
    
    Why this works:
    - Sorting is canonical representation of anagram
    - Hash table provides O(1) lookup
    - Single pass through all strings
    </span><span class="sh">"""</span>
    <span class="c1"># Hash table: sorted_string -&gt; list of original strings
</span>    <span class="n">anagram_map</span> <span class="o">=</span> <span class="nf">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">strs</span><span class="p">:</span>
        <span class="c1"># Sort the string to create hash key
</span>        <span class="c1"># "eat" -&gt; ['a', 'e', 't'] -&gt; "aet"
</span>        <span class="n">sorted_str</span> <span class="o">=</span> <span class="sh">''</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="nf">sorted</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
        
        <span class="c1"># Group by sorted key
</span>        <span class="n">anagram_map</span><span class="p">[</span><span class="n">sorted_str</span><span class="p">].</span><span class="nf">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    
    <span class="c1"># Return all groups
</span>    <span class="k">return</span> <span class="nf">list</span><span class="p">(</span><span class="n">anagram_map</span><span class="p">.</span><span class="nf">values</span><span class="p">())</span>


<span class="c1"># Test cases
</span><span class="n">test_cases</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">[</span><span class="sh">"</span><span class="s">eat</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">tea</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">tan</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">ate</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">nat</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">bat</span><span class="sh">"</span><span class="p">],</span>
    <span class="p">[</span><span class="sh">""</span><span class="p">],</span>
    <span class="p">[</span><span class="sh">"</span><span class="s">a</span><span class="sh">"</span><span class="p">],</span>
    <span class="p">[</span><span class="sh">"</span><span class="s">abc</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">bca</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">cab</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">xyz</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">zyx</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">yxz</span><span class="sh">"</span><span class="p">],</span>
<span class="p">]</span>

<span class="k">for</span> <span class="n">test</span> <span class="ow">in</span> <span class="n">test_cases</span><span class="p">:</span>
    <span class="n">result</span> <span class="o">=</span> <span class="nf">groupAnagrams</span><span class="p">(</span><span class="n">test</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Input: </span><span class="si">{</span><span class="n">test</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Output: </span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="se">\n</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="step-by-step-visualization">Step-by-Step Visualization</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: ["eat","tea","tan","ate","nat","bat"]

Step 1: Process "eat"
  sorted("eat") = "aet"
  anagram_map = {"aet": ["eat"]}

Step 2: Process "tea"
  sorted("tea") = "aet"
  anagram_map = {"aet": ["eat", "tea"]}

Step 3: Process "tan"
  sorted("tan") = "ant"
  anagram_map = {"aet": ["eat", "tea"], "ant": ["tan"]}

Step 4: Process "ate"
  sorted("ate") = "aet"
  anagram_map = {"aet": ["eat", "tea", "ate"], "ant": ["tan"]}

Step 5: Process "nat"
  sorted("nat") = "ant"
  anagram_map = {"aet": ["eat", "tea", "ate"], "ant": ["tan", "nat"]}

Step 6: Process "bat"
  sorted("bat") = "abt"
  anagram_map = {
    "aet": ["eat", "tea", "ate"],
    "ant": ["tan", "nat"],
    "abt": ["bat"]
  }

Output: [["eat","tea","ate"], ["tan","nat"], ["bat"]]
</code></pre></div></div>

<h2 id="approach-3-character-count-as-hash-key-optimal-for-large-k">Approach 3: Character Count as Hash Key (Optimal for Large K)</h2>

<h3 id="alternative-hash-key">Alternative Hash Key</h3>

<p>Instead of sorting, we can use <strong>character frequencies</strong> as the hash key.</p>

<p><strong>Why?</strong> When strings are very long (K » 26), counting is faster than sorting.</p>

<h3 id="implementation-2">Implementation</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">List</span>

<span class="k">def</span> <span class="nf">groupAnagrams_count</span><span class="p">(</span><span class="n">strs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
    <span class="sh">"""</span><span class="s">
    Use character count as hash key.
    
    Time: O(NK) where N = number of strings, K = max string length
    Space: O(NK)
    
    Advantage over sorting:
    - O(K) instead of O(K log K) per string
    - Better for very long strings
    
    Hash key format:
    - Tuple of 26 integers (a-z counts)
    - e.g., </span><span class="sh">"</span><span class="s">aab</span><span class="sh">"</span><span class="s"> -&gt; (2, 1, 0, 0, ..., 0)
    </span><span class="sh">"""</span>
    <span class="n">anagram_map</span> <span class="o">=</span> <span class="nf">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">strs</span><span class="p">:</span>
        <span class="c1"># Count characters (a-z)
</span>        <span class="n">count</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">26</span>
        
        <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
            <span class="n">count</span><span class="p">[</span><span class="nf">ord</span><span class="p">(</span><span class="n">char</span><span class="p">)</span> <span class="o">-</span> <span class="nf">ord</span><span class="p">(</span><span class="sh">'</span><span class="s">a</span><span class="sh">'</span><span class="p">)]</span> <span class="o">+=</span> <span class="mi">1</span>
        
        <span class="c1"># Use tuple as hash key (lists aren't hashable)
</span>        <span class="n">key</span> <span class="o">=</span> <span class="nf">tuple</span><span class="p">(</span><span class="n">count</span><span class="p">)</span>
        
        <span class="n">anagram_map</span><span class="p">[</span><span class="n">key</span><span class="p">].</span><span class="nf">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="nf">list</span><span class="p">(</span><span class="n">anagram_map</span><span class="p">.</span><span class="nf">values</span><span class="p">())</span>


<span class="c1"># Test
</span><span class="n">test</span> <span class="o">=</span> <span class="p">[</span><span class="sh">"</span><span class="s">eat</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">tea</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">tan</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">ate</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">nat</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">bat</span><span class="sh">"</span><span class="p">]</span>
<span class="n">result</span> <span class="o">=</span> <span class="nf">groupAnagrams_count</span><span class="p">(</span><span class="n">test</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Result: </span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="character-count-visualization">Character Count Visualization</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"eat" -&gt; count array:
Index:  0  1  2  3  4  5  ... 19 20 21 ...
Char:   a  b  c  d  e  f  ... t  u  v  ...
Count: [1, 0, 0, 0, 1, 0, ... 1, 0, 0, ...]
       (a=1, e=1, t=1)

Key = (1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0)

"tea" -&gt; same count array -&gt; same key!
"tan" -&gt; different count array -&gt; different key
</code></pre></div></div>

<h2 id="implementation-production-grade-solution">Implementation: Production-Grade Solution</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Optional</span>
<span class="kn">import</span> <span class="n">logging</span>
<span class="kn">from</span> <span class="n">enum</span> <span class="kn">import</span> <span class="n">Enum</span>

<span class="k">class</span> <span class="nc">GroupingStrategy</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">Strategy for creating hash keys.</span><span class="sh">"""</span>
    <span class="n">SORTED</span> <span class="o">=</span> <span class="sh">"</span><span class="s">sorted</span><span class="sh">"</span>
    <span class="n">COUNT</span> <span class="o">=</span> <span class="sh">"</span><span class="s">count</span><span class="sh">"</span>
    <span class="n">PRIME</span> <span class="o">=</span> <span class="sh">"</span><span class="s">prime</span><span class="sh">"</span>  <span class="c1"># Advanced: prime number hash
</span>
<span class="k">class</span> <span class="nc">AnagramGrouper</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">
    Production-ready anagram grouper with multiple strategies.
    
    Features:
    - Multiple grouping strategies
    - Input validation
    - Performance metrics
    - Detailed logging
    </span><span class="sh">"""</span>
    
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">strategy</span><span class="p">:</span> <span class="n">GroupingStrategy</span> <span class="o">=</span> <span class="n">GroupingStrategy</span><span class="p">.</span><span class="n">SORTED</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">
        Initialize grouper.
        
        Args:
            strategy: Grouping strategy to use
        </span><span class="sh">"""</span>
        <span class="n">self</span><span class="p">.</span><span class="n">strategy</span> <span class="o">=</span> <span class="n">strategy</span>
        <span class="n">self</span><span class="p">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="p">.</span><span class="nf">getLogger</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>
        
        <span class="c1"># Metrics
</span>        <span class="n">self</span><span class="p">.</span><span class="n">comparisons</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">self</span><span class="p">.</span><span class="n">groups_created</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="k">def</span> <span class="nf">group_anagrams</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">strs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
        <span class="sh">"""</span><span class="s">
        Group anagrams using selected strategy.
        
        Args:
            strs: List of strings to group
            
        Returns:
            List of groups (each group is a list of anagrams)
            
        Raises:
            ValueError: If input is invalid
        </span><span class="sh">"""</span>
        <span class="c1"># Validate input
</span>        <span class="k">if</span> <span class="ow">not</span> <span class="nf">isinstance</span><span class="p">(</span><span class="n">strs</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">raise</span> <span class="nc">ValueError</span><span class="p">(</span><span class="sh">"</span><span class="s">Input must be a list of strings</span><span class="sh">"</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="nf">all</span><span class="p">(</span><span class="nf">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">strs</span><span class="p">):</span>
            <span class="k">raise</span> <span class="nc">ValueError</span><span class="p">(</span><span class="sh">"</span><span class="s">All elements must be strings</span><span class="sh">"</span><span class="p">)</span>
        
        <span class="c1"># Reset metrics
</span>        <span class="n">self</span><span class="p">.</span><span class="n">comparisons</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">self</span><span class="p">.</span><span class="n">groups_created</span> <span class="o">=</span> <span class="mi">0</span>
        
        <span class="c1"># Choose strategy
</span>        <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">strategy</span> <span class="o">==</span> <span class="n">GroupingStrategy</span><span class="p">.</span><span class="n">SORTED</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">_group_by_sorted</span><span class="p">(</span><span class="n">strs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">self</span><span class="p">.</span><span class="n">strategy</span> <span class="o">==</span> <span class="n">GroupingStrategy</span><span class="p">.</span><span class="n">COUNT</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">_group_by_count</span><span class="p">(</span><span class="n">strs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">self</span><span class="p">.</span><span class="n">strategy</span> <span class="o">==</span> <span class="n">GroupingStrategy</span><span class="p">.</span><span class="n">PRIME</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">_group_by_prime</span><span class="p">(</span><span class="n">strs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="nc">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Unknown strategy: </span><span class="si">{</span><span class="n">self</span><span class="p">.</span><span class="n">strategy</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
        
        <span class="n">self</span><span class="p">.</span><span class="n">groups_created</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        
        <span class="n">self</span><span class="p">.</span><span class="n">logger</span><span class="p">.</span><span class="nf">info</span><span class="p">(</span>
            <span class="sa">f</span><span class="sh">"</span><span class="s">Grouped </span><span class="si">{</span><span class="nf">len</span><span class="p">(</span><span class="n">strs</span><span class="p">)</span><span class="si">}</span><span class="s"> strings into </span><span class="si">{</span><span class="n">self</span><span class="p">.</span><span class="n">groups_created</span><span class="si">}</span><span class="s"> groups </span><span class="sh">"</span>
            <span class="sa">f</span><span class="sh">"</span><span class="s">using </span><span class="si">{</span><span class="n">self</span><span class="p">.</span><span class="n">strategy</span><span class="p">.</span><span class="n">value</span><span class="si">}</span><span class="s"> strategy</span><span class="sh">"</span>
        <span class="p">)</span>
        
        <span class="k">return</span> <span class="n">result</span>
    
    <span class="k">def</span> <span class="nf">_group_by_sorted</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">strs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
        <span class="sh">"""</span><span class="s">Group using sorted string as key.</span><span class="sh">"""</span>
        <span class="n">anagram_map</span> <span class="o">=</span> <span class="nf">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">strs</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="sh">''</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="nf">sorted</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
            <span class="n">anagram_map</span><span class="p">[</span><span class="n">key</span><span class="p">].</span><span class="nf">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
            <span class="n">self</span><span class="p">.</span><span class="n">comparisons</span> <span class="o">+=</span> <span class="mi">1</span>
        
        <span class="k">return</span> <span class="nf">list</span><span class="p">(</span><span class="n">anagram_map</span><span class="p">.</span><span class="nf">values</span><span class="p">())</span>
    
    <span class="k">def</span> <span class="nf">_group_by_count</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">strs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
        <span class="sh">"""</span><span class="s">Group using character count as key.</span><span class="sh">"""</span>
        <span class="n">anagram_map</span> <span class="o">=</span> <span class="nf">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">strs</span><span class="p">:</span>
            <span class="c1"># Count characters
</span>            <span class="n">count</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">26</span>
            <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
                <span class="k">if</span> <span class="sh">'</span><span class="s">a</span><span class="sh">'</span> <span class="o">&lt;=</span> <span class="n">char</span> <span class="o">&lt;=</span> <span class="sh">'</span><span class="s">z</span><span class="sh">'</span><span class="p">:</span>
                    <span class="n">count</span><span class="p">[</span><span class="nf">ord</span><span class="p">(</span><span class="n">char</span><span class="p">)</span> <span class="o">-</span> <span class="nf">ord</span><span class="p">(</span><span class="sh">'</span><span class="s">a</span><span class="sh">'</span><span class="p">)]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Handle uppercase or non-alphabetic
</span>                    <span class="n">char_lower</span> <span class="o">=</span> <span class="n">char</span><span class="p">.</span><span class="nf">lower</span><span class="p">()</span>
                    <span class="k">if</span> <span class="sh">'</span><span class="s">a</span><span class="sh">'</span> <span class="o">&lt;=</span> <span class="n">char_lower</span> <span class="o">&lt;=</span> <span class="sh">'</span><span class="s">z</span><span class="sh">'</span><span class="p">:</span>
                        <span class="n">count</span><span class="p">[</span><span class="nf">ord</span><span class="p">(</span><span class="n">char_lower</span><span class="p">)</span> <span class="o">-</span> <span class="nf">ord</span><span class="p">(</span><span class="sh">'</span><span class="s">a</span><span class="sh">'</span><span class="p">)]</span> <span class="o">+=</span> <span class="mi">1</span>
            
            <span class="n">key</span> <span class="o">=</span> <span class="nf">tuple</span><span class="p">(</span><span class="n">count</span><span class="p">)</span>
            <span class="n">anagram_map</span><span class="p">[</span><span class="n">key</span><span class="p">].</span><span class="nf">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
            <span class="n">self</span><span class="p">.</span><span class="n">comparisons</span> <span class="o">+=</span> <span class="mi">1</span>
        
        <span class="k">return</span> <span class="nf">list</span><span class="p">(</span><span class="n">anagram_map</span><span class="p">.</span><span class="nf">values</span><span class="p">())</span>
    
    <span class="k">def</span> <span class="nf">_group_by_prime</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">strs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
        <span class="sh">"""</span><span class="s">
        Group using prime number hash.
        
        Assign each letter a prime number:
        a=2, b=3, c=5, d=7, e=11, ...
        
        Hash = product of primes for each character.
        
        Advantage: Unique hash for each anagram group
        Disadvantage: Can overflow for long strings
        </span><span class="sh">"""</span>
        <span class="c1"># Prime numbers for a-z
</span>        <span class="n">primes</span> <span class="o">=</span> <span class="p">[</span>
            <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">29</span><span class="p">,</span>
            <span class="mi">31</span><span class="p">,</span> <span class="mi">37</span><span class="p">,</span> <span class="mi">41</span><span class="p">,</span> <span class="mi">43</span><span class="p">,</span> <span class="mi">47</span><span class="p">,</span> <span class="mi">53</span><span class="p">,</span> <span class="mi">59</span><span class="p">,</span> <span class="mi">61</span><span class="p">,</span> <span class="mi">67</span><span class="p">,</span> <span class="mi">71</span><span class="p">,</span>
            <span class="mi">73</span><span class="p">,</span> <span class="mi">79</span><span class="p">,</span> <span class="mi">83</span><span class="p">,</span> <span class="mi">89</span><span class="p">,</span> <span class="mi">97</span><span class="p">,</span> <span class="mi">101</span>
        <span class="p">]</span>
        
        <span class="n">anagram_map</span> <span class="o">=</span> <span class="nf">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">strs</span><span class="p">:</span>
            <span class="c1"># Calculate prime product
</span>            <span class="n">hash_value</span> <span class="o">=</span> <span class="mi">1</span>
            
            <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
                <span class="k">if</span> <span class="sh">'</span><span class="s">a</span><span class="sh">'</span> <span class="o">&lt;=</span> <span class="n">char</span> <span class="o">&lt;=</span> <span class="sh">'</span><span class="s">z</span><span class="sh">'</span><span class="p">:</span>
                    <span class="n">hash_value</span> <span class="o">*=</span> <span class="n">primes</span><span class="p">[</span><span class="nf">ord</span><span class="p">(</span><span class="n">char</span><span class="p">)</span> <span class="o">-</span> <span class="nf">ord</span><span class="p">(</span><span class="sh">'</span><span class="s">a</span><span class="sh">'</span><span class="p">)]</span>
            
            <span class="n">anagram_map</span><span class="p">[</span><span class="n">hash_value</span><span class="p">].</span><span class="nf">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
            <span class="n">self</span><span class="p">.</span><span class="n">comparisons</span> <span class="o">+=</span> <span class="mi">1</span>
        
        <span class="k">return</span> <span class="nf">list</span><span class="p">(</span><span class="n">anagram_map</span><span class="p">.</span><span class="nf">values</span><span class="p">())</span>
    
    <span class="k">def</span> <span class="nf">find_anagrams_of</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">strs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sh">"""</span><span class="s">
        Find all anagrams of a target string in a list.
        
        Args:
            target: Target string
            strs: List of strings to search
            
        Returns:
            List of strings that are anagrams of target
        </span><span class="sh">"""</span>
        <span class="c1"># Get hash key for target
</span>        <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">strategy</span> <span class="o">==</span> <span class="n">GroupingStrategy</span><span class="p">.</span><span class="n">SORTED</span><span class="p">:</span>
            <span class="n">target_key</span> <span class="o">=</span> <span class="sh">''</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="nf">sorted</span><span class="p">(</span><span class="n">target</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">self</span><span class="p">.</span><span class="n">strategy</span> <span class="o">==</span> <span class="n">GroupingStrategy</span><span class="p">.</span><span class="n">COUNT</span><span class="p">:</span>
            <span class="n">count</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">26</span>
            <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">target</span><span class="p">:</span>
                <span class="k">if</span> <span class="sh">'</span><span class="s">a</span><span class="sh">'</span> <span class="o">&lt;=</span> <span class="n">char</span> <span class="o">&lt;=</span> <span class="sh">'</span><span class="s">z</span><span class="sh">'</span><span class="p">:</span>
                    <span class="n">count</span><span class="p">[</span><span class="nf">ord</span><span class="p">(</span><span class="n">char</span><span class="p">)</span> <span class="o">-</span> <span class="nf">ord</span><span class="p">(</span><span class="sh">'</span><span class="s">a</span><span class="sh">'</span><span class="p">)]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">target_key</span> <span class="o">=</span> <span class="nf">tuple</span><span class="p">(</span><span class="n">count</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">target_key</span> <span class="o">=</span> <span class="bp">None</span>
        
        <span class="c1"># Find matching strings
</span>        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">strs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">strategy</span> <span class="o">==</span> <span class="n">GroupingStrategy</span><span class="p">.</span><span class="n">SORTED</span><span class="p">:</span>
                <span class="n">key</span> <span class="o">=</span> <span class="sh">''</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="nf">sorted</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">self</span><span class="p">.</span><span class="n">strategy</span> <span class="o">==</span> <span class="n">GroupingStrategy</span><span class="p">.</span><span class="n">COUNT</span><span class="p">:</span>
                <span class="n">count</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">26</span>
                <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
                    <span class="k">if</span> <span class="sh">'</span><span class="s">a</span><span class="sh">'</span> <span class="o">&lt;=</span> <span class="n">char</span> <span class="o">&lt;=</span> <span class="sh">'</span><span class="s">z</span><span class="sh">'</span><span class="p">:</span>
                        <span class="n">count</span><span class="p">[</span><span class="nf">ord</span><span class="p">(</span><span class="n">char</span><span class="p">)</span> <span class="o">-</span> <span class="nf">ord</span><span class="p">(</span><span class="sh">'</span><span class="s">a</span><span class="sh">'</span><span class="p">)]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">key</span> <span class="o">=</span> <span class="nf">tuple</span><span class="p">(</span><span class="n">count</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="n">target_key</span><span class="p">:</span>
                <span class="n">result</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">result</span>
    
    <span class="k">def</span> <span class="nf">get_stats</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">:</span>
        <span class="sh">"""</span><span class="s">Get performance statistics.</span><span class="sh">"""</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="sh">"</span><span class="s">strategy</span><span class="sh">"</span><span class="p">:</span> <span class="n">self</span><span class="p">.</span><span class="n">strategy</span><span class="p">.</span><span class="n">value</span><span class="p">,</span>
            <span class="sh">"</span><span class="s">comparisons</span><span class="sh">"</span><span class="p">:</span> <span class="n">self</span><span class="p">.</span><span class="n">comparisons</span><span class="p">,</span>
            <span class="sh">"</span><span class="s">groups_created</span><span class="sh">"</span><span class="p">:</span> <span class="n">self</span><span class="p">.</span><span class="n">groups_created</span><span class="p">,</span>
        <span class="p">}</span>


<span class="c1"># Example usage
</span><span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="sh">"</span><span class="s">__main__</span><span class="sh">"</span><span class="p">:</span>
    <span class="n">logging</span><span class="p">.</span><span class="nf">basicConfig</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="n">logging</span><span class="p">.</span><span class="n">INFO</span><span class="p">)</span>
    
    <span class="c1"># Test data
</span>    <span class="n">test_strs</span> <span class="o">=</span> <span class="p">[</span><span class="sh">"</span><span class="s">eat</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">tea</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">tan</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">ate</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">nat</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">bat</span><span class="sh">"</span><span class="p">]</span>
    
    <span class="c1"># Test different strategies
</span>    <span class="k">for</span> <span class="n">strategy</span> <span class="ow">in</span> <span class="n">GroupingStrategy</span><span class="p">:</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="se">\n</span><span class="s">=== Testing </span><span class="si">{</span><span class="n">strategy</span><span class="p">.</span><span class="n">value</span><span class="si">}</span><span class="s"> strategy ===</span><span class="sh">"</span><span class="p">)</span>
        
        <span class="n">grouper</span> <span class="o">=</span> <span class="nc">AnagramGrouper</span><span class="p">(</span><span class="n">strategy</span><span class="o">=</span><span class="n">strategy</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">grouper</span><span class="p">.</span><span class="nf">group_anagrams</span><span class="p">(</span><span class="n">test_strs</span><span class="p">)</span>
        
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Result: </span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Stats: </span><span class="si">{</span><span class="n">grouper</span><span class="p">.</span><span class="nf">get_stats</span><span class="p">()</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
        
        <span class="c1"># Test finding anagrams
</span>        <span class="n">anagrams_of_eat</span> <span class="o">=</span> <span class="n">grouper</span><span class="p">.</span><span class="nf">find_anagrams_of</span><span class="p">(</span><span class="sh">"</span><span class="s">eat</span><span class="sh">"</span><span class="p">,</span> <span class="n">test_strs</span><span class="p">)</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Anagrams of </span><span class="sh">'</span><span class="s">eat</span><span class="sh">'</span><span class="s">: </span><span class="si">{</span><span class="n">anagrams_of_eat</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="testing">Testing</h2>

<h3 id="comprehensive-test-suite">Comprehensive Test Suite</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">pytest</span>
<span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">List</span>

<span class="k">class</span> <span class="nc">TestAnagramGrouper</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">Comprehensive test suite for anagram grouping.</span><span class="sh">"""</span>
    
    <span class="nd">@pytest.fixture</span>
    <span class="k">def</span> <span class="nf">grouper</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nc">AnagramGrouper</span><span class="p">(</span><span class="n">strategy</span><span class="o">=</span><span class="n">GroupingStrategy</span><span class="p">.</span><span class="n">SORTED</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">test_basic_examples</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">grouper</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">Test basic examples from problem.</span><span class="sh">"""</span>
        <span class="c1"># Example 1
</span>        <span class="n">result</span> <span class="o">=</span> <span class="n">grouper</span><span class="p">.</span><span class="nf">group_anagrams</span><span class="p">([</span><span class="sh">"</span><span class="s">eat</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">tea</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">tan</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">ate</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">nat</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">bat</span><span class="sh">"</span><span class="p">])</span>
        
        <span class="c1"># Convert to sets for comparison (order doesn't matter)
</span>        <span class="n">result_sets</span> <span class="o">=</span> <span class="p">[</span><span class="nf">set</span><span class="p">(</span><span class="n">group</span><span class="p">)</span> <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">result</span><span class="p">]</span>
        <span class="n">expected_sets</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">{</span><span class="sh">"</span><span class="s">eat</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">tea</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">ate</span><span class="sh">"</span><span class="p">},</span>
            <span class="p">{</span><span class="sh">"</span><span class="s">tan</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">nat</span><span class="sh">"</span><span class="p">},</span>
            <span class="p">{</span><span class="sh">"</span><span class="s">bat</span><span class="sh">"</span><span class="p">}</span>
        <span class="p">]</span>
        
        <span class="k">assert</span> <span class="nf">len</span><span class="p">(</span><span class="n">result_sets</span><span class="p">)</span> <span class="o">==</span> <span class="nf">len</span><span class="p">(</span><span class="n">expected_sets</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">expected</span> <span class="ow">in</span> <span class="n">expected_sets</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">expected</span> <span class="ow">in</span> <span class="n">result_sets</span>
    
    <span class="k">def</span> <span class="nf">test_empty_string</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">grouper</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">Test with empty string.</span><span class="sh">"""</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">grouper</span><span class="p">.</span><span class="nf">group_anagrams</span><span class="p">([</span><span class="sh">""</span><span class="p">])</span>
        <span class="k">assert</span> <span class="n">result</span> <span class="o">==</span> <span class="p">[[</span><span class="sh">""</span><span class="p">]]</span>
    
    <span class="k">def</span> <span class="nf">test_single_string</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">grouper</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">Test with single string.</span><span class="sh">"""</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">grouper</span><span class="p">.</span><span class="nf">group_anagrams</span><span class="p">([</span><span class="sh">"</span><span class="s">a</span><span class="sh">"</span><span class="p">])</span>
        <span class="k">assert</span> <span class="n">result</span> <span class="o">==</span> <span class="p">[[</span><span class="sh">"</span><span class="s">a</span><span class="sh">"</span><span class="p">]]</span>
    
    <span class="k">def</span> <span class="nf">test_no_anagrams</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">grouper</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">Test when no strings are anagrams.</span><span class="sh">"""</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">grouper</span><span class="p">.</span><span class="nf">group_anagrams</span><span class="p">([</span><span class="sh">"</span><span class="s">abc</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">def</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">ghi</span><span class="sh">"</span><span class="p">])</span>
        <span class="k">assert</span> <span class="nf">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span>
        <span class="k">assert</span> <span class="nf">all</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">group</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">result</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">test_all_anagrams</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">grouper</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">Test when all strings are anagrams.</span><span class="sh">"""</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">grouper</span><span class="p">.</span><span class="nf">group_anagrams</span><span class="p">([</span><span class="sh">"</span><span class="s">abc</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">bca</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">cab</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">acb</span><span class="sh">"</span><span class="p">])</span>
        <span class="k">assert</span> <span class="nf">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="k">assert</span> <span class="nf">len</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">4</span>
    
    <span class="k">def</span> <span class="nf">test_long_strings</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">grouper</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">Test with long strings.</span><span class="sh">"""</span>
        <span class="n">long1</span> <span class="o">=</span> <span class="sh">"</span><span class="s">a</span><span class="sh">"</span> <span class="o">*</span> <span class="mi">100</span>
        <span class="n">long2</span> <span class="o">=</span> <span class="sh">"</span><span class="s">a</span><span class="sh">"</span> <span class="o">*</span> <span class="mi">100</span>
        <span class="n">long3</span> <span class="o">=</span> <span class="sh">"</span><span class="s">b</span><span class="sh">"</span> <span class="o">*</span> <span class="mi">100</span>
        
        <span class="n">result</span> <span class="o">=</span> <span class="n">grouper</span><span class="p">.</span><span class="nf">group_anagrams</span><span class="p">([</span><span class="n">long1</span><span class="p">,</span> <span class="n">long2</span><span class="p">,</span> <span class="n">long3</span><span class="p">])</span>
        <span class="k">assert</span> <span class="nf">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
    
    <span class="k">def</span> <span class="nf">test_strategy_equivalence</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">Test that all strategies produce equivalent results.</span><span class="sh">"""</span>
        <span class="n">test_input</span> <span class="o">=</span> <span class="p">[</span><span class="sh">"</span><span class="s">eat</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">tea</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">tan</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">ate</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">nat</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">bat</span><span class="sh">"</span><span class="p">]</span>
        
        <span class="n">results</span> <span class="o">=</span> <span class="p">{}</span>
        
        <span class="k">for</span> <span class="n">strategy</span> <span class="ow">in</span> <span class="n">GroupingStrategy</span><span class="p">:</span>
            <span class="n">grouper</span> <span class="o">=</span> <span class="nc">AnagramGrouper</span><span class="p">(</span><span class="n">strategy</span><span class="o">=</span><span class="n">strategy</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">grouper</span><span class="p">.</span><span class="nf">group_anagrams</span><span class="p">(</span><span class="n">test_input</span><span class="p">)</span>
            
            <span class="c1"># Convert to frozensets for comparison
</span>            <span class="n">result_sets</span> <span class="o">=</span> <span class="nf">frozenset</span><span class="p">(</span>
                <span class="nf">frozenset</span><span class="p">(</span><span class="n">group</span><span class="p">)</span> <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">result</span>
            <span class="p">)</span>
            <span class="n">results</span><span class="p">[</span><span class="n">strategy</span><span class="p">]</span> <span class="o">=</span> <span class="n">result_sets</span>
        
        <span class="c1"># All strategies should produce same groupings
</span>        <span class="k">assert</span> <span class="nf">len</span><span class="p">(</span><span class="nf">set</span><span class="p">(</span><span class="n">results</span><span class="p">.</span><span class="nf">values</span><span class="p">()))</span> <span class="o">==</span> <span class="mi">1</span>
    
    <span class="k">def</span> <span class="nf">test_case_insensitive</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">Test case handling.</span><span class="sh">"""</span>
        <span class="n">grouper</span> <span class="o">=</span> <span class="nc">AnagramGrouper</span><span class="p">(</span><span class="n">strategy</span><span class="o">=</span><span class="n">GroupingStrategy</span><span class="p">.</span><span class="n">COUNT</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">grouper</span><span class="p">.</span><span class="nf">group_anagrams</span><span class="p">([</span><span class="sh">"</span><span class="s">Eat</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">Tea</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">eat</span><span class="sh">"</span><span class="p">])</span>
        
        <span class="c1"># Should group regardless of case
</span>        <span class="k">assert</span> <span class="nf">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">2</span>  <span class="c1"># Depends on implementation
</span>    
    <span class="k">def</span> <span class="nf">test_invalid_input</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">grouper</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">Test input validation.</span><span class="sh">"""</span>
        <span class="k">with</span> <span class="n">pytest</span><span class="p">.</span><span class="nf">raises</span><span class="p">(</span><span class="nb">ValueError</span><span class="p">):</span>
            <span class="n">grouper</span><span class="p">.</span><span class="nf">group_anagrams</span><span class="p">(</span><span class="sh">"</span><span class="s">not a list</span><span class="sh">"</span><span class="p">)</span>
        
        <span class="k">with</span> <span class="n">pytest</span><span class="p">.</span><span class="nf">raises</span><span class="p">(</span><span class="nb">ValueError</span><span class="p">):</span>
            <span class="n">grouper</span><span class="p">.</span><span class="nf">group_anagrams</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
    
    <span class="k">def</span> <span class="nf">test_find_anagrams</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">grouper</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">Test finding specific anagrams.</span><span class="sh">"""</span>
        <span class="n">strs</span> <span class="o">=</span> <span class="p">[</span><span class="sh">"</span><span class="s">eat</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">tea</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">tan</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">ate</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">nat</span><span class="sh">"</span><span class="p">,</span><span class="sh">"</span><span class="s">bat</span><span class="sh">"</span><span class="p">]</span>
        
        <span class="n">anagrams</span> <span class="o">=</span> <span class="n">grouper</span><span class="p">.</span><span class="nf">find_anagrams_of</span><span class="p">(</span><span class="sh">"</span><span class="s">eat</span><span class="sh">"</span><span class="p">,</span> <span class="n">strs</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nf">set</span><span class="p">(</span><span class="n">anagrams</span><span class="p">)</span> <span class="o">==</span> <span class="p">{</span><span class="sh">"</span><span class="s">eat</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">tea</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">ate</span><span class="sh">"</span><span class="p">}</span>
        
        <span class="n">anagrams</span> <span class="o">=</span> <span class="n">grouper</span><span class="p">.</span><span class="nf">find_anagrams_of</span><span class="p">(</span><span class="sh">"</span><span class="s">tan</span><span class="sh">"</span><span class="p">,</span> <span class="n">strs</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nf">set</span><span class="p">(</span><span class="n">anagrams</span><span class="p">)</span> <span class="o">==</span> <span class="p">{</span><span class="sh">"</span><span class="s">tan</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">nat</span><span class="sh">"</span><span class="p">}</span>


<span class="c1"># Run tests
</span><span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="sh">"</span><span class="s">__main__</span><span class="sh">"</span><span class="p">:</span>
    <span class="n">pytest</span><span class="p">.</span><span class="nf">main</span><span class="p">([</span><span class="n">__file__</span><span class="p">,</span> <span class="sh">"</span><span class="s">-v</span><span class="sh">"</span><span class="p">])</span>
</code></pre></div></div>

<h2 id="complexity-analysis">Complexity Analysis</h2>

<h3 id="sorting-approach">Sorting Approach</h3>

<p><strong>Time Complexity: O(N × K log K)</strong></p>
<ul>
  <li>N strings to process</li>
  <li>Each string of length K needs sorting: O(K log K)</li>
  <li>Hash table operations: O(1) average</li>
</ul>

<p><strong>Space Complexity: O(NK)</strong></p>
<ul>
  <li>Store all strings in hash table: O(NK)</li>
  <li>Hash keys: O(NK)</li>
</ul>

<h3 id="character-count-approach">Character Count Approach</h3>

<p><strong>Time Complexity: O(NK)</strong></p>
<ul>
  <li>N strings to process</li>
  <li>Each string of length K needs counting: O(K)</li>
  <li>Better than sorting for large K!</li>
</ul>

<p><strong>Space Complexity: O(NK)</strong></p>
<ul>
  <li>Store all strings: O(NK)</li>
  <li>Hash keys (26-element tuples): O(N)</li>
</ul>

<h3 id="comparison">Comparison</h3>

<table>
  <thead>
    <tr>
      <th>Approach</th>
      <th>Time</th>
      <th>Space</th>
      <th>Best For</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Brute Force</td>
      <td>O(N²K)</td>
      <td>O(NK)</td>
      <td>Never (too slow)</td>
    </tr>
    <tr>
      <td>Sorting</td>
      <td>O(NK log K)</td>
      <td>O(NK)</td>
      <td>Short to medium strings</td>
    </tr>
    <tr>
      <td>Count</td>
      <td>O(NK)</td>
      <td>O(NK)</td>
      <td>Long strings (K » 26)</td>
    </tr>
    <tr>
      <td>Prime</td>
      <td>O(NK)</td>
      <td>O(NK)</td>
      <td>Theoretical interest</td>
    </tr>
  </tbody>
</table>

<p><strong>When K is small (≤100):</strong> Sorting is simpler and sufficient.
<strong>When K is large (&gt;1000):</strong> Character count is faster.</p>

<h2 id="production-considerations">Production Considerations</h2>

<h3 id="1-unicode-support">1. Unicode Support</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">group_anagrams_unicode</span><span class="p">(</span><span class="n">strs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
    <span class="sh">"""</span><span class="s">
    Group anagrams with full Unicode support.
    
    Handles:
    - Non-ASCII characters
    - Emojis
    - Accented characters
    </span><span class="sh">"""</span>
    <span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">Counter</span>
    
    <span class="n">anagram_map</span> <span class="o">=</span> <span class="nf">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">strs</span><span class="p">:</span>
        <span class="c1"># Use Counter for Unicode-safe counting
</span>        <span class="c1"># Convert to frozenset of items for hashing
</span>        <span class="n">key</span> <span class="o">=</span> <span class="nf">tuple</span><span class="p">(</span><span class="nf">sorted</span><span class="p">(</span><span class="nc">Counter</span><span class="p">(</span><span class="n">s</span><span class="p">).</span><span class="nf">items</span><span class="p">()))</span>
        <span class="n">anagram_map</span><span class="p">[</span><span class="n">key</span><span class="p">].</span><span class="nf">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="nf">list</span><span class="p">(</span><span class="n">anagram_map</span><span class="p">.</span><span class="nf">values</span><span class="p">())</span>


<span class="c1"># Test with Unicode
</span><span class="n">unicode_strs</span> <span class="o">=</span> <span class="p">[</span><span class="sh">"</span><span class="s">café</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">éfac</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">hello</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">हेलो</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">😀😁</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">😁😀</span><span class="sh">"</span><span class="p">]</span>
<span class="n">result</span> <span class="o">=</span> <span class="nf">group_anagrams_unicode</span><span class="p">(</span><span class="n">unicode_strs</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="2-case-insensitive-grouping">2. Case-Insensitive Grouping</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">group_anagrams_case_insensitive</span><span class="p">(</span><span class="n">strs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
    <span class="sh">"""</span><span class="s">Group anagrams ignoring case.</span><span class="sh">"""</span>
    <span class="n">anagram_map</span> <span class="o">=</span> <span class="nf">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">strs</span><span class="p">:</span>
        <span class="c1"># Normalize to lowercase before sorting
</span>        <span class="n">key</span> <span class="o">=</span> <span class="sh">''</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="nf">sorted</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="nf">lower</span><span class="p">()))</span>
        <span class="n">anagram_map</span><span class="p">[</span><span class="n">key</span><span class="p">].</span><span class="nf">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="nf">list</span><span class="p">(</span><span class="n">anagram_map</span><span class="p">.</span><span class="nf">values</span><span class="p">())</span>


<span class="c1"># Test
</span><span class="n">result</span> <span class="o">=</span> <span class="nf">group_anagrams_case_insensitive</span><span class="p">([</span><span class="sh">"</span><span class="s">Eat</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">Tea</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">eat</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">tea</span><span class="sh">"</span><span class="p">])</span>
<span class="nf">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>  <span class="c1"># All in one group
</span></code></pre></div></div>

<h3 id="3-streaming--online-grouping">3. Streaming / Online Grouping</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">StreamingAnagramGrouper</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">
    Group anagrams in streaming fashion.
    
    Useful when:
    - Data doesn</span><span class="sh">'</span><span class="s">t fit in memory
    - Processing real-time stream
    - Need incremental results
    </span><span class="sh">"""</span>
    
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">groups</span> <span class="o">=</span> <span class="nf">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">group_ids</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">self</span><span class="p">.</span><span class="n">next_id</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="k">def</span> <span class="nf">add_string</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sh">"""</span><span class="s">
        Add string to grouping.
        
        Returns:
            Group ID for this string
        </span><span class="sh">"""</span>
        <span class="n">key</span> <span class="o">=</span> <span class="sh">''</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="nf">sorted</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
        
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">group_ids</span><span class="p">:</span>
            <span class="n">self</span><span class="p">.</span><span class="n">group_ids</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">next_id</span>
            <span class="n">self</span><span class="p">.</span><span class="n">next_id</span> <span class="o">+=</span> <span class="mi">1</span>
        
        <span class="n">group_id</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">group_ids</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="n">self</span><span class="p">.</span><span class="n">groups</span><span class="p">[</span><span class="n">group_id</span><span class="p">].</span><span class="nf">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">group_id</span>
    
    <span class="k">def</span> <span class="nf">get_group</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">group_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sh">"""</span><span class="s">Get strings in a specific group.</span><span class="sh">"""</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">groups</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">group_id</span><span class="p">,</span> <span class="p">[])</span>
    
    <span class="k">def</span> <span class="nf">get_all_groups</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
        <span class="sh">"""</span><span class="s">Get all groups.</span><span class="sh">"""</span>
        <span class="k">return</span> <span class="nf">list</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">groups</span><span class="p">.</span><span class="nf">values</span><span class="p">())</span>


<span class="c1"># Usage
</span><span class="n">streamer</span> <span class="o">=</span> <span class="nc">StreamingAnagramGrouper</span><span class="p">()</span>

<span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="p">[</span><span class="sh">"</span><span class="s">eat</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">tea</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">tan</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">ate</span><span class="sh">"</span><span class="p">]:</span>
    <span class="n">group_id</span> <span class="o">=</span> <span class="n">streamer</span><span class="p">.</span><span class="nf">add_string</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"'</span><span class="si">{</span><span class="n">word</span><span class="si">}</span><span class="sh">'</span><span class="s"> -&gt; group </span><span class="si">{</span><span class="n">group_id</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>

<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Final groups: </span><span class="si">{</span><span class="n">streamer</span><span class="p">.</span><span class="nf">get_all_groups</span><span class="p">()</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="4-performance-monitoring">4. Performance Monitoring</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">time</span>
<span class="kn">from</span> <span class="n">dataclasses</span> <span class="kn">import</span> <span class="n">dataclass</span>

<span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">PerformanceMetrics</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">Performance metrics for grouping operation.</span><span class="sh">"""</span>
    <span class="n">total_strings</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">total_groups</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">execution_time_ms</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">avg_group_size</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">largest_group_size</span><span class="p">:</span> <span class="nb">int</span>
    
    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="nf">return </span><span class="p">(</span>
            <span class="sa">f</span><span class="sh">"</span><span class="s">Performance Metrics:</span><span class="se">\n</span><span class="sh">"</span>
            <span class="sa">f</span><span class="sh">"</span><span class="s">  Strings processed: </span><span class="si">{</span><span class="n">self</span><span class="p">.</span><span class="n">total_strings</span><span class="si">}</span><span class="se">\n</span><span class="sh">"</span>
            <span class="sa">f</span><span class="sh">"</span><span class="s">  Groups created: </span><span class="si">{</span><span class="n">self</span><span class="p">.</span><span class="n">total_groups</span><span class="si">}</span><span class="se">\n</span><span class="sh">"</span>
            <span class="sa">f</span><span class="sh">"</span><span class="s">  Execution time: </span><span class="si">{</span><span class="n">self</span><span class="p">.</span><span class="n">execution_time_ms</span><span class="si">:</span><span class="p">.</span><span class="mi">2</span><span class="n">f</span><span class="si">}</span><span class="s">ms</span><span class="se">\n</span><span class="sh">"</span>
            <span class="sa">f</span><span class="sh">"</span><span class="s">  Avg group size: </span><span class="si">{</span><span class="n">self</span><span class="p">.</span><span class="n">avg_group_size</span><span class="si">:</span><span class="p">.</span><span class="mi">2</span><span class="n">f</span><span class="si">}</span><span class="se">\n</span><span class="sh">"</span>
            <span class="sa">f</span><span class="sh">"</span><span class="s">  Largest group: </span><span class="si">{</span><span class="n">self</span><span class="p">.</span><span class="n">largest_group_size</span><span class="si">}</span><span class="sh">"</span>
        <span class="p">)</span>


<span class="k">def</span> <span class="nf">group_anagrams_with_metrics</span><span class="p">(</span><span class="n">strs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">PerformanceMetrics</span><span class="p">]:</span>
    <span class="sh">"""</span><span class="s">Group anagrams and return performance metrics.</span><span class="sh">"""</span>
    <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">perf_counter</span><span class="p">()</span>
    
    <span class="c1"># Group anagrams
</span>    <span class="n">anagram_map</span> <span class="o">=</span> <span class="nf">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">strs</span><span class="p">:</span>
        <span class="n">key</span> <span class="o">=</span> <span class="sh">''</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="nf">sorted</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
        <span class="n">anagram_map</span><span class="p">[</span><span class="n">key</span><span class="p">].</span><span class="nf">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    
    <span class="n">result</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="n">anagram_map</span><span class="p">.</span><span class="nf">values</span><span class="p">())</span>
    
    <span class="c1"># Calculate metrics
</span>    <span class="n">execution_time</span> <span class="o">=</span> <span class="p">(</span><span class="n">time</span><span class="p">.</span><span class="nf">perf_counter</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1000</span>
    
    <span class="n">group_sizes</span> <span class="o">=</span> <span class="p">[</span><span class="nf">len</span><span class="p">(</span><span class="n">group</span><span class="p">)</span> <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">result</span><span class="p">]</span>
    
    <span class="n">metrics</span> <span class="o">=</span> <span class="nc">PerformanceMetrics</span><span class="p">(</span>
        <span class="n">total_strings</span><span class="o">=</span><span class="nf">len</span><span class="p">(</span><span class="n">strs</span><span class="p">),</span>
        <span class="n">total_groups</span><span class="o">=</span><span class="nf">len</span><span class="p">(</span><span class="n">result</span><span class="p">),</span>
        <span class="n">execution_time_ms</span><span class="o">=</span><span class="n">execution_time</span><span class="p">,</span>
        <span class="n">avg_group_size</span><span class="o">=</span><span class="nf">sum</span><span class="p">(</span><span class="n">group_sizes</span><span class="p">)</span> <span class="o">/</span> <span class="nf">len</span><span class="p">(</span><span class="n">group_sizes</span><span class="p">)</span> <span class="k">if</span> <span class="n">group_sizes</span> <span class="k">else</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">largest_group_size</span><span class="o">=</span><span class="nf">max</span><span class="p">(</span><span class="n">group_sizes</span><span class="p">)</span> <span class="k">if</span> <span class="n">group_sizes</span> <span class="k">else</span> <span class="mi">0</span>
    <span class="p">)</span>
    
    <span class="k">return</span> <span class="n">result</span><span class="p">,</span> <span class="n">metrics</span>
</code></pre></div></div>

<h2 id="connections-to-ml-systems">Connections to ML Systems</h2>

<p>The <strong>hash-based grouping</strong> pattern from this problem is fundamental to clustering systems:</p>

<h3 id="1-clustering-systems">1. Clustering Systems</h3>

<p><strong>Similarity to Group Anagrams:</strong></p>
<ul>
  <li><strong>Anagrams:</strong> Group strings by character composition</li>
  <li><strong>Clustering:</strong> Group data points by feature similarity</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>

<span class="k">class</span> <span class="nc">SimpleClusterer</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">
    Simple clustering using hash-based grouping.
    
    Similar to anagram grouping:
    - Hash key: quantized feature vector
    - Grouping: points with same hash go to same cluster
    </span><span class="sh">"""</span>
    
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">num_bins</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">num_bins</span> <span class="o">=</span> <span class="n">num_bins</span>
    
    <span class="k">def</span> <span class="nf">cluster</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">points</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="sh">"""</span><span class="s">
        Cluster points using locality-sensitive hashing.
        
        Args:
            points: Array of shape (n_samples, n_features)
            
        Returns:
            List of clusters (each cluster is list of point indices)
        </span><span class="sh">"""</span>
        <span class="n">clusters</span> <span class="o">=</span> <span class="nf">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">point</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">points</span><span class="p">):</span>
            <span class="c1"># Create hash key by quantizing features
</span>            <span class="c1"># (similar to sorting characters in anagram)
</span>            <span class="n">hash_key</span> <span class="o">=</span> <span class="nf">tuple</span><span class="p">(</span>
                <span class="nf">int</span><span class="p">(</span><span class="n">feature</span> <span class="o">*</span> <span class="n">self</span><span class="p">.</span><span class="n">num_bins</span><span class="p">)</span> <span class="k">for</span> <span class="n">feature</span> <span class="ow">in</span> <span class="n">point</span>
            <span class="p">)</span>
            
            <span class="n">clusters</span><span class="p">[</span><span class="n">hash_key</span><span class="p">].</span><span class="nf">append</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="nf">list</span><span class="p">(</span><span class="n">clusters</span><span class="p">.</span><span class="nf">values</span><span class="p">())</span>


<span class="c1"># Example: Cluster 2D points
</span><span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span>
    <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">],</span>  <span class="c1"># Cluster 1
</span>    <span class="p">[</span><span class="mf">0.12</span><span class="p">,</span> <span class="mf">0.11</span><span class="p">],</span>  <span class="c1"># Cluster 1
</span>    <span class="p">[</span><span class="mf">0.8</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">],</span>  <span class="c1"># Cluster 2
</span>    <span class="p">[</span><span class="mf">0.82</span><span class="p">,</span> <span class="mf">0.88</span><span class="p">],</span>  <span class="c1"># Cluster 2
</span><span class="p">])</span>

<span class="n">clusterer</span> <span class="o">=</span> <span class="nc">SimpleClusterer</span><span class="p">(</span><span class="n">num_bins</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="n">clusters</span> <span class="o">=</span> <span class="n">clusterer</span><span class="p">.</span><span class="nf">cluster</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Clusters: </span><span class="si">{</span><span class="n">clusters</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="2-duplicate-detection">2. Duplicate Detection</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">DocumentDeduplicator</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">
    Detect duplicate or near-duplicate documents.
    
    Uses same pattern as anagram grouping:
    - Hash key: document signature
    - Grouping: similar documents
    </span><span class="sh">"""</span>
    
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">doc_groups</span> <span class="o">=</span> <span class="nf">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">add_document</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">doc_id</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">text</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">Add document to deduplication system.</span><span class="sh">"""</span>
        <span class="c1"># Create signature (like anagram key)
</span>        <span class="n">signature</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">_create_signature</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">doc_groups</span><span class="p">[</span><span class="n">signature</span><span class="p">].</span><span class="nf">append</span><span class="p">(</span><span class="n">doc_id</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">_create_signature</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">text</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sh">"""</span><span class="s">
        Create document signature.
        
        Methods:
        1. Word frequency (like character count)
        2. N-gram hashing
        3. MinHash
        </span><span class="sh">"""</span>
        <span class="c1"># Simple: use sorted bag of words
</span>        <span class="n">words</span> <span class="o">=</span> <span class="n">text</span><span class="p">.</span><span class="nf">lower</span><span class="p">().</span><span class="nf">split</span><span class="p">()</span>
        <span class="k">return</span> <span class="sh">'</span><span class="s"> </span><span class="sh">'</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="nf">sorted</span><span class="p">(</span><span class="n">words</span><span class="p">))</span>
    
    <span class="k">def</span> <span class="nf">find_duplicates</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
        <span class="sh">"""</span><span class="s">Find groups of duplicate documents.</span><span class="sh">"""</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="n">group</span> <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">doc_groups</span><span class="p">.</span><span class="nf">values</span><span class="p">()</span>
            <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">group</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span>
        <span class="p">]</span>


<span class="c1"># Usage
</span><span class="n">dedup</span> <span class="o">=</span> <span class="nc">DocumentDeduplicator</span><span class="p">()</span>
<span class="n">dedup</span><span class="p">.</span><span class="nf">add_document</span><span class="p">(</span><span class="sh">"</span><span class="s">doc1</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">the quick brown fox</span><span class="sh">"</span><span class="p">)</span>
<span class="n">dedup</span><span class="p">.</span><span class="nf">add_document</span><span class="p">(</span><span class="sh">"</span><span class="s">doc2</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">quick brown fox the</span><span class="sh">"</span><span class="p">)</span>  <span class="c1"># Duplicate!
</span><span class="n">dedup</span><span class="p">.</span><span class="nf">add_document</span><span class="p">(</span><span class="sh">"</span><span class="s">doc3</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">hello world</span><span class="sh">"</span><span class="p">)</span>

<span class="n">duplicates</span> <span class="o">=</span> <span class="n">dedup</span><span class="p">.</span><span class="nf">find_duplicates</span><span class="p">()</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Duplicate groups: </span><span class="si">{</span><span class="n">duplicates</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="3-feature-hashing">3. Feature Hashing</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">FeatureHasher</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">
    Hash high-dimensional features to lower dimensions.
    
    Similar to anagram grouping:
    - Hash collisions group similar features
    - Dimensionality reduction via hashing
    </span><span class="sh">"""</span>
    
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">n_features</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">n_features</span> <span class="o">=</span> <span class="n">n_features</span>
    
    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">feature_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sh">"""</span><span class="s">
        Transform feature dictionary to fixed-size vector.
        
        Args:
            feature_dict: {feature_name: value}
            
        Returns:
            Dense feature vector
        </span><span class="sh">"""</span>
        <span class="c1"># Initialize vector
</span>        <span class="n">vector</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">n_features</span><span class="p">)</span>
        
        <span class="c1"># Hash each feature to a bin
</span>        <span class="k">for</span> <span class="n">feature_name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">feature_dict</span><span class="p">.</span><span class="nf">items</span><span class="p">():</span>
            <span class="c1"># Hash feature name to index
</span>            <span class="c1"># (like sorting string to create key)
</span>            <span class="n">hash_idx</span> <span class="o">=</span> <span class="nf">hash</span><span class="p">(</span><span class="n">feature_name</span><span class="p">)</span> <span class="o">%</span> <span class="n">self</span><span class="p">.</span><span class="n">n_features</span>
            <span class="n">vector</span><span class="p">[</span><span class="n">hash_idx</span><span class="p">]</span> <span class="o">+=</span> <span class="n">value</span>
        
        <span class="k">return</span> <span class="n">vector</span>


<span class="c1"># Example: Text features
</span><span class="n">hasher</span> <span class="o">=</span> <span class="nc">FeatureHasher</span><span class="p">(</span><span class="n">n_features</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>

<span class="n">doc1_features</span> <span class="o">=</span> <span class="p">{</span><span class="sh">"</span><span class="s">word_cat</span><span class="sh">"</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="sh">"</span><span class="s">word_dog</span><span class="sh">"</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="sh">"</span><span class="s">word_house</span><span class="sh">"</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>
<span class="n">doc2_features</span> <span class="o">=</span> <span class="p">{</span><span class="sh">"</span><span class="s">word_cat</span><span class="sh">"</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="sh">"</span><span class="s">word_dog</span><span class="sh">"</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="sh">"</span><span class="s">word_car</span><span class="sh">"</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>

<span class="n">vec1</span> <span class="o">=</span> <span class="n">hasher</span><span class="p">.</span><span class="nf">transform</span><span class="p">(</span><span class="n">doc1_features</span><span class="p">)</span>
<span class="n">vec2</span> <span class="o">=</span> <span class="n">hasher</span><span class="p">.</span><span class="nf">transform</span><span class="p">(</span><span class="n">doc2_features</span><span class="p">)</span>

<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Vector 1: </span><span class="si">{</span><span class="n">vec1</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Vector 2: </span><span class="si">{</span><span class="n">vec2</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Similarity: </span><span class="si">{</span><span class="n">np</span><span class="p">.</span><span class="nf">dot</span><span class="p">(</span><span class="n">vec1</span><span class="p">,</span> <span class="n">vec2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="nf">norm</span><span class="p">(</span><span class="n">vec1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="nf">norm</span><span class="p">(</span><span class="n">vec2</span><span class="p">))</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="key-parallels">Key Parallels</h3>

<table>
  <thead>
    <tr>
      <th>Group Anagrams</th>
      <th>Clustering/ML</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Sorted string as hash key</td>
      <td>Feature signature as hash key</td>
    </tr>
    <tr>
      <td>Group identical keys</td>
      <td>Group similar signatures</td>
    </tr>
    <tr>
      <td>O(1) hash lookup</td>
      <td>O(1) hash lookup</td>
    </tr>
    <tr>
      <td>Character frequency</td>
      <td>Feature frequency</td>
    </tr>
    <tr>
      <td>String similarity</td>
      <td>Data point similarity</td>
    </tr>
  </tbody>
</table>

<h2 id="interview-strategy">Interview Strategy</h2>

<h3 id="how-to-approach-in-an-interview">How to Approach in an Interview</h3>

<p><strong>1. Clarify (1 min)</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- Are all strings lowercase? (Yes, per constraints)
- Can strings be empty? (Yes)
- Does order of output matter? (No)
- Memory constraints? (Reasonable for N ≤ 10^4)
</code></pre></div></div>

<p><strong>2. Explain Intuition (2 min)</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"Anagrams have the same characters, just rearranged. If we sort
each string, anagrams become identical. We can use this sorted
string as a hash key to group them together in O(1) time per lookup."
</code></pre></div></div>

<p><strong>3. Discuss Approaches (2 min)</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. Brute force: Compare all pairs - O(N²K)
2. Sorting as key: Sort each string - O(NK log K)
3. Count as key: Count characters - O(NK)

I'll implement approach 2 (sorting) as it's simpler and efficient
enough for the constraints.
</code></pre></div></div>

<p><strong>4. Code (10 min)</strong></p>
<ul>
  <li>Clear variable names</li>
  <li>Add comments</li>
  <li>Handle edge cases</li>
</ul>

<p><strong>5. Test (3 min)</strong></p>
<ul>
  <li>Walk through example</li>
  <li>Edge cases: empty string, single string</li>
</ul>

<p><strong>6. Optimize (2 min)</strong></p>
<ul>
  <li>Discuss count approach for very long strings</li>
</ul>

<h3 id="common-mistakes">Common Mistakes</h3>

<ol>
  <li><strong>Forgetting to handle empty strings</strong>
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Wrong: crashes on empty string
</span><span class="n">key</span> <span class="o">=</span> <span class="nf">sorted</span><span class="p">(</span><span class="n">s</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
   
<span class="c1"># Correct: works for empty
</span><span class="n">key</span> <span class="o">=</span> <span class="sh">''</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="nf">sorted</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
</code></pre></div>    </div>
  </li>
  <li><strong>Using list as hash key</strong>
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Wrong: lists aren't hashable
</span><span class="n">key</span> <span class="o">=</span> <span class="nf">sorted</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>  <span class="c1"># Returns list
</span>   
<span class="c1"># Correct: convert to string or tuple
</span><span class="n">key</span> <span class="o">=</span> <span class="sh">''</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="nf">sorted</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
<span class="n">key</span> <span class="o">=</span> <span class="nf">tuple</span><span class="p">(</span><span class="nf">sorted</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
</code></pre></div>    </div>
  </li>
  <li><strong>Not considering case sensitivity</strong>
    <ul>
      <li>Problem says lowercase only, but clarify in interview</li>
    </ul>
  </li>
  <li><strong>Inefficient anagram checking in brute force</strong>
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Inefficient
</span><span class="k">def</span> <span class="nf">are_anagrams</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">):</span>
    <span class="k">return</span> <span class="nf">sorted</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span> <span class="o">==</span> <span class="nf">sorted</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span>
   
<span class="c1"># Better: use Counter
</span><span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">Counter</span>
<span class="k">return</span> <span class="nc">Counter</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span> <span class="o">==</span> <span class="nc">Counter</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span>
</code></pre></div>    </div>
  </li>
</ol>

<h3 id="follow-up-questions">Follow-up Questions</h3>

<p><strong>Q1: How would you find the largest group of anagrams?</strong></p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">find_largest_anagram_group</span><span class="p">(</span><span class="n">strs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
    <span class="sh">"""</span><span class="s">Find the group with most anagrams.</span><span class="sh">"""</span>
    <span class="n">anagram_map</span> <span class="o">=</span> <span class="nf">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">strs</span><span class="p">:</span>
        <span class="n">key</span> <span class="o">=</span> <span class="sh">''</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="nf">sorted</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
        <span class="n">anagram_map</span><span class="p">[</span><span class="n">key</span><span class="p">].</span><span class="nf">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    
    <span class="c1"># Return largest group
</span>    <span class="k">return</span> <span class="nf">max</span><span class="p">(</span><span class="n">anagram_map</span><span class="p">.</span><span class="nf">values</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="nb">len</span><span class="p">)</span>
</code></pre></div></div>

<p><strong>Q2: Can you do this without sorting?</strong></p>

<p>Yes! Use character count (shown in Approach 3).</p>

<p><strong>Q3: How would you handle very large datasets?</strong></p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="sh">"""</span><span class="s">
For datasets that don</span><span class="sh">'</span><span class="s">t fit in memory:
1. Use external sorting / MapReduce
2. Process in batches
3. Use database with hash index
4. Stream processing with approximate grouping
</span><span class="sh">"""</span>

<span class="k">def</span> <span class="nf">group_anagrams_distributed</span><span class="p">(</span><span class="n">strs_iterator</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">
    Process large dataset in streaming fashion.
    
    MapReduce approach:
    - Map: (string -&gt; (sorted_key, string))
    - Reduce: Group by sorted_key
    </span><span class="sh">"""</span>
    <span class="k">pass</span>
</code></pre></div></div>

<p><strong>Q4: What if we want fuzzy matching (allow 1-2 character differences)?</strong></p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">group_similar_strings</span><span class="p">(</span><span class="n">strs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">max_diff</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
    <span class="sh">"""</span><span class="s">
    Group strings that are similar (not exact anagrams).
    
    This requires different approach:
    - Locality-sensitive hashing
    - Edit distance clustering
    - N-gram similarity
    </span><span class="sh">"""</span>
    <span class="c1"># More complex - would need LSH or edit distance
</span>    <span class="k">pass</span>
</code></pre></div></div>

<h2 id="key-takeaways">Key Takeaways</h2>

<p>✅ <strong>Hash tables are perfect for grouping</strong> - O(1) lookup and insertion</p>

<p>✅ <strong>Good hash keys are canonical</strong> - sorted string represents all anagrams</p>

<p>✅ <strong>Two main approaches:</strong> Sorting O(NK log K) vs Counting O(NK)</p>

<p>✅ <strong>Character count is faster</strong> for very long strings (K » 26)</p>

<p>✅ <strong>Pattern applies broadly:</strong> Document clustering, duplicate detection, feature hashing</p>

<p>✅ <strong>Production considerations:</strong> Unicode support, case-insensitivity, streaming</p>

<p>✅ <strong>Same pattern in clustering:</strong> Hash key = feature signature, grouping = clustering</p>

<p>✅ <strong>Same pattern in speaker diarization:</strong> Hash key = voice embedding, grouping = speaker clusters</p>

<p>✅ <strong>Defaultdict is cleaner</strong> than manually checking key existence</p>

<p>✅ <strong>Testing is crucial:</strong> Edge cases (empty strings, single string, all anagrams)</p>

<h3 id="mental-model">Mental Model</h3>

<p>Think of this problem as:</p>
<ul>
  <li><strong>Anagrams:</strong> Hash-based string grouping</li>
  <li><strong>Clustering:</strong> Hash-based data point grouping</li>
  <li><strong>Speaker Diarization:</strong> Hash-based audio segment grouping</li>
</ul>

<p>All use the same pattern: <strong>create signature → hash → group by signature</strong></p>

<h2 id="additional-practice--variants">Additional Practice &amp; Variants</h2>

<p>If you want to deepen your understanding and move closer to production use cases, here are some structured follow-ups:</p>

<ul>
  <li><strong>Variant 1 – Top-K Anagram Groups:</strong>
    <ul>
      <li>Given a list of words, return only the <strong>K largest</strong> anagram groups.</li>
      <li>Forces you to combine grouping with <strong>heap / sorting</strong> logic.</li>
      <li>Think about how to stream this when the vocabulary is huge.</li>
    </ul>
  </li>
  <li><strong>Variant 2 – Online Anagram Service:</strong>
    <ul>
      <li>Build an HTTP service with two endpoints:
        <ul>
          <li><code class="language-plaintext highlighter-rouge">POST /word</code> to insert a new word into the system.</li>
          <li><code class="language-plaintext highlighter-rouge">GET /anagrams?word=...</code> to retrieve all known anagrams of a given word.</li>
        </ul>
      </li>
      <li>Internally, you still use the same <strong>signature → list-of-words</strong> hash map,
but now you must think about:
        <ul>
          <li>Concurrency (multiple writers/readers),</li>
          <li>Persistence (Redis / database),</li>
          <li>Eviction or TTLs if memory is constrained.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>Variant 3 – Fuzzy Anagrams:</strong>
    <ul>
      <li>Allow up to 1 character insertion/deletion/substitution (edit distance 1).</li>
      <li>You can still start from the exact-anagram hash grouping,
but now you need a <strong>secondary similarity check</strong> inside each bucket.</li>
      <li>This parallels approximate matching in search systems and LSH in clustering.</li>
    </ul>
  </li>
</ul>

<p>Beyond interviews, this problem is a good mental model for any system where you:</p>
<ol>
  <li>Define a <strong>signature</strong> for items (exact or approximate),</li>
  <li>Use that signature as a <strong>hash key or index</strong>,</li>
  <li>Group or retrieve items efficiently based on that signature.</li>
</ol>

<p>Once you can explain and implement this pattern fluently, you are in a good place
to reason about higher-level systems like feature stores, deduplication pipelines,
and similarity-based retrieval engines.</p>

<hr />

<p><strong>Originally published at:</strong> <a href="https://www.arunbaby.com/dsa/0015-group-anagrams/">arunbaby.com/dsa/0015-group-anagrams</a></p>

<p><em>If you found this helpful, consider sharing it with others who might benefit.</em></p>


        
      </section>

      <footer class="page__meta">
        
        
  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-tags" aria-hidden="true"></i> Tags: </strong>
    <span itemprop="keywords">
    
      <a href="/tags/#anagrams" class="page__taxonomy-item p-category" rel="tag">anagrams</a><span class="sep">, </span>
    
      <a href="/tags/#grouping" class="page__taxonomy-item p-category" rel="tag">grouping</a><span class="sep">, </span>
    
      <a href="/tags/#hash-table" class="page__taxonomy-item p-category" rel="tag">hash-table</a><span class="sep">, </span>
    
      <a href="/tags/#medium-easy" class="page__taxonomy-item p-category" rel="tag">medium-easy</a><span class="sep">, </span>
    
      <a href="/tags/#sorting" class="page__taxonomy-item p-category" rel="tag">sorting</a><span class="sep">, </span>
    
      <a href="/tags/#string" class="page__taxonomy-item p-category" rel="tag">string</a>
    
    </span>
  </p>




  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> Categories: </strong>
    <span itemprop="keywords">
    
      <a href="/categories/#dsa" class="page__taxonomy-item p-category" rel="tag">dsa</a>
    
    </span>
  </p>


        
      </footer>

      <div class="page__related page__related--full">
  <h2 class="page__related-title">Related across topics</h2>
  <style>
    /* Make section span full content width and use 2 equal columns */
    .page__related--full { float: inline-start; width: 100%; padding: 0; }
    .cross-related-grid { display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 2rem; }
    @media (max-width: 768px) { .cross-related-grid { grid-template-columns: 1fr; } }
    /* Ensure archive cards stretch nicely in the grid */
    .cross-related-grid .list__item, .cross-related-grid .grid__item { width: auto; float: none; margin: 0; }
  </style>
  <div class="cross-related-grid">
    



<div class="list__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/ml-system-design/0015-clustering-systems/" rel="permalink">Clustering Systems
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          23 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">Design production clustering systems that group similar items using hash-based and distance-based approaches for recommendations, search, and analytics.
</p>
  </article>
</div>




<div class="list__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/speech-tech/0015-speaker-clustering-diarization/" rel="permalink">Speaker Clustering (Diarization)
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          16 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">Build production speaker diarization systems that cluster audio segments by speaker using embedding-based similarity and hash-based grouping.
</p>
  </article>
</div>

  </div>
</div>

      <section class="page__share">
  <h4 class="page__share-title">Share on</h4>

  <a href="https://twitter.com/intent/tweet?via=arunbaby0&text=Group+Anagrams%20https%3A%2F%2Fwww.arunbaby.com%2Fdsa%2F0015-group-anagrams%2F" class="btn btn--twitter" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Twitter"><i class="fab fa-fw fa-twitter" aria-hidden="true"></i><span> Twitter</span></a>

  <a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fwww.arunbaby.com%2Fdsa%2F0015-group-anagrams%2F" class="btn btn--facebook" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Facebook"><i class="fab fa-fw fa-facebook" aria-hidden="true"></i><span> Facebook</span></a>

  <a href="https://www.linkedin.com/shareArticle?mini=true&url=https://www.arunbaby.com/dsa/0015-group-anagrams/" class="btn btn--linkedin" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on LinkedIn"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i><span> LinkedIn</span></a>
</section>


      
  <nav class="pagination">
    
      <a href="/dsa/0014-generate-parentheses/" class="pagination--pager" title="Generate Parentheses">Previous</a>
    
    
      <a href="/dsa/0016-merge-intervals/" class="pagination--pager" title="Merge Intervals">Next</a>
    
  </nav>


    </div>

    
  </article>

  
  
</div>

      
    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';" role="search">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Enter your search term..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    

    
      
        
          <li><a href="https://twitter.com/arunbaby0" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-twitter-square" aria-hidden="true"></i> Twitter</a></li>
        
      
        
          <li><a href="https://github.com/arunbaby0" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
        
      
        
          <li><a href="https://www.linkedin.com/in/arunbaby0/" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i> LinkedIn</a></li>
        
      
        
          <li><a href="https://scholar.google.co.in/citations?user=6fSYWhkAAAAJ" rel="nofollow noopener noreferrer"><i class="fas fa-fw fa-graduation-cap" aria-hidden="true"></i> Google Scholar</a></li>
        
      
    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 1990 - 2143 <a href="https://www.arunbaby.com">Arun Baby</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>




  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-0JRJPEC9SS"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-0JRJPEC9SS', { 'anonymize_ip': false});
</script>








  </body>
</html>
