<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.26.2 by Michael Rose
  Copyright 2013-2024 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->

<html lang="en-US" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Median of Two Sorted Arrays - Arun Baby</title>
<meta name="description" content="“Finding the middle ground between two ordered worlds.”">


  <meta name="author" content="Arun Baby">
  
  <meta property="article:author" content="Arun Baby">
  


<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="Arun Baby">
<meta property="og:title" content="Median of Two Sorted Arrays">
<meta property="og:url" content="https://www.arunbaby.com/dsa/0043-median-of-two-sorted-arrays/">


  <meta property="og:description" content="“Finding the middle ground between two ordered worlds.”">



  <meta property="og:image" content="https://www.arunbaby.com/assets/images/profile-photo.png">



  <meta name="twitter:site" content="@arunbaby0">
  <meta name="twitter:title" content="Median of Two Sorted Arrays">
  <meta name="twitter:description" content="“Finding the middle ground between two ordered worlds.”">
  <meta name="twitter:url" content="https://www.arunbaby.com/dsa/0043-median-of-two-sorted-arrays/">

  
    <meta name="twitter:card" content="summary">
    
      <meta name="twitter:image" content="https://www.arunbaby.com/assets/images/profile-photo.png">
    
  

  



  <meta property="article:published_time" content="2025-12-31T10:08:45+05:30">





  

  


<link rel="canonical" href="https://www.arunbaby.com/dsa/0043-median-of-two-sorted-arrays/">












<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Arun Baby Feed">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
  
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css"></noscript>



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--single" dir="ltr">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
           
          <span class="site-subtitle">Arun Baby</span>
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a
                href="/about/"
                
                
              >About</a>
            </li><li class="masthead__menu-item">
              <a
                href="/dsa/"
                
                
              >DSA</a>
            </li><li class="masthead__menu-item">
              <a
                href="/ml-system-design/"
                
                
              >ML Systems</a>
            </li><li class="masthead__menu-item">
              <a
                href="/speech-tech/"
                
                
              >Speech Tech</a>
            </li><li class="masthead__menu-item">
              <a
                href="/ai-agents/"
                
                
              >AI Agents</a>
            </li><li class="masthead__menu-item">
              <a
                href="/publications/"
                
                
              >Publications</a>
            </li><li class="masthead__menu-item">
              <a
                href="/statuses/"
                
                
              >Statuses</a>
            </li><li class="masthead__menu-item">
              <a
                href="/contact/"
                
                
              >Contact</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <i class="fas fa-search"></i>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      





<div id="main" role="main" class="no-author-sidebar">
  
  <div class="sidebar sticky">
  
  
  </div>



  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="Median of Two Sorted Arrays">
    <meta itemprop="description" content="“Finding the middle ground between two ordered worlds.”">
    <meta itemprop="datePublished" content="2025-12-31T10:08:45+05:30">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">
            <a href="https://www.arunbaby.com/dsa/0043-median-of-two-sorted-arrays/" itemprop="url">Median of Two Sorted Arrays
</a>
          </h1>
          

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          17 minute read
        
      </span>
    
  </p>


        </header>
      

      <section class="page__content" itemprop="text">
        
          <aside class="sidebar__right sticky">
            <nav class="toc">
              <header><h4 class="nav__title"><i class="fas fa-file-alt"></i> On this page</h4></header>
              <ul class="toc__menu"><li><a href="#1-problem-statement">1. Problem Statement</a></li><li><a href="#2-understanding-the-median">2. Understanding the Median</a></li><li><a href="#3-approach-1-merge-and-find-brute-force">3. Approach 1: Merge and Find (Brute Force)</a></li><li><a href="#4-approach-2-two-pointer-merge-no-full-merge">4. Approach 2: Two-Pointer Merge (No Full Merge)</a></li><li><a href="#5-approach-3-binary-search-optimal">5. Approach 3: Binary Search (Optimal)</a></li><li><a href="#6-detailed-walkthrough">6. Detailed Walkthrough</a></li><li><a href="#7-why-binary-search-works">7. Why Binary Search Works</a></li><li><a href="#8-edge-cases">8. Edge Cases</a></li><li><a href="#9-system-design-distributed-median-finding">9. System Design: Distributed Median Finding</a></li><li><a href="#10-deep-dive-kth-element-in-two-sorted-arrays">10. Deep Dive: Kth Element in Two Sorted Arrays</a></li><li><a href="#11-production-application-real-time-percentile-computation">11. Production Application: Real-Time Percentile Computation</a></li><li><a href="#12-interview-questions">12. Interview Questions</a></li><li><a href="#13-common-mistakes">13. Common Mistakes</a></li><li><a href="#14-variant-median-of-k-sorted-arrays">14. Variant: Median of K Sorted Arrays</a></li><li><a href="#15-mathematical-proof-of-correctness">15. Mathematical Proof of Correctness</a></li><li><a href="#16-deep-dive-weighted-median">16. Deep Dive: Weighted Median</a></li><li><a href="#17-performance-benchmarking">17. Performance Benchmarking</a></li><li><a href="#18-alternative-divide-and-conquer">18. Alternative: Divide and Conquer</a></li><li><a href="#19-conclusion">19. Conclusion</a></li><li><a href="#20-related-problems">20. Related Problems</a></li><li><a href="#21-deep-dive-median-in-a-stream-two-heaps">21. Deep Dive: Median in a Stream (Two Heaps)</a></li><li><a href="#22-deep-dive-median-in-a-matrix-binary-search-on-value">22. Deep Dive: Median in a Matrix (Binary Search on Value)</a></li><li><a href="#23-variant-sliding-window-median">23. Variant: Sliding Window Median</a></li><li><a href="#24-application-ab-testing-statistics">24. Application: A/B Testing Statistics</a></li><li><a href="#25-application-database-query-optimization">25. Application: Database Query Optimization</a></li><li><a href="#26-deep-dive-approximating-median-with-t-digest">26. Deep Dive: Approximating Median with T-Digest</a></li><li><a href="#27-testing-strategy">27. Testing Strategy</a></li><li><a href="#28-interview-tips">28. Interview Tips</a></li><li><a href="#29-common-follow-up-questions">29. Common Follow-up Questions</a></li><li><a href="#30-mastery-checklist">30. Mastery Checklist</a></li><li><a href="#31-conclusion">31. Conclusion</a></li></ul>
            </nav>
          </aside>
        
        <p><strong>“Finding the middle ground between two ordered worlds.”</strong></p>

<h2 id="1-problem-statement">1. Problem Statement</h2>

<p>Given two sorted arrays <code class="language-plaintext highlighter-rouge">nums1</code> and <code class="language-plaintext highlighter-rouge">nums2</code> of size <code class="language-plaintext highlighter-rouge">m</code> and <code class="language-plaintext highlighter-rouge">n</code> respectively, return the <strong>median</strong> of the two sorted arrays.</p>

<p>The overall run time complexity should be <code class="language-plaintext highlighter-rouge">O(\log(m+n))</code>.</p>

<p><strong>Example 1:</strong>
<code class="language-plaintext highlighter-rouge">
Input: nums1 = [1,3], nums2 = [2]
Output: 2.00000
Explanation: merged array = [1,2,3] and median is 2.
</code></p>

<p><strong>Example 2:</strong>
<code class="language-plaintext highlighter-rouge">
Input: nums1 = [1,2], nums2 = [3,4]
Output: 2.50000
Explanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.
</code></p>

<p><strong>Constraints:</strong></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">nums1.length == m</code></li>
  <li><code class="language-plaintext highlighter-rouge">nums2.length == n</code></li>
  <li><code class="language-plaintext highlighter-rouge">0 &lt;= m &lt;= 1000</code></li>
  <li><code class="language-plaintext highlighter-rouge">0 &lt;= n &lt;= 1000</code></li>
  <li><code class="language-plaintext highlighter-rouge">1 &lt;= m + n &lt;= 2000</code></li>
  <li><code class="language-plaintext highlighter-rouge">-10^6 &lt;= nums1[i], nums2[i] &lt;= 10^6</code></li>
</ul>

<h2 id="2-understanding-the-median">2. Understanding the Median</h2>

<p><strong>Definition:</strong></p>
<ul>
  <li>For an odd-length array: the middle element.</li>
  <li>For an even-length array: the average of the two middle elements.</li>
</ul>

<p><strong>Key Insight:</strong> The median divides the combined array into two equal halves:</p>
<ul>
  <li>Left half: All elements ≤ median.</li>
  <li>Right half: All elements ≥ median.</li>
</ul>

<h2 id="3-approach-1-merge-and-find-brute-force">3. Approach 1: Merge and Find (Brute Force)</h2>

<p><strong>Algorithm:</strong></p>
<ol>
  <li>Merge both arrays into one sorted array.</li>
  <li>Find the median.</li>
</ol>

<p>``python
def findMedianSortedArrays(nums1, nums2):
 merged = sorted(nums1 + nums2)
 n = len(merged)</p>

<p>if n % 2 == 1:
 return merged[n // 2]
 else:
 return (merged[n // 2 - 1] + merged[n // 2]) / 2
``</p>

<p><strong>Complexity:</strong></p>
<ul>
  <li><strong>Time:</strong> <code class="language-plaintext highlighter-rouge">O((m+n) \log(m+n))</code> for sorting, or O(m+n) if using merge sort’s merge step.</li>
  <li><strong>Space:</strong> O(m+n) for the merged array.</li>
</ul>

<p><strong>Issue:</strong> Doesn’t meet the <code class="language-plaintext highlighter-rouge">O(\log(m+n))</code> requirement.</p>

<h2 id="4-approach-2-two-pointer-merge-no-full-merge">4. Approach 2: Two-Pointer Merge (No Full Merge)</h2>

<p><strong>Algorithm:</strong></p>
<ol>
  <li>Use two pointers to “virtually” merge.</li>
  <li>Stop when we reach the median position.</li>
</ol>

<p>``python
def findMedianSortedArrays(nums1, nums2):
 m, n = len(nums1), len(nums2)
 total = m + n</p>

<p># We need element at (total-1)//2 and total//2 for median
 target1 = (total - 1) // 2
 target2 = total // 2</p>

<p>i = j = 0
 val1 = val2 = 0</p>

<p>for k in range(target2 + 1):
 if i &lt; m and (j &gt;= n or nums1[i] &lt;= nums2[j]):
 val = nums1[i]
 i += 1
 else:
 val = nums2[j]
 j += 1</p>

<p>if k == target1:
 val1 = val
 if k == target2:
 val2 = val</p>

<p>return (val1 + val2) / 2
``</p>

<p><strong>Complexity:</strong></p>
<ul>
  <li><strong>Time:</strong> O(m+n).</li>
  <li><strong>Space:</strong> O(1).</li>
</ul>

<p><strong>Still doesn’t meet</strong> the <code class="language-plaintext highlighter-rouge">O(\log(m+n))</code> requirement.</p>

<h2 id="5-approach-3-binary-search-optimal">5. Approach 3: Binary Search (Optimal)</h2>

<p><strong>Key Insight:</strong> We need to partition both arrays such that:</p>
<ol>
  <li>Left partition has <code class="language-plaintext highlighter-rouge">(m + n + 1) // 2</code> elements.</li>
  <li>All elements in left partition ≤ all elements in right partition.</li>
</ol>

<p><strong>Algorithm:</strong></p>
<ol>
  <li>Binary search on the smaller array.</li>
  <li>For each partition of the smaller array, compute the corresponding partition of the larger array.</li>
  <li>Check if the partition is valid.</li>
</ol>

<p>``python
def findMedianSortedArrays(nums1, nums2):
 # Ensure nums1 is the smaller array
 if len(nums1) &gt; len(nums2):
 nums1, nums2 = nums2, nums1</p>

<p>m, n = len(nums1), len(nums2)
 total = m + n
 half = (total + 1) // 2</p>

<p>lo, hi = 0, m</p>

<p>while lo &lt;= hi:
 i = (lo + hi) // 2 # Partition index for nums1
 j = half - i # Partition index for nums2</p>

<p># Edge handling with -inf and +inf
 nums1_left = nums1[i - 1] if i &gt; 0 else float(‘-inf’)
 nums1_right = nums1[i] if i &lt; m else float(‘inf’)
 nums2_left = nums2[j - 1] if j &gt; 0 else float(‘-inf’)
 nums2_right = nums2[j] if j &lt; n else float(‘inf’)</p>

<p># Check if partition is valid
 if nums1_left &lt;= nums2_right and nums2_left &lt;= nums1_right:
 # Valid partition found
 if total % 2 == 1:
 return max(nums1_left, nums2_left)
 else:
 return (max(nums1_left, nums2_left) + min(nums1_right, nums2_right)) / 2
 elif nums1_left &gt; nums2_right:
 hi = i - 1 # Too many elements from nums1
 else:
 lo = i + 1 # Too few elements from nums1</p>

<p>return 0 # Should never reach here
``</p>

<p><strong>Complexity:</strong></p>
<ul>
  <li><strong>Time:</strong> <code class="language-plaintext highlighter-rouge">O(\log(\min(m, n)))</code>.</li>
  <li><strong>Space:</strong> O(1).</li>
</ul>

<h2 id="6-detailed-walkthrough">6. Detailed Walkthrough</h2>

<p><strong>Example:</strong> <code class="language-plaintext highlighter-rouge">nums1 = [1, 3, 8, 9, 15]</code>, <code class="language-plaintext highlighter-rouge">nums2 = [7, 11, 18, 19, 21, 25]</code></p>

<p><strong>Setup:</strong></p>
<ul>
  <li>m = 5, n = 6, total = 11.</li>
  <li>half = (11 + 1) // 2 = 6.</li>
  <li>Need 6 elements in left partition.</li>
</ul>

<p><strong>Binary Search:</strong></p>

<p><strong>Iteration 1:</strong> lo=0, hi=5, i=2, j=6-2=4</p>
<ul>
  <li>nums1_left = nums1[1] = 3</li>
  <li>nums1_right = nums1[2] = 8</li>
  <li>nums2_left = nums2[3] = 19</li>
  <li>nums2_right = nums2[4] = 21</li>
  <li>Check: 3 ≤ 21 ✓, 19 ≤ 8 ✗</li>
  <li>19 &gt; 8, so we need more from nums1. lo = 3.</li>
</ul>

<p><strong>Iteration 2:</strong> lo=3, hi=5, i=4, j=6-4=2</p>
<ul>
  <li>nums1_left = nums1[3] = 9</li>
  <li>nums1_right = nums1[4] = 15</li>
  <li>nums2_left = nums2[1] = 11</li>
  <li>nums2_right = nums2[2] = 18</li>
  <li>Check: 9 ≤ 18 ✓, 11 ≤ 15 ✓</li>
  <li>Valid partition!</li>
  <li>Odd total: median = max(9, 11) = 11.</li>
</ul>

<p><strong>Merged Array (for verification):</strong> [1, 3, 7, 8, 9, <strong>11</strong>, 15, 18, 19, 21, 25]. Median = 11. ✓</p>

<h2 id="7-why-binary-search-works">7. Why Binary Search Works</h2>

<p><strong>Invariant:</strong> If we take <code class="language-plaintext highlighter-rouge">i</code> elements from nums1, we must take <code class="language-plaintext highlighter-rouge">half - i</code> elements from nums2.</p>

<p><strong>Validity Condition:</strong></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">nums1[i-1] ≤ nums2[j]</code>: Largest in nums1’s left ≤ smallest in nums2’s right.</li>
  <li><code class="language-plaintext highlighter-rouge">nums2[j-1] ≤ nums1[i]</code>: Largest in nums2’s left ≤ smallest in nums1’s right.</li>
</ul>

<p><strong>Binary Search Logic:</strong></p>
<ul>
  <li>If <code class="language-plaintext highlighter-rouge">nums1[i-1] &gt; nums2[j]</code>: We took too many from nums1. Decrease i.</li>
  <li>If <code class="language-plaintext highlighter-rouge">nums2[j-1] &gt; nums1[i]</code>: We took too few from nums1. Increase i.</li>
</ul>

<h2 id="8-edge-cases">8. Edge Cases</h2>

<ol>
  <li><strong>One Array is Empty:</strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">nums1 = []</code>, <code class="language-plaintext highlighter-rouge">nums2 = [2, 3]</code> → Median of nums2 = 2.5.</li>
      <li>Handle with <code class="language-plaintext highlighter-rouge">-inf</code> and <code class="language-plaintext highlighter-rouge">+inf</code> sentinels.</li>
    </ul>
  </li>
  <li><strong>Arrays of Different Sizes:</strong>
    <ul>
      <li>Always binary search on the smaller array for efficiency.</li>
    </ul>
  </li>
  <li><strong>All Elements in One Array are Smaller:</strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">nums1 = [1, 2]</code>, <code class="language-plaintext highlighter-rouge">nums2 = [3, 4, 5, 6]</code>.</li>
      <li>Partition: All of nums1 in left, some of nums2 in left.</li>
    </ul>
  </li>
  <li><strong>Single Element Arrays:</strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">nums1 = [1]</code>, <code class="language-plaintext highlighter-rouge">nums2 = [2]</code> → Median = 1.5.</li>
    </ul>
  </li>
</ol>

<h2 id="9-system-design-distributed-median-finding">9. System Design: Distributed Median Finding</h2>

<p><strong>Problem:</strong> Find the median of data distributed across k servers.</p>

<p><strong>Naive Approach:</strong> Collect all data, sort, find median. O(N \log N).</p>

<p><strong>Efficient Approach (Sampling-Based):</strong></p>
<ol>
  <li><strong>Sample:</strong> Each server sends a random sample.</li>
  <li><strong>Estimate:</strong> Find approximate median from samples.</li>
  <li><strong>Count:</strong> Each server counts elements &lt; median, &gt; median.</li>
  <li><strong>Refine:</strong> Narrow the range containing the true median.</li>
</ol>

<p><strong>Algorithm (Binary Search on Value):</strong></p>
<ol>
  <li>Binary search on the median value (not indices).</li>
  <li>For each candidate value, count how many elements are ≤ it.</li>
  <li>If count = (total + 1) / 2, we found the median.</li>
</ol>

<h2 id="10-deep-dive-kth-element-in-two-sorted-arrays">10. Deep Dive: Kth Element in Two Sorted Arrays</h2>

<p><strong>Generalization:</strong> Find the k-th smallest element in two sorted arrays.</p>

<p><strong>Algorithm (Binary Search):</strong>
``python
def findKthElement(nums1, nums2, k):
 if len(nums1) &gt; len(nums2):
 nums1, nums2 = nums2, nums1</p>

<p>m, n = len(nums1), len(nums2)
 lo, hi = max(0, k - n), min(k, m)</p>

<p>while lo &lt;= hi:
 i = (lo + hi) // 2
 j = k - i</p>

<p>nums1_left = nums1[i - 1] if i &gt; 0 else float(‘-inf’)
 nums1_right = nums1[i] if i &lt; m else float(‘inf’)
 nums2_left = nums2[j - 1] if j &gt; 0 else float(‘-inf’)
 nums2_right = nums2[j] if j &lt; n else float(‘inf’)</p>

<p>if nums1_left &lt;= nums2_right and nums2_left &lt;= nums1_right:
 return max(nums1_left, nums2_left)
 elif nums1_left &gt; nums2_right:
 hi = i - 1
 else:
 lo = i + 1</p>

<p>return -1
``</p>

<p><strong>Use Case:</strong> Median is just k = (m + n + 1) // 2.</p>

<h2 id="11-production-application-real-time-percentile-computation">11. Production Application: Real-Time Percentile Computation</h2>

<p><strong>Scenario:</strong> Compute the 99th percentile latency from logs stored on multiple servers.</p>

<p><strong>Algorithm:</strong></p>
<ol>
  <li><strong>Histogram Binning:</strong> Each server maintains a histogram of latencies.</li>
  <li><strong>Merge Histograms:</strong> Sum histograms across servers.</li>
  <li><strong>Find Percentile:</strong> Walk through the merged histogram.</li>
</ol>

<p><strong>Optimization:</strong></p>
<ul>
  <li>Use exponential binning (log-scale) for accuracy across wide ranges.</li>
  <li>Stream histograms instead of raw data (reduces network traffic).</li>
</ul>

<h2 id="12-interview-questions">12. Interview Questions</h2>

<ol>
  <li><strong>Median of Two Sorted Arrays (Classic):</strong> Solve with binary search.</li>
  <li><strong>Kth Smallest Element:</strong> Generalize the median solution.</li>
  <li><strong>Median of Data Stream:</strong> Design with two heaps.</li>
  <li><strong>Distributed Median:</strong> Explain the sampling + counting approach.</li>
  <li><strong>Running Median:</strong> Use balanced BST or two heaps.</li>
</ol>

<h2 id="13-common-mistakes">13. Common Mistakes</h2>

<ul>
  <li><strong>Not Handling Empty Arrays:</strong> Leads to index out of bounds.</li>
  <li><strong>Off-by-One in Partition:</strong> Careful with i-1, j-1.</li>
  <li><strong>Binary Searching the Wrong Array:</strong> Always search the smaller one.</li>
  <li><strong>Integer Overflow:</strong> (a + b) / 2 can overflow. Use a + (b - a) / 2.</li>
  <li><strong>Forgetting Even/Odd Cases:</strong> Median calculation differs.</li>
</ul>

<h2 id="14-variant-median-of-k-sorted-arrays">14. Variant: Median of K Sorted Arrays</h2>

<p><strong>Problem:</strong> Given k sorted arrays, find the overall median.</p>

<p><strong>Approach 1: Sequential Merge</strong></p>
<ul>
  <li>Merge pairs until one array remains.</li>
  <li>Find median.</li>
  <li><strong>Time:</strong> O(N \log k) where N is total elements.</li>
</ul>

<p><strong>Approach 2: Binary Search on Value</strong></p>
<ul>
  <li>Binary search on the median value.</li>
  <li>For each candidate, count elements ≤ it in all arrays using binary search.</li>
  <li><strong>Time:</strong> O(k \log V \log N) where V is the value range.</li>
</ul>

<h2 id="15-mathematical-proof-of-correctness">15. Mathematical Proof of Correctness</h2>

<p><strong>Theorem:</strong> The binary search algorithm correctly finds the median.</p>

<p><strong>Proof:</strong></p>
<ol>
  <li><strong>Partition Property:</strong> The left partition has exactly <code class="language-plaintext highlighter-rouge">(m + n + 1) // 2</code> elements.</li>
  <li><strong>Validity:</strong> If <code class="language-plaintext highlighter-rouge">nums1[i-1] ≤ nums2[j]</code> and <code class="language-plaintext highlighter-rouge">nums2[j-1] ≤ nums1[i]</code>, then all left elements ≤ all right elements.</li>
  <li><strong>Binary Search Correctness:</strong>
    <ul>
      <li>If <code class="language-plaintext highlighter-rouge">nums1[i-1] &gt; nums2[j]</code>, we need fewer elements from nums1 (decrease i).</li>
      <li>If <code class="language-plaintext highlighter-rouge">nums2[j-1] &gt; nums1[i]</code>, we need more elements from nums1 (increase i).</li>
    </ul>
  </li>
  <li><strong>Termination:</strong> Binary search terminates when a valid partition is found.</li>
  <li><strong>Median:</strong> The median is max(left) or (max(left) + min(right)) / 2.</li>
</ol>

<h2 id="16-deep-dive-weighted-median">16. Deep Dive: Weighted Median</h2>

<p><strong>Problem:</strong> Given elements with weights, find the median where weight sums to 50% on each side.</p>

<p><strong>Algorithm:</strong></p>
<ol>
  <li>Sort elements by value.</li>
  <li>Accumulate weights.</li>
  <li>Find where cumulative weight = total_weight / 2.</li>
</ol>

<p><strong>Use Case:</strong> Weighted voting, robust averaging.</p>

<h2 id="17-performance-benchmarking">17. Performance Benchmarking</h2>

<p>``python
import time
import random</p>

<p>def benchmark():
 sizes = [(100, 100), (1000, 1000), (10000, 10000)]</p>

<p>for m, n in sizes:
 nums1 = sorted(random.sample(range(1000000), m))
 nums2 = sorted(random.sample(range(1000000), n))</p>

<p># Binary Search
 start = time.time()
 for _ in range(1000):
 findMedianSortedArrays(nums1, nums2)
 bs_time = time.time() - start</p>

<p># Merge
 start = time.time()
 for _ in range(1000):
 findMedian_merge(nums1, nums2)
 merge_time = time.time() - start</p>

<p>print(f”m={m}, n={n}: BS={bs_time:.4f}s, Merge={merge_time:.4f}s”)</p>

<h1 id="expected-binary-search-is-significantly-faster-for-large-arrays">Expected: Binary search is significantly faster for large arrays</h1>
<p>``</p>

<h2 id="18-alternative-divide-and-conquer">18. Alternative: Divide and Conquer</h2>

<p><strong>Algorithm:</strong></p>
<ol>
  <li>Compare medians of both arrays.</li>
  <li>Discard the half that cannot contain the overall median.</li>
  <li>Recur on the remaining halves.</li>
</ol>

<p>``python
def findMedian_DC(nums1, nums2):
 def kth(a, a_start, a_end, b, b_start, b_end, k):
 if a_start &gt; a_end:
 return b[b_start + k - 1]
 if b_start &gt; b_end:
 return a[a_start + k - 1]
 if k == 1:
 return min(a[a_start], b[b_start])</p>

<p>mid_a = float(‘inf’) if a_start + k // 2 - 1 &gt; a_end else a[a_start + k // 2 - 1]
 mid_b = float(‘inf’) if b_start + k // 2 - 1 &gt; b_end else b[b_start + k // 2 - 1]</p>

<p>if mid_a &lt; mid_b:
 return kth(a, a_start + k // 2, a_end, b, b_start, b_end, k - k // 2)
 else:
 return kth(a, a_start, a_end, b, b_start + k // 2, b_end, k - k // 2)</p>

<p>m, n = len(nums1), len(nums2)
 total = m + n</p>

<p>if total % 2 == 1:
 return kth(nums1, 0, m - 1, nums2, 0, n - 1, total // 2 + 1)
 else:
 left = kth(nums1, 0, m - 1, nums2, 0, n - 1, total // 2)
 right = kth(nums1, 0, m - 1, nums2, 0, n - 1, total // 2 + 1)
 return (left + right) / 2
``</p>

<p><strong>Complexity:</strong> <code class="language-plaintext highlighter-rouge">O(\log(m + n))</code>.</p>

<h2 id="19-conclusion">19. Conclusion</h2>

<p>The Median of Two Sorted Arrays problem is a classic example of how binary search can achieve logarithmic time complexity in non-obvious ways.</p>

<p><strong>Key Takeaways:</strong></p>
<ul>
  <li><strong>Binary Search on Partition:</strong> Instead of searching for a value, search for a valid partition.</li>
  <li><strong>Invariant Maintenance:</strong> Ensure left and right partitions satisfy the ordering property.</li>
  <li><strong>Edge Handling:</strong> Use sentinels (-inf, +inf) for boundary cases.</li>
  <li><strong>Generalization:</strong> The same technique works for finding the k-th element.</li>
</ul>

<p>This problem demonstrates that mastering binary search goes beyond simple “find the target”—it’s about identifying the right search space.</p>

<h2 id="20-related-problems">20. Related Problems</h2>

<ul>
  <li><strong>Median of Data Stream</strong> (LeetCode 295)</li>
  <li><strong>Kth Smallest Element in a Sorted Matrix</strong> (LeetCode 378)</li>
  <li><strong>Find K-th Smallest Pair Distance</strong> (LeetCode 719)</li>
  <li><strong>Split Array Largest Sum</strong> (LeetCode 410)</li>
</ul>

<p>Practice these to solidify your understanding of binary search on answer patterns!</p>

<h2 id="21-deep-dive-median-in-a-stream-two-heaps">21. Deep Dive: Median in a Stream (Two Heaps)</h2>

<p><strong>Problem:</strong> Find the median as elements are added one by one.</p>

<p><strong>Algorithm:</strong></p>
<ol>
  <li>Maintain two heaps:
    <ul>
      <li><strong>Max-Heap (left):</strong> Smaller half.</li>
      <li><strong>Min-Heap (right):</strong> Larger half.</li>
    </ul>
  </li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>Balance:</td>
          <td>left</td>
          <td>=</td>
          <td>right</td>
          <td>or</td>
          <td>left</td>
          <td>=</td>
          <td>right</td>
          <td>+ 1.</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>Median = top(left) or (top(left) + top(right)) / 2.</li>
</ol>

<p>``python
import heapq</p>

<p>class MedianFinder:
 def <strong>init</strong>(self):
 self.left = [] # Max-heap (negate values)
 self.right = [] # Min-heap</p>

<p>def addNum(self, num):
 # Add to left (max-heap)
 heapq.heappush(self.left, -num)</p>

<p># Balance: Move largest from left to right
 heapq.heappush(self.right, -heapq.heappop(self.left))</p>

<p># Ensure left has at least as many elements
 if len(self.left) &lt; len(self.right):
 heapq.heappush(self.left, -heapq.heappop(self.right))</p>

<p>def findMedian(self):
 if len(self.left) &gt; len(self.right):
 return -self.left[0]
 return (-self.left[0] + self.right[0]) / 2
``</p>

<p><strong>Complexity:</strong></p>
<ul>
  <li><strong>Add:</strong> O(\log n).</li>
  <li><strong>Find Median:</strong> O(1).</li>
</ul>

<h2 id="22-deep-dive-median-in-a-matrix-binary-search-on-value">22. Deep Dive: Median in a Matrix (Binary Search on Value)</h2>

<p><strong>Problem:</strong> Find the median of a row-wise sorted matrix.</p>

<p><strong>Algorithm:</strong></p>
<ol>
  <li>Binary search on the value (not index).</li>
  <li>For each candidate value, count elements ≤ it in each row.</li>
  <li>If count = (rows × cols + 1) / 2, we found the median.</li>
</ol>

<p>``python
def matrixMedian(matrix):
 rows, cols = len(matrix), len(matrix[0])</p>

<p>lo = min(row[0] for row in matrix)
 hi = max(row[-1] for row in matrix)</p>

<p>target = (rows * cols + 1) // 2</p>

<p>while lo &lt; hi:
 mid = (lo + hi) // 2</p>

<p># Count elements &lt;= mid in all rows
 count = sum(bisect.bisect_right(row, mid) for row in matrix)</p>

<p>if count &lt; target:
 lo = mid + 1
 else:
 hi = mid</p>

<p>return lo
``</p>

<p><strong>Complexity:</strong> <code class="language-plaintext highlighter-rouge">O(R \cdot \log C \cdot \log(\max - \min))</code>.</p>

<h2 id="23-variant-sliding-window-median">23. Variant: Sliding Window Median</h2>

<p><strong>Problem:</strong> Find the median of each window of size k.</p>

<p><strong>Approach:</strong></p>
<ol>
  <li>Use two heaps (like streaming median).</li>
  <li>Use lazy deletion to handle elements leaving the window.</li>
</ol>

<p><strong>Challenge:</strong> Efficiently removing elements from heaps.</p>

<p>``python
from sortedcontainers import SortedList</p>

<p>def medianSlidingWindow(nums, k):
 window = SortedList()
 result = []</p>

<p>for i, num in enumerate(nums):
 window.add(num)</p>

<p>if len(window) &gt; k:
 window.remove(nums[i - k])</p>

<p>if len(window) == k:
 if k % 2 == 1:
 result.append(window[k // 2])
 else:
 result.append((window[k // 2 - 1] + window[k // 2]) / 2)</p>

<p>return result
``</p>

<p><strong>Complexity:</strong> O(n \cdot \log k) with balanced BST.</p>

<h2 id="24-application-ab-testing-statistics">24. Application: A/B Testing Statistics</h2>

<p><strong>Scenario:</strong> Compare median latency between control and treatment groups.</p>

<p><strong>Challenge:</strong> Latencies are stored on multiple servers.</p>

<p><strong>Approach:</strong></p>
<ol>
  <li>Each server computes a histogram of latencies.</li>
  <li>Merge histograms.</li>
  <li>Find median from merged histogram.</li>
</ol>

<p><strong>Benefit:</strong> Avoids transferring raw data.</p>

<h2 id="25-application-database-query-optimization">25. Application: Database Query Optimization</h2>

<p><strong>Scenario:</strong> SQL query <code class="language-plaintext highlighter-rouge">SELECT MEDIAN(column) FROM table</code>.</p>

<p><strong>Implementation:</strong></p>
<ol>
  <li>If table is sorted: Direct access to middle element.</li>
  <li>If unsorted: Use quickselect (O(n) average) or sort (O(n \log n)).</li>
  <li>For approximate median: Use sampling or t-digest.</li>
</ol>

<h2 id="26-deep-dive-approximating-median-with-t-digest">26. Deep Dive: Approximating Median with T-Digest</h2>

<p><strong>T-Digest</strong> is a data structure for approximate percentile computation.</p>

<p><strong>Algorithm:</strong></p>
<ol>
  <li>Maintain a set of centroids (mean, count).</li>
  <li>Centroids near the median are small (high precision).</li>
  <li>Centroids at the extremes are large (low precision).</li>
</ol>

<p><strong>Operations:</strong></p>
<ul>
  <li><strong>Add:</strong> Merge new element into nearest centroid.</li>
  <li><strong>Query:</strong> Walk through centroids to find percentile.</li>
</ul>

<p><strong>Use Case:</strong> Real-time percentile computation at scale (Netflix, Elasticsearch).</p>

<h2 id="27-testing-strategy">27. Testing Strategy</h2>

<p><strong>Test Cases:</strong></p>
<ol>
  <li><strong>Both Arrays Empty:</strong> Handle gracefully.</li>
  <li><strong>One Array Empty:</strong> Return median of the other.</li>
  <li><strong>Same Size Arrays:</strong> <code class="language-plaintext highlighter-rouge">[1,2]</code>, <code class="language-plaintext highlighter-rouge">[3,4]</code> → 2.5.</li>
  <li><strong>Different Size Arrays:</strong> <code class="language-plaintext highlighter-rouge">[1,3]</code>, <code class="language-plaintext highlighter-rouge">[2]</code> → 2.</li>
  <li><strong>All Elements in One Array Smaller:</strong> <code class="language-plaintext highlighter-rouge">[1,2]</code>, <code class="language-plaintext highlighter-rouge">[3,4,5,6]</code>.</li>
  <li><strong>Duplicates:</strong> <code class="language-plaintext highlighter-rouge">[1,1,1]</code>, <code class="language-plaintext highlighter-rouge">[1,1,1]</code> → 1.</li>
  <li><strong>Large Arrays:</strong> Performance testing.</li>
</ol>

<p><strong>Edge Cases:</strong></p>
<ul>
  <li>Single element in each array.</li>
  <li>Negative numbers.</li>
  <li>Very large values.</li>
</ul>

<h2 id="28-interview-tips">28. Interview Tips</h2>

<p><strong>Step-by-Step Approach:</strong></p>
<ol>
  <li><strong>Clarify:</strong> Sizes, sorted order, allowed time complexity.</li>
  <li><strong>Brute Force:</strong> Merge and find median (O(m+n)).</li>
  <li><strong>Optimize:</strong> Binary search on partition (<code class="language-plaintext highlighter-rouge">O(\log \min(m,n))</code>).</li>
  <li><strong>Walk Through:</strong> Use a specific example.</li>
  <li><strong>Edge Cases:</strong> Empty arrays, single elements.</li>
  <li><strong>Code:</strong> Write clean, bug-free code.</li>
  <li><strong>Complexity:</strong> Analyze time and space.</li>
</ol>

<h2 id="29-common-follow-up-questions">29. Common Follow-up Questions</h2>

<p><strong>Q: What if arrays are not sorted?</strong>
<strong>A:</strong> Sort first (O(n \log n)), or use quickselect.</p>

<p><strong>Q: What if we can’t afford <code class="language-plaintext highlighter-rouge">O(\log(m+n))</code>?</strong>
<strong>A:</strong> Two-pointer merge is O(m+n) and may be acceptable.</p>

<p><strong>Q: What if arrays are on different machines?</strong>
<strong>A:</strong> Use the sampling/counting approach for distributed median.</p>

<p><strong>Q: What if we need the k-th element instead of median?</strong>
<strong>A:</strong> Same algorithm, just change the target partition size.</p>

<h2 id="30-mastery-checklist">30. Mastery Checklist</h2>

<p><strong>Mastery Checklist:</strong></p>
<ul class="task-list">
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Implement brute force (merge and find)</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Implement two-pointer (virtual merge)</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Implement binary search on partition</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Handle edge cases (empty arrays, single elements)</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Generalize to k-th element</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Understand the divide-and-conquer approach</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Explain why binary search works (partition invariant)</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Implement streaming median (two heaps)</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Implement sliding window median</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Understand distributed median algorithms</li>
</ul>

<h2 id="31-conclusion">31. Conclusion</h2>

<p>The Median of Two Sorted Arrays is one of the most elegant problems in computer science. It combines:</p>
<ul>
  <li><strong>Binary Search:</strong> A powerful algorithmic paradigm.</li>
  <li><strong>Partition Logic:</strong> Dividing arrays into meaningful halves.</li>
  <li><strong>Edge Case Handling:</strong> Using sentinels for boundaries.</li>
</ul>

<p>Mastering this problem opens the door to many advanced topics: distributed computing, real-time statistics, and database optimization. It’s a testament to how mathematical insight can lead to efficient algorithms.</p>

<p><strong>The journey from O(m+n) to <code class="language-plaintext highlighter-rouge">O(\log \min(m,n))</code> teaches us that the right perspective can transform a problem.</strong></p>

<hr />

<p><strong>Originally published at:</strong> <a href="https://www.arunbaby.com/dsa/0043-median-of-two-sorted-arrays/">arunbaby.com/dsa/0043-median-of-two-sorted-arrays</a></p>

<p><em>If you found this helpful, consider sharing it with others who might benefit.</em></p>


        
      </section>

      <footer class="page__meta">
        
        
  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-tags" aria-hidden="true"></i> Tags: </strong>
    <span itemprop="keywords">
    
      <a href="/tags/#array" class="page__taxonomy-item p-category" rel="tag">array</a><span class="sep">, </span>
    
      <a href="/tags/#binary-search" class="page__taxonomy-item p-category" rel="tag">binary-search</a><span class="sep">, </span>
    
      <a href="/tags/#divide-and-conquer" class="page__taxonomy-item p-category" rel="tag">divide-and-conquer</a>
    
    </span>
  </p>




  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> Categories: </strong>
    <span itemprop="keywords">
    
      <a href="/categories/#dsa" class="page__taxonomy-item p-category" rel="tag">dsa</a>
    
    </span>
  </p>


        
      </footer>

      <div class="page__related page__related--full">
  <h2 class="page__related-title">Related across topics</h2>
  <style>
    /* Make section span full content width and use 2 equal columns */
    .page__related--full { float: inline-start; width: 100%; padding: 0; }
    .cross-related-grid { display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 2rem; }
    @media (max-width: 768px) { .cross-related-grid { grid-template-columns: 1fr; } }
    /* Ensure archive cards stretch nicely in the grid */
    .cross-related-grid .list__item, .cross-related-grid .grid__item { width: auto; float: none; margin: 0; }
  </style>
  <div class="cross-related-grid">
    



<div class="list__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/ml-system-design/0043-vector-databases/" rel="permalink">Vector Databases
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          14 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">“The infrastructure for semantic search and AI-native applications.”
</p>
  </article>
</div>




<div class="list__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/speech-tech/0043-speech-enhancement/" rel="permalink">Speech Enhancement
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          14 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">“Extracting clear speech from the noise of the real world.”
</p>
  </article>
</div>




<div class="list__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/ai-agents/0043-testing-ai-agents/" rel="permalink">Testing AI Agents
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          12 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">“Test agents like systems: validate tool calls, pin behaviors with replayable traces, and catch regressions before users do.”
</p>
  </article>
</div>

  </div>
</div>

      <section class="page__share">
  <h4 class="page__share-title">Share on</h4>

  <a href="https://twitter.com/intent/tweet?via=arunbaby0&text=Median+of+Two+Sorted+Arrays%20https%3A%2F%2Fwww.arunbaby.com%2Fdsa%2F0043-median-of-two-sorted-arrays%2F" class="btn btn--twitter" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Twitter"><i class="fab fa-fw fa-twitter" aria-hidden="true"></i><span> Twitter</span></a>

  <a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fwww.arunbaby.com%2Fdsa%2F0043-median-of-two-sorted-arrays%2F" class="btn btn--facebook" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Facebook"><i class="fab fa-fw fa-facebook" aria-hidden="true"></i><span> Facebook</span></a>

  <a href="https://www.linkedin.com/shareArticle?mini=true&url=https://www.arunbaby.com/dsa/0043-median-of-two-sorted-arrays/" class="btn btn--linkedin" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on LinkedIn"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i><span> LinkedIn</span></a>
</section>


      
  <nav class="pagination">
    
      <a href="/dsa/0042-merge-k-sorted-lists/" class="pagination--pager" title="Merge K Sorted Lists">Previous</a>
    
    
      <a href="/dsa/0044-largest-rectangle-histogram/" class="pagination--pager" title="Largest Rectangle in Histogram">Next</a>
    
  </nav>


    </div>

    
  </article>

  
  
</div>

      
    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';" role="search">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Enter your search term..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    

    
      
        
          <li><a href="https://twitter.com/arunbaby0" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-twitter-square" aria-hidden="true"></i> Twitter</a></li>
        
      
        
          <li><a href="https://github.com/arunbaby0" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
        
      
        
          <li><a href="https://www.linkedin.com/in/arunbaby0/" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i> LinkedIn</a></li>
        
      
        
          <li><a href="https://scholar.google.co.in/citations?user=6fSYWhkAAAAJ" rel="nofollow noopener noreferrer"><i class="fas fa-fw fa-graduation-cap" aria-hidden="true"></i> Google Scholar</a></li>
        
      
    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 1990 - 2143 <a href="https://www.arunbaby.com">Arun Baby</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>




  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-0JRJPEC9SS"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-0JRJPEC9SS', { 'anonymize_ip': false});
</script>








  </body>
</html>
