<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.26.2 by Michael Rose
  Copyright 2013-2024 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->

<html lang="en-US" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Median of Two Sorted Arrays - Arun Baby</title>
<meta name="description" content="“Finding the middle ground between two ordered worlds.”">


  <meta name="author" content="Arun Baby">
  
  <meta property="article:author" content="Arun Baby">
  


<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="Arun Baby">
<meta property="og:title" content="Median of Two Sorted Arrays">
<meta property="og:url" content="https://www.arunbaby.com/dsa/0043-median-of-two-sorted-arrays/">


  <meta property="og:description" content="“Finding the middle ground between two ordered worlds.”">



  <meta property="og:image" content="https://www.arunbaby.com/assets/images/profile-photo.png">



  <meta name="twitter:site" content="@arunbaby0">
  <meta name="twitter:title" content="Median of Two Sorted Arrays">
  <meta name="twitter:description" content="“Finding the middle ground between two ordered worlds.”">
  <meta name="twitter:url" content="https://www.arunbaby.com/dsa/0043-median-of-two-sorted-arrays/">

  
    <meta name="twitter:card" content="summary">
    
      <meta name="twitter:image" content="https://www.arunbaby.com/assets/images/profile-photo.png">
    
  

  



  <meta property="article:published_time" content="2025-12-20T18:15:29+05:30">





  

  


<link rel="canonical" href="https://www.arunbaby.com/dsa/0043-median-of-two-sorted-arrays/">












<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Arun Baby Feed">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
  
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css"></noscript>



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--single" dir="ltr">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
           
          <span class="site-subtitle">Arun Baby</span>
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a
                href="/about/"
                
                
              >About</a>
            </li><li class="masthead__menu-item">
              <a
                href="/dsa/"
                
                
              >DSA</a>
            </li><li class="masthead__menu-item">
              <a
                href="/ml-system-design/"
                
                
              >ML Systems</a>
            </li><li class="masthead__menu-item">
              <a
                href="/speech-tech/"
                
                
              >Speech Tech</a>
            </li><li class="masthead__menu-item">
              <a
                href="/ai-agents/"
                
                
              >AI Agents</a>
            </li><li class="masthead__menu-item">
              <a
                href="/publications/"
                
                
              >Publications</a>
            </li><li class="masthead__menu-item">
              <a
                href="/statuses/"
                
                
              >Statuses</a>
            </li><li class="masthead__menu-item">
              <a
                href="/contact/"
                
                
              >Contact</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <i class="fas fa-search"></i>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      





<div id="main" role="main" class="no-author-sidebar">
  
  <div class="sidebar sticky">
  
  
  </div>



  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="Median of Two Sorted Arrays">
    <meta itemprop="description" content="“Finding the middle ground between two ordered worlds.”">
    <meta itemprop="datePublished" content="2025-12-20T18:15:29+05:30">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">
            <a href="https://www.arunbaby.com/dsa/0043-median-of-two-sorted-arrays/" itemprop="url">Median of Two Sorted Arrays
</a>
          </h1>
          

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          17 minute read
        
      </span>
    
  </p>


        </header>
      

      <section class="page__content" itemprop="text">
        
          <aside class="sidebar__right sticky">
            <nav class="toc">
              <header><h4 class="nav__title"><i class="fas fa-file-alt"></i> On this page</h4></header>
              <ul class="toc__menu"><li><a href="#1-problem-statement">1. Problem Statement</a></li><li><a href="#2-understanding-the-median">2. Understanding the Median</a></li><li><a href="#3-approach-1-merge-and-find-brute-force">3. Approach 1: Merge and Find (Brute Force)</a></li><li><a href="#4-approach-2-two-pointer-merge-no-full-merge">4. Approach 2: Two-Pointer Merge (No Full Merge)</a></li><li><a href="#5-approach-3-binary-search-optimal">5. Approach 3: Binary Search (Optimal)</a></li><li><a href="#6-detailed-walkthrough">6. Detailed Walkthrough</a></li><li><a href="#7-why-binary-search-works">7. Why Binary Search Works</a></li><li><a href="#8-edge-cases">8. Edge Cases</a></li><li><a href="#9-system-design-distributed-median-finding">9. System Design: Distributed Median Finding</a></li><li><a href="#10-deep-dive-kth-element-in-two-sorted-arrays">10. Deep Dive: Kth Element in Two Sorted Arrays</a></li><li><a href="#11-production-application-real-time-percentile-computation">11. Production Application: Real-Time Percentile Computation</a></li><li><a href="#12-interview-questions">12. Interview Questions</a></li><li><a href="#13-common-mistakes">13. Common Mistakes</a></li><li><a href="#14-variant-median-of-k-sorted-arrays">14. Variant: Median of K Sorted Arrays</a></li><li><a href="#15-mathematical-proof-of-correctness">15. Mathematical Proof of Correctness</a></li><li><a href="#16-deep-dive-weighted-median">16. Deep Dive: Weighted Median</a></li><li><a href="#17-performance-benchmarking">17. Performance Benchmarking</a></li><li><a href="#18-alternative-divide-and-conquer">18. Alternative: Divide and Conquer</a></li><li><a href="#19-conclusion">19. Conclusion</a></li><li><a href="#20-related-problems">20. Related Problems</a></li><li><a href="#21-deep-dive-median-in-a-stream-two-heaps">21. Deep Dive: Median in a Stream (Two Heaps)</a></li><li><a href="#22-deep-dive-median-in-a-matrix-binary-search-on-value">22. Deep Dive: Median in a Matrix (Binary Search on Value)</a></li><li><a href="#23-variant-sliding-window-median">23. Variant: Sliding Window Median</a></li><li><a href="#24-application-ab-testing-statistics">24. Application: A/B Testing Statistics</a></li><li><a href="#25-application-database-query-optimization">25. Application: Database Query Optimization</a></li><li><a href="#26-deep-dive-approximating-median-with-t-digest">26. Deep Dive: Approximating Median with T-Digest</a></li><li><a href="#27-testing-strategy">27. Testing Strategy</a></li><li><a href="#28-interview-tips">28. Interview Tips</a></li><li><a href="#29-common-follow-up-questions">29. Common Follow-up Questions</a></li><li><a href="#30-mastery-checklist">30. Mastery Checklist</a></li><li><a href="#31-conclusion">31. Conclusion</a></li></ul>
            </nav>
          </aside>
        
        <p><strong>“Finding the middle ground between two ordered worlds.”</strong></p>

<h2 id="1-problem-statement">1. Problem Statement</h2>

<p>Given two sorted arrays <code class="language-plaintext highlighter-rouge">nums1</code> and <code class="language-plaintext highlighter-rouge">nums2</code> of size <code class="language-plaintext highlighter-rouge">m</code> and <code class="language-plaintext highlighter-rouge">n</code> respectively, return the <strong>median</strong> of the two sorted arrays.</p>

<p>The overall run time complexity should be $O(\log(m+n))$.</p>

<p><strong>Example 1:</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums1 = [1,3], nums2 = [2]
Output: 2.00000
Explanation: merged array = [1,2,3] and median is 2.
</code></pre></div></div>

<p><strong>Example 2:</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums1 = [1,2], nums2 = [3,4]
Output: 2.50000
Explanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.
</code></pre></div></div>

<p><strong>Constraints:</strong></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">nums1.length == m</code></li>
  <li><code class="language-plaintext highlighter-rouge">nums2.length == n</code></li>
  <li><code class="language-plaintext highlighter-rouge">0 &lt;= m &lt;= 1000</code></li>
  <li><code class="language-plaintext highlighter-rouge">0 &lt;= n &lt;= 1000</code></li>
  <li><code class="language-plaintext highlighter-rouge">1 &lt;= m + n &lt;= 2000</code></li>
  <li><code class="language-plaintext highlighter-rouge">-10^6 &lt;= nums1[i], nums2[i] &lt;= 10^6</code></li>
</ul>

<h2 id="2-understanding-the-median">2. Understanding the Median</h2>

<p><strong>Definition:</strong></p>
<ul>
  <li>For an odd-length array: the middle element.</li>
  <li>For an even-length array: the average of the two middle elements.</li>
</ul>

<p><strong>Key Insight:</strong> The median divides the combined array into two equal halves:</p>
<ul>
  <li>Left half: All elements ≤ median.</li>
  <li>Right half: All elements ≥ median.</li>
</ul>

<h2 id="3-approach-1-merge-and-find-brute-force">3. Approach 1: Merge and Find (Brute Force)</h2>

<p><strong>Algorithm:</strong></p>
<ol>
  <li>Merge both arrays into one sorted array.</li>
  <li>Find the median.</li>
</ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">findMedianSortedArrays</span><span class="p">(</span><span class="n">nums1</span><span class="p">,</span> <span class="n">nums2</span><span class="p">):</span>
    <span class="n">merged</span> <span class="o">=</span> <span class="nf">sorted</span><span class="p">(</span><span class="n">nums1</span> <span class="o">+</span> <span class="n">nums2</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">merged</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">merged</span><span class="p">[</span><span class="n">n</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nf">return </span><span class="p">(</span><span class="n">merged</span><span class="p">[</span><span class="n">n</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">merged</span><span class="p">[</span><span class="n">n</span> <span class="o">//</span> <span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span>
</code></pre></div></div>

<p><strong>Complexity:</strong></p>
<ul>
  <li><strong>Time:</strong> $O((m+n) \log(m+n))$ for sorting, or $O(m+n)$ if using merge sort’s merge step.</li>
  <li><strong>Space:</strong> $O(m+n)$ for the merged array.</li>
</ul>

<p><strong>Issue:</strong> Doesn’t meet the $O(\log(m+n))$ requirement.</p>

<h2 id="4-approach-2-two-pointer-merge-no-full-merge">4. Approach 2: Two-Pointer Merge (No Full Merge)</h2>

<p><strong>Algorithm:</strong></p>
<ol>
  <li>Use two pointers to “virtually” merge.</li>
  <li>Stop when we reach the median position.</li>
</ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">findMedianSortedArrays</span><span class="p">(</span><span class="n">nums1</span><span class="p">,</span> <span class="n">nums2</span><span class="p">):</span>
    <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">nums1</span><span class="p">),</span> <span class="nf">len</span><span class="p">(</span><span class="n">nums2</span><span class="p">)</span>
    <span class="n">total</span> <span class="o">=</span> <span class="n">m</span> <span class="o">+</span> <span class="n">n</span>
    
    <span class="c1"># We need element at (total-1)//2 and total//2 for median
</span>    <span class="n">target1</span> <span class="o">=</span> <span class="p">(</span><span class="n">total</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="n">target2</span> <span class="o">=</span> <span class="n">total</span> <span class="o">//</span> <span class="mi">2</span>
    
    <span class="n">i</span> <span class="o">=</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">val1</span> <span class="o">=</span> <span class="n">val2</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">target2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span> <span class="ow">and</span> <span class="p">(</span><span class="n">j</span> <span class="o">&gt;=</span> <span class="n">n</span> <span class="ow">or</span> <span class="n">nums1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">nums2</span><span class="p">[</span><span class="n">j</span><span class="p">]):</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">nums1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">nums2</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
        
        <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="n">target1</span><span class="p">:</span>
            <span class="n">val1</span> <span class="o">=</span> <span class="n">val</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="n">target2</span><span class="p">:</span>
            <span class="n">val2</span> <span class="o">=</span> <span class="n">val</span>
    
    <span class="nf">return </span><span class="p">(</span><span class="n">val1</span> <span class="o">+</span> <span class="n">val2</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
</code></pre></div></div>

<p><strong>Complexity:</strong></p>
<ul>
  <li><strong>Time:</strong> $O(m+n)$.</li>
  <li><strong>Space:</strong> $O(1)$.</li>
</ul>

<p><strong>Still doesn’t meet</strong> the $O(\log(m+n))$ requirement.</p>

<h2 id="5-approach-3-binary-search-optimal">5. Approach 3: Binary Search (Optimal)</h2>

<p><strong>Key Insight:</strong> We need to partition both arrays such that:</p>
<ol>
  <li>Left partition has <code class="language-plaintext highlighter-rouge">(m + n + 1) // 2</code> elements.</li>
  <li>All elements in left partition ≤ all elements in right partition.</li>
</ol>

<p><strong>Algorithm:</strong></p>
<ol>
  <li>Binary search on the smaller array.</li>
  <li>For each partition of the smaller array, compute the corresponding partition of the larger array.</li>
  <li>Check if the partition is valid.</li>
</ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">findMedianSortedArrays</span><span class="p">(</span><span class="n">nums1</span><span class="p">,</span> <span class="n">nums2</span><span class="p">):</span>
    <span class="c1"># Ensure nums1 is the smaller array
</span>    <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">nums1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nf">len</span><span class="p">(</span><span class="n">nums2</span><span class="p">):</span>
        <span class="n">nums1</span><span class="p">,</span> <span class="n">nums2</span> <span class="o">=</span> <span class="n">nums2</span><span class="p">,</span> <span class="n">nums1</span>
    
    <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">nums1</span><span class="p">),</span> <span class="nf">len</span><span class="p">(</span><span class="n">nums2</span><span class="p">)</span>
    <span class="n">total</span> <span class="o">=</span> <span class="n">m</span> <span class="o">+</span> <span class="n">n</span>
    <span class="n">half</span> <span class="o">=</span> <span class="p">(</span><span class="n">total</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
    
    <span class="n">lo</span><span class="p">,</span> <span class="n">hi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">m</span>
    
    <span class="k">while</span> <span class="n">lo</span> <span class="o">&lt;=</span> <span class="n">hi</span><span class="p">:</span>
        <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">lo</span> <span class="o">+</span> <span class="n">hi</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>  <span class="c1"># Partition index for nums1
</span>        <span class="n">j</span> <span class="o">=</span> <span class="n">half</span> <span class="o">-</span> <span class="n">i</span>         <span class="c1"># Partition index for nums2
</span>        
        <span class="c1"># Edge handling with -inf and +inf
</span>        <span class="n">nums1_left</span> <span class="o">=</span> <span class="n">nums1</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="nf">float</span><span class="p">(</span><span class="sh">'</span><span class="s">-inf</span><span class="sh">'</span><span class="p">)</span>
        <span class="n">nums1_right</span> <span class="o">=</span> <span class="n">nums1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span> <span class="k">else</span> <span class="nf">float</span><span class="p">(</span><span class="sh">'</span><span class="s">inf</span><span class="sh">'</span><span class="p">)</span>
        <span class="n">nums2_left</span> <span class="o">=</span> <span class="n">nums2</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="nf">float</span><span class="p">(</span><span class="sh">'</span><span class="s">-inf</span><span class="sh">'</span><span class="p">)</span>
        <span class="n">nums2_right</span> <span class="o">=</span> <span class="n">nums2</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="k">else</span> <span class="nf">float</span><span class="p">(</span><span class="sh">'</span><span class="s">inf</span><span class="sh">'</span><span class="p">)</span>
        
        <span class="c1"># Check if partition is valid
</span>        <span class="k">if</span> <span class="n">nums1_left</span> <span class="o">&lt;=</span> <span class="n">nums2_right</span> <span class="ow">and</span> <span class="n">nums2_left</span> <span class="o">&lt;=</span> <span class="n">nums1_right</span><span class="p">:</span>
            <span class="c1"># Valid partition found
</span>            <span class="k">if</span> <span class="n">total</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="nf">max</span><span class="p">(</span><span class="n">nums1_left</span><span class="p">,</span> <span class="n">nums2_left</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nf">return </span><span class="p">(</span><span class="nf">max</span><span class="p">(</span><span class="n">nums1_left</span><span class="p">,</span> <span class="n">nums2_left</span><span class="p">)</span> <span class="o">+</span> <span class="nf">min</span><span class="p">(</span><span class="n">nums1_right</span><span class="p">,</span> <span class="n">nums2_right</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="k">elif</span> <span class="n">nums1_left</span> <span class="o">&gt;</span> <span class="n">nums2_right</span><span class="p">:</span>
            <span class="n">hi</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># Too many elements from nums1
</span>        <span class="k">else</span><span class="p">:</span>
            <span class="n">lo</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># Too few elements from nums1
</span>    
    <span class="k">return</span> <span class="mi">0</span>  <span class="c1"># Should never reach here
</span></code></pre></div></div>

<p><strong>Complexity:</strong></p>
<ul>
  <li><strong>Time:</strong> $O(\log(\min(m, n)))$.</li>
  <li><strong>Space:</strong> $O(1)$.</li>
</ul>

<h2 id="6-detailed-walkthrough">6. Detailed Walkthrough</h2>

<p><strong>Example:</strong> <code class="language-plaintext highlighter-rouge">nums1 = [1, 3, 8, 9, 15]</code>, <code class="language-plaintext highlighter-rouge">nums2 = [7, 11, 18, 19, 21, 25]</code></p>

<p><strong>Setup:</strong></p>
<ul>
  <li>m = 5, n = 6, total = 11.</li>
  <li>half = (11 + 1) // 2 = 6.</li>
  <li>Need 6 elements in left partition.</li>
</ul>

<p><strong>Binary Search:</strong></p>

<p><strong>Iteration 1:</strong> lo=0, hi=5, i=2, j=6-2=4</p>
<ul>
  <li>nums1_left = nums1[1] = 3</li>
  <li>nums1_right = nums1[2] = 8</li>
  <li>nums2_left = nums2[3] = 19</li>
  <li>nums2_right = nums2[4] = 21</li>
  <li>Check: 3 ≤ 21 ✓, 19 ≤ 8 ✗</li>
  <li>19 &gt; 8, so we need more from nums1. lo = 3.</li>
</ul>

<p><strong>Iteration 2:</strong> lo=3, hi=5, i=4, j=6-4=2</p>
<ul>
  <li>nums1_left = nums1[3] = 9</li>
  <li>nums1_right = nums1[4] = 15</li>
  <li>nums2_left = nums2[1] = 11</li>
  <li>nums2_right = nums2[2] = 18</li>
  <li>Check: 9 ≤ 18 ✓, 11 ≤ 15 ✓</li>
  <li>Valid partition!</li>
  <li>Odd total: median = max(9, 11) = 11.</li>
</ul>

<p><strong>Merged Array (for verification):</strong> [1, 3, 7, 8, 9, <strong>11</strong>, 15, 18, 19, 21, 25]. Median = 11. ✓</p>

<h2 id="7-why-binary-search-works">7. Why Binary Search Works</h2>

<p><strong>Invariant:</strong> If we take <code class="language-plaintext highlighter-rouge">i</code> elements from nums1, we must take <code class="language-plaintext highlighter-rouge">half - i</code> elements from nums2.</p>

<p><strong>Validity Condition:</strong></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">nums1[i-1] ≤ nums2[j]</code>: Largest in nums1’s left ≤ smallest in nums2’s right.</li>
  <li><code class="language-plaintext highlighter-rouge">nums2[j-1] ≤ nums1[i]</code>: Largest in nums2’s left ≤ smallest in nums1’s right.</li>
</ul>

<p><strong>Binary Search Logic:</strong></p>
<ul>
  <li>If <code class="language-plaintext highlighter-rouge">nums1[i-1] &gt; nums2[j]</code>: We took too many from nums1. Decrease i.</li>
  <li>If <code class="language-plaintext highlighter-rouge">nums2[j-1] &gt; nums1[i]</code>: We took too few from nums1. Increase i.</li>
</ul>

<h2 id="8-edge-cases">8. Edge Cases</h2>

<ol>
  <li><strong>One Array is Empty:</strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">nums1 = []</code>, <code class="language-plaintext highlighter-rouge">nums2 = [2, 3]</code> → Median of nums2 = 2.5.</li>
      <li>Handle with <code class="language-plaintext highlighter-rouge">-inf</code> and <code class="language-plaintext highlighter-rouge">+inf</code> sentinels.</li>
    </ul>
  </li>
  <li><strong>Arrays of Different Sizes:</strong>
    <ul>
      <li>Always binary search on the smaller array for efficiency.</li>
    </ul>
  </li>
  <li><strong>All Elements in One Array are Smaller:</strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">nums1 = [1, 2]</code>, <code class="language-plaintext highlighter-rouge">nums2 = [3, 4, 5, 6]</code>.</li>
      <li>Partition: All of nums1 in left, some of nums2 in left.</li>
    </ul>
  </li>
  <li><strong>Single Element Arrays:</strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">nums1 = [1]</code>, <code class="language-plaintext highlighter-rouge">nums2 = [2]</code> → Median = 1.5.</li>
    </ul>
  </li>
</ol>

<h2 id="9-system-design-distributed-median-finding">9. System Design: Distributed Median Finding</h2>

<p><strong>Problem:</strong> Find the median of data distributed across k servers.</p>

<p><strong>Naive Approach:</strong> Collect all data, sort, find median. $O(N \log N)$.</p>

<p><strong>Efficient Approach (Sampling-Based):</strong></p>
<ol>
  <li><strong>Sample:</strong> Each server sends a random sample.</li>
  <li><strong>Estimate:</strong> Find approximate median from samples.</li>
  <li><strong>Count:</strong> Each server counts elements &lt; median, &gt; median.</li>
  <li><strong>Refine:</strong> Narrow the range containing the true median.</li>
</ol>

<p><strong>Algorithm (Binary Search on Value):</strong></p>
<ol>
  <li>Binary search on the median value (not indices).</li>
  <li>For each candidate value, count how many elements are ≤ it.</li>
  <li>If count = (total + 1) / 2, we found the median.</li>
</ol>

<h2 id="10-deep-dive-kth-element-in-two-sorted-arrays">10. Deep Dive: Kth Element in Two Sorted Arrays</h2>

<p><strong>Generalization:</strong> Find the k-th smallest element in two sorted arrays.</p>

<p><strong>Algorithm (Binary Search):</strong></p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">findKthElement</span><span class="p">(</span><span class="n">nums1</span><span class="p">,</span> <span class="n">nums2</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
    <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">nums1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nf">len</span><span class="p">(</span><span class="n">nums2</span><span class="p">):</span>
        <span class="n">nums1</span><span class="p">,</span> <span class="n">nums2</span> <span class="o">=</span> <span class="n">nums2</span><span class="p">,</span> <span class="n">nums1</span>
    
    <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">nums1</span><span class="p">),</span> <span class="nf">len</span><span class="p">(</span><span class="n">nums2</span><span class="p">)</span>
    <span class="n">lo</span><span class="p">,</span> <span class="n">hi</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">k</span> <span class="o">-</span> <span class="n">n</span><span class="p">),</span> <span class="nf">min</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
    
    <span class="k">while</span> <span class="n">lo</span> <span class="o">&lt;=</span> <span class="n">hi</span><span class="p">:</span>
        <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">lo</span> <span class="o">+</span> <span class="n">hi</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">k</span> <span class="o">-</span> <span class="n">i</span>
        
        <span class="n">nums1_left</span> <span class="o">=</span> <span class="n">nums1</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="nf">float</span><span class="p">(</span><span class="sh">'</span><span class="s">-inf</span><span class="sh">'</span><span class="p">)</span>
        <span class="n">nums1_right</span> <span class="o">=</span> <span class="n">nums1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span> <span class="k">else</span> <span class="nf">float</span><span class="p">(</span><span class="sh">'</span><span class="s">inf</span><span class="sh">'</span><span class="p">)</span>
        <span class="n">nums2_left</span> <span class="o">=</span> <span class="n">nums2</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="nf">float</span><span class="p">(</span><span class="sh">'</span><span class="s">-inf</span><span class="sh">'</span><span class="p">)</span>
        <span class="n">nums2_right</span> <span class="o">=</span> <span class="n">nums2</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="k">else</span> <span class="nf">float</span><span class="p">(</span><span class="sh">'</span><span class="s">inf</span><span class="sh">'</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">nums1_left</span> <span class="o">&lt;=</span> <span class="n">nums2_right</span> <span class="ow">and</span> <span class="n">nums2_left</span> <span class="o">&lt;=</span> <span class="n">nums1_right</span><span class="p">:</span>
            <span class="k">return</span> <span class="nf">max</span><span class="p">(</span><span class="n">nums1_left</span><span class="p">,</span> <span class="n">nums2_left</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">nums1_left</span> <span class="o">&gt;</span> <span class="n">nums2_right</span><span class="p">:</span>
            <span class="n">hi</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lo</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
    
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
</code></pre></div></div>

<p><strong>Use Case:</strong> Median is just k = (m + n + 1) // 2.</p>

<h2 id="11-production-application-real-time-percentile-computation">11. Production Application: Real-Time Percentile Computation</h2>

<p><strong>Scenario:</strong> Compute the 99th percentile latency from logs stored on multiple servers.</p>

<p><strong>Algorithm:</strong></p>
<ol>
  <li><strong>Histogram Binning:</strong> Each server maintains a histogram of latencies.</li>
  <li><strong>Merge Histograms:</strong> Sum histograms across servers.</li>
  <li><strong>Find Percentile:</strong> Walk through the merged histogram.</li>
</ol>

<p><strong>Optimization:</strong></p>
<ul>
  <li>Use exponential binning (log-scale) for accuracy across wide ranges.</li>
  <li>Stream histograms instead of raw data (reduces network traffic).</li>
</ul>

<h2 id="12-interview-questions">12. Interview Questions</h2>

<ol>
  <li><strong>Median of Two Sorted Arrays (Classic):</strong> Solve with binary search.</li>
  <li><strong>Kth Smallest Element:</strong> Generalize the median solution.</li>
  <li><strong>Median of Data Stream:</strong> Design with two heaps.</li>
  <li><strong>Distributed Median:</strong> Explain the sampling + counting approach.</li>
  <li><strong>Running Median:</strong> Use balanced BST or two heaps.</li>
</ol>

<h2 id="13-common-mistakes">13. Common Mistakes</h2>

<ul>
  <li><strong>Not Handling Empty Arrays:</strong> Leads to index out of bounds.</li>
  <li><strong>Off-by-One in Partition:</strong> Careful with i-1, j-1.</li>
  <li><strong>Binary Searching the Wrong Array:</strong> Always search the smaller one.</li>
  <li><strong>Integer Overflow:</strong> (a + b) / 2 can overflow. Use a + (b - a) / 2.</li>
  <li><strong>Forgetting Even/Odd Cases:</strong> Median calculation differs.</li>
</ul>

<h2 id="14-variant-median-of-k-sorted-arrays">14. Variant: Median of K Sorted Arrays</h2>

<p><strong>Problem:</strong> Given k sorted arrays, find the overall median.</p>

<p><strong>Approach 1: Sequential Merge</strong></p>
<ul>
  <li>Merge pairs until one array remains.</li>
  <li>Find median.</li>
  <li><strong>Time:</strong> $O(N \log k)$ where N is total elements.</li>
</ul>

<p><strong>Approach 2: Binary Search on Value</strong></p>
<ul>
  <li>Binary search on the median value.</li>
  <li>For each candidate, count elements ≤ it in all arrays using binary search.</li>
  <li><strong>Time:</strong> $O(k \log V \log N)$ where V is the value range.</li>
</ul>

<h2 id="15-mathematical-proof-of-correctness">15. Mathematical Proof of Correctness</h2>

<p><strong>Theorem:</strong> The binary search algorithm correctly finds the median.</p>

<p><strong>Proof:</strong></p>
<ol>
  <li><strong>Partition Property:</strong> The left partition has exactly <code class="language-plaintext highlighter-rouge">(m + n + 1) // 2</code> elements.</li>
  <li><strong>Validity:</strong> If <code class="language-plaintext highlighter-rouge">nums1[i-1] ≤ nums2[j]</code> and <code class="language-plaintext highlighter-rouge">nums2[j-1] ≤ nums1[i]</code>, then all left elements ≤ all right elements.</li>
  <li><strong>Binary Search Correctness:</strong>
    <ul>
      <li>If <code class="language-plaintext highlighter-rouge">nums1[i-1] &gt; nums2[j]</code>, we need fewer elements from nums1 (decrease i).</li>
      <li>If <code class="language-plaintext highlighter-rouge">nums2[j-1] &gt; nums1[i]</code>, we need more elements from nums1 (increase i).</li>
    </ul>
  </li>
  <li><strong>Termination:</strong> Binary search terminates when a valid partition is found.</li>
  <li><strong>Median:</strong> The median is max(left) or (max(left) + min(right)) / 2.</li>
</ol>

<h2 id="16-deep-dive-weighted-median">16. Deep Dive: Weighted Median</h2>

<p><strong>Problem:</strong> Given elements with weights, find the median where weight sums to 50% on each side.</p>

<p><strong>Algorithm:</strong></p>
<ol>
  <li>Sort elements by value.</li>
  <li>Accumulate weights.</li>
  <li>Find where cumulative weight = total_weight / 2.</li>
</ol>

<p><strong>Use Case:</strong> Weighted voting, robust averaging.</p>

<h2 id="17-performance-benchmarking">17. Performance Benchmarking</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">time</span>
<span class="kn">import</span> <span class="n">random</span>

<span class="k">def</span> <span class="nf">benchmark</span><span class="p">():</span>
    <span class="n">sizes</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span> <span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">1000</span><span class="p">),</span> <span class="p">(</span><span class="mi">10000</span><span class="p">,</span> <span class="mi">10000</span><span class="p">)]</span>
    
    <span class="k">for</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">sizes</span><span class="p">:</span>
        <span class="n">nums1</span> <span class="o">=</span> <span class="nf">sorted</span><span class="p">(</span><span class="n">random</span><span class="p">.</span><span class="nf">sample</span><span class="p">(</span><span class="nf">range</span><span class="p">(</span><span class="mi">1000000</span><span class="p">),</span> <span class="n">m</span><span class="p">))</span>
        <span class="n">nums2</span> <span class="o">=</span> <span class="nf">sorted</span><span class="p">(</span><span class="n">random</span><span class="p">.</span><span class="nf">sample</span><span class="p">(</span><span class="nf">range</span><span class="p">(</span><span class="mi">1000000</span><span class="p">),</span> <span class="n">n</span><span class="p">))</span>
        
        <span class="c1"># Binary Search
</span>        <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1000</span><span class="p">):</span>
            <span class="nf">findMedianSortedArrays</span><span class="p">(</span><span class="n">nums1</span><span class="p">,</span> <span class="n">nums2</span><span class="p">)</span>
        <span class="n">bs_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span>
        
        <span class="c1"># Merge
</span>        <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1000</span><span class="p">):</span>
            <span class="nf">findMedian_merge</span><span class="p">(</span><span class="n">nums1</span><span class="p">,</span> <span class="n">nums2</span><span class="p">)</span>
        <span class="n">merge_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span>
        
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">m=</span><span class="si">{</span><span class="n">m</span><span class="si">}</span><span class="s">, n=</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s">: BS=</span><span class="si">{</span><span class="n">bs_time</span><span class="si">:</span><span class="p">.</span><span class="mi">4</span><span class="n">f</span><span class="si">}</span><span class="s">s, Merge=</span><span class="si">{</span><span class="n">merge_time</span><span class="si">:</span><span class="p">.</span><span class="mi">4</span><span class="n">f</span><span class="si">}</span><span class="s">s</span><span class="sh">"</span><span class="p">)</span>

<span class="c1"># Expected: Binary search is significantly faster for large arrays
</span></code></pre></div></div>

<h2 id="18-alternative-divide-and-conquer">18. Alternative: Divide and Conquer</h2>

<p><strong>Algorithm:</strong></p>
<ol>
  <li>Compare medians of both arrays.</li>
  <li>Discard the half that cannot contain the overall median.</li>
  <li>Recur on the remaining halves.</li>
</ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">findMedian_DC</span><span class="p">(</span><span class="n">nums1</span><span class="p">,</span> <span class="n">nums2</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">kth</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">a_start</span><span class="p">,</span> <span class="n">a_end</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">b_start</span><span class="p">,</span> <span class="n">b_end</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">a_start</span> <span class="o">&gt;</span> <span class="n">a_end</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">b</span><span class="p">[</span><span class="n">b_start</span> <span class="o">+</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">b_start</span> <span class="o">&gt;</span> <span class="n">b_end</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">a</span><span class="p">[</span><span class="n">a_start</span> <span class="o">+</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="nf">min</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">a_start</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="n">b_start</span><span class="p">])</span>
        
        <span class="n">mid_a</span> <span class="o">=</span> <span class="nf">float</span><span class="p">(</span><span class="sh">'</span><span class="s">inf</span><span class="sh">'</span><span class="p">)</span> <span class="k">if</span> <span class="n">a_start</span> <span class="o">+</span> <span class="n">k</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="n">a_end</span> <span class="k">else</span> <span class="n">a</span><span class="p">[</span><span class="n">a_start</span> <span class="o">+</span> <span class="n">k</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">mid_b</span> <span class="o">=</span> <span class="nf">float</span><span class="p">(</span><span class="sh">'</span><span class="s">inf</span><span class="sh">'</span><span class="p">)</span> <span class="k">if</span> <span class="n">b_start</span> <span class="o">+</span> <span class="n">k</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="n">b_end</span> <span class="k">else</span> <span class="n">b</span><span class="p">[</span><span class="n">b_start</span> <span class="o">+</span> <span class="n">k</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="n">mid_a</span> <span class="o">&lt;</span> <span class="n">mid_b</span><span class="p">:</span>
            <span class="k">return</span> <span class="nf">kth</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">a_start</span> <span class="o">+</span> <span class="n">k</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span> <span class="n">a_end</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">b_start</span><span class="p">,</span> <span class="n">b_end</span><span class="p">,</span> <span class="n">k</span> <span class="o">-</span> <span class="n">k</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nf">kth</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">a_start</span><span class="p">,</span> <span class="n">a_end</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">b_start</span> <span class="o">+</span> <span class="n">k</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span> <span class="n">b_end</span><span class="p">,</span> <span class="n">k</span> <span class="o">-</span> <span class="n">k</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>
    
    <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">nums1</span><span class="p">),</span> <span class="nf">len</span><span class="p">(</span><span class="n">nums2</span><span class="p">)</span>
    <span class="n">total</span> <span class="o">=</span> <span class="n">m</span> <span class="o">+</span> <span class="n">n</span>
    
    <span class="k">if</span> <span class="n">total</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="nf">kth</span><span class="p">(</span><span class="n">nums1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nums2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">total</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">left</span> <span class="o">=</span> <span class="nf">kth</span><span class="p">(</span><span class="n">nums1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nums2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">total</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">right</span> <span class="o">=</span> <span class="nf">kth</span><span class="p">(</span><span class="n">nums1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nums2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">total</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="nf">return </span><span class="p">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
</code></pre></div></div>

<p><strong>Complexity:</strong> $O(\log(m + n))$.</p>

<h2 id="19-conclusion">19. Conclusion</h2>

<p>The Median of Two Sorted Arrays problem is a classic example of how binary search can achieve logarithmic time complexity in non-obvious ways.</p>

<p><strong>Key Takeaways:</strong></p>
<ul>
  <li><strong>Binary Search on Partition:</strong> Instead of searching for a value, search for a valid partition.</li>
  <li><strong>Invariant Maintenance:</strong> Ensure left and right partitions satisfy the ordering property.</li>
  <li><strong>Edge Handling:</strong> Use sentinels (-inf, +inf) for boundary cases.</li>
  <li><strong>Generalization:</strong> The same technique works for finding the k-th element.</li>
</ul>

<p>This problem demonstrates that mastering binary search goes beyond simple “find the target”—it’s about identifying the right search space.</p>

<h2 id="20-related-problems">20. Related Problems</h2>

<ul>
  <li><strong>Median of Data Stream</strong> (LeetCode 295)</li>
  <li><strong>Kth Smallest Element in a Sorted Matrix</strong> (LeetCode 378)</li>
  <li><strong>Find K-th Smallest Pair Distance</strong> (LeetCode 719)</li>
  <li><strong>Split Array Largest Sum</strong> (LeetCode 410)</li>
</ul>

<p>Practice these to solidify your understanding of binary search on answer patterns!</p>

<h2 id="21-deep-dive-median-in-a-stream-two-heaps">21. Deep Dive: Median in a Stream (Two Heaps)</h2>

<p><strong>Problem:</strong> Find the median as elements are added one by one.</p>

<p><strong>Algorithm:</strong></p>
<ol>
  <li>Maintain two heaps:
    <ul>
      <li><strong>Max-Heap (left):</strong> Smaller half.</li>
      <li><strong>Min-Heap (right):</strong> Larger half.</li>
    </ul>
  </li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>Balance:</td>
          <td>left</td>
          <td>=</td>
          <td>right</td>
          <td>or</td>
          <td>left</td>
          <td>=</td>
          <td>right</td>
          <td>+ 1.</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>Median = top(left) or (top(left) + top(right)) / 2.</li>
</ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">heapq</span>

<span class="k">class</span> <span class="nc">MedianFinder</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="p">[]</span>   <span class="c1"># Max-heap (negate values)
</span>        <span class="n">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Min-heap
</span>    
    <span class="k">def</span> <span class="nf">addNum</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">num</span><span class="p">):</span>
        <span class="c1"># Add to left (max-heap)
</span>        <span class="n">heapq</span><span class="p">.</span><span class="nf">heappush</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="o">-</span><span class="n">num</span><span class="p">)</span>
        
        <span class="c1"># Balance: Move largest from left to right
</span>        <span class="n">heapq</span><span class="p">.</span><span class="nf">heappush</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">right</span><span class="p">,</span> <span class="o">-</span><span class="n">heapq</span><span class="p">.</span><span class="nf">heappop</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">left</span><span class="p">))</span>
        
        <span class="c1"># Ensure left has at least as many elements
</span>        <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">left</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nf">len</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">right</span><span class="p">):</span>
            <span class="n">heapq</span><span class="p">.</span><span class="nf">heappush</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="o">-</span><span class="n">heapq</span><span class="p">.</span><span class="nf">heappop</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">right</span><span class="p">))</span>
    
    <span class="k">def</span> <span class="nf">findMedian</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">left</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nf">len</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">right</span><span class="p">):</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">self</span><span class="p">.</span><span class="n">left</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="nf">return </span><span class="p">(</span><span class="o">-</span><span class="n">self</span><span class="p">.</span><span class="n">left</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">self</span><span class="p">.</span><span class="n">right</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span>
</code></pre></div></div>

<p><strong>Complexity:</strong></p>
<ul>
  <li><strong>Add:</strong> $O(\log n)$.</li>
  <li><strong>Find Median:</strong> $O(1)$.</li>
</ul>

<h2 id="22-deep-dive-median-in-a-matrix-binary-search-on-value">22. Deep Dive: Median in a Matrix (Binary Search on Value)</h2>

<p><strong>Problem:</strong> Find the median of a row-wise sorted matrix.</p>

<p><strong>Algorithm:</strong></p>
<ol>
  <li>Binary search on the value (not index).</li>
  <li>For each candidate value, count elements ≤ it in each row.</li>
  <li>If count = (rows × cols + 1) / 2, we found the median.</li>
</ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">matrixMedian</span><span class="p">(</span><span class="n">matrix</span><span class="p">):</span>
    <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">matrix</span><span class="p">),</span> <span class="nf">len</span><span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    
    <span class="n">lo</span> <span class="o">=</span> <span class="nf">min</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">matrix</span><span class="p">)</span>
    <span class="n">hi</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">matrix</span><span class="p">)</span>
    
    <span class="n">target</span> <span class="o">=</span> <span class="p">(</span><span class="n">rows</span> <span class="o">*</span> <span class="n">cols</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
    
    <span class="k">while</span> <span class="n">lo</span> <span class="o">&lt;</span> <span class="n">hi</span><span class="p">:</span>
        <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">lo</span> <span class="o">+</span> <span class="n">hi</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        
        <span class="c1"># Count elements &lt;= mid in all rows
</span>        <span class="n">count</span> <span class="o">=</span> <span class="nf">sum</span><span class="p">(</span><span class="n">bisect</span><span class="p">.</span><span class="nf">bisect_right</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">mid</span><span class="p">)</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">matrix</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="n">target</span><span class="p">:</span>
            <span class="n">lo</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">hi</span> <span class="o">=</span> <span class="n">mid</span>
    
    <span class="k">return</span> <span class="n">lo</span>
</code></pre></div></div>

<p><strong>Complexity:</strong> $O(R \cdot \log C \cdot \log(\max - \min))$.</p>

<h2 id="23-variant-sliding-window-median">23. Variant: Sliding Window Median</h2>

<p><strong>Problem:</strong> Find the median of each window of size k.</p>

<p><strong>Approach:</strong></p>
<ol>
  <li>Use two heaps (like streaming median).</li>
  <li>Use lazy deletion to handle elements leaving the window.</li>
</ol>

<p><strong>Challenge:</strong> Efficiently removing elements from heaps.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">sortedcontainers</span> <span class="kn">import</span> <span class="n">SortedList</span>

<span class="k">def</span> <span class="nf">medianSlidingWindow</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
    <span class="n">window</span> <span class="o">=</span> <span class="nc">SortedList</span><span class="p">()</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">num</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">nums</span><span class="p">):</span>
        <span class="n">window</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">window</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">k</span><span class="p">:</span>
            <span class="n">window</span><span class="p">.</span><span class="nf">remove</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">k</span><span class="p">])</span>
        
        <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">window</span><span class="p">)</span> <span class="o">==</span> <span class="n">k</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">result</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">window</span><span class="p">[</span><span class="n">k</span> <span class="o">//</span> <span class="mi">2</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span><span class="p">.</span><span class="nf">append</span><span class="p">((</span><span class="n">window</span><span class="p">[</span><span class="n">k</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">window</span><span class="p">[</span><span class="n">k</span> <span class="o">//</span> <span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">result</span>
</code></pre></div></div>

<p><strong>Complexity:</strong> $O(n \cdot \log k)$ with balanced BST.</p>

<h2 id="24-application-ab-testing-statistics">24. Application: A/B Testing Statistics</h2>

<p><strong>Scenario:</strong> Compare median latency between control and treatment groups.</p>

<p><strong>Challenge:</strong> Latencies are stored on multiple servers.</p>

<p><strong>Approach:</strong></p>
<ol>
  <li>Each server computes a histogram of latencies.</li>
  <li>Merge histograms.</li>
  <li>Find median from merged histogram.</li>
</ol>

<p><strong>Benefit:</strong> Avoids transferring raw data.</p>

<h2 id="25-application-database-query-optimization">25. Application: Database Query Optimization</h2>

<p><strong>Scenario:</strong> SQL query <code class="language-plaintext highlighter-rouge">SELECT MEDIAN(column) FROM table</code>.</p>

<p><strong>Implementation:</strong></p>
<ol>
  <li>If table is sorted: Direct access to middle element.</li>
  <li>If unsorted: Use quickselect ($O(n)$ average) or sort ($O(n \log n)$).</li>
  <li>For approximate median: Use sampling or t-digest.</li>
</ol>

<h2 id="26-deep-dive-approximating-median-with-t-digest">26. Deep Dive: Approximating Median with T-Digest</h2>

<p><strong>T-Digest</strong> is a data structure for approximate percentile computation.</p>

<p><strong>Algorithm:</strong></p>
<ol>
  <li>Maintain a set of centroids (mean, count).</li>
  <li>Centroids near the median are small (high precision).</li>
  <li>Centroids at the extremes are large (low precision).</li>
</ol>

<p><strong>Operations:</strong></p>
<ul>
  <li><strong>Add:</strong> Merge new element into nearest centroid.</li>
  <li><strong>Query:</strong> Walk through centroids to find percentile.</li>
</ul>

<p><strong>Use Case:</strong> Real-time percentile computation at scale (Netflix, Elasticsearch).</p>

<h2 id="27-testing-strategy">27. Testing Strategy</h2>

<p><strong>Test Cases:</strong></p>
<ol>
  <li><strong>Both Arrays Empty:</strong> Handle gracefully.</li>
  <li><strong>One Array Empty:</strong> Return median of the other.</li>
  <li><strong>Same Size Arrays:</strong> <code class="language-plaintext highlighter-rouge">[1,2]</code>, <code class="language-plaintext highlighter-rouge">[3,4]</code> → 2.5.</li>
  <li><strong>Different Size Arrays:</strong> <code class="language-plaintext highlighter-rouge">[1,3]</code>, <code class="language-plaintext highlighter-rouge">[2]</code> → 2.</li>
  <li><strong>All Elements in One Array Smaller:</strong> <code class="language-plaintext highlighter-rouge">[1,2]</code>, <code class="language-plaintext highlighter-rouge">[3,4,5,6]</code>.</li>
  <li><strong>Duplicates:</strong> <code class="language-plaintext highlighter-rouge">[1,1,1]</code>, <code class="language-plaintext highlighter-rouge">[1,1,1]</code> → 1.</li>
  <li><strong>Large Arrays:</strong> Performance testing.</li>
</ol>

<p><strong>Edge Cases:</strong></p>
<ul>
  <li>Single element in each array.</li>
  <li>Negative numbers.</li>
  <li>Very large values.</li>
</ul>

<h2 id="28-interview-tips">28. Interview Tips</h2>

<p><strong>Step-by-Step Approach:</strong></p>
<ol>
  <li><strong>Clarify:</strong> Sizes, sorted order, allowed time complexity.</li>
  <li><strong>Brute Force:</strong> Merge and find median ($O(m+n)$).</li>
  <li><strong>Optimize:</strong> Binary search on partition ($O(\log \min(m,n))$).</li>
  <li><strong>Walk Through:</strong> Use a specific example.</li>
  <li><strong>Edge Cases:</strong> Empty arrays, single elements.</li>
  <li><strong>Code:</strong> Write clean, bug-free code.</li>
  <li><strong>Complexity:</strong> Analyze time and space.</li>
</ol>

<h2 id="29-common-follow-up-questions">29. Common Follow-up Questions</h2>

<p><strong>Q: What if arrays are not sorted?</strong>
<strong>A:</strong> Sort first ($O(n \log n)$), or use quickselect.</p>

<p><strong>Q: What if we can’t afford $O(\log(m+n))$?</strong>
<strong>A:</strong> Two-pointer merge is $O(m+n)$ and may be acceptable.</p>

<p><strong>Q: What if arrays are on different machines?</strong>
<strong>A:</strong> Use the sampling/counting approach for distributed median.</p>

<p><strong>Q: What if we need the k-th element instead of median?</strong>
<strong>A:</strong> Same algorithm, just change the target partition size.</p>

<h2 id="30-mastery-checklist">30. Mastery Checklist</h2>

<p><strong>Mastery Checklist:</strong></p>
<ul class="task-list">
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Implement brute force (merge and find)</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Implement two-pointer (virtual merge)</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Implement binary search on partition</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Handle edge cases (empty arrays, single elements)</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Generalize to k-th element</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Understand the divide-and-conquer approach</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Explain why binary search works (partition invariant)</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Implement streaming median (two heaps)</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Implement sliding window median</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Understand distributed median algorithms</li>
</ul>

<h2 id="31-conclusion">31. Conclusion</h2>

<p>The Median of Two Sorted Arrays is one of the most elegant problems in computer science. It combines:</p>
<ul>
  <li><strong>Binary Search:</strong> A powerful algorithmic paradigm.</li>
  <li><strong>Partition Logic:</strong> Dividing arrays into meaningful halves.</li>
  <li><strong>Edge Case Handling:</strong> Using sentinels for boundaries.</li>
</ul>

<p>Mastering this problem opens the door to many advanced topics: distributed computing, real-time statistics, and database optimization. It’s a testament to how mathematical insight can lead to efficient algorithms.</p>

<p><strong>The journey from $O(m+n)$ to $O(\log \min(m,n))$ teaches us that the right perspective can transform a problem.</strong></p>


        
      </section>

      <footer class="page__meta">
        
        
  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-tags" aria-hidden="true"></i> Tags: </strong>
    <span itemprop="keywords">
    
      <a href="/tags/#array" class="page__taxonomy-item p-category" rel="tag">array</a><span class="sep">, </span>
    
      <a href="/tags/#binary-search" class="page__taxonomy-item p-category" rel="tag">binary-search</a><span class="sep">, </span>
    
      <a href="/tags/#divide-and-conquer" class="page__taxonomy-item p-category" rel="tag">divide-and-conquer</a>
    
    </span>
  </p>




  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> Categories: </strong>
    <span itemprop="keywords">
    
      <a href="/categories/#dsa" class="page__taxonomy-item p-category" rel="tag">dsa</a>
    
    </span>
  </p>


        
      </footer>

      

      <section class="page__share">
  <h4 class="page__share-title">Share on</h4>

  <a href="https://twitter.com/intent/tweet?via=arunbaby0&text=Median+of+Two+Sorted+Arrays%20https%3A%2F%2Fwww.arunbaby.com%2Fdsa%2F0043-median-of-two-sorted-arrays%2F" class="btn btn--twitter" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Twitter"><i class="fab fa-fw fa-twitter" aria-hidden="true"></i><span> Twitter</span></a>

  <a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fwww.arunbaby.com%2Fdsa%2F0043-median-of-two-sorted-arrays%2F" class="btn btn--facebook" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Facebook"><i class="fab fa-fw fa-facebook" aria-hidden="true"></i><span> Facebook</span></a>

  <a href="https://www.linkedin.com/shareArticle?mini=true&url=https://www.arunbaby.com/dsa/0043-median-of-two-sorted-arrays/" class="btn btn--linkedin" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on LinkedIn"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i><span> LinkedIn</span></a>
</section>


      
  <nav class="pagination">
    
      <a href="/dsa/0042-merge-k-sorted-lists/" class="pagination--pager" title="Merge K Sorted Lists">Previous</a>
    
    
      <a href="/dsa/0044-largest-rectangle-histogram/" class="pagination--pager" title="Largest Rectangle in Histogram">Next</a>
    
  </nav>


    </div>

    
  </article>

  
  
</div>

      
    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';" role="search">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Enter your search term..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    

    
      
        
          <li><a href="https://twitter.com/arunbaby0" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-twitter-square" aria-hidden="true"></i> Twitter</a></li>
        
      
        
          <li><a href="https://github.com/arunbaby0" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
        
      
        
          <li><a href="https://www.linkedin.com/in/arunbaby0/" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i> LinkedIn</a></li>
        
      
        
          <li><a href="https://scholar.google.co.in/citations?user=6fSYWhkAAAAJ" rel="nofollow noopener noreferrer"><i class="fas fa-fw fa-graduation-cap" aria-hidden="true"></i> Google Scholar</a></li>
        
      
    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 1990 - 2143 <a href="https://www.arunbaby.com">Arun Baby</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>




  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-0JRJPEC9SS"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-0JRJPEC9SS', { 'anonymize_ip': false});
</script>








  </body>
</html>
