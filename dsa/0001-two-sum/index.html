<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.26.2 by Michael Rose
  Copyright 2013-2024 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->

<html lang="en-US" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Two Sum - Arun Baby</title>
<meta name="description" content="The hash table trick that makes O(n²) become O(n) and why this pattern appears everywhere from feature stores to embedding lookups.">


  <meta name="author" content="Arun Baby">
  
  <meta property="article:author" content="Arun Baby">
  


<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="Arun Baby">
<meta property="og:title" content="Two Sum">
<meta property="og:url" content="https://www.arunbaby.com/dsa/0001-two-sum/">


  <meta property="og:description" content="The hash table trick that makes O(n²) become O(n) and why this pattern appears everywhere from feature stores to embedding lookups.">



  <meta property="og:image" content="https://www.arunbaby.com/assets/images/profile-photo.png">



  <meta name="twitter:site" content="@arunbaby0">
  <meta name="twitter:title" content="Two Sum">
  <meta name="twitter:description" content="The hash table trick that makes O(n²) become O(n) and why this pattern appears everywhere from feature stores to embedding lookups.">
  <meta name="twitter:url" content="https://www.arunbaby.com/dsa/0001-two-sum/">

  
    <meta name="twitter:card" content="summary">
    
      <meta name="twitter:image" content="https://www.arunbaby.com/assets/images/profile-photo.png">
    
  

  



  <meta property="article:published_time" content="2025-12-29T16:05:30+05:30">





  

  


<link rel="canonical" href="https://www.arunbaby.com/dsa/0001-two-sum/">












<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Arun Baby Feed">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
  
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css"></noscript>



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--single" dir="ltr">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
           
          <span class="site-subtitle">Arun Baby</span>
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a
                href="/about/"
                
                
              >About</a>
            </li><li class="masthead__menu-item">
              <a
                href="/dsa/"
                
                
              >DSA</a>
            </li><li class="masthead__menu-item">
              <a
                href="/ml-system-design/"
                
                
              >ML Systems</a>
            </li><li class="masthead__menu-item">
              <a
                href="/speech-tech/"
                
                
              >Speech Tech</a>
            </li><li class="masthead__menu-item">
              <a
                href="/ai-agents/"
                
                
              >AI Agents</a>
            </li><li class="masthead__menu-item">
              <a
                href="/publications/"
                
                
              >Publications</a>
            </li><li class="masthead__menu-item">
              <a
                href="/statuses/"
                
                
              >Statuses</a>
            </li><li class="masthead__menu-item">
              <a
                href="/contact/"
                
                
              >Contact</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <i class="fas fa-search"></i>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      





<div id="main" role="main" class="no-author-sidebar">
  
  <div class="sidebar sticky">
  
  
  </div>



  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="Two Sum">
    <meta itemprop="description" content="The hash table trick that makes O(n²) become O(n) and why this pattern appears everywhere from feature stores to embedding lookups.">
    <meta itemprop="datePublished" content="2025-12-29T16:05:30+05:30">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">
            <a href="https://www.arunbaby.com/dsa/0001-two-sum/" itemprop="url">Two Sum
</a>
          </h1>
          

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          28 minute read
        
      </span>
    
  </p>


        </header>
      

      <section class="page__content" itemprop="text">
        
          <aside class="sidebar__right sticky">
            <nav class="toc">
              <header><h4 class="nav__title"><i class="fas fa-file-alt"></i> On this page</h4></header>
              <ul class="toc__menu"><li><a href="#introduction">Introduction</a></li><li><a href="#problem-statement">Problem Statement</a><ul><li><a href="#constraints-and-assumptions">Constraints and Assumptions</a></li><li><a href="#examples">Examples</a></li></ul></li><li><a href="#approach-1-brute-force-the-naive-solution">Approach 1: Brute Force (The Naive Solution)</a><ul><li><a href="#the-idea">The Idea</a></li><li><a href="#implementation">Implementation</a></li><li><a href="#step-by-step-walkthrough">Step-by-Step Walkthrough</a></li><li><a href="#complexity-analysis">Complexity Analysis</a></li><li><a href="#why-this-fails-at-scale">Why This Fails at Scale</a></li></ul></li><li><a href="#approach-2-hash-table-the-optimal-solution">Approach 2: Hash Table (The Optimal Solution)</a><ul><li><a href="#the-breakthrough-insight">The Breakthrough Insight</a></li><li><a href="#what-is-a-hash-table">What is a Hash Table?</a></li><li><a href="#the-algorithm">The Algorithm</a></li><li><a href="#detailed-walkthrough">Detailed Walkthrough</a></li><li><a href="#why-this-works">Why This Works</a></li><li><a href="#complexity-analysis-1">Complexity Analysis</a></li><li><a href="#performance-comparison">Performance Comparison</a></li></ul></li><li><a href="#deep-dive-hash-table-mechanics">Deep Dive: Hash Table Mechanics</a><ul><li><a href="#how-hash-functions-work">How Hash Functions Work</a></li><li><a href="#collision-handling">Collision Handling</a></li><li><a href="#why-hash-tables-are-o1">Why Hash Tables are O(1)</a></li></ul></li><li><a href="#variants-and-extensions">Variants and Extensions</a><ul><li><a href="#variant-1-return-values-instead-of-indices">Variant 1: Return Values Instead of Indices</a></li><li><a href="#variant-2-return-all-pairs">Variant 2: Return All Pairs</a></li><li><a href="#variant-3-sorted-input-two-pointers">Variant 3: Sorted Input (Two Pointers)</a></li><li><a href="#variant-4-count-number-of-pairs">Variant 4: Count Number of Pairs</a></li></ul></li><li><a href="#edge-cases-and-pitfalls">Edge Cases and Pitfalls</a><ul><li><a href="#edge-case-1-empty-or-single-element-array">Edge Case 1: Empty or Single Element Array</a></li><li><a href="#edge-case-2-using-same-element-twice">Edge Case 2: Using Same Element Twice</a></li><li><a href="#edge-case-3-negative-numbers">Edge Case 3: Negative Numbers</a></li><li><a href="#edge-case-4-zero-in-array">Edge Case 4: Zero in Array</a></li><li><a href="#edge-case-5-large-numbers">Edge Case 5: Large Numbers</a></li><li><a href="#common-mistake-1-overwriting-indices">Common Mistake 1: Overwriting Indices</a></li><li><a href="#common-mistake-2-forgetting-to-check-for-same-index">Common Mistake 2: Forgetting to Check for Same Index</a></li></ul></li><li><a href="#production-considerations">Production Considerations</a><ul><li><a href="#input-validation">Input Validation</a></li><li><a href="#logging-and-monitoring">Logging and Monitoring</a></li><li><a href="#thread-safety">Thread Safety</a></li><li><a href="#memory-management">Memory Management</a></li></ul></li><li><a href="#connections-to-real-world-systems">Connections to Real-World Systems</a><ul><li><a href="#1-feature-stores-in-ml">1. Feature Stores in ML</a></li><li><a href="#2-embedding-lookups">2. Embedding Lookups</a></li><li><a href="#3-cache-systems">3. Cache Systems</a></li><li><a href="#4-deduplication">4. Deduplication</a></li><li><a href="#5-join-operations-in-databases">5. Join Operations in Databases</a></li></ul></li><li><a href="#when-not-to-use-hash-tables">When NOT to Use Hash Tables</a><ul><li><a href="#1-need-sorted-order">1. Need Sorted Order</a></li><li><a href="#2-memory-constrained">2. Memory Constrained</a></li><li><a href="#3-small-inputs">3. Small Inputs</a></li></ul></li><li><a href="#testing-and-validation">Testing and Validation</a><ul><li><a href="#comprehensive-test-suite">Comprehensive Test Suite</a></li></ul></li><li><a href="#summary-and-key-takeaways">Summary and Key Takeaways</a><ul><li><a href="#core-concepts">Core Concepts</a></li><li><a href="#when-to-use-this-pattern">When to Use This Pattern</a></li><li><a href="#production-lessons">Production Lessons</a></li><li><a href="#related-patterns">Related Patterns</a></li><li><a href="#further-practice">Further Practice</a></li></ul></li><li><a href="#conclusion">Conclusion</a></li></ul>
            </nav>
          </aside>
        
        <p><strong>The hash table trick that makes O(n²) become O(n) and why this pattern appears everywhere from feature stores to embedding lookups.</strong></p>

<h2 id="introduction">Introduction</h2>

<p>Two Sum is often the first problem engineers encounter when starting their algorithm journey, but don’t let its “Easy” label fool you. This problem introduces one of the most powerful patterns in computer science: <strong>trading space for time using hash tables</strong>. This pattern isn’t just academic it powers real production systems handling millions of requests per second, from recommendation engines to real-time analytics.</p>

<p>In this comprehensive guide, we’ll explore:</p>
<ul>
  <li>Why the naive O(n²) solution fails at scale</li>
  <li>How hash tables enable O(1) lookups</li>
  <li>The underlying mechanics of hash tables</li>
  <li>When and why to use this pattern</li>
  <li>Real-world applications in ML systems</li>
  <li>Production considerations and edge cases</li>
  <li>Common pitfalls and how to avoid them</li>
</ul>

<h2 id="problem-statement">Problem Statement</h2>

<p><strong>Given an array of integers <code class="language-plaintext highlighter-rouge">nums</code> and an integer <code class="language-plaintext highlighter-rouge">target</code>, return the indices of the two numbers that add up to <code class="language-plaintext highlighter-rouge">target</code>.</strong></p>

<h3 id="constraints-and-assumptions">Constraints and Assumptions</h3>
<ul>
  <li>Each input has <strong>exactly one solution</strong></li>
  <li>You <strong>cannot use the same element twice</strong></li>
  <li>You can return the answer in any order</li>
  <li><code class="language-plaintext highlighter-rouge">2 &lt;= nums.length &lt;= 10^4</code></li>
  <li><code class="language-plaintext highlighter-rouge">-10^9 &lt;= nums[i] &lt;= 10^9</code></li>
  <li><code class="language-plaintext highlighter-rouge">-10^9 &lt;= target &lt;= 10^9</code></li>
</ul>

<h3 id="examples">Examples</h3>

<p><strong>Example 1:</strong>
<code class="language-plaintext highlighter-rouge">python
Input: nums = [2, 7, 11, 15], target = 9
Output: [0, 1]
Explanation: nums[0] + nums[1] = 2 + 7 = 9
</code></p>

<p><strong>Example 2:</strong>
<code class="language-plaintext highlighter-rouge">python
Input: nums = [3, 2, 4], target = 6
Output: [1, 2]
Explanation: nums[1] + nums[2] = 2 + 4 = 6
Note: We can't use [0, 0] because we can't use the same element twice
</code></p>

<p><strong>Example 3:</strong>
<code class="language-plaintext highlighter-rouge">python
Input: nums = [3, 3], target = 6
Output: [0, 1]
Explanation: Even though both values are 3, they're at different indices
</code></p>

<hr />

<h2 id="approach-1-brute-force-the-naive-solution">Approach 1: Brute Force (The Naive Solution)</h2>

<h3 id="the-idea">The Idea</h3>

<p>The most straightforward approach is to check every possible pair of numbers to see if they sum to the target. This is what most beginners think of first, and it’s a perfectly valid starting point.</p>

<h3 id="implementation">Implementation</h3>

<p>``python
def twoSum(nums: list[int], target: int) -&gt; list[int]:
 “””
 Brute force: Check all possible pairs</p>

<p>Args:
 nums: List of integers
 target: Target sum</p>

<p>Returns:
 List containing two indices [i, j] where nums[i] + nums[j] = target
 “””
 n = len(nums)</p>

<p># Outer loop: select first number
 for i in range(n):
 # Inner loop: select second number
 # Start from i+1 to avoid using same element twice
 for j in range(i + 1, n):
 if nums[i] + nums[j] == target:
 return [i, j]</p>

<p># Should never reach here given problem constraints
 return []
``</p>

<h3 id="step-by-step-walkthrough">Step-by-Step Walkthrough</h3>

<p>Let’s trace through <code class="language-plaintext highlighter-rouge">nums = [2, 7, 11, 15]</code>, <code class="language-plaintext highlighter-rouge">target = 9</code>:</p>

<p><code class="language-plaintext highlighter-rouge">
Iteration 1: i=0, nums[i]=2
 j=1: nums[1]=7 → 2+7=9 ✓ FOUND! Return [0,1]
</code></p>

<p>That was quick! But let’s see a case where it’s slower:</p>

<p>``
nums = [1, 2, 3, 4, 5], target = 9</p>

<p>Iteration 1: i=0, nums[i]=1
 j=1: 1+2=3 ✗
 j=2: 1+3=4 ✗
 j=3: 1+4=5 ✗
 j=4: 1+5=6 ✗</p>

<p>Iteration 2: i=1, nums[i]=2
 j=2: 2+3=5 ✗
 j=3: 2+4=6 ✗
 j=4: 2+5=7 ✗</p>

<p>Iteration 3: i=2, nums[i]=3
 j=3: 3+4=7 ✗
 j=4: 3+5=8 ✗</p>

<p>Iteration 4: i=3, nums[i]=4
 j=4: 4+5=9 ✓ FOUND! Return [3,4]
``</p>

<p>We had to check 9 pairs before finding the answer!</p>

<h3 id="complexity-analysis">Complexity Analysis</h3>

<p><strong>Time Complexity: O(n²)</strong></p>
<ul>
  <li>Outer loop runs n times</li>
  <li>For each outer iteration, inner loop runs (n-1), (n-2), …, 1 times</li>
  <li>Total comparisons: (n-1) + (n-2) + … + 1 = n(n-1)/2 ≈ n²/2</li>
  <li>In Big-O notation, we drop constants, so O(n²)</li>
</ul>

<p><strong>Space Complexity: O(1)</strong></p>
<ul>
  <li>We only use a fixed amount of extra space (variables i, j)</li>
  <li>No data structures that grow with input size</li>
</ul>

<h3 id="why-this-fails-at-scale">Why This Fails at Scale</h3>

<p>Let’s see what happens with different input sizes:</p>

<table>
  <thead>
    <tr>
      <th>Array Size</th>
      <th>Comparisons</th>
      <th>Time @ 1B ops/sec</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>100</td>
      <td>4,950</td>
      <td>0.005 ms</td>
    </tr>
    <tr>
      <td>1,000</td>
      <td>499,500</td>
      <td>0.5 ms</td>
    </tr>
    <tr>
      <td>10,000</td>
      <td>49,995,000</td>
      <td>50 ms</td>
    </tr>
    <tr>
      <td>100,000</td>
      <td>4,999,950,000</td>
      <td>5 seconds</td>
    </tr>
    <tr>
      <td>1,000,000</td>
      <td>~500 billion</td>
      <td>8+ minutes</td>
    </tr>
  </tbody>
</table>

<p><strong>Problem:</strong> As input doubles, runtime quadruples. This is catastrophic for large inputs.</p>

<p><strong>When it’s acceptable:</strong></p>
<ul>
  <li>Tiny arrays (n &lt; 100)</li>
  <li>One-time offline computation</li>
  <li>Prototyping/testing</li>
  <li>Interview follow-up after optimal solution</li>
</ul>

<p><strong>When it’s unacceptable:</strong></p>
<ul>
  <li>Production systems with unpredictable input sizes</li>
  <li>Real-time/latency-sensitive applications</li>
  <li>Repeated queries on same data</li>
  <li>Any n &gt; 10,000</li>
</ul>

<hr />

<h2 id="approach-2-hash-table-the-optimal-solution">Approach 2: Hash Table (The Optimal Solution)</h2>

<h3 id="the-breakthrough-insight">The Breakthrough Insight</h3>

<p>The key realization: <strong>For each number <code class="language-plaintext highlighter-rouge">nums[i]</code>, we need to find if <code class="language-plaintext highlighter-rouge">target - nums[i]</code> exists in the array.</strong></p>

<p>Instead of searching through the entire array each time (O(n)), we can use a <strong>hash table</strong> to check existence in O(1).</p>

<h3 id="what-is-a-hash-table">What is a Hash Table?</h3>

<p>Before diving into the solution, let’s understand the data structure that makes it possible.</p>

<p><strong>Hash Table (Dictionary/Map):</strong> A data structure that maps keys to values with O(1) average-case lookup time.</p>

<p><strong>How it works:</strong></p>
<ol>
  <li><strong>Hash Function:</strong> Converts a key into an array index</li>
  <li><strong>Array Storage:</strong> Stores values at computed indices</li>
  <li><strong>Collision Handling:</strong> Manages when two keys hash to same index</li>
</ol>

<p><strong>Example:</strong>
``python</p>
<h1 id="python-dictionary-is-a-hash-table">Python dictionary is a hash table</h1>
<p>seen = {}
seen[2] = 0 # Key 2 maps to value 0
seen[7] = 1 # Key 7 maps to value 1</p>

<h1 id="later-check-if-7-exists">Later, check if 7 exists</h1>
<p>if 7 in seen: # O(1) operation!
 print(f”Found at index {seen[7]}”)
``</p>

<p><strong>Under the Hood:</strong>
``
Key → Hash Function → Index in array</p>

<p>Example: hash(2) → 12345 % array_size → index 5
 hash(7) → 98765 % array_size → index 3</p>

<p>Array: [_, _, _, (7→1), _, (2→0), _, …]
 0 1 2 3 4 5 6
``</p>

<h3 id="the-algorithm">The Algorithm</h3>

<p><strong>Strategy:</strong> Build the hash table as we iterate, checking for complements.</p>

<p>``python
def twoSum(nums: list[int], target: int) -&gt; list[int]:
 “””
 Optimal solution using hash table</p>

<p>Time: O(n), Space: O(n)
 “””
 # Dictionary to store: number → index
 seen = {}</p>

<p>for i, num in enumerate(nums):
 # Calculate what number we need
 complement = target - num</p>

<p># Check if we’ve seen the complement before
 if complement in seen:
 # Found it! Return both indices
 return [seen[complement], i]</p>

<p># Haven’t found complement yet, store current number
 seen[num] = i</p>

<p># Problem guarantees a solution exists
 return []
``</p>

<h3 id="detailed-walkthrough">Detailed Walkthrough</h3>

<p>Let’s trace <code class="language-plaintext highlighter-rouge">nums = [2, 7, 11, 15]</code>, <code class="language-plaintext highlighter-rouge">target = 9</code>:</p>

<p>``
Initial state:
seen = {}</p>

<p>Iteration 1: i=0, num=2
 complement = 9 - 2 = 7
 Is 7 in seen? No
 Store: seen[2] = 0
 seen = {2: 0}</p>

<p>Iteration 2: i=1, num=7
 complement = 9 - 7 = 2
 Is 2 in seen? Yes! (at index 0)
 Return [0, 1] ✓
``</p>

<p><strong>Another example:</strong> <code class="language-plaintext highlighter-rouge">nums = [3, 2, 4]</code>, <code class="language-plaintext highlighter-rouge">target = 6</code>:</p>

<p>``
Initial: seen = {}</p>

<p>Iteration 1: i=0, num=3
 complement = 6 - 3 = 3
 Is 3 in seen? No
 seen = {3: 0}</p>

<p>Iteration 2: i=1, num=2
 complement = 6 - 2 = 4
 Is 4 in seen? No
 seen = {3: 0, 2: 1}</p>

<p>Iteration 3: i=2, num=4
 complement = 6 - 4 = 2
 Is 2 in seen? Yes! (at index 1)
 Return [1, 2] ✓
``</p>

<h3 id="why-this-works">Why This Works</h3>

<p><strong>Key observations:</strong></p>
<ol>
  <li><strong>Single pass:</strong> We only iterate through the array once</li>
  <li><strong>O(1) lookups:</strong> Hash table checks are constant time</li>
  <li><strong>Build as we go:</strong> No need to pre-populate the hash table</li>
  <li><strong>Order independent:</strong> Works regardless of element order</li>
</ol>

<p><strong>Mathematical proof:</strong></p>
<ul>
  <li>If <code class="language-plaintext highlighter-rouge">nums[i] + nums[j] = target</code></li>
  <li>Then <code class="language-plaintext highlighter-rouge">nums[j] = target - nums[i]</code></li>
  <li>When we reach <code class="language-plaintext highlighter-rouge">nums[j]</code>, we check if <code class="language-plaintext highlighter-rouge">(target - nums[j])</code> exists</li>
  <li>This equals <code class="language-plaintext highlighter-rouge">nums[i]</code>, which we stored earlier</li>
  <li>Therefore, we’ll find the pair when we encounter the second number</li>
</ul>

<h3 id="complexity-analysis-1">Complexity Analysis</h3>

<p><strong>Time Complexity: O(n)</strong></p>
<ul>
  <li>Single loop through n elements: O(n)</li>
  <li>Hash table operations (insert, lookup): O(1) average</li>
  <li>Total: O(n) × O(1) = O(n)</li>
</ul>

<p><strong>Space Complexity: O(n)</strong></p>
<ul>
  <li>Hash table stores at most n elements</li>
  <li>In worst case (no solution found until end), we store all n numbers</li>
</ul>

<p><strong>Best case:</strong> Solution found immediately → O(1) time, O(1) space
<strong>Average case:</strong> Solution found midway → O(n/2) ≈ O(n) time, O(n/2) ≈ O(n) space
<strong>Worst case:</strong> Solution at end → O(n) time, O(n) space</p>

<h3 id="performance-comparison">Performance Comparison</h3>

<table>
  <thead>
    <tr>
      <th>Array Size</th>
      <th>Brute Force</th>
      <th>Hash Table</th>
      <th>Speedup</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>100</td>
      <td>0.005 ms</td>
      <td>0.001 ms</td>
      <td>5x</td>
    </tr>
    <tr>
      <td>1,000</td>
      <td>0.5 ms</td>
      <td>0.01 ms</td>
      <td>50x</td>
    </tr>
    <tr>
      <td>10,000</td>
      <td>50 ms</td>
      <td>0.1 ms</td>
      <td>500x</td>
    </tr>
    <tr>
      <td>100,000</td>
      <td>5 sec</td>
      <td>1 ms</td>
      <td>5000x</td>
    </tr>
    <tr>
      <td>1,000,000</td>
      <td>8 min</td>
      <td>10 ms</td>
      <td>50000x</td>
    </tr>
  </tbody>
</table>

<p><strong>The speedup grows linearly with input size!</strong></p>

<hr />

<h2 id="deep-dive-hash-table-mechanics">Deep Dive: Hash Table Mechanics</h2>

<h3 id="how-hash-functions-work">How Hash Functions Work</h3>

<p>A hash function converts arbitrary data into a fixed-size integer:</p>

<p>``python
def simple_hash(key, table_size):
 “””
 Simplified hash function for integers
 “””
 return key % table_size</p>

<h1 id="example">Example</h1>
<p>table_size = 10
print(simple_hash(23, table_size)) # 3
print(simple_hash(47, table_size)) # 7
print(simple_hash(33, table_size)) # 3 ← Collision!
``</p>

<p><strong>Real hash functions are more sophisticated:</strong></p>
<ul>
  <li>Python uses SipHash for strings/bytes; integers hash to their value (with a special-case for -1)</li>
  <li>Involves bit manipulation and prime numbers</li>
  <li>Designed to minimize collisions</li>
  <li>Must be deterministic (same input → same output)</li>
</ul>

<h3 id="collision-handling">Collision Handling</h3>

<p><strong>Problem:</strong> Two different keys might hash to the same index.</p>

<p><strong>Solution 1: Chaining</strong>
<code class="language-plaintext highlighter-rouge">
Index 0: []
Index 1: [(7, idx_a), (17, idx_b)] ← Both hash to 1
Index 2: []
Index 3: [(3, idx_c)]
Index 4: [(4, idx_d), (14, idx_e)] ← Both hash to 4
</code></p>

<p>Each slot holds a linked list. Lookup requires traversing the list.</p>

<p><strong>Solution 2: Open Addressing</strong>
``
If slot is occupied, try next slot:</p>
<ul>
  <li>Linear probing: try slot+1, slot+2, …</li>
  <li>Quadratic probing: try slot+1², slot+2², …</li>
  <li>Double hashing: use second hash function
``</li>
</ul>

<p><strong>Python’s approach:</strong> Uses open addressing with a deterministic perturbation-based probing sequence.</p>

<h3 id="why-hash-tables-are-o1">Why Hash Tables are O(1)</h3>

<p><strong>Average case:</strong></p>
<ul>
  <li>Good hash function distributes keys uniformly</li>
  <li>Low load factor (&lt; 0.75) means few collisions</li>
  <li>Most lookups hit immediately</li>
</ul>

<p><strong>Worst case:</strong></p>
<ul>
  <li>All keys hash to same index → O(n) lookup</li>
  <li>But hash functions are designed to make this extremely unlikely</li>
  <li>Python automatically resizes table when load factor exceeds threshold</li>
</ul>

<p><strong>Load Factor:</strong>
``
load_factor = num_elements / table_size</p>

<p>Example:</p>
<ul>
  <li>~66 elements in table of size 100 → load factor ≈ 0.66</li>
  <li>When load factor exceeds roughly 2/3, CPython grows the table (with overallocation)</li>
  <li>This keeps lookup times close to O(1)
``</li>
</ul>

<hr />

<h2 id="variants-and-extensions">Variants and Extensions</h2>

<h3 id="variant-1-return-values-instead-of-indices">Variant 1: Return Values Instead of Indices</h3>

<p>``python
def twoSumValues(nums: list[int], target: int) -&gt; list[int]:
 “””
 Return the actual values, not indices
 “””
 seen = set()</p>

<p>for num in nums:
 complement = target - num
 if complement in seen:
 return [complement, num]
 seen.add(num)</p>

<p>return []</p>

<h1 id="example-1">Example</h1>
<p>nums = [2, 7, 11, 15], target = 9
result = twoSumValues(nums, 9) # [2, 7]
``</p>

<p><strong>When to use:</strong> You only need the values, not their positions.</p>

<h3 id="variant-2-return-all-pairs">Variant 2: Return All Pairs</h3>

<p>``python
def twoSumAllPairs(nums: list[int], target: int) -&gt; list[list[int]]:
 “””
 Find all pairs that sum to target (may have duplicates)
 “””
 seen = {}
 pairs = []</p>

<p>for i, num in enumerate(nums):
 complement = target - num</p>

<p># If complement exists, found a pair
 if complement in seen:
 for prev_idx in seen[complement]:
 pairs.append([prev_idx, i])</p>

<p># Store current number’s index
 if num not in seen:
 seen[num] = []
 seen[num].append(i)</p>

<p>return pairs</p>

<h1 id="example-2">Example</h1>
<p>nums = [1, 1, 1, 2, 2], target = 3
result = twoSumAllPairs(nums, 3)</p>
<h1 id="0-3-0-4-1-3-1-4-2-3-2-4">[[0, 3], [0, 4], [1, 3], [1, 4], [2, 3], [2, 4]]</h1>
<p>``</p>

<h3 id="variant-3-sorted-input-two-pointers">Variant 3: Sorted Input (Two Pointers)</h3>

<p><strong>If the array is sorted</strong>, we can use a more space-efficient approach:</p>

<p>``python
def twoSumSorted(nums: list[int], target: int) -&gt; list[int]:
 “””
 Two pointers approach for sorted array</p>

<p>Time: O(n), Space: O(1)
 “””
 left = 0
 right = len(nums) - 1</p>

<p>while left &lt; right:
 current_sum = nums[left] + nums[right]</p>

<p>if current_sum == target:
 return [left, right]
 elif current_sum &lt; target:
 # Sum too small, need larger number
 left += 1
 else:
 # Sum too large, need smaller number
 right -= 1</p>

<p>return []
``</p>

<p><strong>Why this works:</strong></p>
<ul>
  <li>Start with smallest and largest numbers</li>
  <li>If sum is too small, increase left pointer (make sum larger)</li>
  <li>If sum is too large, decrease right pointer (make sum smaller)</li>
  <li>Guaranteed to find solution in one pass</li>
</ul>

<p><strong>Trade-off:</strong></p>
<ul>
  <li>Pro: O(1) space (no hash table)</li>
  <li>Con: Requires sorted input (sorting is O(n log n))</li>
  <li>Use when: Array already sorted or space is critical</li>
</ul>

<p><strong>Example walkthrough:</strong>
``
nums = [1, 2, 3, 4, 5], target = 9</p>

<p>Step 1: left=0, right=4
 sum = 1 + 5 = 6 &lt; 9 → left++</p>

<p>Step 2: left=1, right=4
 sum = 2 + 5 = 7 &lt; 9 → left++</p>

<p>Step 3: left=2, right=4
 sum = 3 + 5 = 8 &lt; 9 → left++</p>

<p>Step 4: left=3, right=4
 sum = 4 + 5 = 9 = target ✓ Return [3, 4]
``</p>

<h3 id="variant-4-count-number-of-pairs">Variant 4: Count Number of Pairs</h3>

<p>``python
def countPairs(nums: list[int], target: int) -&gt; int:
 “””
 Count how many pairs sum to target
 “””
 seen = {}
 count = 0</p>

<p>for num in nums:
 complement = target - num</p>

<p># If complement exists, all its occurrences form pairs
 if complement in seen:
 count += seen[complement]</p>

<p># Increment count for current number
 seen[num] = seen.get(num, 0) + 1</p>

<p>return count</p>

<h1 id="example-3">Example</h1>
<p>nums = [1, 1, 1, 2, 2], target = 3
count = countPairs(nums, 3) # 6 pairs
``</p>

<hr />

<h2 id="edge-cases-and-pitfalls">Edge Cases and Pitfalls</h2>

<h3 id="edge-case-1-empty-or-single-element-array">Edge Case 1: Empty or Single Element Array</h3>

<p>``python
def twoSum(nums: list[int], target: int) -&gt; list[int]:
 if not nums or len(nums) &lt; 2:
 raise ValueError(“Array must have at least 2 elements”)</p>

<p>seen = {}
 for i, num in enumerate(nums):
 complement = target - num
 if complement in seen:
 return [seen[complement], i]
 seen[num] = i</p>

<p>raise ValueError(“No solution found”)
``</p>

<p><strong>Problem guarantees:</strong> The problem states there’s always exactly one solution, so we shouldn’t reach the exception in valid inputs.</p>

<h3 id="edge-case-2-using-same-element-twice">Edge Case 2: Using Same Element Twice</h3>

<p>``python</p>
<h1 id="wrong">Wrong!</h1>
<p>nums = [3, 3], target = 6</p>
<h1 id="if-were-not-careful-might-try-to-use-index-0-twice">If we’re not careful, might try to use index 0 twice</h1>

<h1 id="correct-approach-our-solution-naturally-handles-this">Correct approach: Our solution naturally handles this</h1>
<h1 id="because-we-only-add-to-seen-after-checking-for-complement">because we only add to <code class="language-plaintext highlighter-rouge">seen</code> after checking for complement</h1>
<p>``</p>

<p><strong>Why our solution works:</strong>
``
i=0, num=3:
 complement = 3
 3 not in seen yet
 seen = {3: 0}</p>

<p>i=1, num=3:
 complement = 3
 3 IS in seen (at index 0)
 Return [0, 1] ✓
``</p>

<h3 id="edge-case-3-negative-numbers">Edge Case 3: Negative Numbers</h3>

<p>``python
nums = [-1, -2, -3, -4, -5], target = -8</p>
<h1 id="works-perfectly-hash-tables-handle-negative-numbers-fine">Works perfectly! Hash tables handle negative numbers fine</h1>

<p>complement = -8 - (-5) = -3</p>
<h1 id="no-special-handling-needed">No special handling needed</h1>
<p>``</p>

<h3 id="edge-case-4-zero-in-array">Edge Case 4: Zero in Array</h3>

<p>``python
nums = [0, 4, 3, 0], target = 0</p>
<h1 id="target--0-means-we-need-two-numbers-that-sum-to-0">target = 0 means we need two numbers that sum to 0</h1>
<h1 id="ie-opposites-or-two-zeros">i.e., opposites or two zeros</h1>

<h1 id="our-solution-handles-this-correctly">Our solution handles this correctly</h1>
<p>``</p>

<h3 id="edge-case-5-large-numbers">Edge Case 5: Large Numbers</h3>

<p>``python
nums = [1000000000, -1000000000, 1], target = 1</p>
<h1 id="hash-tables-handle-large-integers-efficiently">Hash tables handle large integers efficiently</h1>
<h1 id="python-has-arbitrary-precision-integers-no-overflow">Python has arbitrary-precision integers, no overflow</h1>
<p>``</p>

<p><strong>In other languages (C++, Java):</strong>
``cpp
// Be careful with overflow when computing complement via subtraction
long long complement = static_cast<long long="">(target) - static_cast<long long="">(nums[i]);</long></long></p>

<p>// Safer approach: use 64-bit math throughout to avoid overflow
// If you must check for addition overflow explicitly:
if (nums[i] &gt; 0 &amp;&amp; target &gt; INT_MAX - nums[i]) { /* handle overflow <em>/ }
if (nums[i] &lt; 0 &amp;&amp; target &lt; INT_MIN - nums[i]) { /</em> handle underflow */ }
``</p>

<h3 id="common-mistake-1-overwriting-indices">Common Mistake 1: Overwriting Indices</h3>

<p>``python</p>
<h1 id="wrong-1">Wrong!</h1>
<p>def twoSumWrong(nums, target):
 seen = {}</p>

<p># Pre-populate hash table
 for i, num in enumerate(nums):
 seen[num] = i</p>

<p># Search for complement
 for i, num in enumerate(nums):
 complement = target - num
 if complement in seen and seen[complement] != i:
 return [i, seen[complement]]</p>

<p>return []</p>

<h1 id="problem-if-there-are-duplicates-we-overwrite-indices">Problem: If there are duplicates, we overwrite indices</h1>
<p>nums = [3, 2, 4], target = 6</p>
<h1 id="after-pre-population-seen--3-0-2-1-4-2">After pre-population: seen = {3: 0, 2: 1, 4: 2}</h1>
<h1 id="when-we-check-nums12-complement4-we-find-it">When we check nums[1]=2, complement=4, we find it</h1>
<h1 id="but-we-should-not-have-used-i0-for-num3">But we should not have used i=0 for num=3</h1>
<p>``</p>

<p><strong>Fix:</strong> Build hash table as we search (our original solution).</p>

<h3 id="common-mistake-2-forgetting-to-check-for-same-index">Common Mistake 2: Forgetting to Check for Same Index</h3>

<p>``python</p>
<h1 id="wrong-2">Wrong!</h1>
<p>def twoSumWrong(nums, target):
 seen = {}
 for i, num in enumerate(nums):
 seen[num] = i</p>

<p>for i, num in enumerate(nums):
 complement = target - num
 if complement in seen: # Missing check!
 return [i, seen[complement]]</p>

<p>return []</p>

<h1 id="problem-with-3-target--6">Problem with [3], target = 6:</h1>
<h1 id="complement--6---3--3">complement = 6 - 3 = 3</h1>
<h1 id="3-is-in-seen-at-index-0">3 is in seen at index 0</h1>
<h1 id="would-return-0-0-">Would return [0, 0] ✗</h1>
<p>``</p>

<p><strong>Fix:</strong> Check <code class="language-plaintext highlighter-rouge">seen[complement] != i</code>.</p>

<hr />

<h2 id="production-considerations">Production Considerations</h2>

<h3 id="input-validation">Input Validation</h3>

<p>``python
from typing import List, Optional</p>

<p>def twoSum(nums: Optional[List[int]], target: int) -&gt; List[int]:
 “””
 Production-grade implementation with validation
 “””
 # Validate inputs
 if nums is None:
 raise TypeError(“nums cannot be None”)</p>

<p>if not isinstance(nums, list):
 raise TypeError(f”nums must be a list, got {type(nums)}”)</p>

<p>if len(nums) &lt; 2:
 raise ValueError(f”nums must have at least 2 elements, got {len(nums)}”)</p>

<p>if not isinstance(target, (int, float)):
 raise TypeError(f”target must be a number, got {type(target)}”)</p>

<p># Main logic
 seen = {}
 for i, num in enumerate(nums):
 if not isinstance(num, (int, float)):
 raise TypeError(f”nums[{i}] must be a number, got {type(num)}”)</p>

<p>complement = target - num</p>

<p>if complement in seen:
 return [seen[complement], i]</p>

<p>seen[num] = i</p>

<p>raise ValueError(“No solution found”)
``</p>

<h3 id="logging-and-monitoring">Logging and Monitoring</h3>

<p>``python
import logging
import time</p>

<p>def twoSum(nums: List[int], target: int) -&gt; List[int]:
 “””
 Production version with logging
 “””
 logger = logging.getLogger(<strong>name</strong>)
 start_time = time.time()</p>

<p>logger.debug(f”Starting twoSum with {len(nums)} elements, target={target}”)</p>

<p>seen = {}
 for i, num in enumerate(nums):
 complement = target - num</p>

<p>if complement in seen:
 elapsed = (time.time() - start_time) * 1000
 logger.info(f”Found solution in {elapsed:.2f}ms after checking {i+1} elements”)
 return [seen[complement], i]</p>

<p>seen[num] = i</p>

<p>elapsed = (time.time() - start_time) * 1000
 logger.warning(f”No solution found after {elapsed:.2f}ms”)
 raise ValueError(“No solution found”)
``</p>

<h3 id="thread-safety">Thread Safety</h3>

<p>``python
from threading import Lock
from typing import Dict</p>

<p>class TwoSumCache:
 “””
 Thread-safe cache for repeated two-sum queries on same array
 “””
 def <strong>init</strong>(self):
 self._cache: Dict[tuple, List[int]] = {}
 self._lock = Lock()</p>

<p>def two_sum(self, nums: List[int], target: int) -&gt; List[int]:
 # Create cache key (tuple of nums and target)
 cache_key = (tuple(nums), target)</p>

<p># Check cache (thread-safe)
 with self._lock:
 if cache_key in self._cache:
 return self._cache[cache_key].copy()</p>

<p># Compute result
 result = self._two_sum_impl(nums, target)</p>

<p># Store in cache (thread-safe)
 with self._lock:
 self._cache[cache_key] = result.copy()</p>

<p>return result</p>

<p>def _two_sum_impl(self, nums: List[int], target: int) -&gt; List[int]:
 seen = {}
 for i, num in enumerate(nums):
 complement = target - num
 if complement in seen:
 return [seen[complement], i]
 seen[num] = i
 raise ValueError(“No solution found”)
``</p>

<h3 id="memory-management">Memory Management</h3>

<p>``python
def twoSumMemoryEfficient(nums: List[int], target: int) -&gt; List[int]:
 “””
 More memory-efficient for very large arrays
 “””
 # Instead of storing all elements, we can estimate capacity
 seen = {}</p>

<p># Pre-allocate to reduce resizing
 # (Python does this automatically, but you can hint)
 expected_size = min(len(nums), 10000) # Cap at 10k</p>

<p>for i, num in enumerate(nums):
 complement = target - num</p>

<p>if complement in seen:
 result = [seen[complement], i]</p>

<p># Clear hash table to free memory
 seen.clear()</p>

<p>return result</p>

<p>seen[num] = i</p>

<p># Optional: Limit hash table size in streaming scenarios
 if len(seen) &gt; expected_size:
 # This is a heuristic; adjust based on your use case
 pass</p>

<p>raise ValueError(“No solution found”)
``</p>

<hr />

<h2 id="connections-to-real-world-systems">Connections to Real-World Systems</h2>

<h3 id="1-feature-stores-in-ml">1. Feature Stores in ML</h3>

<p><strong>Problem:</strong> For each user request, quickly look up precomputed features.</p>

<p>``python
class FeatureStore:
 def <strong>init</strong>(self):
 # Hash table mapping user_id → features
 self.user_features = {}</p>

<p>def get_features(self, user_id: int) -&gt; dict:
 “"”O(1) lookup, just like Two Sum!”””
 if user_id in self.user_features:
 return self.user_features[user_id]</p>

<p># Compute and cache
 features = self._compute_features(user_id)
 self.user_features[user_id] = features
 return features</p>

<p>def _compute_features(self, user_id: int) -&gt; dict:
 # Expensive computation
 return {
 ‘age’: 28,
 ‘engagement_score’: 0.75,
 ‘last_active’: ‘2025-10-13’
 }</p>

<h1 id="usage">Usage</h1>
<p>store = FeatureStore()
features = store.get_features(user_id=12345) # O(1)!
``</p>

<p><strong>Scale:</strong> Feature stores at companies like Uber and Netflix serve millions of lookups per second using this exact pattern.</p>

<h3 id="2-embedding-lookups">2. Embedding Lookups</h3>

<p><strong>Problem:</strong> Given a token ID, retrieve its embedding vector.</p>

<p>``python
import numpy as np</p>

<p>class EmbeddingTable:
 def <strong>init</strong>(self, vocab_size: int, embedding_dim: int):
 # Hash table: token_id → embedding vector
 self.embeddings = {}</p>

<p># Initialize with random embeddings
 for token_id in range(vocab_size):
 self.embeddings[token_id] = np.random.randn(embedding_dim)</p>

<p>def lookup(self, token_id: int) -&gt; np.ndarray:
 “"”O(1) embedding lookup”””
 return self.embeddings[token_id]</p>

<h1 id="usage-in-neural-network">Usage in neural network</h1>
<p>embedding_table = EmbeddingTable(vocab_size=50000, embedding_dim=300)</p>

<h1 id="during-inference">During inference</h1>
<p>token_id = 4567
embedding = embedding_table.lookup(token_id) # O(1)!
``</p>

<p><strong>Real systems:</strong> GPT, BERT, and other transformer models perform millions of embedding lookups per second.</p>

<h3 id="3-cache-systems">3. Cache Systems</h3>

<p><strong>Problem:</strong> Store frequently accessed data for O(1) retrieval.</p>

<p>``python
from collections import OrderedDict</p>

<p>class LRUCache:
 def <strong>init</strong>(self, capacity: int):
 self.cache = OrderedDict()
 self.capacity = capacity</p>

<p>def get(self, key: int) -&gt; int:
 “"”O(1) lookup with LRU tracking”””
 if key not in self.cache:
 return -1</p>

<p># Move to end (mark as recently used)
 self.cache.move_to_end(key)
 return self.cache[key]</p>

<p>def put(self, key: int, value: int) -&gt; None:
 “"”O(1) insertion with LRU eviction”””
 if key in self.cache:
 # Update existing key
 self.cache.move_to_end(key)
 else:
 # Add new key
 if len(self.cache) &gt;= self.capacity:
 # Evict least recently used
 self.cache.popitem(last=False)</p>

<p>self.cache[key] = value</p>

<h1 id="usage-1">Usage</h1>
<p>cache = LRUCache(capacity=1000)
cache.put(user_id=123, value={“name”: “Alice”})
user_data = cache.get(user_id=123) # O(1)!
``</p>

<p><strong>Production examples:</strong> Redis, Memcached, and CDN caches use hash tables for O(1) lookups.</p>

<h3 id="4-deduplication">4. Deduplication</h3>

<p><strong>Problem:</strong> Remove duplicate entries from a stream of data.</p>

<p>``python
def deduplicate_stream(data_stream):
 “””
 Remove duplicates from stream in O(n) time
 “””
 seen = set() # Hash set (hash table with no values)
 unique_items = []</p>

<p>for item in data_stream:
 if item not in seen: # O(1) check
 unique_items.append(item)
 seen.add(item) # O(1) insertion</p>

<p>return unique_items</p>

<h1 id="usage-in-data-pipeline">Usage in data pipeline</h1>
<p>raw_events = [
 {“user_id”: 1, “action”: “click”},
 {“user_id”: 2, “action”: “view”},
 {“user_id”: 1, “action”: “click”}, # Duplicate
 {“user_id”: 3, “action”: “purchase”}
]</p>

<p>unique_events = deduplicate_stream(raw_events)</p>
<h1 id="on-time-instead-of-on-with-nested-loops">O(n) time instead of O(n²) with nested loops!</h1>
<p>``</p>

<h3 id="5-join-operations-in-databases">5. Join Operations in Databases</h3>

<p><strong>Problem:</strong> SQL JOIN operations use hash tables for efficiency.</p>

<p>``python
def hash_join(table1, table2, join_key):
 “””
 Simplified hash join algorithm (used in databases)</p>

<p>Similar to Two Sum: build hash table from one table,
 probe with the other
 “””
 # Build phase: Create hash table from smaller table
 hash_table = {}
 for row in table1:
 key = row[join_key]
 if key not in hash_table:
 hash_table[key] = []
 hash_table[key].append(row)</p>

<p># Probe phase: Lookup each row from table2
 result = []
 for row in table2:
 key = row[join_key]
 if key in hash_table: # O(1) lookup!
 for matching_row in hash_table[key]:
 result.append({**matching_row, **row})</p>

<p>return result</p>

<h1 id="example-4">Example</h1>
<p>users = [
 {“user_id”: 1, “name”: “Alice”},
 {“user_id”: 2, “name”: “Bob”}
]</p>

<p>orders = [
 {“user_id”: 1, “order_id”: 101},
 {“user_id”: 1, “order_id”: 102},
 {“user_id”: 2, “order_id”: 103}
]</p>

<h1 id="on--m-hash-join-vs-on--m-nested-loop-join">O(n + m) hash join vs O(n * m) nested loop join</h1>
<p>joined = hash_join(users, orders, “user_id”)
``</p>

<p><strong>Database systems</strong> (PostgreSQL, MySQL) use hash joins when appropriate, achieving massive speedups over nested loop joins.</p>

<hr />

<h2 id="when-not-to-use-hash-tables">When NOT to Use Hash Tables</h2>

<p>Despite their power, hash tables aren’t always the answer:</p>

<h3 id="1-need-sorted-order">1. Need Sorted Order</h3>

<p>``python</p>
<h1 id="if-you-need-results-in-sorted-order-hash-tables-wont-help">If you need results in sorted order, hash tables won’t help</h1>
<h1 id="use-sorting--two-pointers-instead">Use sorting + two pointers instead</h1>

<p>def twoSumSortedResult(nums, target):
 # Create list of (value, index) pairs
 indexed = [(num, i) for i, num in enumerate(nums)]</p>

<p># Sort by value
 indexed.sort()</p>

<p>left, right = 0, len(indexed) - 1
 while left &lt; right:
 curr_sum = indexed[left][0] + indexed[right][0]
 if curr_sum == target:
 return sorted([indexed[left][1], indexed[right][1]])
 elif curr_sum &lt; target:
 left += 1
 else:
 right -= 1</p>

<p>return []
``</p>

<h3 id="2-memory-constrained">2. Memory Constrained</h3>

<p>``python</p>
<h1 id="embedded-systems-mobile-devices-with-limited-memory">Embedded systems, mobile devices with limited memory</h1>
<h1 id="if-on-extra-space-is-too-much-use-two-pointers-on-sorted-array">If O(n) extra space is too much, use two pointers on sorted array</h1>

<p>def twoSumLowMemory(nums, target):
 # Sort in-place (if allowed to modify input)
 sorted_indices = sorted(range(len(nums)), key=lambda i: nums[i])</p>

<p>left, right = 0, len(nums) - 1
 while left &lt; right:
 l_idx, r_idx = sorted_indices[left], sorted_indices[right]
 curr_sum = nums[l_idx] + nums[r_idx]</p>

<p>if curr_sum == target:
 return [l_idx, r_idx]
 elif curr_sum &lt; target:
 left += 1
 else:
 right -= 1</p>

<p>return []
``</p>

<h3 id="3-small-inputs">3. Small Inputs</h3>

<p>``python</p>
<h1 id="for-n--100-brute-force-might-be-faster">For n &lt; 100, brute force might be faster</h1>
<h1 id="no-hash-table-overhead-better-cache-locality">No hash table overhead, better cache locality</h1>

<p>def twoSumSmallInput(nums, target):
 if len(nums) &lt; 100:
 # Brute force for small inputs
 for i in range(len(nums)):
 for j in range(i+1, len(nums)):
 if nums[i] + nums[j] == target:
 return [i, j]
 else:
 # Hash table for large inputs
 return twoSum(nums, target)
``</p>

<hr />

<h2 id="testing-and-validation">Testing and Validation</h2>

<h3 id="comprehensive-test-suite">Comprehensive Test Suite</h3>

<p>``python
import unittest</p>

<p>class TestTwoSum(unittest.TestCase):
 def test_basic_case(self):
 “"”Test example from problem statement”””
 nums = [2, 7, 11, 15]
 target = 9
 result = twoSum(nums, target)
 self.assertEqual(sorted(result), [0, 1])
 self.assertEqual(nums[result[0]] + nums[result[1]], target)</p>

<p>def test_duplicates(self):
 “"”Test with duplicate values”””
 nums = [3, 3]
 target = 6
 result = twoSum(nums, target)
 self.assertEqual(sorted(result), [0, 1])</p>

<p>def test_negative_numbers(self):
 “"”Test with negative numbers”””
 nums = [-1, -2, -3, -4, -5]
 target = -8
 result = twoSum(nums, target)
 self.assertEqual(nums[result[0]] + nums[result[1]], target)</p>

<p>def test_zero_target(self):
 “"”Test with zero as target”””
 nums = [-3, 0, 3, 4]
 target = 0
 result = twoSum(nums, target)
 self.assertEqual(nums[result[0]] + nums[result[1]], 0)</p>

<p>def test_large_numbers(self):
 “"”Test with large numbers”””
 nums = [1000000000, -1000000000, 1]
 target = 1
 result = twoSum(nums, target)
 self.assertEqual(nums[result[0]] + nums[result[1]], 1)</p>

<p>def test_minimum_size(self):
 “"”Test with minimum array size”””
 nums = [1, 2]
 target = 3
 result = twoSum(nums, target)
 self.assertEqual(sorted(result), [0, 1])</p>

<p>def test_unordered(self):
 “"”Test that order doesn’t matter”””
 nums = [15, 11, 7, 2]
 target = 9
 result = twoSum(nums, target)
 self.assertEqual(nums[result[0]] + nums[result[1]], 9)</p>

<p>def test_performance(self):
 “"”Test performance with large input”””
 import time</p>

<p># Generate large array
 nums = list(range(10000))
 target = 19999 # Last two elements</p>

<p>start = time.time()
 result = twoSum(nums, target)
 elapsed = time.time() - start</p>

<p>self.assertEqual(nums[result[0]] + nums[result[1]], target)
 self.assertLess(elapsed, 0.1, “Should complete in &lt; 100ms”)</p>

<p>if <strong>name</strong> == ‘<strong>main</strong>’:
 unittest.main()
``</p>

<hr />

<h2 id="summary-and-key-takeaways">Summary and Key Takeaways</h2>

<h3 id="core-concepts">Core Concepts</h3>

<p>✅ <strong>Hash tables enable O(1) lookups</strong>, reducing O(n²) to O(n)
✅ <strong>Space-time tradeoff</strong>: We use O(n) space to achieve O(n) time
✅ <strong>Build as you go</strong>: No need to pre-populate the hash table
✅ <strong>Complement pattern</strong>: For each element, check if its “partner” exists</p>

<h3 id="when-to-use-this-pattern">When to Use This Pattern</h3>

<p><strong>Use hash tables when:</strong></p>
<ul>
  <li>Need fast lookups (O(1) vs O(n))</li>
  <li>Memory is available</li>
  <li>Order doesn’t matter</li>
  <li>Working with large datasets</li>
</ul>

<p><strong>Use two pointers when:</strong></p>
<ul>
  <li>Input is already sorted</li>
  <li>Space is constrained</li>
  <li>Need sorted output</li>
  <li>Input is small (n &lt; 100)</li>
</ul>

<h3 id="production-lessons">Production Lessons</h3>

<ol>
  <li><strong>Always validate inputs</strong> in production code</li>
  <li><strong>Consider edge cases</strong> (empty, single element, duplicates, negatives)</li>
  <li><strong>Monitor performance</strong> with logging and metrics</li>
  <li><strong>Handle errors gracefully</strong> with clear error messages</li>
  <li><strong>Document assumptions</strong> (e.g., “exactly one solution exists”)</li>
</ol>

<h3 id="related-patterns">Related Patterns</h3>

<p>This hash table pattern appears in:</p>
<ul>
  <li><strong>3Sum, 4Sum, K-Sum</strong> problems</li>
  <li><strong>Feature stores</strong> in ML systems</li>
  <li><strong>Embedding tables</strong> in NLP</li>
  <li><strong>Cache systems</strong> (LRU, LFU)</li>
  <li><strong>Deduplication</strong> pipelines</li>
  <li><strong>Database joins</strong> (hash join)</li>
</ul>

<h3 id="further-practice">Further Practice</h3>

<p><strong>Next steps:</strong></p>
<ol>
  <li>Solve <a href="https://leetcode.com/problems/3sum/">3Sum</a> (extends Two Sum)</li>
  <li>Implement <a href="https://leetcode.com/problems/lru-cache/">LRU Cache</a> (uses hash table + doubly linked list)</li>
  <li>Study <a href="https://leetcode.com/problems/group-anagrams/">Group Anagrams</a> (hash table with string keys)</li>
  <li>Read about <a href="https://en.wikipedia.org/wiki/Consistent_hashing">Consistent Hashing</a> (used in distributed systems)</li>
</ol>

<p><strong>Books and resources:</strong></p>
<ul>
  <li><em>Introduction to Algorithms</em> (CLRS) - Chapter on Hash Tables</li>
  <li><em>Designing Data-Intensive Applications</em> by Martin Kleppmann</li>
  <li><em>The Algorithm Design Manual</em> by Steven Skiena</li>
</ul>

<hr />

<h2 id="conclusion">Conclusion</h2>

<p>Two Sum may seem simple, but it introduces one of the most important patterns in computer science: <strong>using hash tables to trade space for time</strong>. This pattern powers countless production systems, from recommendation engines serving millions of users to real-time analytics processing billions of events.</p>

<p>The next time you reach for a nested loop, ask yourself: “Could a hash table make this O(n) instead of O(n²)?” Often, the answer is yes and the performance difference can be transformational.</p>

<p>Remember: <strong>Algorithms aren’t just for interviews. They’re the foundation of scalable, efficient production systems.</strong></p>

<p>Happy coding! 🚀</p>

<hr />

<p><strong>Originally published at:</strong> <a href="https://www.arunbaby.com/dsa/0001-two-sum/">arunbaby.com/dsa/0001-two-sum</a></p>

<p><em>If you found this helpful, consider sharing it with others who might benefit.</em></p>

        
      </section>

      <footer class="page__meta">
        
        
  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-tags" aria-hidden="true"></i> Tags: </strong>
    <span itemprop="keywords">
    
      <a href="/tags/#arrays" class="page__taxonomy-item p-category" rel="tag">arrays</a><span class="sep">, </span>
    
      <a href="/tags/#hash-tables" class="page__taxonomy-item p-category" rel="tag">hash-tables</a>
    
    </span>
  </p>




  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> Categories: </strong>
    <span itemprop="keywords">
    
      <a href="/categories/#dsa" class="page__taxonomy-item p-category" rel="tag">dsa</a>
    
    </span>
  </p>


        
      </footer>

      <div class="page__related page__related--full">
  <h2 class="page__related-title">Related across topics</h2>
  <style>
    /* Make section span full content width and use 2 equal columns */
    .page__related--full { float: inline-start; width: 100%; padding: 0; }
    .cross-related-grid { display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 2rem; }
    @media (max-width: 768px) { .cross-related-grid { grid-template-columns: 1fr; } }
    /* Ensure archive cards stretch nicely in the grid */
    .cross-related-grid .list__item, .cross-related-grid .grid__item { width: auto; float: none; margin: 0; }
  </style>
  <div class="cross-related-grid">
    



<div class="list__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/ml-system-design/0001-recommendation-system/" rel="permalink">Recommendation System: Candidate Retrieval
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          14 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">How do you narrow down 10 million items to 1000 candidates in under 50ms? The art of fast retrieval at scale.
</p>
  </article>
</div>




<div class="list__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/speech-tech/0001-streaming-asr/" rel="permalink">Streaming ASR Architecture
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          12 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">Why batch ASR won’t work for voice assistants, and how streaming models transcribe speech as you speak in under 200ms.
</p>
  </article>
</div>




<div class="list__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/ai-agents/0001-what-are-ai-agents/" rel="permalink">What are AI Agents?
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          17 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">“From Passive Tools to Active Assistants: The Cognitive Revolution in Software.”
</p>
  </article>
</div>

  </div>
</div>

      <section class="page__share">
  <h4 class="page__share-title">Share on</h4>

  <a href="https://twitter.com/intent/tweet?via=arunbaby0&text=Two+Sum%20https%3A%2F%2Fwww.arunbaby.com%2Fdsa%2F0001-two-sum%2F" class="btn btn--twitter" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Twitter"><i class="fab fa-fw fa-twitter" aria-hidden="true"></i><span> Twitter</span></a>

  <a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fwww.arunbaby.com%2Fdsa%2F0001-two-sum%2F" class="btn btn--facebook" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Facebook"><i class="fab fa-fw fa-facebook" aria-hidden="true"></i><span> Facebook</span></a>

  <a href="https://www.linkedin.com/shareArticle?mini=true&url=https://www.arunbaby.com/dsa/0001-two-sum/" class="btn btn--linkedin" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on LinkedIn"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i><span> LinkedIn</span></a>
</section>


      
  <nav class="pagination">
    
      <a href="#" class="pagination--pager disabled">Previous</a>
    
    
      <a href="/dsa/0002-valid-parentheses/" class="pagination--pager" title="Valid Parentheses">Next</a>
    
  </nav>


    </div>

    
  </article>

  
  
</div>

      
    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';" role="search">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Enter your search term..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    

    
      
        
          <li><a href="https://twitter.com/arunbaby0" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-twitter-square" aria-hidden="true"></i> Twitter</a></li>
        
      
        
          <li><a href="https://github.com/arunbaby0" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
        
      
        
          <li><a href="https://www.linkedin.com/in/arunbaby0/" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i> LinkedIn</a></li>
        
      
        
          <li><a href="https://scholar.google.co.in/citations?user=6fSYWhkAAAAJ" rel="nofollow noopener noreferrer"><i class="fas fa-fw fa-graduation-cap" aria-hidden="true"></i> Google Scholar</a></li>
        
      
    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 1990 - 2143 <a href="https://www.arunbaby.com">Arun Baby</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>




  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-0JRJPEC9SS"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-0JRJPEC9SS', { 'anonymize_ip': false});
</script>








  </body>
</html>
