<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.26.2 by Michael Rose
  Copyright 2013-2024 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->

<html lang="en-US" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Climbing Stairs - Arun Baby</title>
<meta name="description" content="The Fibonacci problem in disguise, teaching the fundamental transition from recursion to dynamic programming to space optimization.">


  <meta name="author" content="Arun Baby">
  
  <meta property="article:author" content="Arun Baby">
  


<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="Arun Baby">
<meta property="og:title" content="Climbing Stairs">
<meta property="og:url" content="https://www.arunbaby.com/dsa/0006-climbing-stairs/">


  <meta property="og:description" content="The Fibonacci problem in disguise, teaching the fundamental transition from recursion to dynamic programming to space optimization.">



  <meta property="og:image" content="https://www.arunbaby.com/assets/images/profile-photo.png">



  <meta name="twitter:site" content="@arunbaby0">
  <meta name="twitter:title" content="Climbing Stairs">
  <meta name="twitter:description" content="The Fibonacci problem in disguise, teaching the fundamental transition from recursion to dynamic programming to space optimization.">
  <meta name="twitter:url" content="https://www.arunbaby.com/dsa/0006-climbing-stairs/">

  
    <meta name="twitter:card" content="summary">
    
      <meta name="twitter:image" content="https://www.arunbaby.com/assets/images/profile-photo.png">
    
  

  



  <meta property="article:published_time" content="2025-12-31T09:51:02+05:30">





  

  


<link rel="canonical" href="https://www.arunbaby.com/dsa/0006-climbing-stairs/">












<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Arun Baby Feed">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
  
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css"></noscript>



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--single" dir="ltr">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
           
          <span class="site-subtitle">Arun Baby</span>
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a
                href="/about/"
                
                
              >About</a>
            </li><li class="masthead__menu-item">
              <a
                href="/dsa/"
                
                
              >DSA</a>
            </li><li class="masthead__menu-item">
              <a
                href="/ml-system-design/"
                
                
              >ML Systems</a>
            </li><li class="masthead__menu-item">
              <a
                href="/speech-tech/"
                
                
              >Speech Tech</a>
            </li><li class="masthead__menu-item">
              <a
                href="/ai-agents/"
                
                
              >AI Agents</a>
            </li><li class="masthead__menu-item">
              <a
                href="/publications/"
                
                
              >Publications</a>
            </li><li class="masthead__menu-item">
              <a
                href="/statuses/"
                
                
              >Statuses</a>
            </li><li class="masthead__menu-item">
              <a
                href="/contact/"
                
                
              >Contact</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <i class="fas fa-search"></i>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      





<div id="main" role="main" class="no-author-sidebar">
  
  <div class="sidebar sticky">
  
  
  </div>



  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="Climbing Stairs">
    <meta itemprop="description" content="The Fibonacci problem in disguise, teaching the fundamental transition from recursion to dynamic programming to space optimization.">
    <meta itemprop="datePublished" content="2025-12-31T09:51:02+05:30">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">
            <a href="https://www.arunbaby.com/dsa/0006-climbing-stairs/" itemprop="url">Climbing Stairs
</a>
          </h1>
          

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          25 minute read
        
      </span>
    
  </p>


        </header>
      

      <section class="page__content" itemprop="text">
        
          <aside class="sidebar__right sticky">
            <nav class="toc">
              <header><h4 class="nav__title"><i class="fas fa-file-alt"></i> On this page</h4></header>
              <ul class="toc__menu"><li><a href="#problem">Problem</a></li><li><a href="#intuition">Intuition</a></li><li><a href="#approach-1-recursion-not-optimal">Approach 1: Recursion (Not Optimal)</a><ul><li><a href="#implementation">Implementation</a></li></ul></li><li><a href="#approach-2-recursion-with-memoization">Approach 2: Recursion with Memoization</a><ul><li><a href="#implementation-1">Implementation</a></li></ul></li><li><a href="#approach-3-dynamic-programming-bottom-up">Approach 3: Dynamic Programming (Bottom-Up)</a><ul><li><a href="#implementation-2">Implementation</a></li><li><a href="#walkthrough">Walkthrough</a></li></ul></li><li><a href="#approach-4-space-optimized-optimal">Approach 4: Space Optimized (Optimal)</a><ul><li><a href="#implementation-3">Implementation</a></li></ul></li><li><a href="#approach-5-fibonacci-formula-constant-time">Approach 5: Fibonacci Formula (Constant Time)</a><ul><li><a href="#implementation-4">Implementation</a></li></ul></li><li><a href="#approach-6-matrix-exponentiation-logarithmic-time">Approach 6: Matrix Exponentiation (Logarithmic Time)</a><ul><li><a href="#mathematical-foundation">Mathematical Foundation</a></li><li><a href="#implementation-5">Implementation</a></li><li><a href="#when-to-use-matrix-exponentiation">When to Use Matrix Exponentiation</a></li></ul></li><li><a href="#performance-comparison">Performance Comparison</a></li><li><a href="#common-mistakes--edge-cases">Common Mistakes &amp; Edge Cases</a><ul><li><a href="#mistake-1-off-by-one-errors">Mistake 1: Off-by-One Errors</a></li><li><a href="#mistake-2-not-handling-edge-cases">Mistake 2: Not Handling Edge Cases</a></li><li><a href="#mistake-3-integer-overflow">Mistake 3: Integer Overflow</a></li><li><a href="#mistake-4-modifying-input-in-memoization">Mistake 4: Modifying Input in Memoization</a></li><li><a href="#edge-case-n--0">Edge Case: n = 0</a></li></ul></li><li><a href="#production-engineering-considerations">Production Engineering Considerations</a><ul><li><a href="#1-caching-for-repeated-queries">1. Caching for Repeated Queries</a></li><li><a href="#2-precomputation-for-low-latency">2. Precomputation for Low Latency</a></li><li><a href="#3-handling-large-scale-distributed-systems">3. Handling Large-Scale Distributed Systems</a></li></ul></li><li><a href="#deep-dive-why-dynamic-programming">Deep Dive: Why Dynamic Programming?</a><ul><li><a href="#the-optimal-substructure-property">The Optimal Substructure Property</a></li><li><a href="#the-overlapping-subproblems-property">The Overlapping Subproblems Property</a></li><li><a href="#why-not-greedy">Why Not Greedy?</a></li></ul></li><li><a href="#variations">Variations</a><ul><li><a href="#variation-1-can-climb-1-2-or-3-steps">Variation 1: Can Climb 1, 2, or 3 Steps</a></li><li><a href="#variation-2-variable-step-sizes">Variation 2: Variable Step Sizes</a></li><li><a href="#variation-3-minimum-cost-climbing-stairs">Variation 3: Minimum Cost Climbing Stairs</a></li><li><a href="#variation-4-count-paths-with-constraints">Variation 4: Count Paths with Constraints</a></li></ul></li><li><a href="#connection-to-ml-systems">Connection to ML Systems</a><ul><li><a href="#model-training-iteration-strategy">Model Training Iteration Strategy</a></li><li><a href="#feature-selection-combinations">Feature Selection Combinations</a></li><li><a href="#pipeline-stage-combinations">Pipeline Stage Combinations</a></li></ul></li><li><a href="#testing">Testing</a><ul><li><a href="#comprehensive-test-suite">Comprehensive Test Suite</a></li></ul></li><li><a href="#interview-tips">Interview Tips</a><ul><li><a href="#recognizing-the-pattern">Recognizing the Pattern</a></li><li><a href="#interview-strategy-how-to-approach-this-problem">Interview Strategy: How to Approach This Problem</a></li><li><a href="#common-follow-ups">Common Follow-ups</a></li></ul></li><li><a href="#key-takeaways">Key Takeaways</a></li><li><a href="#related-problems">Related Problems</a></li></ul>
            </nav>
          </aside>
        
        <p><strong>The Fibonacci problem in disguise, teaching the fundamental transition from recursion to dynamic programming to space optimization.</strong></p>

<h2 id="problem">Problem</h2>

<p>You are climbing a staircase. It takes <code class="language-plaintext highlighter-rouge">n</code> steps to reach the top.</p>

<p>Each time you can either climb <strong>1 or 2 steps</strong>. In how many distinct ways can you climb to the top?</p>

<p><strong>Example 1:</strong>
``
Input: n = 2
Output: 2
Explanation: Two ways:</p>
<ol>
  <li>1 step + 1 step</li>
  <li>2 steps
``</li>
</ol>

<p><strong>Example 2:</strong>
``
Input: n = 3
Output: 3
Explanation: Three ways:</p>
<ol>
  <li>1 step + 1 step + 1 step</li>
  <li>1 step + 2 steps</li>
  <li>2 steps + 1 step
``</li>
</ol>

<p><strong>Constraints:</strong></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">1 &lt;= n &lt;= 45</code></li>
</ul>

<hr />

<h2 id="intuition">Intuition</h2>

<p><strong>Key Insight:</strong> To reach step <code class="language-plaintext highlighter-rouge">n</code>, you must have come from either step <code class="language-plaintext highlighter-rouge">n-1</code> (then climb 1 step) or step <code class="language-plaintext highlighter-rouge">n-2</code> (then climb 2 steps).</p>

<p><strong>Recurrence relation:</strong>
<code class="language-plaintext highlighter-rouge">
ways(n) = ways(n-1) + ways(n-2)
</code></p>

<p>This is the <strong>Fibonacci sequence</strong>!</p>

<p><strong>Why?</strong></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">ways(1) = 1</code> (one way: single step)</li>
  <li><code class="language-plaintext highlighter-rouge">ways(2) = 2</code> (two ways: 1+1 or 2)</li>
  <li><code class="language-plaintext highlighter-rouge">ways(3) = ways(2) + ways(1) = 2 + 1 = 3</code></li>
  <li><code class="language-plaintext highlighter-rouge">ways(4) = ways(3) + ways(2) = 3 + 2 = 5</code></li>
  <li>…</li>
</ul>

<hr />

<h2 id="approach-1-recursion-not-optimal">Approach 1: Recursion (Not Optimal)</h2>

<p>Direct recursive implementation.</p>

<h3 id="implementation">Implementation</h3>

<p>``python
def climbStairs(n: int) -&gt; int:
 “””
 Recursive solution</p>

<p>Time: O(2^n) - exponential!
 Space: O(n) - recursion stack
 “””
 # Base cases
 if n &lt;= 2:
 return n</p>

<p># Recursive case
 return climbStairs(n - 1) + climbStairs(n - 2)</p>

<h1 id="example">Example</h1>
<p>print(climbStairs(5)) # 8
``</p>

<p><strong>Why this is bad:</strong>
``
climbStairs(5)
├── climbStairs(4)
│ ├── climbStairs(3)
│ │ ├── climbStairs(2) ✓
│ │ └── climbStairs(1) ✓
│ └── climbStairs(2) ✓ (recomputed!)
└── climbStairs(3) (entire subtree recomputed!)
 ├── climbStairs(2) ✓
 └── climbStairs(1) ✓</p>

<p>Massive redundant computation!
``</p>

<p><strong>Time Complexity:</strong> O(2^n) - each call spawns two more calls 
<strong>Space Complexity:</strong> O(n) - maximum recursion depth</p>

<hr />

<h2 id="approach-2-recursion-with-memoization">Approach 2: Recursion with Memoization</h2>

<p>Cache results to avoid recomputation.</p>

<h3 id="implementation-1">Implementation</h3>

<p>``python
def climbStairs(n: int) -&gt; int:
 “””
 Recursion with memoization (top-down DP)</p>

<p>Time: O(n) - each subproblem solved once
 Space: O(n) - memoization cache + recursion stack
 “””
 memo = {}</p>

<p>def helper(n):
 # Base cases
 if n &lt;= 2:
 return n</p>

<p># Check memo
 if n in memo:
 return memo[n]</p>

<p># Compute and cache
 memo[n] = helper(n - 1) + helper(n - 2)
 return memo[n]</p>

<p>return helper(n)</p>

<h1 id="example-1">Example</h1>
<p>print(climbStairs(10)) # 89
``</p>

<p><strong>Time Complexity:</strong> O(n) - each value computed once 
<strong>Space Complexity:</strong> O(n) - memo dictionary + recursion stack</p>

<hr />

<h2 id="approach-3-dynamic-programming-bottom-up">Approach 3: Dynamic Programming (Bottom-Up)</h2>

<p>Build solution iteratively from base cases.</p>

<h3 id="implementation-2">Implementation</h3>

<p>``python
def climbStairs(n: int) -&gt; int:
 “””
 Bottom-up dynamic programming</p>

<p>Time: O(n)
 Space: O(n)
 “””
 if n &lt;= 2:
 return n</p>

<p># DP table
 dp = [0] * (n + 1)</p>

<p># Base cases
 dp[1] = 1
 dp[2] = 2</p>

<p># Fill table
 for i in range(3, n + 1):
 dp[i] = dp[i - 1] + dp[i - 2]</p>

<p>return dp[n]</p>

<h1 id="example-2">Example</h1>
<p>print(climbStairs(5)) # 8
``</p>

<h3 id="walkthrough">Walkthrough</h3>

<p>``
n = 5</p>

<p>Initial: dp = [0, 1, 2, 0, 0, 0]
 0 1 2 3 4 5</p>

<p>i = 3:
 dp[3] = dp[2] + dp[1] = 2 + 1 = 3
 dp = [0, 1, 2, 3, 0, 0]</p>

<p>i = 4:
 dp[4] = dp[3] + dp[2] = 3 + 2 = 5
 dp = [0, 1, 2, 3, 5, 0]</p>

<p>i = 5:
 dp[5] = dp[4] + dp[3] = 5 + 3 = 8
 dp = [0, 1, 2, 3, 5, 8]</p>

<p>Answer: dp[5] = 8
``</p>

<p><strong>Time Complexity:</strong> O(n) 
<strong>Space Complexity:</strong> O(n)</p>

<hr />

<h2 id="approach-4-space-optimized-optimal">Approach 4: Space Optimized (Optimal)</h2>

<p>Since we only need previous two values, use two variables.</p>

<h3 id="implementation-3">Implementation</h3>

<p>``python
def climbStairs(n: int) -&gt; int:
 “””
 Space-optimized DP</p>

<p>Time: O(n)
 Space: O(1) - only two variables!
 “””
 if n &lt;= 2:
 return n</p>

<p># Only need previous two values
 prev2 = 1 # ways(1)
 prev1 = 2 # ways(2)</p>

<p>for i in range(3, n + 1):
 current = prev1 + prev2
 prev2 = prev1
 prev1 = current</p>

<p>return prev1</p>

<h1 id="example-3">Example</h1>
<p>print(climbStairs(10)) # 89
``</p>

<p><strong>Time Complexity:</strong> O(n) 
<strong>Space Complexity:</strong> O(1) - optimal!</p>

<hr />

<h2 id="approach-5-fibonacci-formula-constant-time">Approach 5: Fibonacci Formula (Constant Time)</h2>

<p>Use Binet’s formula for Fibonacci numbers.</p>

<h3 id="implementation-4">Implementation</h3>

<p>``python
import math</p>

<p>def climbStairs(n: int) -&gt; int:
 “””
 Mathematical formula (Binet’s formula)</p>

<p>Time: O(1) - constant time!
 Space: O(1)</p>

<p>Note: May have floating point precision issues for large n
 “””
 sqrt5 = math.sqrt(5)
 phi = (1 + sqrt5) / 2 # Golden ratio
 psi = (1 - sqrt5) / 2</p>

<p># Binet’s formula (adjusted for stairs indexing)
 result = (phi ** (n + 1) - psi ** (n + 1)) / sqrt5</p>

<p>return int(round(result))</p>

<h1 id="example-4">Example</h1>
<p>print(climbStairs(10)) # 89
``</p>

<p><strong>Time Complexity:</strong> O(1) - direct calculation 
<strong>Space Complexity:</strong> O(1)</p>

<p><strong>Caveat:</strong> Floating point arithmetic may cause precision issues for very large n.</p>

<hr />

<h2 id="approach-6-matrix-exponentiation-logarithmic-time">Approach 6: Matrix Exponentiation (Logarithmic Time)</h2>

<p>For very large n, we can use matrix exponentiation to achieve O(log n) time.</p>

<h3 id="mathematical-foundation">Mathematical Foundation</h3>

<p>The Fibonacci recurrence can be expressed as matrix multiplication:</p>

<p><code class="language-plaintext highlighter-rouge">
[F(n+1)] [1 1] [F(n) ]
[F(n) ] = [1 0] × [F(n-1)]
</code></p>

<p>Therefore:</p>

<p><code class="language-plaintext highlighter-rouge">
[F(n+1)] [1 1]^n [F(1)]
[F(n) ] = [1 0] × [F(0)]
</code></p>

<p>We can compute the matrix power in O(log n) time using <strong>exponentiation by squaring</strong>.</p>

<h3 id="implementation-5">Implementation</h3>

<p>``python
import numpy as np</p>

<p>def climbStairsMatrix(n: int) -&gt; int:
 “””
 Matrix exponentiation approach</p>

<p>Time: O(log n)
 Space: O(1)</p>

<p>Best for very large n where even O(n) is too slow
 “””
 if n &lt;= 2:
 return n</p>

<p>def matrix_multiply(A, B):
 “"”Multiply two 2x2 matrices”””
 return [
 [A[0][0]<em>B[0][0] + A[0][1]</em>B[1][0], A[0][0]<em>B[0][1] + A[0][1]</em>B[1][1]],
 [A[1][0]<em>B[0][0] + A[1][1]</em>B[1][0], A[1][0]<em>B[0][1] + A[1][1]</em>B[1][1]]
 ]</p>

<p>def matrix_power(M, n):
 “"”Compute M^n using exponentiation by squaring”””
 if n == 1:
 return M</p>

<p>if n % 2 == 0:
 half = matrix_power(M, n // 2)
 return matrix_multiply(half, half)
 else:
 return matrix_multiply(M, matrix_power(M, n - 1))</p>

<p># Base matrix
 base = [[1, 1], [1, 0]]</p>

<p># Compute base^n
 result = matrix_power(base, n)</p>

<p># Result is in result[0][0] (adjusted for our indexing)
 return result[0][0]</p>

<h1 id="example-5">Example</h1>
<p>print(climbStairsMatrix(10)) # 89
print(climbStairsMatrix(50)) # 20365011074
``</p>

<p><strong>Time Complexity:</strong> O(log n) - halving problem size at each step 
<strong>Space Complexity:</strong> O(log n) - recursion stack (can be optimized to O(1) iteratively)</p>

<h3 id="when-to-use-matrix-exponentiation">When to Use Matrix Exponentiation</h3>

<p><strong>Advantages:</strong></p>
<ul>
  <li>Fastest asymptotic time complexity</li>
  <li>Works for extremely large n (where n iterations would be too slow)</li>
</ul>

<p><strong>Disadvantages:</strong></p>
<ul>
  <li>More complex to implement</li>
  <li>Overkill for typical interview constraints (n ≤ 45)</li>
  <li>Risk of integer overflow for very large results</li>
</ul>

<hr />

<h2 id="performance-comparison">Performance Comparison</h2>

<p>Let’s benchmark all approaches:</p>

<p>``python
import time</p>

<p>def climbStairsBottomUp(n):
 if n &lt;= 2:
 return n
 dp = [0] * (n + 1)
 dp[1], dp[2] = 1, 2
 for i in range(3, n + 1):
 dp[i] = dp[i-1] + dp[i-2]
 return dp[n]</p>

<p>def climbStairsSpaceOptimized(n):
 if n &lt;= 2:
 return n
 prev2, prev1 = 1, 2
 for _ in range(3, n + 1):
 prev2, prev1 = prev1, prev1 + prev2
 return prev1</p>

<p>def benchmark(func, n, iterations=1000):
 “"”Benchmark function execution time”””
 start = time.perf_counter()
 for _ in range(iterations):
 func(n)
 end = time.perf_counter()
 return (end - start) / iterations * 1000 # ms</p>

<h1 id="test-different-approaches">Test different approaches</h1>
<p>n = 30</p>

<p>approaches = {
 ‘Space Optimized O(n)’: climbStairsSpaceOptimized,
 ‘Bottom-up O(n)’: climbStairsBottomUp,
 ‘Matrix O(log n)’: climbStairsMatrix,
 ‘Binet O(1)’: climbStairs # Using Binet’s formula
}</p>

<p>print(f”Benchmarking for n={n} (1000 iterations each):\n”)
for name, func in approaches.items():
 time_ms = benchmark(func, n)
 print(f”{name:30s}: {time_ms:.4f} ms”)
``</p>

<p><strong>Key Insights:</strong></p>

<ol>
  <li><strong>For n ≤ 50:</strong> Binet’s formula or space-optimized DP is fastest</li>
  <li><strong>For interviews:</strong> Space-optimized DP is best (simple + optimal)</li>
  <li><strong>For very large n:</strong> Matrix exponentiation avoids iteration but has constant overhead</li>
  <li><strong>Recursive with memo:</strong> Never the best choice (overhead of recursion + dictionary lookups)</li>
</ol>

<hr />

<h2 id="common-mistakes--edge-cases">Common Mistakes &amp; Edge Cases</h2>

<h3 id="mistake-1-off-by-one-errors">Mistake 1: Off-by-One Errors</h3>

<p>``python</p>
<h1 id="wrong-incorrect-base-case">WRONG: Incorrect base case</h1>
<p>def climbStairsWrong(n: int) -&gt; int:
 if n == 0:
 return 0 # Wrong! Should be 1 (one way to do nothing)
 if n == 1:
 return 1
 # …</p>

<h1 id="correct">CORRECT</h1>
<p>def climbStairsCorrect(n: int) -&gt; int:
 if n &lt;= 2:
 return n
 # …
``</p>

<h3 id="mistake-2-not-handling-edge-cases">Mistake 2: Not Handling Edge Cases</h3>

<p>``python</p>
<h1 id="wrong-doesnt-handle-n0">WRONG: Doesn’t handle n=0</h1>
<p>def climbStairsWrong(n: int) -&gt; int:
 prev2, prev1 = 1, 2
 for i in range(3, n + 1): # Breaks if n &lt; 3
 current = prev1 + prev2
 prev2, prev1 = prev1, current
 return prev1</p>

<h1 id="correct-1">CORRECT</h1>
<p>def climbStairsCorrect(n: int) -&gt; int:
 if n &lt;= 2:
 return n # Handle small n explicitly</p>

<p>prev2, prev1 = 1, 2
 for i in range(3, n + 1):
 current = prev1 + prev2
 prev2, prev1 = prev1, current
 return prev1
``</p>

<h3 id="mistake-3-integer-overflow">Mistake 3: Integer Overflow</h3>

<p>For very large n (e.g., n=100), the result exceeds typical integer limits in some languages.</p>

<p>``python</p>
<h1 id="python-handles-big-integers-automatically">Python handles big integers automatically</h1>
<p>print(climbStairs(100)) # 573147844013817084101</p>

<h1 id="in-javac-youd-need-biginteger-or-modular-arithmetic">In Java/C++, you’d need BigInteger or modular arithmetic</h1>
<h1 id="often-interview-problems-ask-for-result--mod">Often interview problems ask for result % MOD</h1>
<p>def climbStairsMod(n: int, MOD: int = 10**9 + 7) -&gt; int:
 “"”Return result modulo MOD to prevent overflow”””
 if n &lt;= 2:
 return n</p>

<p>prev2, prev1 = 1, 2
 for i in range(3, n + 1):
 current = (prev1 + prev2) % MOD
 prev2, prev1 = prev1, current</p>

<p>return prev1</p>

<p>print(climbStairsMod(100)) # 687995182
``</p>

<h3 id="mistake-4-modifying-input-in-memoization">Mistake 4: Modifying Input in Memoization</h3>

<p>``python</p>
<h1 id="wrong-global-memo-persists-across-test-cases">WRONG: Global memo persists across test cases</h1>
<p>memo = {}</p>

<p>def climbStairsWrong(n: int) -&gt; int:
 if n &lt;= 2:
 return n
 if n in memo:
 return memo[n]
 memo[n] = climbStairsWrong(n-1) + climbStairsWrong(n-2)
 return memo[n]</p>

<h1 id="first-call-correct">First call: correct</h1>
<p>print(climbStairsWrong(5)) # 8</p>

<h1 id="second-call-uses-stale-memo">Second call: uses stale memo</h1>
<p>print(climbStairsWrong(3)) # 3, but used cached values from n=5 call</p>

<h1 id="correct-memo-as-local-variable-or-function-argument">CORRECT: Memo as local variable or function argument</h1>
<p>def climbStairsCorrect(n: int) -&gt; int:
 memo = {} # Fresh memo for each call</p>

<p>def helper(n):
 if n &lt;= 2:
 return n
 if n in memo:
 return memo[n]
 memo[n] = helper(n-1) + helper(n-2)
 return memo[n]</p>

<p>return helper(n)
``</p>

<h3 id="edge-case-n--0">Edge Case: n = 0</h3>

<p>``python</p>
<h1 id="problem-statement-says-1--n--45-but-defensive-coding">Problem statement says 1 &lt;= n &lt;= 45, but defensive coding:</h1>
<p>def climbStairsSafe(n: int) -&gt; int:
 if n &lt; 0:
 raise ValueError(“n must be non-negative”)
 if n == 0:
 return 1 # One way to not climb (stay at ground)
 if n &lt;= 2:
 return n</p>

<p>prev2, prev1 = 1, 2
 for i in range(3, n + 1):
 current = prev1 + prev2
 prev2, prev1 = prev1, current</p>

<p>return prev1
``</p>

<hr />

<h2 id="production-engineering-considerations">Production Engineering Considerations</h2>

<h3 id="1-caching-for-repeated-queries">1. Caching for Repeated Queries</h3>

<p>In a production system handling many queries:</p>

<p>``python
from functools import lru_cache</p>

<p>class StairClimber:
 “””
 Production-ready stair climbing calculator</p>

<p>Use case: API endpoint that computes climbing ways for various n
 “””</p>

<p>@lru_cache(maxsize=128)
 def compute(self, n: int) -&gt; int:
 “””
 Compute with caching for repeated queries</p>

<p>LRU cache stores recent results
 “””
 if n &lt;= 2:
 return n</p>

<p>prev2, prev1 = 1, 2
 for i in range(3, n + 1):
 current = prev1 + prev2
 prev2, prev1 = prev1, current</p>

<p>return prev1</p>

<p>def get_cache_info(self):
 “"”Get cache statistics”””
 return self.compute.cache_info()</p>

<h1 id="usage">Usage</h1>
<p>climber = StairClimber()</p>

<h1 id="first-calls-compute">First calls compute</h1>
<p>print(climber.compute(10)) # Computes
print(climber.compute(10)) # Cache hit
print(climber.compute(15)) # Computes</p>

<p>print(climber.get_cache_info())</p>
<h1 id="cacheinfohits1-misses2-maxsize128-currsize2">CacheInfo(hits=1, misses=2, maxsize=128, currsize=2)</h1>
<p>``</p>

<h3 id="2-precomputation-for-low-latency">2. Precomputation for Low Latency</h3>

<p>If you need ultra-low latency and n has known upper bound:</p>

<p>``python
class PrecomputedStairs:
 “””
 Precompute all results up to MAX_N</p>

<p>Use case: Latency-critical systems (e.g., real-time game logic)
 “””</p>

<p>MAX_N = 100</p>

<p>def <strong>init</strong>(self):
 “"”Precompute all values at initialization”””
 self._precompute()</p>

<p>def _precompute(self):
 “"”Compute all values from 1 to MAX_N”””
 self.cache = [0] * (self.MAX_N + 1)
 self.cache[1] = 1
 if self.MAX_N &gt;= 2:
 self.cache[2] = 2</p>

<p>for i in range(3, self.MAX_N + 1):
 self.cache[i] = self.cache[i-1] + self.cache[i-2]</p>

<p>def compute(self, n: int) -&gt; int:
 “"”O(1) lookup”””
 if n &gt; self.MAX_N:
 raise ValueError(f”n must be &lt;= {self.MAX_N}”)
 return self.cache[n]</p>

<h1 id="usage-1">Usage</h1>
<p>stairs = PrecomputedStairs() # Precompute on init</p>

<h1 id="all-queries-are-o1">All queries are O(1)</h1>
<p>print(stairs.compute(50)) # Instant lookup
print(stairs.compute(100)) # Instant lookup
``</p>

<h3 id="3-handling-large-scale-distributed-systems">3. Handling Large-Scale Distributed Systems</h3>

<p>``python
class DistributedStairComputer:
 “””
 Handle climbing stairs in distributed system</p>

<p>Use case: Distributed computing cluster
 “””</p>

<p>def compute_range(self, start: int, end: int) -&gt; dict[int, int]:
 “””
 Compute multiple values efficiently</p>

<p>Instead of computing each independently, compute iteratively
 and return all values in range
 “””
 if start &lt; 1 or end &lt; start:
 raise ValueError(“Invalid range”)</p>

<p>results = {}</p>

<p># Bootstrap
 if start == 1:
 results[1] = 1
 prev2, prev1 = 1, 2
 current_n = 2
 elif start == 2:
 results[2] = 2
 prev2, prev1 = 1, 2
 current_n = 2
 else:
 # Compute up to start
 prev2, prev1 = 1, 2
 for i in range(3, start):
 current = prev1 + prev2
 prev2, prev1 = prev1, current
 current_n = start - 1</p>

<p># Compute range
 for n in range(max(start, current_n), end + 1):
 if n == 1:
 results[1] = 1
 elif n == 2:
 results[2] = 2
 else:
 current = prev1 + prev2
 results[n] = current
 prev2, prev1 = prev1, current</p>

<p>return results</p>

<h1 id="usage-2">Usage</h1>
<p>computer = DistributedStairComputer()</p>

<h1 id="compute-batch-of-values-eg-for-multiple-users">Compute batch of values (e.g., for multiple users)</h1>
<p>batch_results = computer.compute_range(10, 20)
print(batch_results)</p>
<h1 id="10-89-11-144-12-233--20-10946">{10: 89, 11: 144, 12: 233, …, 20: 10946}</h1>
<p>``</p>

<hr />

<h2 id="deep-dive-why-dynamic-programming">Deep Dive: Why Dynamic Programming?</h2>

<h3 id="the-optimal-substructure-property">The Optimal Substructure Property</h3>

<p><strong>Definition:</strong> A problem has <em>optimal substructure</em> if the optimal solution can be constructed from optimal solutions of its subproblems.</p>

<p><strong>For climbing stairs:</strong>
<code class="language-plaintext highlighter-rouge">
Optimal way to reach step n = 
 Optimal way to reach step (n-1) + take 1 step
 OR
 Optimal way to reach step (n-2) + take 2 steps
</code></p>

<p>This property is <strong>necessary</strong> for DP to work.</p>

<h3 id="the-overlapping-subproblems-property">The Overlapping Subproblems Property</h3>

<p><strong>Definition:</strong> The problem can be broken down into subproblems which are reused multiple times.</p>

<p><strong>For climbing stairs:</strong>
``
climbStairs(5) needs:</p>
<ul>
  <li>climbStairs(4) and climbStairs(3)</li>
</ul>

<p>climbStairs(4) needs:</p>
<ul>
  <li>climbStairs(3) and climbStairs(2)</li>
</ul>

<p>Notice: climbStairs(3) is computed TWICE!
``</p>

<h3 id="why-not-greedy">Why Not Greedy?</h3>

<p><strong>Greedy approach:</strong> Always take the largest possible step (2 steps).</p>

<p>``python
def climbStairsGreedy(n: int) -&gt; int:
 “””
 WRONG: Greedy doesn’t work here</p>

<p>This would always take 2-steps when possible
 “””
 ways = 0
 while n &gt; 0:
 if n &gt;= 2:
 n -= 2 # Take 2 steps
 else:
 n -= 1 # Take 1 step
 ways += 1
 return ways</p>

<p>print(climbStairsGreedy(5)) # Wrong answer!
``</p>

<p><strong>Why greedy fails:</strong> We’re counting <em>number of ways</em>, not finding <em>optimal path</em>. Greedy works for optimization problems with greedy choice property, not counting problems.</p>

<hr />

<h2 id="variations">Variations</h2>

<h3 id="variation-1-can-climb-1-2-or-3-steps">Variation 1: Can Climb 1, 2, or 3 Steps</h3>

<p>``python
def climbStairsThreeSteps(n: int) -&gt; int:
 “””
 Can climb 1, 2, or 3 steps at a time</p>

<p>Recurrence: ways(n) = ways(n-1) + ways(n-2) + ways(n-3)</p>

<p>Time: O(n)
 Space: O(1)
 “””
 if n &lt;= 2:
 return n
 if n == 3:
 return 4 # 1+1+1, 1+2, 2+1, 3</p>

<p># Track previous three values
 prev3 = 1 # ways(1)
 prev2 = 2 # ways(2)
 prev1 = 4 # ways(3)</p>

<p>for i in range(4, n + 1):
 current = prev1 + prev2 + prev3
 prev3 = prev2
 prev2 = prev1
 prev1 = current</p>

<p>return prev1</p>

<h1 id="example-6">Example</h1>
<p>print(climbStairsThreeSteps(4)) # 7</p>
<h1 id="1111-112-121-211-22-13-31">1+1+1+1, 1+1+2, 1+2+1, 2+1+1, 2+2, 1+3, 3+1</h1>
<p>``</p>

<h3 id="variation-2-variable-step-sizes">Variation 2: Variable Step Sizes</h3>

<p>``python
def climbStairsVariableSteps(n: int, steps: list[int]) -&gt; int:
 “””
 Can climb any step size in ‘steps’ list</p>

<p>Example: steps = [1, 2, 5]</p>

<p>Time: O(n * k) where k = len(steps)
 Space: O(n)
 “””
 if n == 0:
 return 1
 if n &lt; 0:
 return 0</p>

<p># DP table
 dp = [0] * (n + 1)
 dp[0] = 1 # One way to stay at ground (do nothing)</p>

<p># For each position
 for i in range(1, n + 1):
 # Try each step size
 for step in steps:
 if i - step &gt;= 0:
 dp[i] += dp[i - step]</p>

<p>return dp[n]</p>

<h1 id="example-7">Example</h1>
<p>print(climbStairsVariableSteps(5, [1, 2, 5]))</p>
<h1 id="can-reach-5-using-11111-1112-1121-1211-2111-122-212-221-5">Can reach 5 using: 1+1+1+1+1, 1+1+1+2, 1+1+2+1, 1+2+1+1, 2+1+1+1, 1+2+2, 2+1+2, 2+2+1, 5</h1>
<p>``</p>

<h3 id="variation-3-minimum-cost-climbing-stairs">Variation 3: Minimum Cost Climbing Stairs</h3>

<p>``python
def minCostClimbingStairs(cost: list[int]) -&gt; int:
 “””
 LeetCode 746: Min Cost Climbing Stairs</p>

<p>Each step has a cost. Find minimum cost to reach top.
 Can start from step 0 or step 1.</p>

<p>Time: O(n)
 Space: O(1)
 “””
 n = len(cost)</p>

<p>if n &lt;= 1:
 return 0</p>

<p># Track min cost to reach previous two steps
 prev2 = cost[0]
 prev1 = cost[1]</p>

<p>for i in range(2, n):
 current = cost[i] + min(prev1, prev2)
 prev2 = prev1
 prev1 = current</p>

<p># Can finish from either last or second-last step
 return min(prev1, prev2)</p>

<h1 id="example-8">Example</h1>
<p>cost = [10, 15, 20]
print(minCostClimbingStairs(cost)) # 15</p>
<h1 id="start-at-index-1-pay-15-step-to-top">Start at index 1, pay 15, step to top</h1>
<p>``</p>

<h3 id="variation-4-count-paths-with-constraints">Variation 4: Count Paths with Constraints</h3>

<p>``python
def climbStairsWithConstraint(n: int, max_consecutive_ones: int = 2) -&gt; int:
 “””
 Count ways to climb stairs with constraint on consecutive 1-steps</p>

<p>Example: max_consecutive_ones = 2 means can’t take more than 2
 consecutive single steps</p>

<p>Time: O(n)
 Space: O(n)
 “””
 # dp[i][j] = ways to reach step i with j consecutive 1-steps at end
 dp = [[0] * (max_consecutive_ones + 1) for _ in range(n + 1)]
 dp[0][0] = 1</p>

<p>for i in range(n):
 for j in range(max_consecutive_ones + 1):
 if dp[i][j] == 0:
 continue</p>

<p># Take 2 steps (resets consecutive count)
 if i + 2 &lt;= n:
 dp[i + 2][0] += dp[i][j]</p>

<p># Take 1 step (increment consecutive count)
 if i + 1 &lt;= n and j + 1 &lt;= max_consecutive_ones:
 dp[i + 1][j + 1] += dp[i][j]</p>

<p>return sum(dp[n])</p>

<h1 id="example-9">Example</h1>
<p>print(climbStairsWithConstraint(5, max_consecutive_ones=2))
``</p>

<hr />

<h2 id="connection-to-ml-systems">Connection to ML Systems</h2>

<h3 id="model-training-iteration-strategy">Model Training Iteration Strategy</h3>

<p>``python
class TrainingScheduler:
 “””
 Determine number of training strategies given constraints</p>

<p>Similar to stairs: at each epoch, choose next action
 “””</p>

<p>def count_training_paths(
 self,
 total_epochs: int,
 actions: list[str] = [‘continue’, ‘adjust_lr’, ‘early_stop’]
 ) -&gt; int:
 “””
 Count possible training paths</p>

<p>At each epoch, can take different actions (like step sizes)
 “””
 # Similar to variable step climbing stairs
 # Each action advances training by different amounts</p>

<p>action_advances = {
 ‘continue’: 1, # Continue one epoch
 ‘adjust_lr’: 1, # Adjust and continue
 ‘early_stop’: total_epochs # Jump to end
 }</p>

<p># Count paths using DP (similar to climbing stairs)
 dp = [0] * (total_epochs + 1)
 dp[0] = 1</p>

<p>for epoch in range(total_epochs):
 for action in actions:
 advance = action_advances.get(action, 1)
 next_epoch = min(epoch + advance, total_epochs)
 dp[next_epoch] += dp[epoch]</p>

<p>return dp[total_epochs]</p>

<h1 id="usage-3">Usage</h1>
<p>scheduler = TrainingScheduler()
paths = scheduler.count_training_paths(total_epochs=5)
print(f”Possible training strategies: {paths}”)
``</p>

<h3 id="feature-selection-combinations">Feature Selection Combinations</h3>

<p>``python
class FeatureSelectionCounter:
 “””
 Count ways to select features with constraints</p>

<p>Similar pattern to climbing stairs
 “””</p>

<p>def count_feature_subsets(
 self,
 num_features: int,
 max_features_per_selection: int = 2
 ) -&gt; int:
 “””
 Count ways to select features where each step selects 1-k features</p>

<p>Similar to climbing stairs with variable step sizes
 “””
 # dp[i] = ways to select i features
 dp = [0] * (num_features + 1)
 dp[0] = 1 # Empty selection</p>

<p>for i in range(1, num_features + 1):
 # Can select 1, 2, …, max_features_per_selection at once
 for k in range(1, min(i, max_features_per_selection) + 1):
 dp[i] += dp[i - k]</p>

<p>return dp[num_features]</p>

<h1 id="usage-4">Usage</h1>
<p>counter = FeatureSelectionCounter()
ways = counter.count_feature_subsets(num_features=10, max_features_per_selection=3)
print(f”Ways to build feature set: {ways}”)
``</p>

<h3 id="pipeline-stage-combinations">Pipeline Stage Combinations</h3>

<p>``python
class MLPipelineCounter:
 “””
 Count valid ML pipeline configurations</p>

<p>Each stage can have different options (like step sizes)
 “””</p>

<p>def count_pipeline_configs(
 self,
 stages: list[dict]
 ) -&gt; int:
 “””
 Count possible pipeline configurations</p>

<p>Args:
 stages: List of stage definitions
 e.g., [{‘name’: ‘preprocessing’, ‘options’: 3},
 {‘name’: ‘feature_eng’, ‘options’: 2}]</p>

<p>Returns:
 Total number of valid pipelines
 “””
 if not stages:
 return 1</p>

<p># Multiplicative principle (not exactly stairs, but similar counting)
 total = 1
 for stage in stages:
 total *= stage.get(‘options’, 1)</p>

<p>return total</p>

<p>def count_sequential_pipelines(
 self,
 total_stages: int,
 stage_options: list[int]
 ) -&gt; int:
 “””
 Count ways to build pipeline where each step uses 1-k stages</p>

<p>More directly analogous to climbing stairs
 “””
 # dp[i] = ways to build pipeline with i stages
 dp = [0] * (total_stages + 1)
 dp[0] = 1</p>

<p>for i in range(1, total_stages + 1):
 for num_stages in stage_options:
 if i - num_stages &gt;= 0:
 dp[i] += dp[i - num_stages]</p>

<p>return dp[total_stages]</p>

<h1 id="usage-5">Usage</h1>
<p>pipeline_counter = MLPipelineCounter()</p>

<h1 id="count-sequential-pipeline-configurations">Count sequential pipeline configurations</h1>
<h1 id="can-add-1-2-or-3-stages-at-a-time">Can add 1, 2, or 3 stages at a time</h1>
<p>configs = pipeline_counter.count_sequential_pipelines(
 total_stages=5,
 stage_options=[1, 2, 3]
)
print(f”Sequential pipeline configurations: {configs}”)
``</p>

<hr />

<h2 id="testing">Testing</h2>

<h3 id="comprehensive-test-suite">Comprehensive Test Suite</h3>

<p>``python
import unittest</p>

<p>class TestClimbStairs(unittest.TestCase):</p>

<p>def test_base_cases(self):
 “"”Test base cases”””
 self.assertEqual(climbStairs(1), 1)
 self.assertEqual(climbStairs(2), 2)</p>

<p>def test_small_values(self):
 “"”Test small n”””
 self.assertEqual(climbStairs(3), 3)
 self.assertEqual(climbStairs(4), 5)
 self.assertEqual(climbStairs(5), 8)</p>

<p>def test_fibonacci_sequence(self):
 “"”Verify it follows Fibonacci”””
 # F(1)=1, F(2)=2, F(3)=3, F(4)=5, F(5)=8, …
 expected = [1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
 for i, exp in enumerate(expected, 1):
 self.assertEqual(climbStairs(i), exp)</p>

<p>def test_large_value(self):
 “"”Test larger n”””
 # n=10 should give 89 (11th Fibonacci number)
 self.assertEqual(climbStairs(10), 89)</p>

<p># n=20 should give 10946
 self.assertEqual(climbStairs(20), 10946)</p>

<p>def test_all_approaches_agree(self):
 “"”All approaches should give same answer”””
 for n in range(1, 15):
 memo = climbStairsBottomUp(n)
 space_opt = climbStairsSpaceOptimized(n)
 self.assertEqual(memo, space_opt, f”Mismatch at n={n}”)</p>

<p>def climbStairsBottomUp(n):
 “"”Helper for testing”””
 if n &lt;= 2:
 return n
 dp = [0] * (n + 1)
 dp[1], dp[2] = 1, 2
 for i in range(3, n + 1):
 dp[i] = dp[i-1] + dp[i-2]
 return dp[n]</p>

<p>def climbStairsSpaceOptimized(n):
 “"”Helper for testing”””
 if n &lt;= 2:
 return n
 prev2, prev1 = 1, 2
 for i in range(3, n + 1):
 current = prev1 + prev2
 prev2, prev1 = prev1, current
 return prev1</p>

<p>if <strong>name</strong> == ‘<strong>main</strong>’:
 unittest.main()
``</p>

<hr />

<h2 id="interview-tips">Interview Tips</h2>

<h3 id="recognizing-the-pattern">Recognizing the Pattern</h3>

<p><strong>When you see:</strong></p>
<ul>
  <li>“Count number of ways”</li>
  <li>“Reach position n”</li>
  <li>“Each step has limited options”</li>
  <li>“Previous decisions affect current options”</li>
</ul>

<p><strong>Think:</strong> Dynamic Programming (likely Fibonacci-like)</p>

<h3 id="interview-strategy-how-to-approach-this-problem">Interview Strategy: How to Approach This Problem</h3>

<p><strong>Step 1: Clarify the Problem (1-2 minutes)</strong></p>

<p>Ask clarifying questions:</p>
<ul>
  <li>“Can I confirm: we can take either 1 or 2 steps at a time?”</li>
  <li>“Are we counting distinct ways, not the minimum number of steps?”</li>
  <li>“Is n guaranteed to be positive?”</li>
  <li>“What’s the maximum value of n I should handle?”</li>
</ul>

<p><strong>Step 2: Walkthrough Examples (2-3 minutes)</strong></p>

<p>``
n = 1: [1] → 1 way
n = 2: [1,1], [2] → 2 ways
n = 3: [1,1,1], [1,2], [2,1] → 3 ways
n = 4: [1,1,1,1], [1,1,2], [1,2,1], [2,1,1], [2,2] → 5 ways</p>

<p>Pattern: Each n is sum of previous two → Fibonacci!
``</p>

<p><strong>Step 3: Propose Brute Force (1 minute)</strong></p>

<p>“The naive approach is recursion: to reach step n, we can come from n-1 or n-2. But this has exponential time complexity due to repeated subproblems.”</p>

<p><strong>Step 4: Optimize with DP (3-5 minutes)</strong></p>

<p>“We can optimize using dynamic programming. Since we’re recomputing the same subproblems, we can either:</p>
<ol>
  <li>Use memoization (top-down)</li>
  <li>Use tabulation (bottom-up)</li>
</ol>

<p>I’ll go with bottom-up since it’s simpler and avoids recursion overhead.”</p>

<p><strong>Step 5: Further Optimize Space (1-2 minutes)</strong></p>

<p>“Since we only need the previous two values, we can optimize from O(n) space to O(1) using two variables.”</p>

<p><strong>Step 6: Code + Test (5-7 minutes)</strong></p>

<p>Write the space-optimized solution and test with examples.</p>

<p><strong>Step 7: Discuss Edge Cases &amp; Complexity (1-2 minutes)</strong></p>

<ul>
  <li>Edge cases: n=1, n=2</li>
  <li>Time: O(n)</li>
  <li>Space: O(1)</li>
</ul>

<p><strong>Total: ~15-20 minutes</strong></p>

<hr />

<h3 id="common-follow-ups">Common Follow-ups</h3>

<p><strong>Q1: What if we want to print all possible paths?</strong></p>

<p>``python
def climbStairsAllPaths(n: int) -&gt; list[list[int]]:
 “””
 Return all distinct paths to reach top</p>

<p>Time: O(2^n) - exponential number of paths
 Space: O(2^n) - storing all paths
 “””
 def backtrack(remaining, path, all_paths):
 if remaining == 0:
 all_paths.append(path[:])
 return</p>

<p>if remaining &lt; 0:
 return</p>

<p># Try 1 step
 path.append(1)
 backtrack(remaining - 1, path, all_paths)
 path.pop()</p>

<p># Try 2 steps
 path.append(2)
 backtrack(remaining - 2, path, all_paths)
 path.pop()</p>

<p>all_paths = []
 backtrack(n, [], all_paths)
 return all_paths</p>

<h1 id="example-10">Example</h1>
<p>paths = climbStairsAllPaths(4)
print(f”All paths to climb 4 stairs:”)
for path in paths:
 print(path)</p>
<h1 id="output">Output:</h1>
<h1 id="1-1-1-1">[1, 1, 1, 1]</h1>
<h1 id="1-1-2">[1, 1, 2]</h1>
<h1 id="1-2-1">[1, 2, 1]</h1>
<h1 id="2-1-1">[2, 1, 1]</h1>
<h1 id="2-2">[2, 2]</h1>
<p>``</p>

<p><strong>Q2: What if steps have weights and we want minimum weight path?</strong></p>

<p>See “Minimum Cost Climbing Stairs” variation above.</p>

<p><strong>Q3: What’s the space complexity of the recursive solution with memoization?</strong></p>

<p>O(n) for both memoization cache and recursion stack.</p>

<hr />

<h2 id="key-takeaways">Key Takeaways</h2>

<p>✅ <strong>Fibonacci pattern</strong> - Recognize when problem reduces to Fibonacci 
✅ <strong>DP progression</strong> - Recursion → Memoization → Bottom-up → Space-optimized 
✅ <strong>Space optimization</strong> - Only need last k values for k-way recurrence 
✅ <strong>Counting problems</strong> - DP naturally solves “count number of ways” 
✅ <strong>Recurrence relations</strong> - Key to DP is finding the recurrence 
✅ <strong>ML applications</strong> - Similar counting patterns in training strategies, feature selection 
✅ <strong>Variations</strong> - Variable step sizes, constraints, costs all use same DP template</p>

<hr />

<h2 id="related-problems">Related Problems</h2>

<p>Practice these to master the pattern:</p>
<ul>
  <li><strong><a href="https://leetcode.com/problems/min-cost-climbing-stairs/">Min Cost Climbing Stairs</a></strong> - Add cost dimension</li>
  <li><strong><a href="https://leetcode.com/problems/house-robber/">House Robber</a></strong> - Similar DP pattern with constraints</li>
  <li><strong><a href="https://leetcode.com/problems/fibonacci-number/">Fibonacci Number</a></strong> - Direct Fibonacci</li>
  <li><strong><a href="https://leetcode.com/problems/n-th-tribonacci-number/">N-th Tribonacci Number</a></strong> - Three-way recurrence</li>
  <li><strong><a href="https://leetcode.com/problems/decode-ways/">Decode Ways</a></strong> - Similar counting pattern</li>
</ul>

<hr />

<p><strong>Originally published at:</strong> <a href="https://www.arunbaby.com/dsa/0006-climbing-stairs/">arunbaby.com/dsa/0006-climbing-stairs</a></p>

<p><em>If you found this helpful, consider sharing it with others who might benefit.</em></p>


        
      </section>

      <footer class="page__meta">
        
        
  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-tags" aria-hidden="true"></i> Tags: </strong>
    <span itemprop="keywords">
    
      <a href="/tags/#dynamic-programming" class="page__taxonomy-item p-category" rel="tag">dynamic-programming</a><span class="sep">, </span>
    
      <a href="/tags/#fibonacci" class="page__taxonomy-item p-category" rel="tag">fibonacci</a><span class="sep">, </span>
    
      <a href="/tags/#recursion" class="page__taxonomy-item p-category" rel="tag">recursion</a>
    
    </span>
  </p>




  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> Categories: </strong>
    <span itemprop="keywords">
    
      <a href="/categories/#dsa" class="page__taxonomy-item p-category" rel="tag">dsa</a>
    
    </span>
  </p>


        
      </footer>

      <div class="page__related page__related--full">
  <h2 class="page__related-title">Related across topics</h2>
  <style>
    /* Make section span full content width and use 2 equal columns */
    .page__related--full { float: inline-start; width: 100%; padding: 0; }
    .cross-related-grid { display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 2rem; }
    @media (max-width: 768px) { .cross-related-grid { grid-template-columns: 1fr; } }
    /* Ensure archive cards stretch nicely in the grid */
    .cross-related-grid .list__item, .cross-related-grid .grid__item { width: auto; float: none; margin: 0; }
  </style>
  <div class="cross-related-grid">
    



<div class="list__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/ml-system-design/0006-model-evaluation-metrics/" rel="permalink">Model Evaluation Metrics
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          17 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">How to measure if your ML model is actually good, choosing the right metrics is as important as building the model itself.
</p>
  </article>
</div>




<div class="list__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/speech-tech/0006-text-to-speech-basics/" rel="permalink">Text-to-Speech (TTS) System Fundamentals
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          18 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">From text to natural speech: understanding modern neural TTS architectures that power Alexa, Google Assistant, and Siri.
</p>
  </article>
</div>




<div class="list__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/ai-agents/0006-agent-frameworks-landscape/" rel="permalink">Agent Frameworks Landscape
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          10 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">“To Framework or Not to Framework? Navigating the Agent Ecosystem.”
</p>
  </article>
</div>

  </div>
</div>

      <section class="page__share">
  <h4 class="page__share-title">Share on</h4>

  <a href="https://twitter.com/intent/tweet?via=arunbaby0&text=Climbing+Stairs%20https%3A%2F%2Fwww.arunbaby.com%2Fdsa%2F0006-climbing-stairs%2F" class="btn btn--twitter" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Twitter"><i class="fab fa-fw fa-twitter" aria-hidden="true"></i><span> Twitter</span></a>

  <a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fwww.arunbaby.com%2Fdsa%2F0006-climbing-stairs%2F" class="btn btn--facebook" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Facebook"><i class="fab fa-fw fa-facebook" aria-hidden="true"></i><span> Facebook</span></a>

  <a href="https://www.linkedin.com/shareArticle?mini=true&url=https://www.arunbaby.com/dsa/0006-climbing-stairs/" class="btn btn--linkedin" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on LinkedIn"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i><span> LinkedIn</span></a>
</section>


      
  <nav class="pagination">
    
      <a href="/dsa/0005-maximum-subarray/" class="pagination--pager" title="Maximum Subarray (Kadane’s Algorithm)">Previous</a>
    
    
      <a href="/dsa/0007-binary-tree-traversal/" class="pagination--pager" title="Binary Tree Traversal">Next</a>
    
  </nav>


    </div>

    
  </article>

  
  
</div>

      
    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';" role="search">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Enter your search term..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    

    
      
        
          <li><a href="https://twitter.com/arunbaby0" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-twitter-square" aria-hidden="true"></i> Twitter</a></li>
        
      
        
          <li><a href="https://github.com/arunbaby0" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
        
      
        
          <li><a href="https://www.linkedin.com/in/arunbaby0/" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i> LinkedIn</a></li>
        
      
        
          <li><a href="https://scholar.google.co.in/citations?user=6fSYWhkAAAAJ" rel="nofollow noopener noreferrer"><i class="fas fa-fw fa-graduation-cap" aria-hidden="true"></i> Google Scholar</a></li>
        
      
    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 1990 - 2143 <a href="https://www.arunbaby.com">Arun Baby</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>




  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-0JRJPEC9SS"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-0JRJPEC9SS', { 'anonymize_ip': false});
</script>








  </body>
</html>
