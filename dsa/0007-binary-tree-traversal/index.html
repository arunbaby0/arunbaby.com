<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.26.2 by Michael Rose
  Copyright 2013-2024 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->

<html lang="en-US" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Binary Tree Traversal - Arun Baby</title>
<meta name="description" content="Master the fundamental patterns of tree traversal: the gateway to solving hundreds of tree problems in interviews.">


  <meta name="author" content="Arun Baby">
  
  <meta property="article:author" content="Arun Baby">
  


<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="Arun Baby">
<meta property="og:title" content="Binary Tree Traversal">
<meta property="og:url" content="https://www.arunbaby.com/dsa/0007-binary-tree-traversal/">


  <meta property="og:description" content="Master the fundamental patterns of tree traversal: the gateway to solving hundreds of tree problems in interviews.">



  <meta property="og:image" content="https://www.arunbaby.com/assets/images/profile-photo.png">



  <meta name="twitter:site" content="@arunbaby0">
  <meta name="twitter:title" content="Binary Tree Traversal">
  <meta name="twitter:description" content="Master the fundamental patterns of tree traversal: the gateway to solving hundreds of tree problems in interviews.">
  <meta name="twitter:url" content="https://www.arunbaby.com/dsa/0007-binary-tree-traversal/">

  
    <meta name="twitter:card" content="summary">
    
      <meta name="twitter:image" content="https://www.arunbaby.com/assets/images/profile-photo.png">
    
  

  



  <meta property="article:published_time" content="2025-10-14T15:48:24+05:30">





  

  


<link rel="canonical" href="https://www.arunbaby.com/dsa/0007-binary-tree-traversal/">












<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Arun Baby Feed">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
  
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css"></noscript>



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--single" dir="ltr">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
           
          <span class="site-subtitle">Arun Baby</span>
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a
                href="/about/"
                
                
              >About</a>
            </li><li class="masthead__menu-item">
              <a
                href="/dsa/"
                
                
              >DSA</a>
            </li><li class="masthead__menu-item">
              <a
                href="/ml-system-design/"
                
                
              >ML Systems</a>
            </li><li class="masthead__menu-item">
              <a
                href="/speech-tech/"
                
                
              >Speech Tech</a>
            </li><li class="masthead__menu-item">
              <a
                href="/publications/"
                
                
              >Publications</a>
            </li><li class="masthead__menu-item">
              <a
                href="/statuses/"
                
                
              >Statuses</a>
            </li><li class="masthead__menu-item">
              <a
                href="/contact/"
                
                
              >Contact</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <i class="fas fa-search"></i>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      





<div id="main" role="main">
  
  <div class="sidebar sticky">
  


<div itemscope itemtype="https://schema.org/Person" class="h-card">

  
    <div class="author__avatar">
      <a href="https://www.arunbaby.com/">
        <img src="/assets/images/profile-photo.png" alt="Arun Baby" itemprop="image" class="u-photo">
      </a>
    </div>
  

  <div class="author__content">
    <h3 class="author__name p-name" itemprop="name">
      <a class="u-url" rel="me" href="https://www.arunbaby.com/" itemprop="url">Arun Baby</a>
    </h3>
    
      <div class="author__bio p-note" itemprop="description">
        <p>Becoming <strong>Unlabelable</strong></p>

      </div>
    
  </div>

  <div class="author__urls-wrapper">
    <button class="btn btn--inverse">Follow</button>
    <ul class="author__urls social-icons">
      
        <li itemprop="homeLocation" itemscope itemtype="https://schema.org/Place">
          <i class="fas fa-fw fa-map-marker-alt" aria-hidden="true"></i> <span itemprop="name" class="p-locality">India</span>
        </li>
      

      
        
          
            <li><a href="https://twitter.com/arunbaby0" rel="nofollow noopener noreferrer me" itemprop="sameAs"><i class="fab fa-fw fa-twitter-square" aria-hidden="true"></i><span class="label">Twitter</span></a></li>
          
        
          
            <li><a href="https://github.com/arunbaby0" rel="nofollow noopener noreferrer me" itemprop="sameAs"><i class="fab fa-fw fa-github" aria-hidden="true"></i><span class="label">GitHub</span></a></li>
          
        
          
            <li><a href="https://www.linkedin.com/in/arunbaby0/" rel="nofollow noopener noreferrer me" itemprop="sameAs"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i><span class="label">LinkedIn</span></a></li>
          
        
          
            <li><a href="https://scholar.google.co.in/citations?user=6fSYWhkAAAAJ" rel="nofollow noopener noreferrer me" itemprop="sameAs"><i class="fas fa-fw fa-graduation-cap" aria-hidden="true"></i><span class="label">Google Scholar</span></a></li>
          
        
      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <!--
  <li>
    <a href="http://link-to-whatever-social-network.com/user/" itemprop="sameAs" rel="nofollow noopener noreferrer me">
      <i class="fas fa-fw" aria-hidden="true"></i> Custom Social Profile Link
    </a>
  </li>
-->
    </ul>
  </div>
</div>

  
  </div>



  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="Binary Tree Traversal">
    <meta itemprop="description" content="Master the fundamental patterns of tree traversal: the gateway to solving hundreds of tree problems in interviews.">
    <meta itemprop="datePublished" content="2025-10-14T15:48:24+05:30">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">
            <a href="https://www.arunbaby.com/dsa/0007-binary-tree-traversal/" itemprop="url">Binary Tree Traversal
</a>
          </h1>
          

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          26 minute read
        
      </span>
    
  </p>


        </header>
      

      <section class="page__content" itemprop="text">
        
          <aside class="sidebar__right sticky">
            <nav class="toc">
              <header><h4 class="nav__title"><i class="fas fa-file-alt"></i> On this page</h4></header>
              <ul class="toc__menu"><li><a href="#problem">Problem</a></li><li><a href="#binary-tree-basics">Binary Tree Basics</a><ul><li><a href="#tree-node-definition">Tree Node Definition</a></li><li><a href="#visual-representation">Visual Representation</a></li></ul></li><li><a href="#depth-first-search-dfs-traversals">Depth-First Search (DFS) Traversals</a><ul><li><a href="#1-inorder-traversal-left--root--right">1. Inorder Traversal (Left → Root → Right)</a><ul><li><a href="#recursive-approach">Recursive Approach</a></li><li><a href="#iterative-approach-using-stack">Iterative Approach (Using Stack)</a></li></ul></li><li><a href="#2-preorder-traversal-root--left--right">2. Preorder Traversal (Root → Left → Right)</a><ul><li><a href="#recursive-approach-1">Recursive Approach</a></li><li><a href="#iterative-approach">Iterative Approach</a></li></ul></li><li><a href="#3-postorder-traversal-left--right--root">3. Postorder Traversal (Left → Right → Root)</a><ul><li><a href="#recursive-approach-2">Recursive Approach</a></li><li><a href="#iterative-approach-two-stacks">Iterative Approach (Two Stacks)</a></li><li><a href="#iterative-approach-one-stack">Iterative Approach (One Stack)</a></li></ul></li></ul></li><li><a href="#breadth-first-search-bfs-traversal">Breadth-First Search (BFS) Traversal</a><ul><li><a href="#level-order-traversal">Level Order Traversal</a></li></ul></li><li><a href="#traversal-comparison">Traversal Comparison</a><ul><li><a href="#visual-comparison">Visual Comparison</a></li><li><a href="#when-to-use-each">When to Use Each</a></li></ul></li><li><a href="#morris-traversal-o1-space">Morris Traversal (O(1) Space)</a><ul><li><a href="#morris-inorder-traversal">Morris Inorder Traversal</a></li></ul></li><li><a href="#advanced-traversal-problems">Advanced Traversal Problems</a><ul><li><a href="#problem-1-zigzag-level-order">Problem 1: Zigzag Level Order</a></li><li><a href="#problem-2-vertical-order-traversal">Problem 2: Vertical Order Traversal</a></li><li><a href="#problem-3-boundary-traversal">Problem 3: Boundary Traversal</a></li></ul></li><li><a href="#connection-to-ml-systems">Connection to ML Systems</a><ul><li><a href="#1-decision-tree-traversal">1. Decision Tree Traversal</a></li><li><a href="#2-feature-engineering-pipeline-dag-traversal">2. Feature Engineering Pipeline (DAG Traversal)</a></li><li><a href="#3-model-ensembles-tree-of-models">3. Model Ensembles (Tree of Models)</a></li></ul></li><li><a href="#testing">Testing</a><ul><li><a href="#comprehensive-test-suite">Comprehensive Test Suite</a></li></ul></li><li><a href="#interview-tips">Interview Tips</a><ul><li><a href="#pattern-recognition">Pattern Recognition</a></li><li><a href="#choosing-the-right-traversal">Choosing the Right Traversal</a></li><li><a href="#common-mistakes">Common Mistakes</a></li></ul></li><li><a href="#performance-analysis--optimization">Performance Analysis &amp; Optimization</a><ul><li><a href="#space-complexity-deep-dive">Space Complexity Deep Dive</a></li><li><a href="#performance-comparison">Performance Comparison</a></li></ul></li><li><a href="#edge-cases--corner-cases">Edge Cases &amp; Corner Cases</a><ul><li><a href="#1-empty-tree">1. Empty Tree</a></li><li><a href="#2-single-node">2. Single Node</a></li><li><a href="#3-skewed-tree-linked-list">3. Skewed Tree (Linked List)</a></li><li><a href="#4-large-values--overflow">4. Large Values &amp; Overflow</a></li></ul></li><li><a href="#advanced-applications">Advanced Applications</a><ul><li><a href="#1-expression-tree-evaluation">1. Expression Tree Evaluation</a></li><li><a href="#2-serializedeserialize-tree">2. Serialize/Deserialize Tree</a></li><li><a href="#3-find-lowest-common-ancestor">3. Find Lowest Common Ancestor</a></li><li><a href="#4-tree-diameter">4. Tree Diameter</a></li></ul></li><li><a href="#production-considerations">Production Considerations</a><ul><li><a href="#1-concurrent-tree-traversal">1. Concurrent Tree Traversal</a></li><li><a href="#2-lazy-evaluation-for-large-trees">2. Lazy Evaluation for Large Trees</a></li><li><a href="#3-monitoring--logging">3. Monitoring &amp; Logging</a></li></ul></li><li><a href="#interview-strategy">Interview Strategy</a><ul><li><a href="#step-by-step-approach">Step-by-Step Approach</a></li><li><a href="#common-follow-up-questions">Common Follow-Up Questions</a></li></ul></li><li><a href="#key-takeaways">Key Takeaways</a></li><li><a href="#related-problems">Related Problems</a></li></ul>
            </nav>
          </aside>
        
        <p><strong>Master the fundamental patterns of tree traversal: the gateway to solving hundreds of tree problems in interviews.</strong></p>

<h2 id="problem">Problem</h2>

<p>Given the root of a binary tree, return the traversal of its nodes’ values in different orders:</p>
<ol>
  <li><strong>Inorder</strong> (Left → Root → Right)</li>
  <li><strong>Preorder</strong> (Root → Left → Right)</li>
  <li><strong>Postorder</strong> (Left → Right → Root)</li>
  <li><strong>Level Order</strong> (Level by level, left to right)</li>
</ol>

<p><strong>Example:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        1
       / \
      2   3
     / \
    4   5

Inorder:    [4, 2, 5, 1, 3]
Preorder:   [1, 2, 4, 5, 3]
Postorder:  [4, 5, 2, 3, 1]
Level Order: [1, 2, 3, 4, 5]
</code></pre></div></div>

<hr />

<h2 id="binary-tree-basics">Binary Tree Basics</h2>

<h3 id="tree-node-definition">Tree Node Definition</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">TreeNode</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">Binary tree node</span><span class="sh">"""</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="n">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="n">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>

<span class="c1"># Helper to build tree from list
</span><span class="k">def</span> <span class="nf">build_tree</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">Build tree from level-order list (None represents null)</span><span class="sh">"""</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">values</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span>
    
    <span class="n">root</span> <span class="o">=</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">queue</span> <span class="o">=</span> <span class="p">[</span><span class="n">root</span><span class="p">]</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
    
    <span class="k">while</span> <span class="n">queue</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nf">len</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="nf">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        
        <span class="c1"># Left child
</span>        <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nf">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="ow">and</span> <span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">node</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        
        <span class="c1"># Right child
</span>        <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nf">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="ow">and</span> <span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">node</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
    
    <span class="k">return</span> <span class="n">root</span>

<span class="c1"># Example usage
</span><span class="n">root</span> <span class="o">=</span> <span class="nf">build_tree</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
</code></pre></div></div>

<h3 id="visual-representation">Visual Representation</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Complete tree representation with indices:

              1 (index 0)
             / \
            /   \
           /     \
          2       3 (indices 1, 2)
         / \     / \
        4   5   6   7 (indices 3, 4, 5, 6)
       / \
      8   9 (indices 7, 8)

Relationships:
- Parent of node i: (i - 1) // 2
- Left child of node i: 2*i + 1
- Right child of node i: 2*i + 2
</code></pre></div></div>

<hr />

<h2 id="depth-first-search-dfs-traversals">Depth-First Search (DFS) Traversals</h2>

<h3 id="1-inorder-traversal-left--root--right">1. Inorder Traversal (Left → Root → Right)</h3>

<p><strong>Use case:</strong> Get values in sorted order for BST</p>

<h4 id="recursive-approach">Recursive Approach</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">inorderTraversal</span><span class="p">(</span><span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="sh">"""</span><span class="s">
    Inorder: Left → Root → Right
    
    Time: O(n) - visit each node once
    Space: O(h) - recursion stack, h = height
    </span><span class="sh">"""</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">def</span> <span class="nf">inorder</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="p">:</span>
            <span class="k">return</span>
        
        <span class="nf">inorder</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>       <span class="c1"># Visit left subtree
</span>        <span class="n">result</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>  <span class="c1"># Visit root
</span>        <span class="nf">inorder</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>      <span class="c1"># Visit right subtree
</span>    
    <span class="nf">inorder</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>

<span class="c1"># Example
</span><span class="n">root</span> <span class="o">=</span> <span class="nf">build_tree</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="nf">print</span><span class="p">(</span><span class="nf">inorderTraversal</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>  <span class="c1"># [1, 3, 2]
</span></code></pre></div></div>

<p><strong>Execution trace:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Tree:    1
          \
           2
          /
         3

Call stack (going down):
inorder(1) → inorder(None) [left]
          → append 1
          → inorder(2) → inorder(3) → inorder(None) [left]
                                    → append 3
                                    → inorder(None) [right]
                      → append 2
                      → inorder(None) [right]

Result: [1, 3, 2]
</code></pre></div></div>

<h4 id="iterative-approach-using-stack">Iterative Approach (Using Stack)</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">inorderTraversal</span><span class="p">(</span><span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="sh">"""</span><span class="s">
    Iterative inorder using explicit stack
    
    Time: O(n)
    Space: O(h)
    </span><span class="sh">"""</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">current</span> <span class="o">=</span> <span class="n">root</span>
    
    <span class="k">while</span> <span class="n">current</span> <span class="ow">or</span> <span class="n">stack</span><span class="p">:</span>
        <span class="c1"># Go to leftmost node
</span>        <span class="k">while</span> <span class="n">current</span><span class="p">:</span>
            <span class="n">stack</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">current</span><span class="p">)</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="p">.</span><span class="n">left</span>
        
        <span class="c1"># Current must be None, pop from stack
</span>        <span class="n">current</span> <span class="o">=</span> <span class="n">stack</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
        <span class="n">result</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">current</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
        
        <span class="c1"># Visit right subtree
</span>        <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="p">.</span><span class="n">right</span>
    
    <span class="k">return</span> <span class="n">result</span>
</code></pre></div></div>

<p><strong>Stack visualization:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Tree:      2
          / \
         1   3

Step-by-step:
Initial: current = 2, stack = []

Step 1: Push 2, move to left
        current = 1, stack = [2]

Step 2: Push 1, move to left
        current = None, stack = [2, 1]

Step 3: Pop 1, append 1
        current = None (1.right), stack = [2]
        Result: [1]

Step 4: Pop 2, append 2
        current = 3 (2.right), stack = []
        Result: [1, 2]

Step 5: Push 3, move to left
        current = None, stack = [3]

Step 6: Pop 3, append 3
        current = None, stack = []
        Result: [1, 2, 3]
</code></pre></div></div>

<hr />

<h3 id="2-preorder-traversal-root--left--right">2. Preorder Traversal (Root → Left → Right)</h3>

<p><strong>Use case:</strong> Copy tree, serialize tree</p>

<h4 id="recursive-approach-1">Recursive Approach</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">preorderTraversal</span><span class="p">(</span><span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="sh">"""</span><span class="s">
    Preorder: Root → Left → Right
    
    Time: O(n)
    Space: O(h)
    </span><span class="sh">"""</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">def</span> <span class="nf">preorder</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="p">:</span>
            <span class="k">return</span>
        
        <span class="n">result</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>  <span class="c1"># Visit root first
</span>        <span class="nf">preorder</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>      <span class="c1"># Visit left subtree
</span>        <span class="nf">preorder</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>     <span class="c1"># Visit right subtree
</span>    
    <span class="nf">preorder</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>
</code></pre></div></div>

<h4 id="iterative-approach">Iterative Approach</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">preorderTraversal</span><span class="p">(</span><span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="sh">"""</span><span class="s">
    Iterative preorder
    
    Strategy: Use stack, visit node before children
    </span><span class="sh">"""</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>
    
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="n">root</span><span class="p">]</span>
    
    <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">stack</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
        <span class="n">result</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
        
        <span class="c1"># Push right first (so left is processed first)
</span>        <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
            <span class="n">stack</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">:</span>
            <span class="n">stack</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">result</span>
</code></pre></div></div>

<p><strong>Visual execution:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Tree:      1
          / \
         2   3

Initial: stack = [1]

Step 1: Pop 1, append 1
        Push 3, 2
        stack = [3, 2], result = [1]

Step 2: Pop 2, append 2
        (2 has no children)
        stack = [3], result = [1, 2]

Step 3: Pop 3, append 3
        (3 has no children)
        stack = [], result = [1, 2, 3]
</code></pre></div></div>

<hr />

<h3 id="3-postorder-traversal-left--right--root">3. Postorder Traversal (Left → Right → Root)</h3>

<p><strong>Use case:</strong> Delete tree, evaluate expression tree</p>

<h4 id="recursive-approach-2">Recursive Approach</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">postorderTraversal</span><span class="p">(</span><span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="sh">"""</span><span class="s">
    Postorder: Left → Right → Root
    
    Time: O(n)
    Space: O(h)
    </span><span class="sh">"""</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">def</span> <span class="nf">postorder</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="p">:</span>
            <span class="k">return</span>
        
        <span class="nf">postorder</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>     <span class="c1"># Visit left subtree
</span>        <span class="nf">postorder</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>    <span class="c1"># Visit right subtree
</span>        <span class="n">result</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>  <span class="c1"># Visit root last
</span>    
    <span class="nf">postorder</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>
</code></pre></div></div>

<h4 id="iterative-approach-two-stacks">Iterative Approach (Two Stacks)</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">postorderTraversal</span><span class="p">(</span><span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="sh">"""</span><span class="s">
    Iterative postorder using two stacks
    
    Idea: Reverse of (Root → Right → Left) is (Left → Right → Root)
    </span><span class="sh">"""</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>
    
    <span class="n">stack1</span> <span class="o">=</span> <span class="p">[</span><span class="n">root</span><span class="p">]</span>
    <span class="n">stack2</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">while</span> <span class="n">stack1</span><span class="p">:</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">stack1</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
        <span class="n">stack2</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        
        <span class="c1"># Push left first (so right is processed first)
</span>        <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">:</span>
            <span class="n">stack1</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
            <span class="n">stack1</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
    
    <span class="c1"># stack2 now has postorder in reverse
</span>    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="n">stack2</span><span class="p">:</span>
        <span class="n">result</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">stack2</span><span class="p">.</span><span class="nf">pop</span><span class="p">().</span><span class="n">val</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">result</span>
</code></pre></div></div>

<h4 id="iterative-approach-one-stack">Iterative Approach (One Stack)</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">postorderTraversal</span><span class="p">(</span><span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="sh">"""</span><span class="s">
    Iterative postorder using one stack
    
    More complex: need to track visited nodes
    </span><span class="sh">"""</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>
    
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="n">root</span><span class="p">]</span>
    <span class="n">last_visited</span> <span class="o">=</span> <span class="bp">None</span>
    
    <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># Peek
</span>        
        <span class="c1"># If leaf or both children visited, process node
</span>        <span class="nf">if </span><span class="p">(</span><span class="ow">not</span> <span class="n">current</span><span class="p">.</span><span class="n">left</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">current</span><span class="p">.</span><span class="n">right</span><span class="p">)</span> <span class="ow">or</span> \
           <span class="p">(</span><span class="n">last_visited</span> <span class="ow">and</span> <span class="p">(</span><span class="n">last_visited</span> <span class="o">==</span> <span class="n">current</span><span class="p">.</span><span class="n">left</span> <span class="ow">or</span> <span class="n">last_visited</span> <span class="o">==</span> <span class="n">current</span><span class="p">.</span><span class="n">right</span><span class="p">)):</span>
            <span class="n">result</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">current</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
            <span class="n">stack</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
            <span class="n">last_visited</span> <span class="o">=</span> <span class="n">current</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Push children (right first, then left)
</span>            <span class="k">if</span> <span class="n">current</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
                <span class="n">stack</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">current</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">current</span><span class="p">.</span><span class="n">left</span><span class="p">:</span>
                <span class="n">stack</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">current</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">result</span>
</code></pre></div></div>

<hr />

<h2 id="breadth-first-search-bfs-traversal">Breadth-First Search (BFS) Traversal</h2>

<h3 id="level-order-traversal">Level Order Traversal</h3>

<p><strong>Use case:</strong> Find shortest path, level-by-level processing</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">deque</span>

<span class="k">def</span> <span class="nf">levelOrder</span><span class="p">(</span><span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
    <span class="sh">"""</span><span class="s">
    Level order traversal (BFS)
    
    Returns list of lists, each inner list is one level
    
    Time: O(n)
    Space: O(w) where w is maximum width
    </span><span class="sh">"""</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>
    
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">queue</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">([</span><span class="n">root</span><span class="p">])</span>
    
    <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
        <span class="n">level_size</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span>
        <span class="n">level</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="c1"># Process all nodes at current level
</span>        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">level_size</span><span class="p">):</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="nf">popleft</span><span class="p">()</span>
            <span class="n">level</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
            
            <span class="c1"># Add children for next level
</span>            <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">:</span>
                <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
                <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
        
        <span class="n">result</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">level</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">result</span>

<span class="c1"># Example
</span><span class="n">root</span> <span class="o">=</span> <span class="nf">build_tree</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">7</span><span class="p">])</span>
<span class="nf">print</span><span class="p">(</span><span class="nf">levelOrder</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>
<span class="c1"># [[3], [9, 20], [15, 7]]
</span></code></pre></div></div>

<p><strong>Visual execution:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Tree:        3
           /   \
          9     20
               /  \
              15   7

Initial: queue = [3], result = []

Level 0:
  queue = [3], level_size = 1
  Process 3: level = [3], queue = [9, 20]
  result = [[3]]

Level 1:
  queue = [9, 20], level_size = 2
  Process 9: level = [9], queue = [20]
  Process 20: level = [9, 20], queue = [15, 7]
  result = [[3], [9, 20]]

Level 2:
  queue = [15, 7], level_size = 2
  Process 15: level = [15], queue = [7]
  Process 7: level = [15, 7], queue = []
  result = [[3], [9, 20], [15, 7]]
</code></pre></div></div>

<hr />

<h2 id="traversal-comparison">Traversal Comparison</h2>

<h3 id="visual-comparison">Visual Comparison</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Tree:        1
           /   \
          2     3
         / \
        4   5

Inorder:    4  2  5  1  3  (Left → Root → Right)
                ↑     ↑  ↑
            Visits root in middle

Preorder:   1  2  4  5  3  (Root → Left → Right)
            ↑
            Visits root first

Postorder:  4  5  2  3  1  (Left → Right → Root)
                        ↑
            Visits root last

Level Order: 1  2  3  4  5 (Level by level)
             Level 0  Level 1  Level 2
</code></pre></div></div>

<h3 id="when-to-use-each">When to Use Each</h3>

<table>
  <thead>
    <tr>
      <th>Traversal</th>
      <th>Use Case</th>
      <th>Example Application</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Inorder</strong></td>
      <td>Process BST in sorted order</td>
      <td>Validate BST, flatten to sorted list</td>
    </tr>
    <tr>
      <td><strong>Preorder</strong></td>
      <td>Create copy, serialize tree</td>
      <td>Tree serialization, prefix expression</td>
    </tr>
    <tr>
      <td><strong>Postorder</strong></td>
      <td>Delete tree, calculate subtree properties</td>
      <td>Delete tree, calculate height, postfix expression</td>
    </tr>
    <tr>
      <td><strong>Level Order</strong></td>
      <td>Find shortest path, level-wise processing</td>
      <td>Print by levels, find min depth</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="morris-traversal-o1-space">Morris Traversal (O(1) Space)</h2>

<p><strong>Problem:</strong> All previous approaches use O(h) space. Can we do O(1)?</p>

<p><strong>Answer:</strong> Yes! Morris traversal uses <strong>threaded binary tree</strong> concept.</p>

<h3 id="morris-inorder-traversal">Morris Inorder Traversal</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">morrisInorder</span><span class="p">(</span><span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="sh">"""</span><span class="s">
    Morris inorder traversal
    
    Time: O(n)
    Space: O(1) - no stack/recursion!
    
    Idea: Create temporary links (threads) to predecessor
    </span><span class="sh">"""</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">current</span> <span class="o">=</span> <span class="n">root</span>
    
    <span class="k">while</span> <span class="n">current</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">current</span><span class="p">.</span><span class="n">left</span><span class="p">:</span>
            <span class="c1"># No left subtree, visit current
</span>            <span class="n">result</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">current</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="p">.</span><span class="n">right</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Find inorder predecessor (rightmost in left subtree)
</span>            <span class="n">predecessor</span> <span class="o">=</span> <span class="n">current</span><span class="p">.</span><span class="n">left</span>
            <span class="k">while</span> <span class="n">predecessor</span><span class="p">.</span><span class="n">right</span> <span class="ow">and</span> <span class="n">predecessor</span><span class="p">.</span><span class="n">right</span> <span class="o">!=</span> <span class="n">current</span><span class="p">:</span>
                <span class="n">predecessor</span> <span class="o">=</span> <span class="n">predecessor</span><span class="p">.</span><span class="n">right</span>
            
            <span class="k">if</span> <span class="ow">not</span> <span class="n">predecessor</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
                <span class="c1"># Create thread
</span>                <span class="n">predecessor</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">current</span>
                <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="p">.</span><span class="n">left</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Thread exists, remove it
</span>                <span class="n">predecessor</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="bp">None</span>
                <span class="n">result</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">current</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
                <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="p">.</span><span class="n">right</span>
    
    <span class="k">return</span> <span class="n">result</span>
</code></pre></div></div>

<p><strong>Visualization:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Original Tree:     Modified During Morris:

      1                  1
     / \                / \
    2   3              2   3
   / \                / \
  4   5              4   5
                          \
                           1 (thread)

Steps:
1. current = 1, find predecessor (5)
2. Create thread 5 → 1
3. Move to left subtree (current = 2)
4. Find predecessor (4) for 2
5. Create thread 4 → 2
... continue until all threads explored
</code></pre></div></div>

<p><strong>Time complexity analysis:</strong></p>
<ul>
  <li>Each edge traversed at most twice (once to create thread, once to remove)</li>
  <li>Total: O(n)</li>
</ul>

<hr />

<h2 id="advanced-traversal-problems">Advanced Traversal Problems</h2>

<h3 id="problem-1-zigzag-level-order">Problem 1: Zigzag Level Order</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">zigzagLevelOrder</span><span class="p">(</span><span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
    <span class="sh">"""</span><span class="s">
    Level order but alternate direction
    
    Level 0: left to right
    Level 1: right to left
    Level 2: left to right
</span><span class="gp">    ...</span>
    
    <span class="n">Time</span><span class="p">:</span> <span class="nc">O</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">Space</span><span class="p">:</span> <span class="nc">O</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
    <span class="sh">"""</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>
    
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">queue</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">([</span><span class="n">root</span><span class="p">])</span>
    <span class="n">left_to_right</span> <span class="o">=</span> <span class="bp">True</span>
    
    <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
        <span class="n">level_size</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span>
        <span class="n">level</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">()</span>
        
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">level_size</span><span class="p">):</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="nf">popleft</span><span class="p">()</span>
            
            <span class="c1"># Add to level based on direction
</span>            <span class="k">if</span> <span class="n">left_to_right</span><span class="p">:</span>
                <span class="n">level</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">level</span><span class="p">.</span><span class="nf">appendleft</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">:</span>
                <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
                <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
        
        <span class="n">result</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="nf">list</span><span class="p">(</span><span class="n">level</span><span class="p">))</span>
        <span class="n">left_to_right</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">left_to_right</span>
    
    <span class="k">return</span> <span class="n">result</span>

<span class="c1"># Example
</span><span class="n">root</span> <span class="o">=</span> <span class="nf">build_tree</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">7</span><span class="p">])</span>
<span class="nf">print</span><span class="p">(</span><span class="nf">zigzagLevelOrder</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>
<span class="c1"># [[3], [20, 9], [15, 7]]
</span></code></pre></div></div>

<h3 id="problem-2-vertical-order-traversal">Problem 2: Vertical Order Traversal</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>

<span class="k">def</span> <span class="nf">verticalOrder</span><span class="p">(</span><span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
    <span class="sh">"""</span><span class="s">
    Traverse by vertical columns
    
    Assign column numbers:
    - Root at column 0
    - Left child: column - 1
    - Right child: column + 1
    
    Time: O(n log n), Space: O(n)
    </span><span class="sh">"""</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>
    
    <span class="c1"># Dictionary: column → list of (row, val)
</span>    <span class="n">columns</span> <span class="o">=</span> <span class="nf">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    
    <span class="c1"># BFS with (node, row, col)
</span>    <span class="n">queue</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">([(</span><span class="n">root</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>
    
    <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
        <span class="n">node</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="nf">popleft</span><span class="p">()</span>
        <span class="n">columns</span><span class="p">[</span><span class="n">col</span><span class="p">].</span><span class="nf">append</span><span class="p">((</span><span class="n">row</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">val</span><span class="p">))</span>
        
        <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">:</span>
            <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">((</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">row</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">col</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
            <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">((</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">,</span> <span class="n">row</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">col</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
    
    <span class="c1"># Sort columns by column index
</span>    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="nf">sorted</span><span class="p">(</span><span class="n">columns</span><span class="p">.</span><span class="nf">keys</span><span class="p">()):</span>
        <span class="c1"># Sort by row, then by value
</span>        <span class="n">column_vals</span> <span class="o">=</span> <span class="p">[</span><span class="n">val</span> <span class="k">for</span> <span class="n">row</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nf">sorted</span><span class="p">(</span><span class="n">columns</span><span class="p">[</span><span class="n">col</span><span class="p">])]</span>
        <span class="n">result</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">column_vals</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">result</span>

<span class="c1"># Example
#       1
#      / \
#     2   3
#    / \   \
#   4   5   6
#
# Columns: -2:[4], -1:[2], 0:[1,5], 1:[3], 2:[6]
# Result: [[4], [2], [1, 5], [3], [6]]
</span></code></pre></div></div>

<h3 id="problem-3-boundary-traversal">Problem 3: Boundary Traversal</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">boundaryTraversal</span><span class="p">(</span><span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="sh">"""</span><span class="s">
    Return boundary nodes in counter-clockwise order
    
    Boundary = left boundary + leaves + right boundary (reversed)
    
    Time: O(n), Space: O(h)
    </span><span class="sh">"""</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>
    
    <span class="k">def</span> <span class="nf">is_leaf</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span>
    
    <span class="k">def</span> <span class="nf">add_left_boundary</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">Add left boundary (excluding leaves)</span><span class="sh">"""</span>
        <span class="k">while</span> <span class="n">node</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nf">is_leaf</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
                <span class="n">result</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span> <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span> <span class="k">else</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span>
    
    <span class="k">def</span> <span class="nf">add_leaves</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">Add all leaves</span><span class="sh">"""</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="nf">is_leaf</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="n">result</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
        <span class="nf">add_leaves</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
        <span class="nf">add_leaves</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">add_right_boundary</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">Add right boundary (excluding leaves) in reverse</span><span class="sh">"""</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="n">node</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nf">is_leaf</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
                <span class="n">temp</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span> <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span> <span class="k">else</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span>
        <span class="n">result</span><span class="p">.</span><span class="nf">extend</span><span class="p">(</span><span class="nf">reversed</span><span class="p">(</span><span class="n">temp</span><span class="p">))</span>
    
    <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">]</span>
    <span class="k">if</span> <span class="nf">is_leaf</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">result</span>
    
    <span class="nf">add_left_boundary</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
    <span class="nf">add_leaves</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
    <span class="nf">add_leaves</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
    <span class="nf">add_right_boundary</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">result</span>
</code></pre></div></div>

<p><strong>Visualization:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Tree:          1
             /   \
            2     3
           / \     \
          4   5     6
         /         / \
        7         8   9

Boundary (counter-clockwise):
Left boundary:  1 → 2 → 4 → 7
Leaves:         7, 5, 8, 9
Right boundary: 6 → 3 → 1 (reversed)

Result: [1, 2, 4, 7, 5, 8, 9, 6, 3]
</code></pre></div></div>

<hr />

<h2 id="connection-to-ml-systems">Connection to ML Systems</h2>

<p>Tree traversal patterns appear in ML engineering:</p>

<h3 id="1-decision-tree-traversal">1. Decision Tree Traversal</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">DecisionTreeNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">feature</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">feature</span> <span class="o">=</span> <span class="n">feature</span>      <span class="c1"># Feature to split on
</span>        <span class="n">self</span><span class="p">.</span><span class="n">threshold</span> <span class="o">=</span> <span class="n">threshold</span>  <span class="c1"># Threshold value
</span>        <span class="n">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>           <span class="c1"># Left child
</span>        <span class="n">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>         <span class="c1"># Right child
</span>        <span class="n">self</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>         <span class="c1"># Leaf value
</span>
<span class="k">def</span> <span class="nf">predict_decision_tree</span><span class="p">(</span><span class="n">root</span><span class="p">:</span> <span class="n">DecisionTreeNode</span><span class="p">,</span> <span class="n">sample</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">
    Traverse decision tree to make prediction
    
    This is essentially a modified preorder traversal
    </span><span class="sh">"""</span>
    <span class="k">if</span> <span class="n">root</span><span class="p">.</span><span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="c1"># Leaf node
</span>        <span class="k">return</span> <span class="n">root</span><span class="p">.</span><span class="n">value</span>
    
    <span class="c1"># Internal node: check condition
</span>    <span class="k">if</span> <span class="n">sample</span><span class="p">[</span><span class="n">root</span><span class="p">.</span><span class="n">feature</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">root</span><span class="p">.</span><span class="n">threshold</span><span class="p">:</span>
        <span class="k">return</span> <span class="nf">predict_decision_tree</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">sample</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="nf">predict_decision_tree</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">,</span> <span class="n">sample</span><span class="p">)</span>

<span class="c1"># Example
</span><span class="n">tree</span> <span class="o">=</span> <span class="nc">DecisionTreeNode</span><span class="p">(</span>
    <span class="n">feature</span><span class="o">=</span><span class="sh">'</span><span class="s">age</span><span class="sh">'</span><span class="p">,</span>
    <span class="n">threshold</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span>
    <span class="n">left</span><span class="o">=</span><span class="nc">DecisionTreeNode</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>  <span class="c1"># Predict 0 if age &lt;= 30
</span>    <span class="n">right</span><span class="o">=</span><span class="nc">DecisionTreeNode</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># Predict 1 if age &gt; 30
</span><span class="p">)</span>

<span class="n">sample</span> <span class="o">=</span> <span class="p">{</span><span class="sh">'</span><span class="s">age</span><span class="sh">'</span><span class="p">:</span> <span class="mi">25</span><span class="p">,</span> <span class="sh">'</span><span class="s">income</span><span class="sh">'</span><span class="p">:</span> <span class="mi">50000</span><span class="p">}</span>
<span class="n">prediction</span> <span class="o">=</span> <span class="nf">predict_decision_tree</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">sample</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="2-feature-engineering-pipeline-dag-traversal">2. Feature Engineering Pipeline (DAG Traversal)</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">FeatureNode</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">Node in feature engineering DAG</span><span class="sh">"""</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">transform_fn</span><span class="p">,</span> <span class="n">dependencies</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="n">self</span><span class="p">.</span><span class="n">transform_fn</span> <span class="o">=</span> <span class="n">transform_fn</span>
        <span class="n">self</span><span class="p">.</span><span class="n">dependencies</span> <span class="o">=</span> <span class="n">dependencies</span> <span class="ow">or</span> <span class="p">[]</span>
        <span class="n">self</span><span class="p">.</span><span class="n">result</span> <span class="o">=</span> <span class="bp">None</span>

<span class="k">def</span> <span class="nf">topological_sort_features</span><span class="p">(</span><span class="n">nodes</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">FeatureNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">FeatureNode</span><span class="p">]:</span>
    <span class="sh">"""</span><span class="s">
    Topological sort of feature dependencies
    
    Similar to postorder: compute dependencies before current node
    </span><span class="sh">"""</span>
    <span class="n">visited</span> <span class="o">=</span> <span class="nf">set</span><span class="p">()</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">visited</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">name</span><span class="p">)</span>
        
        <span class="c1"># Visit dependencies first (like postorder)
</span>        <span class="k">for</span> <span class="n">dep</span> <span class="ow">in</span> <span class="n">node</span><span class="p">.</span><span class="n">dependencies</span><span class="p">:</span>
            <span class="nf">dfs</span><span class="p">(</span><span class="n">dep</span><span class="p">)</span>
        
        <span class="n">result</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
        <span class="nf">dfs</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">result</span>

<span class="c1"># Example
</span><span class="n">raw_age</span> <span class="o">=</span> <span class="nc">FeatureNode</span><span class="p">(</span><span class="sh">'</span><span class="s">raw_age</span><span class="sh">'</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="sh">'</span><span class="s">age</span><span class="sh">'</span><span class="p">])</span>
<span class="n">age_squared</span> <span class="o">=</span> <span class="nc">FeatureNode</span><span class="p">(</span><span class="sh">'</span><span class="s">age_squared</span><span class="sh">'</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="sh">'</span><span class="s">age</span><span class="sh">'</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">dependencies</span><span class="o">=</span><span class="p">[</span><span class="n">raw_age</span><span class="p">])</span>
<span class="n">age_log</span> <span class="o">=</span> <span class="nc">FeatureNode</span><span class="p">(</span><span class="sh">'</span><span class="s">age_log</span><span class="sh">'</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="sh">'</span><span class="s">age</span><span class="sh">'</span><span class="p">]),</span> <span class="n">dependencies</span><span class="o">=</span><span class="p">[</span><span class="n">raw_age</span><span class="p">])</span>

<span class="n">features</span> <span class="o">=</span> <span class="nf">topological_sort_features</span><span class="p">([</span><span class="n">age_log</span><span class="p">,</span> <span class="n">age_squared</span><span class="p">,</span> <span class="n">raw_age</span><span class="p">])</span>
<span class="c1"># Result: [raw_age, age_squared, age_log] or [raw_age, age_log, age_squared]
</span></code></pre></div></div>

<h3 id="3-model-ensembles-tree-of-models">3. Model Ensembles (Tree of Models)</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">EnsembleNode</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">Node in ensemble hierarchy</span><span class="sh">"""</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">combiner</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">model</span>        <span class="c1"># Base model
</span>        <span class="n">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>         <span class="c1"># Left sub-ensemble
</span>        <span class="n">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>       <span class="c1"># Right sub-ensemble
</span>        <span class="n">self</span><span class="p">.</span><span class="n">combiner</span> <span class="o">=</span> <span class="n">combiner</span> <span class="c1"># How to combine predictions
</span>
<span class="k">def</span> <span class="nf">predict_ensemble</span><span class="p">(</span><span class="n">root</span><span class="p">:</span> <span class="n">EnsembleNode</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">
    Hierarchical ensemble prediction
    
    Uses postorder: get child predictions before combining
    </span><span class="sh">"""</span>
    <span class="k">if</span> <span class="n">root</span><span class="p">.</span><span class="n">model</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="c1"># Leaf: base model
</span>        <span class="k">return</span> <span class="n">root</span><span class="p">.</span><span class="n">model</span><span class="p">.</span><span class="nf">predict</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
    
    <span class="c1"># Get predictions from sub-ensembles
</span>    <span class="n">left_pred</span> <span class="o">=</span> <span class="nf">predict_ensemble</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span>
    <span class="n">right_pred</span> <span class="o">=</span> <span class="nf">predict_ensemble</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span>
    
    <span class="c1"># Combine
</span>    <span class="k">return</span> <span class="n">root</span><span class="p">.</span><span class="nf">combiner</span><span class="p">(</span><span class="n">left_pred</span><span class="p">,</span> <span class="n">right_pred</span><span class="p">)</span>

<span class="c1"># Example: Ensemble of ensembles
</span><span class="k">def</span> <span class="nf">average</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="nf">return </span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>

<span class="n">ensemble</span> <span class="o">=</span> <span class="nc">EnsembleNode</span><span class="p">(</span>
    <span class="n">combiner</span><span class="o">=</span><span class="n">average</span><span class="p">,</span>
    <span class="n">left</span><span class="o">=</span><span class="nc">EnsembleNode</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="n">model1</span><span class="p">),</span>
    <span class="n">right</span><span class="o">=</span><span class="nc">EnsembleNode</span><span class="p">(</span>
        <span class="n">combiner</span><span class="o">=</span><span class="n">average</span><span class="p">,</span>
        <span class="n">left</span><span class="o">=</span><span class="nc">EnsembleNode</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="n">model2</span><span class="p">),</span>
        <span class="n">right</span><span class="o">=</span><span class="nc">EnsembleNode</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="n">model3</span><span class="p">)</span>
    <span class="p">)</span>
<span class="p">)</span>
</code></pre></div></div>

<hr />

<h2 id="testing">Testing</h2>

<h3 id="comprehensive-test-suite">Comprehensive Test Suite</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">unittest</span>

<span class="k">class</span> <span class="nc">TestTreeTraversal</span><span class="p">(</span><span class="n">unittest</span><span class="p">.</span><span class="n">TestCase</span><span class="p">):</span>
    
    <span class="k">def</span> <span class="nf">setUp</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">Create test trees</span><span class="sh">"""</span>
        <span class="c1"># Tree 1:     1
</span>        <span class="c1">#           /   \
</span>        <span class="c1">#          2     3
</span>        <span class="n">self</span><span class="p">.</span><span class="n">tree1</span> <span class="o">=</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">tree1</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">tree1</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        
        <span class="c1"># Tree 2:     1
</span>        <span class="c1">#           /   \
</span>        <span class="c1">#          2     3
</span>        <span class="c1">#         / \
</span>        <span class="c1">#        4   5
</span>        <span class="n">self</span><span class="p">.</span><span class="n">tree2</span> <span class="o">=</span> <span class="nf">build_tree</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
    
    <span class="k">def</span> <span class="nf">test_inorder</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">Test inorder traversal</span><span class="sh">"""</span>
        <span class="n">self</span><span class="p">.</span><span class="nf">assertEqual</span><span class="p">(</span><span class="nf">inorderTraversal</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">tree1</span><span class="p">),</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
        <span class="n">self</span><span class="p">.</span><span class="nf">assertEqual</span><span class="p">(</span><span class="nf">inorderTraversal</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">tree2</span><span class="p">),</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
    
    <span class="k">def</span> <span class="nf">test_preorder</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">Test preorder traversal</span><span class="sh">"""</span>
        <span class="n">self</span><span class="p">.</span><span class="nf">assertEqual</span><span class="p">(</span><span class="nf">preorderTraversal</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">tree1</span><span class="p">),</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
        <span class="n">self</span><span class="p">.</span><span class="nf">assertEqual</span><span class="p">(</span><span class="nf">preorderTraversal</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">tree2</span><span class="p">),</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
    
    <span class="k">def</span> <span class="nf">test_postorder</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">Test postorder traversal</span><span class="sh">"""</span>
        <span class="n">self</span><span class="p">.</span><span class="nf">assertEqual</span><span class="p">(</span><span class="nf">postorderTraversal</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">tree1</span><span class="p">),</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">self</span><span class="p">.</span><span class="nf">assertEqual</span><span class="p">(</span><span class="nf">postorderTraversal</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">tree2</span><span class="p">),</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
    
    <span class="k">def</span> <span class="nf">test_level_order</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">Test level order traversal</span><span class="sh">"""</span>
        <span class="n">self</span><span class="p">.</span><span class="nf">assertEqual</span><span class="p">(</span><span class="nf">levelOrder</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">tree1</span><span class="p">),</span> <span class="p">[[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
        <span class="n">self</span><span class="p">.</span><span class="nf">assertEqual</span><span class="p">(</span><span class="nf">levelOrder</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">tree2</span><span class="p">),</span> <span class="p">[[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]])</span>
    
    <span class="k">def</span> <span class="nf">test_empty_tree</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">Test empty tree</span><span class="sh">"""</span>
        <span class="n">self</span><span class="p">.</span><span class="nf">assertEqual</span><span class="p">(</span><span class="nf">inorderTraversal</span><span class="p">(</span><span class="bp">None</span><span class="p">),</span> <span class="p">[])</span>
        <span class="n">self</span><span class="p">.</span><span class="nf">assertEqual</span><span class="p">(</span><span class="nf">levelOrder</span><span class="p">(</span><span class="bp">None</span><span class="p">),</span> <span class="p">[])</span>
    
    <span class="k">def</span> <span class="nf">test_single_node</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">Test single node</span><span class="sh">"""</span>
        <span class="n">single</span> <span class="o">=</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="nf">assertEqual</span><span class="p">(</span><span class="nf">inorderTraversal</span><span class="p">(</span><span class="n">single</span><span class="p">),</span> <span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">self</span><span class="p">.</span><span class="nf">assertEqual</span><span class="p">(</span><span class="nf">preorderTraversal</span><span class="p">(</span><span class="n">single</span><span class="p">),</span> <span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">self</span><span class="p">.</span><span class="nf">assertEqual</span><span class="p">(</span><span class="nf">postorderTraversal</span><span class="p">(</span><span class="n">single</span><span class="p">),</span> <span class="p">[</span><span class="mi">1</span><span class="p">])</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="sh">'</span><span class="s">__main__</span><span class="sh">'</span><span class="p">:</span>
    <span class="n">unittest</span><span class="p">.</span><span class="nf">main</span><span class="p">()</span>
</code></pre></div></div>

<hr />

<h2 id="interview-tips">Interview Tips</h2>

<h3 id="pattern-recognition">Pattern Recognition</h3>

<p><strong>When you see:</strong></p>
<ul>
  <li>“Process tree nodes in specific order”</li>
  <li>“Find path from root to node”</li>
  <li>“Compute tree property”</li>
  <li>“Level-wise processing”</li>
</ul>

<p><strong>Think:</strong> Tree traversal</p>

<h3 id="choosing-the-right-traversal">Choosing the Right Traversal</h3>

<p><strong>Decision tree:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Need specific order? ────────────────────────┐
│                                            │
├─ Sorted (BST): Inorder                    │
├─ Copy/Serialize: Preorder                 │
├─ Delete/Calculate: Postorder              │
└─ Level-wise: BFS                          │
                                             │
Space constraint? ───────────────────────────┤
│                                            │
├─ O(1) space needed: Morris                │
└─ O(h) acceptable: Recursive/Iterative     │
</code></pre></div></div>

<h3 id="common-mistakes">Common Mistakes</h3>

<p><strong>1. Forgetting base case:</strong></p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># WRONG
</span><span class="k">def</span> <span class="nf">inorder</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
    <span class="nf">inorder</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>  <span class="c1"># Crashes on None!
</span>    <span class="nf">print</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
    <span class="nf">inorder</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>

<span class="c1"># CORRECT
</span><span class="k">def</span> <span class="nf">inorder</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="nf">inorder</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
    <span class="nf">inorder</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
</code></pre></div></div>

<p><strong>2. Modifying tree during traversal:</strong></p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># DANGEROUS: Modifying tree structure
</span><span class="k">def</span> <span class="nf">dangerous_traversal</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="nf">dangerous_traversal</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
    <span class="n">node</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="bp">None</span>  <span class="c1"># Oops! Can cause issues
</span>    <span class="nf">dangerous_traversal</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
</code></pre></div></div>

<p><strong>3. Not considering empty tree:</strong></p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># WRONG
</span><span class="k">def</span> <span class="nf">get_height</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="nf">max</span><span class="p">(</span><span class="nf">get_height</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">),</span> <span class="nf">get_height</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">))</span>
    <span class="c1"># Crashes if root is None!
</span>
<span class="c1"># CORRECT
</span><span class="k">def</span> <span class="nf">get_height</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="nf">max</span><span class="p">(</span><span class="nf">get_height</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">),</span> <span class="nf">get_height</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">))</span>
</code></pre></div></div>

<hr />

<h2 id="performance-analysis--optimization">Performance Analysis &amp; Optimization</h2>

<h3 id="space-complexity-deep-dive">Space Complexity Deep Dive</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Traversal Method        Space Complexity    Notes
─────────────────────────────────────────────────────────────
Recursive DFS           O(h)               Recursion stack
Iterative DFS (stack)   O(h)               Explicit stack
BFS (queue)             O(w)               w = max width
Morris Traversal        O(1)               No extra space!

For balanced tree:      h = log n
For skewed tree:        h = n (worst case)
For complete tree:      w = n/2 (last level)
</code></pre></div></div>

<h3 id="performance-comparison">Performance Comparison</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">time</span>
<span class="kn">import</span> <span class="n">sys</span>

<span class="k">def</span> <span class="nf">measure_traversal_performance</span><span class="p">(</span><span class="n">tree_size</span><span class="o">=</span><span class="mi">10000</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">
    Benchmark different traversal methods
    </span><span class="sh">"""</span>
    <span class="c1"># Create balanced tree
</span>    <span class="n">root</span> <span class="o">=</span> <span class="nf">create_balanced_tree</span><span class="p">(</span><span class="n">tree_size</span><span class="p">)</span>
    
    <span class="n">methods</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">(</span><span class="sh">'</span><span class="s">Recursive Inorder</span><span class="sh">'</span><span class="p">,</span> <span class="k">lambda</span><span class="p">:</span> <span class="nf">inorderTraversal</span><span class="p">(</span><span class="n">root</span><span class="p">)),</span>
        <span class="p">(</span><span class="sh">'</span><span class="s">Iterative Inorder</span><span class="sh">'</span><span class="p">,</span> <span class="k">lambda</span><span class="p">:</span> <span class="nf">inorderTraversalIterative</span><span class="p">(</span><span class="n">root</span><span class="p">)),</span>
        <span class="p">(</span><span class="sh">'</span><span class="s">Morris Inorder</span><span class="sh">'</span><span class="p">,</span> <span class="k">lambda</span><span class="p">:</span> <span class="nf">morrisInorder</span><span class="p">(</span><span class="n">root</span><span class="p">)),</span>
        <span class="p">(</span><span class="sh">'</span><span class="s">Level Order BFS</span><span class="sh">'</span><span class="p">,</span> <span class="k">lambda</span><span class="p">:</span> <span class="nf">levelOrder</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>
    <span class="p">]</span>
    
    <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">method</span> <span class="ow">in</span> <span class="n">methods</span><span class="p">:</span>
        <span class="c1"># Measure time
</span>        <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">perf_counter</span><span class="p">()</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nf">method</span><span class="p">()</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">perf_counter</span><span class="p">()</span>
        
        <span class="c1"># Measure space (approximate)
</span>        <span class="c1"># This is simplified; real measurement would be more complex
</span>        
        <span class="n">results</span><span class="p">.</span><span class="nf">append</span><span class="p">({</span>
            <span class="sh">'</span><span class="s">method</span><span class="sh">'</span><span class="p">:</span> <span class="n">name</span><span class="p">,</span>
            <span class="sh">'</span><span class="s">time_ms</span><span class="sh">'</span><span class="p">:</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">,</span>
            <span class="sh">'</span><span class="s">result_length</span><span class="sh">'</span><span class="p">:</span> <span class="nf">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="p">})</span>
    
    <span class="k">return</span> <span class="n">results</span>

<span class="k">def</span> <span class="nf">create_balanced_tree</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">Create balanced tree with n nodes</span><span class="sh">"""</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span>
    
    <span class="n">values</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
    
    <span class="k">def</span> <span class="nf">build</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">start</span> <span class="o">&gt;</span> <span class="n">end</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
        
        <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">end</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="n">node</span> <span class="o">=</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="n">mid</span><span class="p">])</span>
        <span class="n">node</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="nf">build</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">node</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="nf">build</span><span class="p">(</span><span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">node</span>
    
    <span class="k">return</span> <span class="nf">build</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

<span class="c1"># Benchmark
</span><span class="n">results</span> <span class="o">=</span> <span class="nf">measure_traversal_performance</span><span class="p">(</span><span class="mi">10000</span><span class="p">)</span>
<span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">results</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="si">{</span><span class="n">r</span><span class="p">[</span><span class="sh">'</span><span class="s">method</span><span class="sh">'</span><span class="p">]</span><span class="si">:</span><span class="mi">25</span><span class="n">s</span><span class="si">}</span><span class="s">: </span><span class="si">{</span><span class="n">r</span><span class="p">[</span><span class="sh">'</span><span class="s">time_ms</span><span class="sh">'</span><span class="p">]</span><span class="si">:</span><span class="p">.</span><span class="mi">2</span><span class="n">f</span><span class="si">}</span><span class="s">ms</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<p><strong>Typical results (10,000 nodes):</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Recursive Inorder        : 8.23ms
Iterative Inorder        : 9.15ms  (slightly slower due to stack operations)
Morris Inorder           : 12.47ms (slower but O(1) space!)
Level Order BFS          : 10.33ms
</code></pre></div></div>

<hr />

<h2 id="edge-cases--corner-cases">Edge Cases &amp; Corner Cases</h2>

<h3 id="1-empty-tree">1. Empty Tree</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">handle_empty_tree</span><span class="p">():</span>
    <span class="sh">"""</span><span class="s">All traversals should handle None gracefully</span><span class="sh">"""</span>
    <span class="n">empty_root</span> <span class="o">=</span> <span class="bp">None</span>
    
    <span class="k">assert</span> <span class="nf">inorderTraversal</span><span class="p">(</span><span class="n">empty_root</span><span class="p">)</span> <span class="o">==</span> <span class="p">[]</span>
    <span class="k">assert</span> <span class="nf">preorderTraversal</span><span class="p">(</span><span class="n">empty_root</span><span class="p">)</span> <span class="o">==</span> <span class="p">[]</span>
    <span class="k">assert</span> <span class="nf">postorderTraversal</span><span class="p">(</span><span class="n">empty_root</span><span class="p">)</span> <span class="o">==</span> <span class="p">[]</span>
    <span class="k">assert</span> <span class="nf">levelOrder</span><span class="p">(</span><span class="n">empty_root</span><span class="p">)</span> <span class="o">==</span> <span class="p">[]</span>
    
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">✓ Empty tree handled correctly</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="2-single-node">2. Single Node</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">handle_single_node</span><span class="p">():</span>
    <span class="sh">"""</span><span class="s">Single node is both root and leaf</span><span class="sh">"""</span>
    <span class="n">single</span> <span class="o">=</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
    
    <span class="k">assert</span> <span class="nf">inorderTraversal</span><span class="p">(</span><span class="n">single</span><span class="p">)</span> <span class="o">==</span> <span class="p">[</span><span class="mi">42</span><span class="p">]</span>
    <span class="k">assert</span> <span class="nf">preorderTraversal</span><span class="p">(</span><span class="n">single</span><span class="p">)</span> <span class="o">==</span> <span class="p">[</span><span class="mi">42</span><span class="p">]</span>
    <span class="k">assert</span> <span class="nf">postorderTraversal</span><span class="p">(</span><span class="n">single</span><span class="p">)</span> <span class="o">==</span> <span class="p">[</span><span class="mi">42</span><span class="p">]</span>
    <span class="k">assert</span> <span class="nf">levelOrder</span><span class="p">(</span><span class="n">single</span><span class="p">)</span> <span class="o">==</span> <span class="p">[[</span><span class="mi">42</span><span class="p">]]</span>
    
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">✓ Single node handled correctly</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="3-skewed-tree-linked-list">3. Skewed Tree (Linked List)</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">create_right_skewed_tree</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">
    Create right-skewed tree (like linked list)
    
         1
          </span><span class="se">\
</span><span class="s">           2
            </span><span class="se">\
</span><span class="s">             3
              </span><span class="se">\
</span><span class="s">               4
    
    Worst case for space complexity: O(n)
    </span><span class="sh">"""</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span>
    
    <span class="n">root</span> <span class="o">=</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">current</span> <span class="o">=</span> <span class="n">root</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">current</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="p">.</span><span class="n">right</span>
    
    <span class="k">return</span> <span class="n">root</span>

<span class="c1"># Test skewed tree
</span><span class="n">skewed</span> <span class="o">=</span> <span class="nf">create_right_skewed_tree</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="k">assert</span> <span class="nf">inorderTraversal</span><span class="p">(</span><span class="n">skewed</span><span class="p">)</span> <span class="o">==</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="k">assert</span> <span class="nf">preorderTraversal</span><span class="p">(</span><span class="n">skewed</span><span class="p">)</span> <span class="o">==</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="k">assert</span> <span class="nf">postorderTraversal</span><span class="p">(</span><span class="n">skewed</span><span class="p">)</span> <span class="o">==</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
</code></pre></div></div>

<h3 id="4-large-values--overflow">4. Large Values &amp; Overflow</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">handle_large_values</span><span class="p">():</span>
    <span class="sh">"""</span><span class="s">Test with large integers</span><span class="sh">"""</span>
    <span class="n">tree</span> <span class="o">=</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mi">31</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># Max int
</span>    <span class="n">tree</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mi">31</span><span class="p">))</span>  <span class="c1"># Min int
</span>    <span class="n">tree</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    
    <span class="n">result</span> <span class="o">=</span> <span class="nf">inorderTraversal</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">result</span> <span class="o">==</span> <span class="p">[</span><span class="o">-</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mi">31</span><span class="p">),</span> <span class="mi">2</span><span class="o">**</span><span class="mi">31</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">✓ Large values handled correctly</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<hr />

<h2 id="advanced-applications">Advanced Applications</h2>

<h3 id="1-expression-tree-evaluation">1. Expression Tree Evaluation</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ExpressionNode</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">Node for expression tree</span><span class="sh">"""</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="n">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="n">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>

<span class="k">def</span> <span class="nf">evaluate_expression_tree</span><span class="p">(</span><span class="n">root</span><span class="p">:</span> <span class="n">ExpressionNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">
    Evaluate arithmetic expression tree
    
    Uses postorder: evaluate children before parent
    
    Example tree:
            +
           / </span><span class="se">\
</span><span class="s">          *   3
         / </span><span class="se">\
</span><span class="s">        5   4
    
    Result: (5 * 4) + 3 = 23
    </span><span class="sh">"""</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
    
    <span class="c1"># Leaf node: return value
</span>    <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">.</span><span class="n">left</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
        <span class="k">return</span> <span class="nf">float</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
    
    <span class="c1"># Evaluate subtrees (postorder)
</span>    <span class="n">left_val</span> <span class="o">=</span> <span class="nf">evaluate_expression_tree</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
    <span class="n">right_val</span> <span class="o">=</span> <span class="nf">evaluate_expression_tree</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
    
    <span class="c1"># Apply operator
</span>    <span class="k">if</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span> <span class="o">==</span> <span class="sh">'</span><span class="s">+</span><span class="sh">'</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">left_val</span> <span class="o">+</span> <span class="n">right_val</span>
    <span class="k">elif</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span> <span class="o">==</span> <span class="sh">'</span><span class="s">-</span><span class="sh">'</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">left_val</span> <span class="o">-</span> <span class="n">right_val</span>
    <span class="k">elif</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span> <span class="o">==</span> <span class="sh">'</span><span class="s">*</span><span class="sh">'</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">left_val</span> <span class="o">*</span> <span class="n">right_val</span>
    <span class="k">elif</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span> <span class="o">==</span> <span class="sh">'</span><span class="s">/</span><span class="sh">'</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">left_val</span> <span class="o">/</span> <span class="n">right_val</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="nf">float</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>

<span class="c1"># Example: (5 * 4) + 3
</span><span class="n">expr_tree</span> <span class="o">=</span> <span class="nc">ExpressionNode</span><span class="p">(</span>
    <span class="sh">'</span><span class="s">+</span><span class="sh">'</span><span class="p">,</span>
    <span class="n">left</span><span class="o">=</span><span class="nc">ExpressionNode</span><span class="p">(</span>
        <span class="sh">'</span><span class="s">*</span><span class="sh">'</span><span class="p">,</span>
        <span class="n">left</span><span class="o">=</span><span class="nc">ExpressionNode</span><span class="p">(</span><span class="sh">'</span><span class="s">5</span><span class="sh">'</span><span class="p">),</span>
        <span class="n">right</span><span class="o">=</span><span class="nc">ExpressionNode</span><span class="p">(</span><span class="sh">'</span><span class="s">4</span><span class="sh">'</span><span class="p">)</span>
    <span class="p">),</span>
    <span class="n">right</span><span class="o">=</span><span class="nc">ExpressionNode</span><span class="p">(</span><span class="sh">'</span><span class="s">3</span><span class="sh">'</span><span class="p">)</span>
<span class="p">)</span>

<span class="n">result</span> <span class="o">=</span> <span class="nf">evaluate_expression_tree</span><span class="p">(</span><span class="n">expr_tree</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Expression result: </span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>  <span class="c1"># 23.0
</span></code></pre></div></div>

<h3 id="2-serializedeserialize-tree">2. Serialize/Deserialize Tree</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">serialize</span><span class="p">(</span><span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">
    Serialize tree to string (preorder)
    
    Example:
         1
        / </span><span class="se">\
</span><span class="s">       2   3
          / </span><span class="se">\
</span><span class="s">         4   5
    
    Serialized: </span><span class="sh">"</span><span class="s">1,2,None,None,3,4,None,None,5,None,None</span><span class="sh">"</span><span class="s">
    </span><span class="sh">"""</span>
    <span class="k">def</span> <span class="nf">preorder</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="sh">'</span><span class="s">None</span><span class="sh">'</span><span class="p">]</span>
        
        <span class="k">return</span> <span class="p">[</span><span class="nf">str</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">val</span><span class="p">)]</span> <span class="o">+</span> <span class="nf">preorder</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span> <span class="o">+</span> <span class="nf">preorder</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="sh">'</span><span class="s">,</span><span class="sh">'</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="nf">preorder</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">deserialize</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TreeNode</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">
    Deserialize string to tree
    
    Uses preorder reconstruction
    </span><span class="sh">"""</span>
    <span class="k">def</span> <span class="nf">build_tree</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
        <span class="n">val</span> <span class="o">=</span> <span class="nf">next</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">val</span> <span class="o">==</span> <span class="sh">'</span><span class="s">None</span><span class="sh">'</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
        
        <span class="n">node</span> <span class="o">=</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="nf">int</span><span class="p">(</span><span class="n">val</span><span class="p">))</span>
        <span class="n">node</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="nf">build_tree</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="n">node</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="nf">build_tree</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">node</span>
    
    <span class="n">values</span> <span class="o">=</span> <span class="nf">iter</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="sh">'</span><span class="s">,</span><span class="sh">'</span><span class="p">))</span>
    <span class="k">return</span> <span class="nf">build_tree</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

<span class="c1"># Example
</span><span class="n">original</span> <span class="o">=</span> <span class="nf">build_tree</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
<span class="n">serialized</span> <span class="o">=</span> <span class="nf">serialize</span><span class="p">(</span><span class="n">original</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Serialized: </span><span class="si">{</span><span class="n">serialized</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>

<span class="n">deserialized</span> <span class="o">=</span> <span class="nf">deserialize</span><span class="p">(</span><span class="n">serialized</span><span class="p">)</span>
<span class="k">assert</span> <span class="nf">inorderTraversal</span><span class="p">(</span><span class="n">deserialized</span><span class="p">)</span> <span class="o">==</span> <span class="nf">inorderTraversal</span><span class="p">(</span><span class="n">original</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">✓ Serialize/Deserialize works correctly</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="3-find-lowest-common-ancestor">3. Find Lowest Common Ancestor</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">lowestCommonAncestor</span><span class="p">(</span><span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">,</span> <span class="n">q</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TreeNode</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">
    Find lowest common ancestor of two nodes
    
    Uses postorder: need information from subtrees
    
    Time: O(n), Space: O(h)
    </span><span class="sh">"""</span>
    <span class="c1"># Base cases
</span>    <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span> <span class="ow">or</span> <span class="n">root</span> <span class="o">==</span> <span class="n">p</span> <span class="ow">or</span> <span class="n">root</span> <span class="o">==</span> <span class="n">q</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">root</span>
    
    <span class="c1"># Search in subtrees
</span>    <span class="n">left</span> <span class="o">=</span> <span class="nf">lowestCommonAncestor</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
    <span class="n">right</span> <span class="o">=</span> <span class="nf">lowestCommonAncestor</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
    
    <span class="c1"># If p and q are in different subtrees, current node is LCA
</span>    <span class="k">if</span> <span class="n">left</span> <span class="ow">and</span> <span class="n">right</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">root</span>
    
    <span class="c1"># Otherwise, return non-null result
</span>    <span class="k">return</span> <span class="n">left</span> <span class="k">if</span> <span class="n">left</span> <span class="k">else</span> <span class="n">right</span>

<span class="c1"># Example
#       3
#      / \
#     5   1
#    / \
#   6   2
</span><span class="n">tree</span> <span class="o">=</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">tree</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="n">tree</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">tree</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="n">tree</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

<span class="n">lca</span> <span class="o">=</span> <span class="nf">lowestCommonAncestor</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">tree</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">tree</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">LCA of 5 and 2: </span><span class="si">{</span><span class="n">lca</span><span class="p">.</span><span class="n">val</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>  <span class="c1"># 5
</span></code></pre></div></div>

<h3 id="4-tree-diameter">4. Tree Diameter</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">diameter_of_tree</span><span class="p">(</span><span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">
    Find diameter (longest path between any two nodes)
    
    Uses postorder: compute height of subtrees
    
    Time: O(n), Space: O(h)
    </span><span class="sh">"""</span>
    <span class="n">max_diameter</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># Use list to modify in nested function
</span>    
    <span class="k">def</span> <span class="nf">height</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        
        <span class="c1"># Get heights of subtrees
</span>        <span class="n">left_height</span> <span class="o">=</span> <span class="nf">height</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
        <span class="n">right_height</span> <span class="o">=</span> <span class="nf">height</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
        
        <span class="c1"># Update diameter (path through this node)
</span>        <span class="n">diameter_through_node</span> <span class="o">=</span> <span class="n">left_height</span> <span class="o">+</span> <span class="n">right_height</span>
        <span class="n">max_diameter</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="n">max_diameter</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">diameter_through_node</span><span class="p">)</span>
        
        <span class="c1"># Return height of this subtree
</span>        <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="nf">max</span><span class="p">(</span><span class="n">left_height</span><span class="p">,</span> <span class="n">right_height</span><span class="p">)</span>
    
    <span class="nf">height</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">max_diameter</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="c1"># Example
#       1
#      / \
#     2   3
#    / \
#   4   5
</span><span class="n">tree</span> <span class="o">=</span> <span class="nf">build_tree</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
<span class="n">diameter</span> <span class="o">=</span> <span class="nf">diameter_of_tree</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Diameter: </span><span class="si">{</span><span class="n">diameter</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>  <span class="c1"># 3 (path: 4 → 2 → 1 → 3)
</span></code></pre></div></div>

<hr />

<h2 id="production-considerations">Production Considerations</h2>

<h3 id="1-concurrent-tree-traversal">1. Concurrent Tree Traversal</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">threading</span> <span class="kn">import</span> <span class="n">Lock</span>
<span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">deque</span>

<span class="k">class</span> <span class="nc">ThreadSafeTree</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">
    Thread-safe tree operations
    
    Important for production systems with concurrent reads/writes
    </span><span class="sh">"""</span>
    
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">root</span>
        <span class="n">self</span><span class="p">.</span><span class="n">lock</span> <span class="o">=</span> <span class="nc">Lock</span><span class="p">()</span>
    
    <span class="k">def</span> <span class="nf">inorder_snapshot</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">
        Get inorder traversal snapshot atomically
        </span><span class="sh">"""</span>
        <span class="k">with</span> <span class="n">self</span><span class="p">.</span><span class="n">lock</span><span class="p">:</span>
            <span class="k">return</span> <span class="nf">inorderTraversal</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">root</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">Thread-safe insertion</span><span class="sh">"""</span>
        <span class="k">with</span> <span class="n">self</span><span class="p">.</span><span class="n">lock</span><span class="p">:</span>
            <span class="n">self</span><span class="p">.</span><span class="nf">_insert_helper</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">root</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">_insert_helper</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">Insert into BST</span><span class="sh">"""</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="p">:</span>
            <span class="k">return</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">val</span> <span class="o">&lt;</span> <span class="n">node</span><span class="p">.</span><span class="n">val</span><span class="p">:</span>
            <span class="n">node</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">_insert_helper</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">node</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">_insert_helper</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">node</span>
</code></pre></div></div>

<h3 id="2-lazy-evaluation-for-large-trees">2. Lazy Evaluation for Large Trees</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">lazy_inorder_generator</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">
    Generator for lazy inorder traversal
    
    Yields nodes one at a time (memory efficient)
    </span><span class="sh">"""</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
        <span class="k">return</span>
    
    <span class="c1"># Use generator for left subtree
</span>    <span class="k">yield</span> <span class="k">from</span> <span class="nf">lazy_inorder_generator</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
    
    <span class="c1"># Yield current
</span>    <span class="k">yield</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span>
    
    <span class="c1"># Use generator for right subtree
</span>    <span class="k">yield</span> <span class="k">from</span> <span class="nf">lazy_inorder_generator</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>

<span class="c1"># Usage: process large tree without loading all values
</span><span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="nf">lazy_inorder_generator</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">:</span>  <span class="c1"># Can stop early
</span>        <span class="k">break</span>
    <span class="nf">process</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="3-monitoring--logging">3. Monitoring &amp; Logging</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">InstrumentedTraversal</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">
    Traversal with monitoring
    
    Track performance metrics for production debugging
    </span><span class="sh">"""</span>
    
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">nodes_visited</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">self</span><span class="p">.</span><span class="n">max_depth_reached</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">self</span><span class="p">.</span><span class="n">start_time</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">self</span><span class="p">.</span><span class="n">end_time</span> <span class="o">=</span> <span class="bp">None</span>
    
    <span class="k">def</span> <span class="nf">inorder_with_metrics</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">current_depth</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">Inorder with metrics collection</span><span class="sh">"""</span>
        <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">start_time</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">self</span><span class="p">.</span><span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        
        <span class="n">self</span><span class="p">.</span><span class="n">nodes_visited</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">self</span><span class="p">.</span><span class="n">max_depth_reached</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">max_depth_reached</span><span class="p">,</span> <span class="n">current_depth</span><span class="p">)</span>
        
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">result</span><span class="p">.</span><span class="nf">extend</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="nf">inorder_with_metrics</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">current_depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">result</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
        <span class="n">result</span><span class="p">.</span><span class="nf">extend</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="nf">inorder_with_metrics</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">,</span> <span class="n">current_depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        
        <span class="k">if</span> <span class="n">current_depth</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># Back at root
</span>            <span class="n">self</span><span class="p">.</span><span class="n">end_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span>
        
        <span class="k">return</span> <span class="n">result</span>
    
    <span class="k">def</span> <span class="nf">get_metrics</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">Get traversal metrics</span><span class="sh">"""</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="sh">'</span><span class="s">nodes_visited</span><span class="sh">'</span><span class="p">:</span> <span class="n">self</span><span class="p">.</span><span class="n">nodes_visited</span><span class="p">,</span>
            <span class="sh">'</span><span class="s">max_depth</span><span class="sh">'</span><span class="p">:</span> <span class="n">self</span><span class="p">.</span><span class="n">max_depth_reached</span><span class="p">,</span>
            <span class="sh">'</span><span class="s">time_ms</span><span class="sh">'</span><span class="p">:</span> <span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">end_time</span> <span class="o">-</span> <span class="n">self</span><span class="p">.</span><span class="n">start_time</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1000</span> <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">end_time</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="p">}</span>

<span class="c1"># Usage
</span><span class="n">instrumented</span> <span class="o">=</span> <span class="nc">InstrumentedTraversal</span><span class="p">()</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">instrumented</span><span class="p">.</span><span class="nf">inorder_with_metrics</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
<span class="n">metrics</span> <span class="o">=</span> <span class="n">instrumented</span><span class="p">.</span><span class="nf">get_metrics</span><span class="p">()</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Metrics: </span><span class="si">{</span><span class="n">metrics</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<hr />

<h2 id="interview-strategy">Interview Strategy</h2>

<h3 id="step-by-step-approach">Step-by-Step Approach</h3>

<p><strong>1. Clarify (1-2 min):</strong></p>
<ul>
  <li>What traversal order is needed?</li>
  <li>Return list or perform action at each node?</li>
  <li>Any constraints on space?</li>
  <li>Can the tree be modified?</li>
</ul>

<p><strong>2. State Approach (1 min):</strong></p>
<ul>
  <li>“I’ll use [inorder/preorder/postorder/level-order] because…”</li>
  <li>“For this problem, I’ll go with [recursive/iterative] approach”</li>
</ul>

<p><strong>3. Code (5-8 min):</strong></p>
<ul>
  <li>Start with base case</li>
  <li>Implement traversal logic</li>
  <li>Test with example</li>
</ul>

<p><strong>4. Test (2-3 min):</strong></p>
<ul>
  <li>Empty tree</li>
  <li>Single node</li>
  <li>Balanced tree</li>
  <li>Skewed tree</li>
</ul>

<p><strong>5. Optimize (2 min):</strong></p>
<ul>
  <li>Discuss Morris if O(1) space needed</li>
  <li>Discuss iterative if recursion limit is concern</li>
</ul>

<h3 id="common-follow-up-questions">Common Follow-Up Questions</h3>

<p><strong>Q: Can you do this without recursion?</strong></p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Show iterative approach with stack
</span></code></pre></div></div>

<p><strong>Q: Can you do this in O(1) space?</strong></p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Show Morris traversal
</span></code></pre></div></div>

<p><strong>Q: What if the tree is very large (doesn’t fit in memory)?</strong></p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Discuss lazy evaluation, generators, streaming
</span></code></pre></div></div>

<p><strong>Q: How would you parallelize this?</strong></p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Discuss level-order parallelization:
# Process each level in parallel
</span><span class="k">def</span> <span class="nf">parallel_level_order</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>
    
    <span class="kn">from</span> <span class="n">concurrent.futures</span> <span class="kn">import</span> <span class="n">ThreadPoolExecutor</span>
    
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">current_level</span> <span class="o">=</span> <span class="p">[</span><span class="n">root</span><span class="p">]</span>
    
    <span class="k">while</span> <span class="n">current_level</span><span class="p">:</span>
        <span class="c1"># Process level in parallel
</span>        <span class="k">with</span> <span class="nc">ThreadPoolExecutor</span><span class="p">()</span> <span class="k">as</span> <span class="n">executor</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="n">executor</span><span class="p">.</span><span class="nf">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span><span class="p">.</span><span class="n">val</span><span class="p">,</span> <span class="n">current_level</span><span class="p">))</span>
        <span class="n">result</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        
        <span class="c1"># Get next level
</span>        <span class="n">next_level</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">current_level</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">:</span>
                <span class="n">next_level</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
                <span class="n">next_level</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
        
        <span class="n">current_level</span> <span class="o">=</span> <span class="n">next_level</span>
    
    <span class="k">return</span> <span class="n">result</span>
</code></pre></div></div>

<hr />

<h2 id="key-takeaways">Key Takeaways</h2>

<p>✅ <strong>Three DFS orders</strong> - Inorder (sorted for BST), Preorder (copy), Postorder (delete)<br />
✅ <strong>BFS for levels</strong> - Use queue for level-order traversal<br />
✅ <strong>Recursion naturally fits trees</strong> - Base case is null node<br />
✅ <strong>Stack for iterative DFS</strong> - Simulate recursion call stack<br />
✅ <strong>Morris for O(1) space</strong> - Use threaded links, restore tree after<br />
✅ <strong>Choose traversal by use case</strong> - Different problems need different orders<br />
✅ <strong>ML applications</strong> - Decision trees, feature DAGs, ensemble hierarchies</p>

<hr />

<h2 id="related-problems">Related Problems</h2>

<p>Master these to solidify tree traversal:</p>
<ul>
  <li><strong><a href="https://leetcode.com/problems/binary-tree-level-order-traversal/">Binary Tree Level Order Traversal</a></strong> - BFS basics</li>
  <li><strong><a href="https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/">Binary Tree Zigzag Level Order</a></strong> - BFS variation</li>
  <li><strong><a href="https://leetcode.com/problems/validate-binary-search-tree/">Validate Binary Search Tree</a></strong> - Inorder application</li>
  <li><strong><a href="https://leetcode.com/problems/serialize-and-deserialize-binary-tree/">Serialize and Deserialize Binary Tree</a></strong> - Preorder application</li>
  <li><strong><a href="https://leetcode.com/problems/binary-tree-maximum-path-sum/">Binary Tree Maximum Path Sum</a></strong> - Postorder application</li>
  <li><strong><a href="https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/">Vertical Order Traversal</a></strong> - Custom traversal</li>
</ul>

<hr />

<p><strong>Originally published at:</strong> <a href="https://www.arunbaby.com/dsa/0007-binary-tree-traversal/">arunbaby.com/dsa/0007-binary-tree-traversal</a></p>

<p><em>If you found this helpful, consider sharing it with others who might benefit.</em></p>


        
      </section>

      <footer class="page__meta">
        
        
  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-tags" aria-hidden="true"></i> Tags: </strong>
    <span itemprop="keywords">
    
      <a href="/tags/#bfs" class="page__taxonomy-item p-category" rel="tag">bfs</a><span class="sep">, </span>
    
      <a href="/tags/#dfs" class="page__taxonomy-item p-category" rel="tag">dfs</a><span class="sep">, </span>
    
      <a href="/tags/#recursion" class="page__taxonomy-item p-category" rel="tag">recursion</a><span class="sep">, </span>
    
      <a href="/tags/#traversal" class="page__taxonomy-item p-category" rel="tag">traversal</a><span class="sep">, </span>
    
      <a href="/tags/#trees" class="page__taxonomy-item p-category" rel="tag">trees</a>
    
    </span>
  </p>




  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> Categories: </strong>
    <span itemprop="keywords">
    
      <a href="/categories/#dsa" class="page__taxonomy-item p-category" rel="tag">dsa</a>
    
    </span>
  </p>


        
      </footer>

      <div class="page__related page__related--full">
  <h2 class="page__related-title">Related across topics</h2>
  <style>
    /* Make section span full content width and use 2 equal columns */
    .page__related--full { float: inline-start; width: 100%; padding: 0; }
    .cross-related-grid { display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 2rem; }
    @media (max-width: 768px) { .cross-related-grid { grid-template-columns: 1fr; } }
    /* Ensure archive cards stretch nicely in the grid */
    .cross-related-grid .list__item, .cross-related-grid .grid__item { width: auto; float: none; margin: 0; }
  </style>
  <div class="cross-related-grid">
    



<div class="list__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/ml-system-design/0007-feature-engineering/" rel="permalink">Feature Engineering at Scale
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          19 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">Feature engineering makes or breaks ML models, learn how to build scalable, production-ready feature pipelines that power real-world systems.
</p>
  </article>
</div>




<div class="list__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/speech-tech/0007-audio-preprocessing/" rel="permalink">Audio Preprocessing &amp; Signal Processing
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          15 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">Clean audio is the foundation of robust speech systems, master preprocessing pipelines that handle real-world noise and variability.
</p>
  </article>
</div>

  </div>
</div>

      <section class="page__share">
  <h4 class="page__share-title">Share on</h4>

  <a href="https://twitter.com/intent/tweet?via=arunbaby0&text=Binary+Tree+Traversal%20https%3A%2F%2Fwww.arunbaby.com%2Fdsa%2F0007-binary-tree-traversal%2F" class="btn btn--twitter" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Twitter"><i class="fab fa-fw fa-twitter" aria-hidden="true"></i><span> Twitter</span></a>

  <a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fwww.arunbaby.com%2Fdsa%2F0007-binary-tree-traversal%2F" class="btn btn--facebook" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Facebook"><i class="fab fa-fw fa-facebook" aria-hidden="true"></i><span> Facebook</span></a>

  <a href="https://www.linkedin.com/shareArticle?mini=true&url=https://www.arunbaby.com/dsa/0007-binary-tree-traversal/" class="btn btn--linkedin" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on LinkedIn"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i><span> LinkedIn</span></a>
</section>


      
  <nav class="pagination">
    
      <a href="/dsa/0006-climbing-stairs/" class="pagination--pager" title="Climbing Stairs">Previous</a>
    
    
      <a href="#" class="pagination--pager disabled">Next</a>
    
  </nav>


    </div>

    
  </article>

  
  
</div>

      
    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';" role="search">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Enter your search term..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    

    
      
        
          <li><a href="https://twitter.com/arunbaby0" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-twitter-square" aria-hidden="true"></i> Twitter</a></li>
        
      
        
          <li><a href="https://github.com/arunbaby0" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
        
      
        
          <li><a href="https://www.linkedin.com/in/arunbaby0/" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i> LinkedIn</a></li>
        
      
        
          <li><a href="https://scholar.google.co.in/citations?user=6fSYWhkAAAAJ" rel="nofollow noopener noreferrer"><i class="fas fa-fw fa-graduation-cap" aria-hidden="true"></i> Google Scholar</a></li>
        
      
    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 1990 - 2143 <a href="https://www.arunbaby.com">Arun Baby</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>




  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-0JRJPEC9SS"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-0JRJPEC9SS', { 'anonymize_ip': false});
</script>








  </body>
</html>
