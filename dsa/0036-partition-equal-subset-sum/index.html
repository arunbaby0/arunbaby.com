<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.26.2 by Michael Rose
  Copyright 2013-2024 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->

<html lang="en-US" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Partition Equal Subset Sum - Arun Baby</title>
<meta name="description" content="“Can you split the treasure evenly?”">


  <meta name="author" content="Arun Baby">
  
  <meta property="article:author" content="Arun Baby">
  


<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="Arun Baby">
<meta property="og:title" content="Partition Equal Subset Sum">
<meta property="og:url" content="https://www.arunbaby.com/dsa/0036-partition-equal-subset-sum/">


  <meta property="og:description" content="“Can you split the treasure evenly?”">



  <meta property="og:image" content="https://www.arunbaby.com/assets/images/profile-photo.png">



  <meta name="twitter:site" content="@arunbaby0">
  <meta name="twitter:title" content="Partition Equal Subset Sum">
  <meta name="twitter:description" content="“Can you split the treasure evenly?”">
  <meta name="twitter:url" content="https://www.arunbaby.com/dsa/0036-partition-equal-subset-sum/">

  
    <meta name="twitter:card" content="summary">
    
      <meta name="twitter:image" content="https://www.arunbaby.com/assets/images/profile-photo.png">
    
  

  



  <meta property="article:published_time" content="2025-12-02T22:27:09+05:30">





  

  


<link rel="canonical" href="https://www.arunbaby.com/dsa/0036-partition-equal-subset-sum/">












<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Arun Baby Feed">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
  
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css"></noscript>



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--single" dir="ltr">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
           
          <span class="site-subtitle">Arun Baby</span>
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a
                href="/about/"
                
                
              >About</a>
            </li><li class="masthead__menu-item">
              <a
                href="/dsa/"
                
                
              >DSA</a>
            </li><li class="masthead__menu-item">
              <a
                href="/ml-system-design/"
                
                
              >ML Systems</a>
            </li><li class="masthead__menu-item">
              <a
                href="/speech-tech/"
                
                
              >Speech Tech</a>
            </li><li class="masthead__menu-item">
              <a
                href="/publications/"
                
                
              >Publications</a>
            </li><li class="masthead__menu-item">
              <a
                href="/statuses/"
                
                
              >Statuses</a>
            </li><li class="masthead__menu-item">
              <a
                href="/contact/"
                
                
              >Contact</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <i class="fas fa-search"></i>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      





<div id="main" role="main" class="no-author-sidebar">
  
  <div class="sidebar sticky">
  
  
  </div>



  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="Partition Equal Subset Sum">
    <meta itemprop="description" content="“Can you split the treasure evenly?”">
    <meta itemprop="datePublished" content="2025-12-02T22:27:09+05:30">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">
            <a href="https://www.arunbaby.com/dsa/0036-partition-equal-subset-sum/" itemprop="url">Partition Equal Subset Sum
</a>
          </h1>
          

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          11 minute read
        
      </span>
    
  </p>


        </header>
      

      <section class="page__content" itemprop="text">
        
          <aside class="sidebar__right sticky">
            <nav class="toc">
              <header><h4 class="nav__title"><i class="fas fa-file-alt"></i> On this page</h4></header>
              <ul class="toc__menu"><li><a href="#1-problem-statement">1. Problem Statement</a></li><li><a href="#2-intuition-the-01-knapsack-connection">2. Intuition: The 0/1 Knapsack Connection</a></li><li><a href="#3-approach-1-recursion-with-memoization-top-down-dp">3. Approach 1: Recursion with Memoization (Top-Down DP)</a></li><li><a href="#4-approach-2-tabulation-bottom-up-dp">4. Approach 2: Tabulation (Bottom-Up DP)</a></li><li><a href="#5-approach-3-space-optimization-1d-array">5. Approach 3: Space Optimization (1D Array)</a></li><li><a href="#6-approach-4-bitset-optimization-the-magic-solution">6. Approach 4: Bitset Optimization (The “Magic” Solution)</a></li><li><a href="#7-deep-dive-np-completeness">7. Deep Dive: NP-Completeness</a></li><li><a href="#8-summary">8. Summary</a></li><li><a href="#9-deep-dive-knapsack-variations">9. Deep Dive: Knapsack Variations</a></li><li><a href="#10-deep-dive-the-magic-of-bitset-optimization">10. Deep Dive: The Magic of Bitset Optimization</a></li><li><a href="#11-deep-dive-meet-in-the-middle">11. Deep Dive: Meet-in-the-Middle</a></li><li><a href="#12-deep-dive-dfs-pruning-techniques">12. Deep Dive: DFS Pruning Techniques</a></li><li><a href="#13-real-world-application-load-balancing">13. Real-World Application: Load Balancing</a></li><li><a href="#14-code-reconstructing-the-solution">14. Code: Reconstructing the Solution</a></li><li><a href="#15-performance-benchmarking">15. Performance Benchmarking</a></li><li><a href="#16-interview-pro-tips">16. Interview Pro Tips</a></li><li><a href="#17-summary">17. Summary</a></li></ul>
            </nav>
          </aside>
        
        <p><strong>“Can you split the treasure evenly?”</strong></p>

<h2 id="1-problem-statement">1. Problem Statement</h2>

<p>Given a non-empty array <code class="language-plaintext highlighter-rouge">nums</code> containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.</p>

<p><strong>Example 1:</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1, 5, 11, 5]
Output: true
Explanation: The array can be partitioned as [1, 5, 5] and [11]. Both sum to 11.
</code></pre></div></div>

<p><strong>Example 2:</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums = [1, 2, 3, 5]
Output: false
Explanation: The array cannot be partitioned into equal sum subsets.
</code></pre></div></div>

<h2 id="2-intuition-the-01-knapsack-connection">2. Intuition: The 0/1 Knapsack Connection</h2>

<ol>
  <li><strong>Total Sum Check:</strong> If the sum of all elements <code class="language-plaintext highlighter-rouge">S</code> is odd, we can’t split it into two equal integers. Return <code class="language-plaintext highlighter-rouge">False</code>.</li>
  <li><strong>Target Sum:</strong> If <code class="language-plaintext highlighter-rouge">S</code> is even, we need to find a subset with sum <code class="language-plaintext highlighter-rouge">target = S / 2</code>. If we find one subset with sum <code class="language-plaintext highlighter-rouge">S/2</code>, the remaining elements must also sum to <code class="language-plaintext highlighter-rouge">S/2</code>.</li>
  <li><strong>Transformation:</strong> This is exactly the <strong>Subset Sum Problem</strong>, which is a variation of the <strong>0/1 Knapsack Problem</strong>.
    <ul>
      <li><strong>Items:</strong> The numbers in <code class="language-plaintext highlighter-rouge">nums</code>.</li>
      <li><strong>Weight:</strong> The value of the number.</li>
      <li><strong>Value:</strong> Irrelevant (we just care if we can fill the knapsack).</li>
      <li><strong>Capacity:</strong> <code class="language-plaintext highlighter-rouge">target</code>.</li>
    </ul>
  </li>
</ol>

<h2 id="3-approach-1-recursion-with-memoization-top-down-dp">3. Approach 1: Recursion with Memoization (Top-Down DP)</h2>

<p>We define a function <code class="language-plaintext highlighter-rouge">canPartition(index, current_sum)</code>.</p>
<ul>
  <li><strong>Base Cases:</strong>
    <ul>
      <li>If <code class="language-plaintext highlighter-rouge">current_sum == target</code>: Return <code class="language-plaintext highlighter-rouge">True</code>.</li>
      <li>If <code class="language-plaintext highlighter-rouge">current_sum &gt; target</code> or <code class="language-plaintext highlighter-rouge">index &gt;= len(nums)</code>: Return <code class="language-plaintext highlighter-rouge">False</code>.</li>
    </ul>
  </li>
  <li><strong>Choices:</strong>
    <ol>
      <li><strong>Include</strong> <code class="language-plaintext highlighter-rouge">nums[index]</code>: <code class="language-plaintext highlighter-rouge">canPartition(index + 1, current_sum + nums[index])</code></li>
      <li><strong>Exclude</strong> <code class="language-plaintext highlighter-rouge">nums[index]</code>: <code class="language-plaintext highlighter-rouge">canPartition(index + 1, current_sum)</code></li>
    </ol>
  </li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">canPartition</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">total_sum</span> <span class="o">=</span> <span class="nf">sum</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">total_sum</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
        
        <span class="n">target</span> <span class="o">=</span> <span class="n">total_sum</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="n">memo</span> <span class="o">=</span> <span class="p">{}</span>
        
        <span class="k">def</span> <span class="nf">backtrack</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">current_sum</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">current_sum</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">True</span>
            <span class="k">if</span> <span class="n">current_sum</span> <span class="o">&gt;</span> <span class="n">target</span> <span class="ow">or</span> <span class="n">index</span> <span class="o">&gt;=</span> <span class="nf">len</span><span class="p">(</span><span class="n">nums</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">False</span>
            
            <span class="n">state</span> <span class="o">=</span> <span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">current_sum</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">memo</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">memo</span><span class="p">[</span><span class="n">state</span><span class="p">]</span>
            
            <span class="c1"># Choice 1: Include
</span>            <span class="k">if</span> <span class="nf">backtrack</span><span class="p">(</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">current_sum</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">index</span><span class="p">]):</span>
                <span class="n">memo</span><span class="p">[</span><span class="n">state</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">return</span> <span class="bp">True</span>
            
            <span class="c1"># Choice 2: Exclude
</span>            <span class="k">if</span> <span class="nf">backtrack</span><span class="p">(</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">current_sum</span><span class="p">):</span>
                <span class="n">memo</span><span class="p">[</span><span class="n">state</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">return</span> <span class="bp">True</span>
            
            <span class="n">memo</span><span class="p">[</span><span class="n">state</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">return</span> <span class="bp">False</span>
            
        <span class="k">return</span> <span class="nf">backtrack</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</code></pre></div></div>

<p><strong>Complexity:</strong></p>
<ul>
  <li><strong>Time:</strong> $O(N \times Target)$. There are $N \times Target$ states.</li>
  <li><strong>Space:</strong> $O(N \times Target)$ for memoization table + recursion stack.</li>
</ul>

<h2 id="4-approach-2-tabulation-bottom-up-dp">4. Approach 2: Tabulation (Bottom-Up DP)</h2>

<p>Let <code class="language-plaintext highlighter-rouge">dp[i][j]</code> be <code class="language-plaintext highlighter-rouge">True</code> if a sum of <code class="language-plaintext highlighter-rouge">j</code> can be achieved using the first <code class="language-plaintext highlighter-rouge">i</code> items.</p>

<ul>
  <li><strong>Initialization:</strong> <code class="language-plaintext highlighter-rouge">dp[0][0] = True</code> (Sum 0 with 0 items is possible).</li>
  <li><strong>Transition:</strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">dp[i][j] = dp[i-1][j]</code> (Exclude current item)</li>
      <li><code class="language-plaintext highlighter-rouge">OR dp[i-1][j - nums[i-1]]</code> (Include current item, if <code class="language-plaintext highlighter-rouge">j &gt;= nums[i-1]</code>)</li>
    </ul>
  </li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">canPartition</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">total_sum</span> <span class="o">=</span> <span class="nf">sum</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">total_sum</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
        
        <span class="n">target</span> <span class="o">=</span> <span class="n">total_sum</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
        
        <span class="c1"># dp[i][j] means using first i items, can we get sum j?
</span>        <span class="n">dp</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">False</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">target</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>  <span class="c1"># Sum 0 is always possible
</span>            
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">curr_num</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">target</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="c1"># Exclude
</span>                <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
                <span class="c1"># Include
</span>                <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">curr_num</span><span class="p">:</span>
                    <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="ow">or</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="n">curr_num</span><span class="p">]</span>
                    
        <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">target</span><span class="p">]</span>
</code></pre></div></div>

<h2 id="5-approach-3-space-optimization-1d-array">5. Approach 3: Space Optimization (1D Array)</h2>

<p>Notice <code class="language-plaintext highlighter-rouge">dp[i][j]</code> only depends on <code class="language-plaintext highlighter-rouge">dp[i-1][...]</code>. We can reduce space to $O(Target)$.
<strong>Crucial:</strong> We must iterate backwards to avoid using the same item twice in the same step.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">canPartition</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">total_sum</span> <span class="o">=</span> <span class="nf">sum</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">total_sum</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="bp">False</span>
        <span class="n">target</span> <span class="o">=</span> <span class="n">total_sum</span> <span class="o">//</span> <span class="mi">2</span>
        
        <span class="n">dp</span> <span class="o">=</span> <span class="p">[</span><span class="bp">False</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">target</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
        
        <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">:</span>
            <span class="c1"># Iterate backwards from target to num
</span>            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">num</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="ow">or</span> <span class="n">dp</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="n">num</span><span class="p">]</span>
                
        <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="n">target</span><span class="p">]</span>
</code></pre></div></div>

<p><strong>Complexity:</strong></p>
<ul>
  <li><strong>Time:</strong> $O(N \times Target)$.</li>
  <li><strong>Space:</strong> $O(Target)$.</li>
</ul>

<h2 id="6-approach-4-bitset-optimization-the-magic-solution">6. Approach 4: Bitset Optimization (The “Magic” Solution)</h2>

<p>For languages like C++ or Java (BitSet), or Python (large integers), we can use bit manipulation.</p>
<ul>
  <li>Represent the set of reachable sums as a bitmask.</li>
  <li>If the $k$-th bit is 1, it means sum $k$ is possible.</li>
  <li>Transition: <code class="language-plaintext highlighter-rouge">bits = bits | (bits &lt;&lt; num)</code>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">bits</code>: existing sums.</li>
      <li><code class="language-plaintext highlighter-rouge">bits &lt;&lt; num</code>: existing sums + <code class="language-plaintext highlighter-rouge">num</code>.</li>
      <li><code class="language-plaintext highlighter-rouge">|</code>: Union of both sets.</li>
    </ul>
  </li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">canPartition</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">total_sum</span> <span class="o">=</span> <span class="nf">sum</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">total_sum</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="bp">False</span>
        <span class="n">target</span> <span class="o">=</span> <span class="n">total_sum</span> <span class="o">//</span> <span class="mi">2</span>
        
        <span class="c1"># Bitmask: 1 at index 0 means sum 0 is possible
</span>        <span class="n">bits</span> <span class="o">=</span> <span class="mi">1</span> 
        
        <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">:</span>
            <span class="n">bits</span> <span class="o">|=</span> <span class="n">bits</span> <span class="o">&lt;&lt;</span> <span class="n">num</span>
            
        <span class="c1"># Check if the target-th bit is 1
</span>        <span class="nf">return </span><span class="p">(</span><span class="n">bits</span> <span class="o">&gt;&gt;</span> <span class="n">target</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">1</span>
</code></pre></div></div>

<p><strong>Why is this fast?</strong></p>
<ul>
  <li>Bitwise operations process 64 bits (sums) in parallel on a 64-bit CPU.</li>
  <li><strong>Time:</strong> $O(N \times Target / 64)$.</li>
  <li><strong>Space:</strong> $O(Target / 64)$.</li>
</ul>

<h2 id="7-deep-dive-np-completeness">7. Deep Dive: NP-Completeness</h2>

<p>The Partition Problem is a special case of the Subset Sum Problem, which is <strong>NP-Complete</strong>.</p>
<ul>
  <li>This means there is no known polynomial-time algorithm ($O(N^k)$) that solves it for <em>all</em> inputs.</li>
  <li>Our DP solution is <strong>Pseudo-Polynomial</strong>. Its complexity depends on the <em>value</em> of the input (<code class="language-plaintext highlighter-rouge">Target</code>), not just the number of elements (<code class="language-plaintext highlighter-rouge">N</code>).</li>
  <li>If <code class="language-plaintext highlighter-rouge">Target</code> is huge (e.g., $10^{18}$), DP fails.</li>
</ul>

<h2 id="8-summary">8. Summary</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: left">Approach</th>
      <th style="text-align: left">Time</th>
      <th style="text-align: left">Space</th>
      <th style="text-align: left">Notes</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left"><strong>Recursion</strong></td>
      <td style="text-align: left">$O(2^N)$</td>
      <td style="text-align: left">$O(N)$</td>
      <td style="text-align: left">TLE</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>Memoization</strong></td>
      <td style="text-align: left">$O(N \cdot S)$</td>
      <td style="text-align: left">$O(N \cdot S)$</td>
      <td style="text-align: left">Good</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>Tabulation</strong></td>
      <td style="text-align: left">$O(N \cdot S)$</td>
      <td style="text-align: left">$O(N \cdot S)$</td>
      <td style="text-align: left">Avoids recursion limit</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>Space Opt</strong></td>
      <td style="text-align: left">$O(N \cdot S)$</td>
      <td style="text-align: left">$O(S)$</td>
      <td style="text-align: left">Standard Interview Solution</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>Bitset</strong></td>
      <td style="text-align: left">$O(N \cdot S / 64)$</td>
      <td style="text-align: left">$O(S / 64)$</td>
      <td style="text-align: left">Fastest</td>
    </tr>
  </tbody>
</table>

<h2 id="9-deep-dive-knapsack-variations">9. Deep Dive: Knapsack Variations</h2>

<p>The <strong>0/1 Knapsack Problem</strong> is the parent of many interview questions. Understanding the family tree helps identify them.</p>

<p><strong>1. Subset Sum Problem:</strong></p>
<ul>
  <li><strong>Goal:</strong> Is there a subset with sum <code class="language-plaintext highlighter-rouge">T</code>?</li>
  <li><strong>Relation:</strong> Partition Equal Subset Sum is Subset Sum with <code class="language-plaintext highlighter-rouge">T = TotalSum / 2</code>.</li>
  <li><strong>Code:</strong> Exactly the same DP.</li>
</ul>

<p><strong>2. Partition to K Equal Sum Subsets:</strong></p>
<ul>
  <li><strong>Goal:</strong> Can we split array into <code class="language-plaintext highlighter-rouge">K</code> subsets with equal sum?</li>
  <li><strong>Relation:</strong> Generalization of Partition Equal Subset Sum (<code class="language-plaintext highlighter-rouge">K=2</code>).</li>
  <li><strong>Approach:</strong> Backtracking with pruning is usually better than DP because state space <code class="language-plaintext highlighter-rouge">(mask, current_sum)</code> is huge.</li>
</ul>

<p><strong>3. Target Sum (LeetCode 494):</strong></p>
<ul>
  <li><strong>Goal:</strong> Assign <code class="language-plaintext highlighter-rouge">+</code> or <code class="language-plaintext highlighter-rouge">-</code> to each number to get <code class="language-plaintext highlighter-rouge">Target</code>.</li>
  <li><strong>Relation:</strong> Let <code class="language-plaintext highlighter-rouge">P</code> be positive subset, <code class="language-plaintext highlighter-rouge">N</code> be negative subset.
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Sum(P) - Sum(N) = Target</code></li>
      <li><code class="language-plaintext highlighter-rouge">Sum(P) + Sum(N) = TotalSum</code></li>
      <li><code class="language-plaintext highlighter-rouge">2 * Sum(P) = Target + TotalSum</code></li>
      <li><code class="language-plaintext highlighter-rouge">Sum(P) = (Target + TotalSum) / 2</code></li>
    </ul>
  </li>
  <li><strong>Reduction:</strong> Find subset with sum <code class="language-plaintext highlighter-rouge">(Target + TotalSum) / 2</code>. This is exactly Subset Sum!</li>
</ul>

<h2 id="10-deep-dive-the-magic-of-bitset-optimization">10. Deep Dive: The Magic of Bitset Optimization</h2>

<p>Let’s break down <code class="language-plaintext highlighter-rouge">bits |= bits &lt;&lt; num</code>.</p>

<p>Imagine <code class="language-plaintext highlighter-rouge">nums = [2, 3]</code>, <code class="language-plaintext highlighter-rouge">target = 5</code>.</p>

<p><strong>Step 0:</strong> <code class="language-plaintext highlighter-rouge">bits = 1</code> (Binary: <code class="language-plaintext highlighter-rouge">...00001</code>)</p>
<ul>
  <li>Represents <code class="language-plaintext highlighter-rouge">{0}</code> is possible.</li>
</ul>

<p><strong>Step 1:</strong> Process <code class="language-plaintext highlighter-rouge">num = 2</code>.</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">bits &lt;&lt; 2</code>: <code class="language-plaintext highlighter-rouge">...00100</code> (Represents <code class="language-plaintext highlighter-rouge">{0+2}</code> = <code class="language-plaintext highlighter-rouge">{2}</code>)</li>
  <li><code class="language-plaintext highlighter-rouge">bits |= ...</code>: <code class="language-plaintext highlighter-rouge">...00101</code> (Represents <code class="language-plaintext highlighter-rouge">{0, 2}</code>)</li>
</ul>

<p><strong>Step 2:</strong> Process <code class="language-plaintext highlighter-rouge">num = 3</code>.</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">bits</code>: <code class="language-plaintext highlighter-rouge">...00101</code> (<code class="language-plaintext highlighter-rouge">{0, 2}</code>)</li>
  <li><code class="language-plaintext highlighter-rouge">bits &lt;&lt; 3</code>: <code class="language-plaintext highlighter-rouge">...00101000</code> -&gt; <code class="language-plaintext highlighter-rouge">...101000</code> (Wait, <code class="language-plaintext highlighter-rouge">101</code> shifted left by 3 is <code class="language-plaintext highlighter-rouge">101000</code>)
    <ul>
      <li>Old bit 0 (value 0) -&gt; New bit 3 (value 3).</li>
      <li>Old bit 2 (value 2) -&gt; New bit 5 (value 5).</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">bits |= ...</code>: <code class="language-plaintext highlighter-rouge">...101101</code>
    <ul>
      <li>Indices set: 0, 2, 3, 5.</li>
      <li>Possible sums: <code class="language-plaintext highlighter-rouge">{0, 2, 3, 5}</code>.</li>
    </ul>
  </li>
</ul>

<p><strong>Result:</strong> Check bit 5. It is 1. Return True.</p>

<p><strong>C++ Implementation:</strong></p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;bitset&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;numeric&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">bool</span> <span class="n">canPartition</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">accumulate</span><span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">nums</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">0</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">sum</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">target</span> <span class="o">=</span> <span class="n">sum</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
        
        <span class="n">std</span><span class="o">::</span><span class="n">bitset</span><span class="o">&lt;</span><span class="mi">10001</span><span class="o">&gt;</span> <span class="n">bits</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// Max sum is 200 * 100 = 20000, target 10000</span>
        
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">bits</span> <span class="o">|=</span> <span class="p">(</span><span class="n">bits</span> <span class="o">&lt;&lt;</span> <span class="n">num</span><span class="p">);</span>
        <span class="p">}</span>
        
        <span class="k">return</span> <span class="n">bits</span><span class="p">[</span><span class="n">target</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<h2 id="11-deep-dive-meet-in-the-middle">11. Deep Dive: Meet-in-the-Middle</h2>

<p>What if <code class="language-plaintext highlighter-rouge">Target</code> is huge (e.g., $10^{15}$), but <code class="language-plaintext highlighter-rouge">N</code> is small (e.g., 40)?
DP fails ($O(N \cdot S)$). Recursion fails ($2^{40}$).</p>

<p><strong>Algorithm:</strong></p>
<ol>
  <li>Split <code class="language-plaintext highlighter-rouge">nums</code> into two halves: <code class="language-plaintext highlighter-rouge">Left</code> (20 items) and <code class="language-plaintext highlighter-rouge">Right</code> (20 items).</li>
  <li>Generate all possible subset sums for <code class="language-plaintext highlighter-rouge">Left</code>. Store in a Set <code class="language-plaintext highlighter-rouge">S_Left</code>. ($2^{20} \approx 10^6$).</li>
  <li>Generate all possible subset sums for <code class="language-plaintext highlighter-rouge">Right</code>. Store in a Set <code class="language-plaintext highlighter-rouge">S_Right</code>.</li>
  <li>Iterate through <code class="language-plaintext highlighter-rouge">x</code> in <code class="language-plaintext highlighter-rouge">S_Left</code>. Check if <code class="language-plaintext highlighter-rouge">Target - x</code> exists in <code class="language-plaintext highlighter-rouge">S_Right</code>.</li>
</ol>

<p><strong>Complexity:</strong></p>
<ul>
  <li><strong>Time:</strong> $O(2^{N/2})$.</li>
  <li><strong>Space:</strong> $O(2^{N/2})$.</li>
  <li>Much better than $2^N$.</li>
</ul>

<h2 id="12-deep-dive-dfs-pruning-techniques">12. Deep Dive: DFS Pruning Techniques</h2>

<p>If we must use DFS (e.g., for K-partition), pruning is vital.</p>

<ol>
  <li><strong>Sort Reverse:</strong> Try larger numbers first. This fills buckets faster and fails faster if impossible.</li>
  <li><strong>Skip Duplicates:</strong> If <code class="language-plaintext highlighter-rouge">nums[i] == nums[i-1]</code> and we skipped <code class="language-plaintext highlighter-rouge">nums[i-1]</code>, skip <code class="language-plaintext highlighter-rouge">nums[i]</code>.</li>
  <li><strong>Boundary Check:</strong> If <code class="language-plaintext highlighter-rouge">current_sum + nums[i] &gt; target</code>, stop (since sorted).</li>
</ol>

<h2 id="13-real-world-application-load-balancing">13. Real-World Application: Load Balancing</h2>

<p>Imagine you have <code class="language-plaintext highlighter-rouge">N</code> tasks with execution times <code class="language-plaintext highlighter-rouge">t1, t2, ..., tn</code>. You have 2 servers.
<strong>Goal:</strong> Minimize the makespan (total time).</p>
<ul>
  <li>This is equivalent to partitioning tasks such that the difference between sums is minimized.</li>
  <li>If <code class="language-plaintext highlighter-rouge">Sum(S1) == Sum(S2)</code>, makespan is <code class="language-plaintext highlighter-rouge">Total / 2</code> (Optimal).</li>
  <li>If not possible, we want <code class="language-plaintext highlighter-rouge">Sum(S1)</code> as close to <code class="language-plaintext highlighter-rouge">Total / 2</code> as possible.</li>
  <li>Our DP table <code class="language-plaintext highlighter-rouge">dp[target]</code> tells us exactly which sums are reachable. We just look for the largest <code class="language-plaintext highlighter-rouge">i &lt;= Total/2</code> such that <code class="language-plaintext highlighter-rouge">dp[i]</code> is True.</li>
</ul>

<h2 id="14-code-reconstructing-the-solution">14. Code: Reconstructing the Solution</h2>

<p>Sometimes we need to print the actual subset, not just <code class="language-plaintext highlighter-rouge">True/False</code>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">getPartitionSubset</span><span class="p">(</span><span class="n">nums</span><span class="p">):</span>
    <span class="n">total</span> <span class="o">=</span> <span class="nf">sum</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">total</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="bp">None</span>
    <span class="n">target</span> <span class="o">=</span> <span class="n">total</span> <span class="o">//</span> <span class="mi">2</span>
    
    <span class="c1"># dp[j] stores True/False
</span>    <span class="c1"># parent[i][j] stores whether we included item i to get sum j
</span>    <span class="n">n</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
    <span class="n">dp</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">}</span>
    <span class="n">parent</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1"># (index, current_sum) -&gt; boolean (included or not)
</span>    
    <span class="c1"># Standard DP with path tracking
</span>    <span class="c1"># Note: Using set for sparse DP to save space if target is large
</span>    <span class="n">reachable</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">}</span>
    
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">num</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">nums</span><span class="p">):</span>
        <span class="n">new_reachable</span> <span class="o">=</span> <span class="nf">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">reachable</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">s</span> <span class="o">+</span> <span class="n">num</span> <span class="o">&lt;=</span> <span class="n">target</span><span class="p">:</span>
                <span class="n">new_reachable</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="n">s</span> <span class="o">+</span> <span class="n">num</span><span class="p">)</span>
                <span class="n">parent</span><span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="o">+</span> <span class="n">num</span><span class="p">)]</span> <span class="o">=</span> <span class="bp">True</span> <span class="c1"># Included
</span>            <span class="n">parent</span><span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">s</span><span class="p">)]</span> <span class="o">=</span> <span class="bp">False</span> <span class="c1"># Excluded (implicitly handled by not overwriting if already reachable)
</span>        <span class="n">reachable</span><span class="p">.</span><span class="nf">update</span><span class="p">(</span><span class="n">new_reachable</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">target</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">reachable</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span>
        
    <span class="c1"># Backtrack
</span>    <span class="n">subset</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">curr</span> <span class="o">=</span> <span class="n">target</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="c1"># Did we include nums[i] to get curr?
</span>        <span class="c1"># This logic is slightly tricky with set DP. 
</span>        <span class="c1"># Better to use 2D array logic for reconstruction.
</span>        <span class="k">pass</span> 
        
    <span class="c1"># Let's use the 2D array logic for clarity
</span>    <span class="n">dp</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">False</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">target</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
    <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">num</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">target</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">num</span> <span class="ow">and</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="n">num</span><span class="p">]:</span>
                <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
                
    <span class="k">if</span> <span class="ow">not</span> <span class="n">dp</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">target</span><span class="p">]:</span> <span class="k">return</span> <span class="bp">None</span>
    
    <span class="n">subset</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">curr</span> <span class="o">=</span> <span class="n">target</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="c1"># If we could get curr without nums[i-1], skip it
</span>        <span class="k">if</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">curr</span><span class="p">]:</span>
            <span class="k">continue</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Must have included it
</span>            <span class="n">subset</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">curr</span> <span class="o">-=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            
    <span class="k">return</span> <span class="n">subset</span>
</code></pre></div></div>

<h2 id="15-performance-benchmarking">15. Performance Benchmarking</h2>

<p><strong>Scenario:</strong> $N=100$, $Target=10000$.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">Approach</th>
      <th style="text-align: left">Python Time</th>
      <th style="text-align: left">C++ Time</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left"><strong>Recursion</strong></td>
      <td style="text-align: left">Timeout</td>
      <td style="text-align: left">Timeout</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>DP (2D)</strong></td>
      <td style="text-align: left">150ms</td>
      <td style="text-align: left">10ms</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>DP (1D)</strong></td>
      <td style="text-align: left">120ms</td>
      <td style="text-align: left">8ms</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>Bitset</strong></td>
      <td style="text-align: left">N/A (Python ints are slow)</td>
      <td style="text-align: left"><strong>0.1ms</strong></td>
    </tr>
  </tbody>
</table>

<p><strong>Takeaway:</strong> In competitive programming or high-frequency trading, C++ Bitset is unbeatable for this class of problems.</p>

<h2 id="16-interview-pro-tips">16. Interview Pro Tips</h2>

<ol>
  <li><strong>Identify the Pattern:</strong> “Equal sum”, “Split array”, “Target sum” -&gt; Think Knapsack.</li>
  <li><strong>Check Constraints:</strong>
    <ul>
      <li>$N \le 20$: Recursion / Meet-in-middle.</li>
      <li>$N \le 100, Sum \le 20000$: DP.</li>
      <li>$Sum &gt; 10^9$: DP fails. Is it a math problem?</li>
    </ul>
  </li>
  <li><strong>Space Optimization:</strong> Always mention the 1D array optimization. It shows system design awareness (cache locality).</li>
  <li><strong>Bitset:</strong> Mentioning this gets you “Senior Engineer” points.</li>
</ol>

<h2 id="17-summary">17. Summary</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: left">Approach</th>
      <th style="text-align: left">Time</th>
      <th style="text-align: left">Space</th>
      <th style="text-align: left">Notes</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left"><strong>Recursion</strong></td>
      <td style="text-align: left">$O(2^N)$</td>
      <td style="text-align: left">$O(N)$</td>
      <td style="text-align: left">TLE</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>Memoization</strong></td>
      <td style="text-align: left">$O(N \cdot S)$</td>
      <td style="text-align: left">$O(N \cdot S)$</td>
      <td style="text-align: left">Good</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>Tabulation</strong></td>
      <td style="text-align: left">$O(N \cdot S)$</td>
      <td style="text-align: left">$O(N \cdot S)$</td>
      <td style="text-align: left">Avoids recursion limit</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>Space Opt</strong></td>
      <td style="text-align: left">$O(N \cdot S)$</td>
      <td style="text-align: left">$O(S)$</td>
      <td style="text-align: left">Standard Interview Solution</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>Bitset</strong></td>
      <td style="text-align: left">$O(N \cdot S / 64)$</td>
      <td style="text-align: left">$O(S / 64)$</td>
      <td style="text-align: left">Fastest</td>
    </tr>
  </tbody>
</table>

<hr />

<p><strong>Originally published at:</strong> <a href="https://www.arunbaby.com/dsa/0036-partition-equal-subset-sum/">arunbaby.com/dsa/0036-partition-equal-subset-sum</a></p>

        
      </section>

      <footer class="page__meta">
        
        
  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-tags" aria-hidden="true"></i> Tags: </strong>
    <span itemprop="keywords">
    
      <a href="/tags/#bit-manipulation" class="page__taxonomy-item p-category" rel="tag">bit-manipulation</a><span class="sep">, </span>
    
      <a href="/tags/#dynamic-programming" class="page__taxonomy-item p-category" rel="tag">dynamic-programming</a><span class="sep">, </span>
    
      <a href="/tags/#knapsack" class="page__taxonomy-item p-category" rel="tag">knapsack</a><span class="sep">, </span>
    
      <a href="/tags/#subset-sum" class="page__taxonomy-item p-category" rel="tag">subset-sum</a>
    
    </span>
  </p>




  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> Categories: </strong>
    <span itemprop="keywords">
    
      <a href="/categories/#dsa" class="page__taxonomy-item p-category" rel="tag">dsa</a>
    
    </span>
  </p>


        
      </footer>

      

      <section class="page__share">
  <h4 class="page__share-title">Share on</h4>

  <a href="https://twitter.com/intent/tweet?via=arunbaby0&text=Partition+Equal+Subset+Sum%20https%3A%2F%2Fwww.arunbaby.com%2Fdsa%2F0036-partition-equal-subset-sum%2F" class="btn btn--twitter" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Twitter"><i class="fab fa-fw fa-twitter" aria-hidden="true"></i><span> Twitter</span></a>

  <a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fwww.arunbaby.com%2Fdsa%2F0036-partition-equal-subset-sum%2F" class="btn btn--facebook" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Facebook"><i class="fab fa-fw fa-facebook" aria-hidden="true"></i><span> Facebook</span></a>

  <a href="https://www.linkedin.com/shareArticle?mini=true&url=https://www.arunbaby.com/dsa/0036-partition-equal-subset-sum/" class="btn btn--linkedin" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on LinkedIn"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i><span> LinkedIn</span></a>
</section>


      
  <nav class="pagination">
    
      <a href="/dsa/0035-surrounded-regions/" class="pagination--pager" title="Surrounded Regions (DFS/BFS)">Previous</a>
    
    
      <a href="/dsa/0037-longest-increasing-subsequence/" class="pagination--pager" title="Longest Increasing Subsequence (LIS)">Next</a>
    
  </nav>


    </div>

    
  </article>

  
  
</div>

      
    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';" role="search">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Enter your search term..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    

    
      
        
          <li><a href="https://twitter.com/arunbaby0" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-twitter-square" aria-hidden="true"></i> Twitter</a></li>
        
      
        
          <li><a href="https://github.com/arunbaby0" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
        
      
        
          <li><a href="https://www.linkedin.com/in/arunbaby0/" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i> LinkedIn</a></li>
        
      
        
          <li><a href="https://scholar.google.co.in/citations?user=6fSYWhkAAAAJ" rel="nofollow noopener noreferrer"><i class="fas fa-fw fa-graduation-cap" aria-hidden="true"></i> Google Scholar</a></li>
        
      
    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 1990 - 2143 <a href="https://www.arunbaby.com">Arun Baby</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>




  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-0JRJPEC9SS"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-0JRJPEC9SS', { 'anonymize_ip': false});
</script>








  </body>
</html>
