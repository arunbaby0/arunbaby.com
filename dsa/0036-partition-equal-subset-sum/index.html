<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.26.2 by Michael Rose
  Copyright 2013-2024 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->

<html lang="en-US" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Partition Equal Subset Sum - Arun Baby</title>
<meta name="description" content="“Can you split the treasure evenly?”">


  <meta name="author" content="Arun Baby">
  
  <meta property="article:author" content="Arun Baby">
  


<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="Arun Baby">
<meta property="og:title" content="Partition Equal Subset Sum">
<meta property="og:url" content="https://www.arunbaby.com/dsa/0036-partition-equal-subset-sum/">


  <meta property="og:description" content="“Can you split the treasure evenly?”">



  <meta property="og:image" content="https://www.arunbaby.com/assets/images/profile-photo.png">



  <meta name="twitter:site" content="@arunbaby0">
  <meta name="twitter:title" content="Partition Equal Subset Sum">
  <meta name="twitter:description" content="“Can you split the treasure evenly?”">
  <meta name="twitter:url" content="https://www.arunbaby.com/dsa/0036-partition-equal-subset-sum/">

  
    <meta name="twitter:card" content="summary">
    
      <meta name="twitter:image" content="https://www.arunbaby.com/assets/images/profile-photo.png">
    
  

  



  <meta property="article:published_time" content="2025-12-31T09:51:02+05:30">





  

  


<link rel="canonical" href="https://www.arunbaby.com/dsa/0036-partition-equal-subset-sum/">












<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Arun Baby Feed">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
  
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css"></noscript>



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--single" dir="ltr">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
           
          <span class="site-subtitle">Arun Baby</span>
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a
                href="/about/"
                
                
              >About</a>
            </li><li class="masthead__menu-item">
              <a
                href="/dsa/"
                
                
              >DSA</a>
            </li><li class="masthead__menu-item">
              <a
                href="/ml-system-design/"
                
                
              >ML Systems</a>
            </li><li class="masthead__menu-item">
              <a
                href="/speech-tech/"
                
                
              >Speech Tech</a>
            </li><li class="masthead__menu-item">
              <a
                href="/ai-agents/"
                
                
              >AI Agents</a>
            </li><li class="masthead__menu-item">
              <a
                href="/publications/"
                
                
              >Publications</a>
            </li><li class="masthead__menu-item">
              <a
                href="/statuses/"
                
                
              >Statuses</a>
            </li><li class="masthead__menu-item">
              <a
                href="/contact/"
                
                
              >Contact</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <i class="fas fa-search"></i>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      





<div id="main" role="main" class="no-author-sidebar">
  
  <div class="sidebar sticky">
  
  
  </div>



  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="Partition Equal Subset Sum">
    <meta itemprop="description" content="“Can you split the treasure evenly?”">
    <meta itemprop="datePublished" content="2025-12-31T09:51:02+05:30">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">
            <a href="https://www.arunbaby.com/dsa/0036-partition-equal-subset-sum/" itemprop="url">Partition Equal Subset Sum
</a>
          </h1>
          

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          19 minute read
        
      </span>
    
  </p>


        </header>
      

      <section class="page__content" itemprop="text">
        
          <aside class="sidebar__right sticky">
            <nav class="toc">
              <header><h4 class="nav__title"><i class="fas fa-file-alt"></i> On this page</h4></header>
              <ul class="toc__menu"><li><a href="#1-problem-statement">1. Problem Statement</a></li><li><a href="#2-intuition-the-01-knapsack-connection">2. Intuition: The 0/1 Knapsack Connection</a></li><li><a href="#3-approach-1-recursion-with-memoization-top-down-dp">3. Approach 1: Recursion with Memoization (Top-Down DP)</a></li><li><a href="#4-approach-2-tabulation-bottom-up-dp">4. Approach 2: Tabulation (Bottom-Up DP)</a></li><li><a href="#5-approach-3-space-optimization-1d-array">5. Approach 3: Space Optimization (1D Array)</a></li><li><a href="#6-approach-4-bitset-optimization-the-magic-solution">6. Approach 4: Bitset Optimization (The “Magic” Solution)</a></li><li><a href="#7-deep-dive-np-completeness">7. Deep Dive: NP-Completeness</a></li><li><a href="#8-summary">8. Summary</a></li><li><a href="#9-deep-dive-knapsack-variations">9. Deep Dive: Knapsack Variations</a></li><li><a href="#10-deep-dive-the-magic-of-bitset-optimization">10. Deep Dive: The Magic of Bitset Optimization</a></li><li><a href="#11-deep-dive-meet-in-the-middle">11. Deep Dive: Meet-in-the-Middle</a></li><li><a href="#12-deep-dive-dfs-pruning-techniques">12. Deep Dive: DFS Pruning Techniques</a></li><li><a href="#13-real-world-application-load-balancing">13. Real-World Application: Load Balancing</a></li><li><a href="#14-code-reconstructing-the-solution">14. Code: Reconstructing the Solution</a></li><li><a href="#15-performance-benchmarking">15. Performance Benchmarking</a></li><li><a href="#16-interview-pro-tips">16. Interview Pro Tips</a></li><li><a href="#17-deep-dive-generating-functions-approach">17. Deep Dive: Generating Functions Approach</a></li><li><a href="#18-deep-dive-randomized-algorithms-approximation">18. Deep Dive: Randomized Algorithms (Approximation)</a></li><li><a href="#19-system-design-distributed-subset-sum">19. System Design: Distributed Subset Sum</a></li><li><a href="#20-common-mistakes-and-pitfalls">20. Common Mistakes and Pitfalls</a></li><li><a href="#21-deep-dive-bit-manipulation-tricks-for-subset-sum">21. Deep Dive: Bit Manipulation Tricks for Subset Sum</a></li><li><a href="#22-ethical-considerations">22. Ethical Considerations</a></li><li><a href="#22-further-reading">22. Further Reading</a></li><li><a href="#23-conclusion">23. Conclusion</a></li><li><a href="#24-summary">24. Summary</a></li></ul>
            </nav>
          </aside>
        
        <p><strong>“Can you split the treasure evenly?”</strong></p>

<h2 id="1-problem-statement">1. Problem Statement</h2>

<p>Given a non-empty array <code class="language-plaintext highlighter-rouge">nums</code> containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.</p>

<p><strong>Example 1:</strong>
<code class="language-plaintext highlighter-rouge">
Input: nums = [1, 5, 11, 5]
Output: true
Explanation: The array can be partitioned as [1, 5, 5] and [11]. Both sum to 11.
</code></p>

<p><strong>Example 2:</strong>
<code class="language-plaintext highlighter-rouge">
Input: nums = [1, 2, 3, 5]
Output: false
Explanation: The array cannot be partitioned into equal sum subsets.
</code></p>

<h2 id="2-intuition-the-01-knapsack-connection">2. Intuition: The 0/1 Knapsack Connection</h2>

<ol>
  <li><strong>Total Sum Check:</strong> If the sum of all elements <code class="language-plaintext highlighter-rouge">S</code> is odd, we can’t split it into two equal integers. Return <code class="language-plaintext highlighter-rouge">False</code>.</li>
  <li><strong>Target Sum:</strong> If <code class="language-plaintext highlighter-rouge">S</code> is even, we need to find a subset with sum <code class="language-plaintext highlighter-rouge">target = S / 2</code>. If we find one subset with sum <code class="language-plaintext highlighter-rouge">S/2</code>, the remaining elements must also sum to <code class="language-plaintext highlighter-rouge">S/2</code>.</li>
  <li><strong>Transformation:</strong> This is exactly the <strong>Subset Sum Problem</strong>, which is a variation of the <strong>0/1 Knapsack Problem</strong>.
    <ul>
      <li><strong>Items:</strong> The numbers in <code class="language-plaintext highlighter-rouge">nums</code>.</li>
      <li><strong>Weight:</strong> The value of the number.</li>
      <li><strong>Value:</strong> Irrelevant (we just care if we can fill the knapsack).</li>
      <li><strong>Capacity:</strong> <code class="language-plaintext highlighter-rouge">target</code>.</li>
    </ul>
  </li>
</ol>

<h2 id="3-approach-1-recursion-with-memoization-top-down-dp">3. Approach 1: Recursion with Memoization (Top-Down DP)</h2>

<p>We define a function <code class="language-plaintext highlighter-rouge">canPartition(index, current_sum)</code>.</p>
<ul>
  <li><strong>Base Cases:</strong></li>
  <li>If <code class="language-plaintext highlighter-rouge">current_sum == target</code>: Return <code class="language-plaintext highlighter-rouge">True</code>.</li>
  <li>If <code class="language-plaintext highlighter-rouge">current_sum &gt; target</code> or <code class="language-plaintext highlighter-rouge">index &gt;= len(nums)</code>: Return <code class="language-plaintext highlighter-rouge">False</code>.</li>
  <li><strong>Choices:</strong>
    <ol>
      <li><strong>Include</strong> <code class="language-plaintext highlighter-rouge">nums[index]</code>: <code class="language-plaintext highlighter-rouge">canPartition(index + 1, current_sum + nums[index])</code></li>
      <li><strong>Exclude</strong> <code class="language-plaintext highlighter-rouge">nums[index]</code>: <code class="language-plaintext highlighter-rouge">canPartition(index + 1, current_sum)</code></li>
    </ol>
  </li>
</ul>

<p>``python
class Solution:
 def canPartition(self, nums: List[int]) -&gt; bool:
 total_sum = sum(nums)
 if total_sum % 2 != 0:
 return False</p>

<p>target = total_sum // 2
 memo = {}</p>

<p>def backtrack(index, current_sum):
 if current_sum == target:
 return True
 if current_sum &gt; target or index &gt;= len(nums):
 return False</p>

<p>state = (index, current_sum)
 if state in memo:
 return memo[state]</p>

<p># Choice 1: Include
 if backtrack(index + 1, current_sum + nums[index]):
 memo[state] = True
 return True</p>

<p># Choice 2: Exclude
 if backtrack(index + 1, current_sum):
 memo[state] = True
 return True</p>

<p>memo[state] = False
 return False</p>

<p>return backtrack(0, 0)
``</p>

<p><strong>Complexity:</strong></p>
<ul>
  <li><strong>Time:</strong> O(N \times Target). There are <code class="language-plaintext highlighter-rouge">N \times Target</code> states.</li>
  <li><strong>Space:</strong> O(N \times Target) for memoization table + recursion stack.</li>
</ul>

<h2 id="4-approach-2-tabulation-bottom-up-dp">4. Approach 2: Tabulation (Bottom-Up DP)</h2>

<p>Let <code class="language-plaintext highlighter-rouge">dp[i][j]</code> be <code class="language-plaintext highlighter-rouge">True</code> if a sum of <code class="language-plaintext highlighter-rouge">j</code> can be achieved using the first <code class="language-plaintext highlighter-rouge">i</code> items.</p>

<ul>
  <li><strong>Initialization:</strong> <code class="language-plaintext highlighter-rouge">dp[0][0] = True</code> (Sum 0 with 0 items is possible).</li>
  <li><strong>Transition:</strong></li>
  <li><code class="language-plaintext highlighter-rouge">dp[i][j] = dp[i-1][j]</code> (Exclude current item)</li>
  <li><code class="language-plaintext highlighter-rouge">OR dp[i-1][j - nums[i-1]]</code> (Include current item, if <code class="language-plaintext highlighter-rouge">j &gt;= nums[i-1]</code>)</li>
</ul>

<p>``python
class Solution:
 def canPartition(self, nums: List[int]) -&gt; bool:
 total_sum = sum(nums)
 if total_sum % 2 != 0:
 return False</p>

<p>target = total_sum // 2
 n = len(nums)</p>

<p># dp[i][j] means using first i items, can we get sum j?
 dp = [[False] * (target + 1) for _ in range(n + 1)]</p>

<p>for i in range(n + 1):
 dp[i][0] = True # Sum 0 is always possible</p>

<p>for i in range(1, n + 1):
 curr_num = nums[i-1]
 for j in range(1, target + 1):
 # Exclude
 dp[i][j] = dp[i-1][j]
 # Include
 if j &gt;= curr_num:
 dp[i][j] = dp[i][j] or dp[i-1][j - curr_num]</p>

<p>return dp[n][target]
``</p>

<h2 id="5-approach-3-space-optimization-1d-array">5. Approach 3: Space Optimization (1D Array)</h2>

<p>Notice <code class="language-plaintext highlighter-rouge">dp[i][j]</code> only depends on <code class="language-plaintext highlighter-rouge">dp[i-1][...]</code>. We can reduce space to O(Target).
<strong>Crucial:</strong> We must iterate backwards to avoid using the same item twice in the same step.</p>

<p>``python
class Solution:
 def canPartition(self, nums: List[int]) -&gt; bool:
 total_sum = sum(nums)
 if total_sum % 2 != 0: return False
 target = total_sum // 2</p>

<p>dp = [False] * (target + 1)
 dp[0] = True</p>

<p>for num in nums:
 # Iterate backwards from target to num
 for j in range(target, num - 1, -1):
 dp[j] = dp[j] or dp[j - num]</p>

<p>return dp[target]
``</p>

<p><strong>Complexity:</strong></p>
<ul>
  <li><strong>Time:</strong> O(N \times Target).</li>
  <li><strong>Space:</strong> O(Target).</li>
</ul>

<h2 id="6-approach-4-bitset-optimization-the-magic-solution">6. Approach 4: Bitset Optimization (The “Magic” Solution)</h2>

<p>For languages like C++ or Java (BitSet), or Python (large integers), we can use bit manipulation.</p>
<ul>
  <li>Represent the set of reachable sums as a bitmask.</li>
  <li>If the <code class="language-plaintext highlighter-rouge">k</code>-th bit is 1, it means sum <code class="language-plaintext highlighter-rouge">k</code> is possible.</li>
  <li>Transition: <code class="language-plaintext highlighter-rouge">bits = bits | (bits &lt;&lt; num)</code></li>
  <li><code class="language-plaintext highlighter-rouge">bits</code>: existing sums.</li>
  <li><code class="language-plaintext highlighter-rouge">bits &lt;&lt; num</code>: existing sums + <code class="language-plaintext highlighter-rouge">num</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">|</code>: Union of both sets.</li>
</ul>

<p>``python
class Solution:
 def canPartition(self, nums: List[int]) -&gt; bool:
 total_sum = sum(nums)
 if total_sum % 2 != 0: return False
 target = total_sum // 2</p>

<p># Bitmask: 1 at index 0 means sum 0 is possible
 bits = 1</p>

<p>for num in nums:
 bits |= bits « num</p>

<p># Check if the target-th bit is 1
 return (bits » target) &amp; 1 == 1
``</p>

<p><strong>Why is this fast?</strong></p>
<ul>
  <li>Bitwise operations process 64 bits (sums) in parallel on a 64-bit CPU.</li>
  <li><strong>Time:</strong> O(N \times Target / 64).</li>
  <li><strong>Space:</strong> O(Target / 64).</li>
</ul>

<h2 id="7-deep-dive-np-completeness">7. Deep Dive: NP-Completeness</h2>

<p>The Partition Problem is a special case of the Subset Sum Problem, which is <strong>NP-Complete</strong>.</p>
<ul>
  <li>This means there is no known polynomial-time algorithm (O(N^k)) that solves it for <em>all</em> inputs.</li>
  <li>Our DP solution is <strong>Pseudo-Polynomial</strong>. Its complexity depends on the <em>value</em> of the input (<code class="language-plaintext highlighter-rouge">Target</code>), not just the number of elements (<code class="language-plaintext highlighter-rouge">N</code>).</li>
  <li>If <code class="language-plaintext highlighter-rouge">Target</code> is huge (e.g., <code class="language-plaintext highlighter-rouge">10^{18}</code>), DP fails.</li>
</ul>

<h2 id="8-summary">8. Summary</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: left">Approach</th>
      <th style="text-align: left">Time</th>
      <th style="text-align: left">Space</th>
      <th style="text-align: left">Notes</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left"><strong>Recursion</strong></td>
      <td style="text-align: left">O(2^N)</td>
      <td style="text-align: left">O(N)</td>
      <td style="text-align: left">TLE</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>Memoization</strong></td>
      <td style="text-align: left">O(N \cdot S)</td>
      <td style="text-align: left">O(N \cdot S)</td>
      <td style="text-align: left">Good</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>Tabulation</strong></td>
      <td style="text-align: left">O(N \cdot S)</td>
      <td style="text-align: left">O(N \cdot S)</td>
      <td style="text-align: left">Avoids recursion limit</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>Space Opt</strong></td>
      <td style="text-align: left">O(N \cdot S)</td>
      <td style="text-align: left">O(S)</td>
      <td style="text-align: left">Standard Interview Solution</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>Bitset</strong></td>
      <td style="text-align: left">O(N \cdot S / 64)</td>
      <td style="text-align: left">O(S / 64)</td>
      <td style="text-align: left">Fastest</td>
    </tr>
  </tbody>
</table>

<h2 id="9-deep-dive-knapsack-variations">9. Deep Dive: Knapsack Variations</h2>

<p>The <strong>0/1 Knapsack Problem</strong> is the parent of many interview questions. Understanding the family tree helps identify them.</p>

<p><strong>1. Subset Sum Problem:</strong></p>
<ul>
  <li><strong>Goal:</strong> Is there a subset with sum <code class="language-plaintext highlighter-rouge">T</code>?</li>
  <li><strong>Relation:</strong> Partition Equal Subset Sum is Subset Sum with <code class="language-plaintext highlighter-rouge">T = TotalSum / 2</code>.</li>
  <li><strong>Code:</strong> Exactly the same DP.</li>
</ul>

<p><strong>2. Partition to K Equal Sum Subsets:</strong></p>
<ul>
  <li><strong>Goal:</strong> Can we split array into <code class="language-plaintext highlighter-rouge">K</code> subsets with equal sum?</li>
  <li><strong>Relation:</strong> Generalization of Partition Equal Subset Sum (<code class="language-plaintext highlighter-rouge">K=2</code>).</li>
  <li><strong>Approach:</strong> Backtracking with pruning is usually better than DP because state space <code class="language-plaintext highlighter-rouge">(mask, current_sum)</code> is huge.</li>
</ul>

<p><strong>3. Target Sum (LeetCode 494):</strong></p>
<ul>
  <li><strong>Goal:</strong> Assign <code class="language-plaintext highlighter-rouge">+</code> or <code class="language-plaintext highlighter-rouge">-</code> to each number to get <code class="language-plaintext highlighter-rouge">Target</code>.</li>
  <li><strong>Relation:</strong> Let <code class="language-plaintext highlighter-rouge">P</code> be positive subset, <code class="language-plaintext highlighter-rouge">N</code> be negative subset.</li>
  <li><code class="language-plaintext highlighter-rouge">Sum(P) - Sum(N) = Target</code></li>
  <li><code class="language-plaintext highlighter-rouge">Sum(P) + Sum(N) = TotalSum</code></li>
  <li><code class="language-plaintext highlighter-rouge">2 * Sum(P) = Target + TotalSum</code></li>
  <li><code class="language-plaintext highlighter-rouge">Sum(P) = (Target + TotalSum) / 2</code></li>
  <li><strong>Reduction:</strong> Find subset with sum <code class="language-plaintext highlighter-rouge">(Target + TotalSum) / 2</code>. This is exactly Subset Sum!</li>
</ul>

<h2 id="10-deep-dive-the-magic-of-bitset-optimization">10. Deep Dive: The Magic of Bitset Optimization</h2>

<p>Let’s break down <code class="language-plaintext highlighter-rouge">bits |= bits &lt;&lt; num</code>.</p>

<p>Imagine <code class="language-plaintext highlighter-rouge">nums = [2, 3]</code>, <code class="language-plaintext highlighter-rouge">target = 5</code>.</p>

<p><strong>Step 0:</strong> <code class="language-plaintext highlighter-rouge">bits = 1</code> (Binary: <code class="language-plaintext highlighter-rouge">...00001</code>)</p>
<ul>
  <li>Represents <code class="language-plaintext highlighter-rouge">{0}</code> is possible.</li>
</ul>

<p><strong>Step 1:</strong> Process <code class="language-plaintext highlighter-rouge">num = 2</code>.</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">bits &lt;&lt; 2</code>: <code class="language-plaintext highlighter-rouge">...00100</code> (Represents <code class="language-plaintext highlighter-rouge">{0+2}</code> = <code class="language-plaintext highlighter-rouge">{2}</code>)</li>
  <li><code class="language-plaintext highlighter-rouge">bits |= ...</code>: <code class="language-plaintext highlighter-rouge">...00101</code> (Represents <code class="language-plaintext highlighter-rouge">{0, 2}</code>)</li>
</ul>

<p><strong>Step 2:</strong> Process <code class="language-plaintext highlighter-rouge">num = 3</code>.</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">bits</code>: <code class="language-plaintext highlighter-rouge">...00101</code> (<code class="language-plaintext highlighter-rouge">{0, 2}</code>)</li>
  <li><code class="language-plaintext highlighter-rouge">bits &lt;&lt; 3</code>: <code class="language-plaintext highlighter-rouge">...00101000</code> -&gt; <code class="language-plaintext highlighter-rouge">...101000</code> (Wait, <code class="language-plaintext highlighter-rouge">101</code> shifted left by 3 is <code class="language-plaintext highlighter-rouge">101000</code>)</li>
  <li>Old bit 0 (value 0) -&gt; New bit 3 (value 3).</li>
  <li>Old bit 2 (value 2) -&gt; New bit 5 (value 5).</li>
  <li><code class="language-plaintext highlighter-rouge">bits |= ...</code>: <code class="language-plaintext highlighter-rouge">...101101</code></li>
  <li>Indices set: 0, 2, 3, 5.</li>
  <li>Possible sums: <code class="language-plaintext highlighter-rouge">{0, 2, 3, 5}</code>.</li>
</ul>

<p><strong>Result:</strong> Check bit 5. It is 1. Return True.</p>

<p><strong>C++ Implementation:</strong>
``cpp
#include <bitset>
#include <vector>
#include <numeric></numeric></vector></bitset></p>

<p>class Solution {
public:
 bool canPartition(std::vector<int>&amp; nums) {
 int sum = std::accumulate(nums.begin(), nums.end(), 0);
 if (sum % 2 != 0) return false;
 int target = sum / 2;</int></p>

<p>std::bitset&lt;10001&gt; bits(1); // Max sum is 200 * 100 = 20000, target 10000</p>

<p>for (int num : nums) {
 bits |= (bits « num);
 }</p>

<p>return bits[target];
 }
};
``</p>

<h2 id="11-deep-dive-meet-in-the-middle">11. Deep Dive: Meet-in-the-Middle</h2>

<p>What if <code class="language-plaintext highlighter-rouge">Target</code> is huge (e.g., <code class="language-plaintext highlighter-rouge">10^{15}</code>), but <code class="language-plaintext highlighter-rouge">N</code> is small (e.g., 40)?
DP fails (O(N \cdot S)). Recursion fails (<code class="language-plaintext highlighter-rouge">2^{40}</code>).</p>

<p><strong>Algorithm:</strong></p>
<ol>
  <li>Split <code class="language-plaintext highlighter-rouge">nums</code> into two halves: <code class="language-plaintext highlighter-rouge">Left</code> (20 items) and <code class="language-plaintext highlighter-rouge">Right</code> (20 items).</li>
  <li>Generate all possible subset sums for <code class="language-plaintext highlighter-rouge">Left</code>. Store in a Set <code class="language-plaintext highlighter-rouge">S_Left</code>. (<code class="language-plaintext highlighter-rouge">2^{20} \approx 10^6</code>).</li>
  <li>Generate all possible subset sums for <code class="language-plaintext highlighter-rouge">Right</code>. Store in a Set <code class="language-plaintext highlighter-rouge">S_Right</code>.</li>
  <li>Iterate through <code class="language-plaintext highlighter-rouge">x</code> in <code class="language-plaintext highlighter-rouge">S_Left</code>. Check if <code class="language-plaintext highlighter-rouge">Target - x</code> exists in <code class="language-plaintext highlighter-rouge">S_Right</code>.</li>
</ol>

<p><strong>Complexity:</strong></p>
<ul>
  <li><strong>Time:</strong> O(2^{N/2}).</li>
  <li><strong>Space:</strong> O(2^{N/2}).</li>
  <li>Much better than <code class="language-plaintext highlighter-rouge">2^N</code>.</li>
</ul>

<h2 id="12-deep-dive-dfs-pruning-techniques">12. Deep Dive: DFS Pruning Techniques</h2>

<p>If we must use DFS (e.g., for K-partition), pruning is vital.</p>

<ol>
  <li><strong>Sort Reverse:</strong> Try larger numbers first. This fills buckets faster and fails faster if impossible.</li>
  <li><strong>Skip Duplicates:</strong> If <code class="language-plaintext highlighter-rouge">nums[i] == nums[i-1]</code> and we skipped <code class="language-plaintext highlighter-rouge">nums[i-1]</code>, skip <code class="language-plaintext highlighter-rouge">nums[i]</code>.</li>
  <li><strong>Boundary Check:</strong> If <code class="language-plaintext highlighter-rouge">current_sum + nums[i] &gt; target</code>, stop (since sorted).</li>
</ol>

<h2 id="13-real-world-application-load-balancing">13. Real-World Application: Load Balancing</h2>

<p>Imagine you have <code class="language-plaintext highlighter-rouge">N</code> tasks with execution times <code class="language-plaintext highlighter-rouge">t1, t2, ..., tn</code>. You have 2 servers.
<strong>Goal:</strong> Minimize the makespan (total time).</p>
<ul>
  <li>This is equivalent to partitioning tasks such that the difference between sums is minimized.</li>
  <li>If <code class="language-plaintext highlighter-rouge">Sum(S1) == Sum(S2)</code>, makespan is <code class="language-plaintext highlighter-rouge">Total / 2</code> (Optimal).</li>
  <li>If not possible, we want <code class="language-plaintext highlighter-rouge">Sum(S1)</code> as close to <code class="language-plaintext highlighter-rouge">Total / 2</code> as possible.</li>
  <li>Our DP table <code class="language-plaintext highlighter-rouge">dp[target]</code> tells us exactly which sums are reachable. We just look for the largest <code class="language-plaintext highlighter-rouge">i &lt;= Total/2</code> such that <code class="language-plaintext highlighter-rouge">dp[i]</code> is True.</li>
</ul>

<h2 id="14-code-reconstructing-the-solution">14. Code: Reconstructing the Solution</h2>

<p>Sometimes we need to print the actual subset, not just <code class="language-plaintext highlighter-rouge">True/False</code>.</p>

<p>``python
def getPartitionSubset(nums):
 total = sum(nums)
 if total % 2 != 0: return None
 target = total // 2</p>

<p># dp[j] stores True/False
 # parent[i][j] stores whether we included item i to get sum j
 n = len(nums)
 dp = {0}
 parent = {} # (index, current_sum) -&gt; boolean (included or not)</p>

<p># Standard DP with path tracking
 # Note: Using set for sparse DP to save space if target is large
 reachable = {0}</p>

<p>for i, num in enumerate(nums):
 new_reachable = set()
 for s in reachable:
 if s + num &lt;= target:
 new_reachable.add(s + num)
 parent[(i, s + num)] = True # Included
 parent[(i, s)] = False # Excluded (implicitly handled by not overwriting if already reachable)
 reachable.update(new_reachable)</p>

<p>if target not in reachable:
 return None</p>

<p># Backtrack
 subset = []
 curr = target
 for i in range(n - 1, -1, -1):
 # Did we include nums[i] to get curr?
 # This logic is slightly tricky with set DP. 
 # Better to use 2D array logic for reconstruction.
 pass</p>

<p># Let’s use the 2D array logic for clarity
 dp = [[False] * (target + 1) for _ in range(n + 1)]
 dp[0][0] = True
 for i in range(1, n + 1):
 num = nums[i-1]
 for j in range(target + 1):
 dp[i][j] = dp[i-1][j]
 if j &gt;= num and dp[i-1][j-num]:
 dp[i][j] = True</p>

<p>if not dp[n][target]: return None</p>

<p>subset = []
 curr = target
 for i in range(n, 0, -1):
 # If we could get curr without nums[i-1], skip it
 if dp[i-1][curr]:
 continue
 else:
 # Must have included it
 subset.append(nums[i-1])
 curr -= nums[i-1]</p>

<p>return subset
``</p>

<h2 id="15-performance-benchmarking">15. Performance Benchmarking</h2>

<p><strong>Scenario:</strong> <code class="language-plaintext highlighter-rouge">N=100</code>, <code class="language-plaintext highlighter-rouge">Target=10000</code>.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">Approach</th>
      <th style="text-align: left">Python Time</th>
      <th style="text-align: left">C++ Time</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left"><strong>Recursion</strong></td>
      <td style="text-align: left">Timeout</td>
      <td style="text-align: left">Timeout</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>DP (2D)</strong></td>
      <td style="text-align: left">150ms</td>
      <td style="text-align: left">10ms</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>DP (1D)</strong></td>
      <td style="text-align: left">120ms</td>
      <td style="text-align: left">8ms</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>Bitset</strong></td>
      <td style="text-align: left">N/A (Python ints are slow)</td>
      <td style="text-align: left"><strong>0.1ms</strong></td>
    </tr>
  </tbody>
</table>

<p><strong>Takeaway:</strong> In competitive programming or high-frequency trading, C++ Bitset is unbeatable for this class of problems.</p>

<h2 id="16-interview-pro-tips">16. Interview Pro Tips</h2>

<ol>
  <li><strong>Identify the Pattern:</strong> “Equal sum”, “Split array”, “Target sum” -&gt; Think Knapsack.</li>
  <li><strong>Check Constraints:</strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">N \le 20</code>: Recursion / Meet-in-middle.</li>
      <li><code class="language-plaintext highlighter-rouge">N \le 100, Sum \le 20000</code>: DP.</li>
      <li><code class="language-plaintext highlighter-rouge">Sum &gt; 10^9</code>: DP fails. Is it a math problem?</li>
    </ul>
  </li>
  <li><strong>Space Optimization:</strong> Always mention the 1D array optimization. It shows system design awareness (cache locality).</li>
  <li>
    <p><strong>Bitset:</strong> Mentioning this gets you “Senior Engineer” points.</p>
  </li>
  <li><strong>Bitset:</strong> Mentioning this gets you “Senior Engineer” points.</li>
</ol>

<h2 id="17-deep-dive-generating-functions-approach">17. Deep Dive: Generating Functions Approach</h2>

<p>For those with a math background, the Subset Sum problem can be modeled using <strong>Generating Functions</strong>.</p>

<p><strong>Polynomial Representation:</strong>
For each number <code class="language-plaintext highlighter-rouge">n \in nums</code>, we construct a polynomial <code class="language-plaintext highlighter-rouge">P_n(x) = 1 + x^n</code>.</p>
<ul>
  <li>The term <code class="language-plaintext highlighter-rouge">1</code> (<code class="language-plaintext highlighter-rouge">x^0</code>) represents excluding <code class="language-plaintext highlighter-rouge">n</code>.</li>
  <li>The term <code class="language-plaintext highlighter-rouge">x^n</code> represents including <code class="language-plaintext highlighter-rouge">n</code>.</li>
</ul>

<p><strong>Product:</strong>
The generating function for the entire set is the product of these polynomials:
<code class="language-plaintext highlighter-rouge">P(x) = \prod_{n \in nums} (1 + x^n)</code></p>

<p><strong>Interpretation:</strong>
If we expand <code class="language-plaintext highlighter-rouge">P(x)</code>, the coefficient of <code class="language-plaintext highlighter-rouge">x^k</code> tells us <strong>how many ways</strong> we can form the sum <code class="language-plaintext highlighter-rouge">k</code>.</p>
<ul>
  <li>If the coefficient of <code class="language-plaintext highlighter-rouge">x^{Target}</code> is non-zero, the answer is True.</li>
</ul>

<p><strong>Example:</strong> <code class="language-plaintext highlighter-rouge">nums = [1, 2]</code>
<code class="language-plaintext highlighter-rouge">P(x) = (1 + x^1)(1 + x^2) = 1 + x + x^2 + x^3</code></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">x^0</code>: Sum 0 (Empty set)</li>
  <li><code class="language-plaintext highlighter-rouge">x^1</code>: Sum 1 ({1})</li>
  <li><code class="language-plaintext highlighter-rouge">x^2</code>: Sum 2 ({2})</li>
  <li><code class="language-plaintext highlighter-rouge">x^3</code>: Sum 3 ({1, 2})</li>
</ul>

<p><strong>Fast Polynomial Multiplication:</strong></p>
<ul>
  <li>Multiplying polynomials naively is slow.</li>
  <li>We can use <strong>FFT (Fast Fourier Transform)</strong> to multiply polynomials in O(S \log S) time, where <code class="language-plaintext highlighter-rouge">S</code> is the sum.</li>
  <li>This is faster than DP (O(N \cdot S)) when <code class="language-plaintext highlighter-rouge">S</code> is small and <code class="language-plaintext highlighter-rouge">N</code> is large.</li>
</ul>

<h2 id="18-deep-dive-randomized-algorithms-approximation">18. Deep Dive: Randomized Algorithms (Approximation)</h2>

<p>What if we just want a “good enough” partition?</p>

<p><strong>Karmarkar-Karp Algorithm (Differencing Method):</strong></p>
<ol>
  <li>Sort numbers in descending order.</li>
  <li>Maintain a set of numbers.</li>
  <li>Take the two largest numbers <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code>.</li>
  <li>Replace them with <code class="language-plaintext highlighter-rouge">|a - b|</code>.</li>
  <li>Repeat until one number remains.</li>
</ol>

<p><strong>Intuition:</strong>
By replacing <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code> with <code class="language-plaintext highlighter-rouge">a-b</code>, we are effectively deciding to put <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code> in different sets. The final number represents the difference between the sums of the two sets.</p>

<p><strong>Example:</strong> <code class="language-plaintext highlighter-rouge">[10, 8, 7, 6, 5]</code></p>
<ol>
  <li>Take 10, 8. Replace with 2. -&gt; <code class="language-plaintext highlighter-rouge">[7, 6, 5, 2]</code></li>
  <li>Take 7, 6. Replace with 1. -&gt; <code class="language-plaintext highlighter-rouge">[5, 2, 1]</code></li>
  <li>Take 5, 2. Replace with 3. -&gt; <code class="language-plaintext highlighter-rouge">[3, 1]</code></li>
  <li>Take 3, 1. Replace with 2.
<strong>Result:</strong> Difference is 2. (Not perfect 0, but close).</li>
</ol>

<p><strong>Performance:</strong></p>
<ul>
  <li>Very fast (O(N \log N)).</li>
  <li>Often gives optimal or near-optimal results in practice, though worst-case is bad.</li>
</ul>

<h2 id="19-system-design-distributed-subset-sum">19. System Design: Distributed Subset Sum</h2>

<p><strong>Scenario:</strong>
You have a dataset of 1 Trillion transactions. You want to find a subset of transactions that sums to exactly $1,000,000.00 to detect fraud (Structuring).</p>

<p><strong>Constraints:</strong></p>
<ul>
  <li>Data doesn’t fit in memory.</li>
  <li><code class="language-plaintext highlighter-rouge">N</code> is huge (<code class="language-plaintext highlighter-rouge">10^{12}</code>).</li>
  <li><code class="language-plaintext highlighter-rouge">Target</code> is relatively small (<code class="language-plaintext highlighter-rouge">10^6</code>).</li>
</ul>

<p><strong>Architecture (MapReduce / Spark):</strong></p>

<p><strong>Phase 1: Frequency Count (Map)</strong></p>
<ul>
  <li>Since <code class="language-plaintext highlighter-rouge">Target</code> is small, many transactions have the same value (e.g., $50.00).</li>
  <li><strong>Map:</strong> <code class="language-plaintext highlighter-rouge">(TransactionID, Amount) -&gt; (Amount, 1)</code></li>
  <li><strong>Reduce:</strong> <code class="language-plaintext highlighter-rouge">(Amount, Count)</code></li>
  <li><strong>Result:</strong> <code class="language-plaintext highlighter-rouge">[(50.00, 10000), (20.00, 5000), ...]</code></li>
  <li>This compresses the input from 1 Trillion to just <code class="language-plaintext highlighter-rouge">Target</code> unique values.</li>
</ul>

<p><strong>Phase 2: Bounded Knapsack (DP on Driver)</strong></p>
<ul>
  <li>Now we have a <strong>Bounded Knapsack Problem</strong>:</li>
  <li>Item: $50.00, Count: 10000.</li>
  <li>Since number of unique items is small (<code class="language-plaintext highlighter-rouge">\le 10^6</code>), we can run DP on a single powerful machine.</li>
  <li><strong>Optimization:</strong> Use the O(S) space optimization.</li>
</ul>

<p><strong>Phase 3: Reconstruction (Distributed)</strong></p>
<ul>
  <li>Once we know <em>how many</em> of each amount we need (e.g., 5000 of $50.00), we launch a Spark job to fetch specific TransactionIDs.</li>
</ul>

<p><strong>Code (Spark-like Pseudocode):</strong>
``python</p>
<h1 id="1-count-frequencies">1. Count frequencies</h1>
<p>counts = transactions.map(lambda t: (t.amount, 1)).reduceByKey(add).collect()</p>

<h1 id="2-solve-bounded-knapsack-locally">2. Solve Bounded Knapsack locally</h1>
<p>def solve_bounded(counts, target):
 # dp[j] = min count of current item needed to get sum j
 dp = [-1] * (target + 1)
 dp[0] = 0</p>

<p>for amount, count in counts:
 for j in range(target + 1):
 if dp[j] &gt;= 0:
 dp[j] = 0 # Reset count for new item
 elif j &gt;= amount and dp[j - amount] &lt; count:
 dp[j] = dp[j - amount] + 1
 else:
 dp[j] = -1</p>

<p>return dp[target] &gt;= 0
``</p>

<h2 id="20-common-mistakes-and-pitfalls">20. Common Mistakes and Pitfalls</h2>

<p><strong>1. Greedy Approach Fails:</strong></p>
<ul>
  <li><em>Mistake:</em> “Just sort and take largest elements until we overshoot.”</li>
  <li><em>Counter-example:</em> <code class="language-plaintext highlighter-rouge">nums = [5, 5, 4, 6]</code>, <code class="language-plaintext highlighter-rouge">Target = 10</code>.</li>
  <li>Greedy taking largest: Take 6. Remaining Target 4. Take 4. Sum = 10. OK.</li>
  <li>Wait, <code class="language-plaintext highlighter-rouge">nums = [5, 4, 3, 2]</code>, <code class="language-plaintext highlighter-rouge">Target = 7</code>.</li>
  <li>Greedy: Take 5. Remaining 2. Take 2. Sum = 7. OK.</li>
  <li><code class="language-plaintext highlighter-rouge">nums = [4, 4, 5]</code>, <code class="language-plaintext highlighter-rouge">Target = 6</code>. (Impossible).</li>
  <li><code class="language-plaintext highlighter-rouge">nums = [5, 10, 5, 20]</code>, <code class="language-plaintext highlighter-rouge">Target = 20</code>.</li>
  <li>Greedy: Take 20. Done.</li>
  <li>Actually, Greedy works for <em>some</em> cases (Change Making with US coins), but not general Subset Sum.</li>
</ul>

<p><strong>2. Integer Overflow:</strong></p>
<ul>
  <li>If <code class="language-plaintext highlighter-rouge">Target</code> is large, <code class="language-plaintext highlighter-rouge">dp</code> array indices might overflow 32-bit integers.</li>
  <li><strong>Fix:</strong> Use 64-bit integers or Python.</li>
</ul>

<p><strong>3. Floating Point Precision:</strong></p>
<ul>
  <li>If inputs are floats (<code class="language-plaintext highlighter-rouge">10.50</code>), don’t use them as array indices.</li>
  <li><strong>Fix:</strong> Multiply by 100 and convert to integers (<code class="language-plaintext highlighter-rouge">1050</code>).</li>
</ul>

<p><strong>4. Modifying DP Array in Place (Forward Iteration):</strong></p>
<ul>
  <li><em>Mistake:</em> <code class="language-plaintext highlighter-rouge">for j in range(num, target + 1): dp[j] = dp[j] or dp[j - num]</code></li>
  <li><em>Result:</em> You use the same item multiple times (Unbounded Knapsack).</li>
  <li>
    <p><em>Fix:</em> Iterate backwards: <code class="language-plaintext highlighter-rouge">range(target, num - 1, -1)</code>.</p>
  </li>
  <li><em>Fix:</em> Iterate backwards: <code class="language-plaintext highlighter-rouge">range(target, num - 1, -1)</code>.</li>
</ul>

<h2 id="21-deep-dive-bit-manipulation-tricks-for-subset-sum">21. Deep Dive: Bit Manipulation Tricks for Subset Sum</h2>

<p>If you are using C++ <code class="language-plaintext highlighter-rouge">std::bitset</code>, you can perform some magic.</p>

<p><strong>1. Find First Missing Sum:</strong></p>
<ul>
  <li>Suppose you want to find the smallest sum that <em>cannot</em> be formed.</li>
  <li><code class="language-plaintext highlighter-rouge">~bits</code> flips all bits.</li>
  <li><code class="language-plaintext highlighter-rouge">(~bits)._Find_first()</code> gives the index of the first 0.</li>
</ul>

<p><strong>2. Count Number of Ways (Approximate):</strong></p>
<ul>
  <li>Standard bitset only tells you <em>if</em> a sum is possible.</li>
  <li>If you need the count, you can’t use bitset directly.</li>
  <li><strong>Trick:</strong> Use modular arithmetic with a large prime.</li>
  <li><code class="language-plaintext highlighter-rouge">dp[j] = (dp[j] + dp[j - num]) % P</code></li>
  <li>This is just standard DP, but optimized for space.</li>
</ul>

<p><strong>3. Negative Numbers:</strong></p>
<ul>
  <li>Bitset indices must be non-negative.</li>
  <li><strong>Fix:</strong> Add an <code class="language-plaintext highlighter-rouge">offset</code> (e.g., 10000) to all indices.</li>
  <li><code class="language-plaintext highlighter-rouge">bits[0]</code> represents sum <code class="language-plaintext highlighter-rouge">-10000</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">bits[10000]</code> represents sum <code class="language-plaintext highlighter-rouge">0</code>.</li>
</ul>

<p><strong>4. Partition into K Subsets (Bitmask DP):</strong></p>
<ul>
  <li>For small <code class="language-plaintext highlighter-rouge">N</code> (<code class="language-plaintext highlighter-rouge">N \le 20</code>), we can use a mask to represent used elements.</li>
  <li><code class="language-plaintext highlighter-rouge">dp[mask]</code> = remainder of sum of subset <code class="language-plaintext highlighter-rouge">mask</code> modulo <code class="language-plaintext highlighter-rouge">target</code>.</li>
  <li>If <code class="language-plaintext highlighter-rouge">dp[mask] == 0</code>, we completed a subset.</li>
  <li>Transition: Try adding <code class="language-plaintext highlighter-rouge">nums[i]</code> if <code class="language-plaintext highlighter-rouge">(mask &gt;&gt; i) &amp; 1 == 0</code>.</li>
</ul>

<h2 id="22-ethical-considerations">22. Ethical Considerations</h2>

<p><strong>1. Cryptography:</strong></p>
<ul>
  <li>The <strong>Knapsack Cryptosystem</strong> (Merkle-Hellman) relied on the hardness of Subset Sum.</li>
  <li>It was broken by Shamir using lattice reduction.</li>
  <li><strong>Lesson:</strong> NP-Complete problems aren’t necessarily hard for <em>average</em> cases, only <em>worst</em> cases. Don’t roll your own crypto.</li>
</ul>

<p><strong>2. Resource Allocation Fairness:</strong></p>
<ul>
  <li>When partitioning resources (e.g., food aid, computing power), “Equal Subset Sum” implies perfect fairness.</li>
  <li>If perfect equality is impossible, minimizing the difference (Partition Problem optimization) is the ethical choice.</li>
</ul>

<h2 id="22-further-reading">22. Further Reading</h2>

<ol>
  <li><strong>“Computers and Intractability: A Guide to the Theory of NP-Completeness” (Garey &amp; Johnson):</strong> The bible of NP.</li>
  <li><strong>“The Easiest Hard Problem” (Hayes):</strong> A great article on the Number Partitioning problem.</li>
  <li><strong>“Dynamic Programming Optimization” (CP-Algorithms):</strong> Advanced tricks like Knuth Optimization (not applicable here, but good to know).</li>
</ol>

<h2 id="23-conclusion">23. Conclusion</h2>

<p>Partition Equal Subset Sum is the “Hello World” of the Knapsack family. It bridges the gap between simple recursion and pseudo-polynomial DP. While the O(N \cdot S) solution is standard, the <strong>Bitset optimization</strong> (O(N \cdot S / 64)) demonstrates a deep understanding of computer architecture. For massive datasets, we shift from DP to <strong>Distributed Counting + Bounded Knapsack</strong>. Whether you’re balancing load on servers or detecting financial structuring, the ability to split a set into equal parts is a fundamental skill in algorithmic design.</p>

<h2 id="24-summary">24. Summary</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: left">Approach</th>
      <th style="text-align: left">Time</th>
      <th style="text-align: left">Space</th>
      <th style="text-align: left">Notes</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left"><strong>Recursion</strong></td>
      <td style="text-align: left">O(2^N)</td>
      <td style="text-align: left">O(N)</td>
      <td style="text-align: left">TLE</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>Memoization</strong></td>
      <td style="text-align: left">O(N \cdot S)</td>
      <td style="text-align: left">O(N \cdot S)</td>
      <td style="text-align: left">Good</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>Tabulation</strong></td>
      <td style="text-align: left">O(N \cdot S)</td>
      <td style="text-align: left">O(N \cdot S)</td>
      <td style="text-align: left">Avoids recursion limit</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>Space Opt</strong></td>
      <td style="text-align: left">O(N \cdot S)</td>
      <td style="text-align: left">O(S)</td>
      <td style="text-align: left">Standard Interview Solution</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>Bitset</strong></td>
      <td style="text-align: left">O(N \cdot S / 64)</td>
      <td style="text-align: left">O(S / 64)</td>
      <td style="text-align: left">Fastest</td>
    </tr>
  </tbody>
</table>

<hr />

<p><strong>Originally published at:</strong> <a href="https://www.arunbaby.com/dsa/0036-partition-equal-subset-sum/">arunbaby.com/dsa/0036-partition-equal-subset-sum</a></p>

        
      </section>

      <footer class="page__meta">
        
        
  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-tags" aria-hidden="true"></i> Tags: </strong>
    <span itemprop="keywords">
    
      <a href="/tags/#bit-manipulation" class="page__taxonomy-item p-category" rel="tag">bit-manipulation</a><span class="sep">, </span>
    
      <a href="/tags/#dynamic-programming" class="page__taxonomy-item p-category" rel="tag">dynamic-programming</a><span class="sep">, </span>
    
      <a href="/tags/#knapsack" class="page__taxonomy-item p-category" rel="tag">knapsack</a><span class="sep">, </span>
    
      <a href="/tags/#subset-sum" class="page__taxonomy-item p-category" rel="tag">subset-sum</a>
    
    </span>
  </p>




  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> Categories: </strong>
    <span itemprop="keywords">
    
      <a href="/categories/#dsa" class="page__taxonomy-item p-category" rel="tag">dsa</a>
    
    </span>
  </p>


        
      </footer>

      <div class="page__related page__related--full">
  <h2 class="page__related-title">Related across topics</h2>
  <style>
    /* Make section span full content width and use 2 equal columns */
    .page__related--full { float: inline-start; width: 100%; padding: 0; }
    .cross-related-grid { display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 2rem; }
    @media (max-width: 768px) { .cross-related-grid { grid-template-columns: 1fr; } }
    /* Ensure archive cards stretch nicely in the grid */
    .cross-related-grid .list__item, .cross-related-grid .grid__item { width: auto; float: none; margin: 0; }
  </style>
  <div class="cross-related-grid">
    



<div class="list__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/ml-system-design/0036-resource-partitioning/" rel="permalink">Resource Partitioning in ML Clusters
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          21 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">“How to share a supercomputer without stepping on each other’s toes.”
</p>
  </article>
</div>




<div class="list__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/speech-tech/0036-multi-task-speech-learning/" rel="permalink">Multi-task Speech Learning
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          23 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">“One model to rule them all: ASR, Translation, and Understanding.”
</p>
  </article>
</div>




<div class="list__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/ai-agents/0036-web-browsing-agents/" rel="permalink">Web Browsing Agents
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          18 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">“Turn the open web into a reliable tool: browse, extract, verify, and cite—without getting prompt-injected.”
</p>
  </article>
</div>

  </div>
</div>

      <section class="page__share">
  <h4 class="page__share-title">Share on</h4>

  <a href="https://twitter.com/intent/tweet?via=arunbaby0&text=Partition+Equal+Subset+Sum%20https%3A%2F%2Fwww.arunbaby.com%2Fdsa%2F0036-partition-equal-subset-sum%2F" class="btn btn--twitter" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Twitter"><i class="fab fa-fw fa-twitter" aria-hidden="true"></i><span> Twitter</span></a>

  <a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fwww.arunbaby.com%2Fdsa%2F0036-partition-equal-subset-sum%2F" class="btn btn--facebook" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Facebook"><i class="fab fa-fw fa-facebook" aria-hidden="true"></i><span> Facebook</span></a>

  <a href="https://www.linkedin.com/shareArticle?mini=true&url=https://www.arunbaby.com/dsa/0036-partition-equal-subset-sum/" class="btn btn--linkedin" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on LinkedIn"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i><span> LinkedIn</span></a>
</section>


      
  <nav class="pagination">
    
      <a href="/dsa/0035-surrounded-regions/" class="pagination--pager" title="Surrounded Regions (DFS/BFS)">Previous</a>
    
    
      <a href="/dsa/0037-longest-increasing-subsequence/" class="pagination--pager" title="Longest Increasing Subsequence (LIS)">Next</a>
    
  </nav>


    </div>

    
  </article>

  
  
</div>

      
    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';" role="search">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Enter your search term..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    

    
      
        
          <li><a href="https://twitter.com/arunbaby0" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-twitter-square" aria-hidden="true"></i> Twitter</a></li>
        
      
        
          <li><a href="https://github.com/arunbaby0" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
        
      
        
          <li><a href="https://www.linkedin.com/in/arunbaby0/" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i> LinkedIn</a></li>
        
      
        
          <li><a href="https://scholar.google.co.in/citations?user=6fSYWhkAAAAJ" rel="nofollow noopener noreferrer"><i class="fas fa-fw fa-graduation-cap" aria-hidden="true"></i> Google Scholar</a></li>
        
      
    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 1990 - 2143 <a href="https://www.arunbaby.com">Arun Baby</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>




  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-0JRJPEC9SS"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-0JRJPEC9SS', { 'anonymize_ip': false});
</script>








  </body>
</html>
