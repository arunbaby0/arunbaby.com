<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.26.2 by Michael Rose
  Copyright 2013-2024 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->

<html lang="en-US" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Word Break - Arun Baby</title>
<meta name="description" content="“Making sense of a stream of characters.”">


  <meta name="author" content="Arun Baby">
  
  <meta property="article:author" content="Arun Baby">
  


<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="Arun Baby">
<meta property="og:title" content="Word Break">
<meta property="og:url" content="https://www.arunbaby.com/dsa/0039-word-break/">


  <meta property="og:description" content="“Making sense of a stream of characters.”">



  <meta property="og:image" content="https://www.arunbaby.com/assets/images/profile-photo.png">



  <meta name="twitter:site" content="@arunbaby0">
  <meta name="twitter:title" content="Word Break">
  <meta name="twitter:description" content="“Making sense of a stream of characters.”">
  <meta name="twitter:url" content="https://www.arunbaby.com/dsa/0039-word-break/">

  
    <meta name="twitter:card" content="summary">
    
      <meta name="twitter:image" content="https://www.arunbaby.com/assets/images/profile-photo.png">
    
  

  



  <meta property="article:published_time" content="2025-12-15T14:32:24+05:30">





  

  


<link rel="canonical" href="https://www.arunbaby.com/dsa/0039-word-break/">












<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Arun Baby Feed">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
  
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css"></noscript>



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--single" dir="ltr">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
           
          <span class="site-subtitle">Arun Baby</span>
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a
                href="/about/"
                
                
              >About</a>
            </li><li class="masthead__menu-item">
              <a
                href="/dsa/"
                
                
              >DSA</a>
            </li><li class="masthead__menu-item">
              <a
                href="/ml-system-design/"
                
                
              >ML Systems</a>
            </li><li class="masthead__menu-item">
              <a
                href="/speech-tech/"
                
                
              >Speech Tech</a>
            </li><li class="masthead__menu-item">
              <a
                href="/ai-agents/"
                
                
              >AI Agents</a>
            </li><li class="masthead__menu-item">
              <a
                href="/publications/"
                
                
              >Publications</a>
            </li><li class="masthead__menu-item">
              <a
                href="/statuses/"
                
                
              >Statuses</a>
            </li><li class="masthead__menu-item">
              <a
                href="/contact/"
                
                
              >Contact</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <i class="fas fa-search"></i>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      





<div id="main" role="main" class="no-author-sidebar">
  
  <div class="sidebar sticky">
  
  
  </div>



  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="Word Break">
    <meta itemprop="description" content="“Making sense of a stream of characters.”">
    <meta itemprop="datePublished" content="2025-12-15T14:32:24+05:30">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">
            <a href="https://www.arunbaby.com/dsa/0039-word-break/" itemprop="url">Word Break
</a>
          </h1>
          

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          21 minute read
        
      </span>
    
  </p>


        </header>
      

      <section class="page__content" itemprop="text">
        
          <aside class="sidebar__right sticky">
            <nav class="toc">
              <header><h4 class="nav__title"><i class="fas fa-file-alt"></i> On this page</h4></header>
              <ul class="toc__menu"><li><a href="#1-problem-statement">1. Problem Statement</a></li><li><a href="#2-intuition">2. Intuition</a></li><li><a href="#3-approach-1-recursion-with-memoization-top-down-dp">3. Approach 1: Recursion with Memoization (Top-Down DP)</a></li><li><a href="#4-approach-2-tabulation-bottom-up-dp">4. Approach 2: Tabulation (Bottom-Up DP)</a></li><li><a href="#5-approach-3-bfs-breadth-first-search">5. Approach 3: BFS (Breadth-First Search)</a></li><li><a href="#6-optimization-trie-prefix-tree">6. Optimization: Trie (Prefix Tree)</a></li><li><a href="#7-deep-dive-word-break-ii-reconstructing-sentences">7. Deep Dive: Word Break II (Reconstructing Sentences)</a></li><li><a href="#8-real-world-application-search-query-segmentation">8. Real-World Application: Search Query Segmentation</a></li><li><a href="#9-deep-dive-aho-corasick-algorithm">9. Deep Dive: Aho-Corasick Algorithm</a></li><li><a href="#10-system-design-spell-checker">10. System Design: Spell Checker</a></li><li><a href="#11-deep-dive-maximum-word-break-max-match">11. Deep Dive: Maximum Word Break (Max Match)</a></li><li><a href="#12-deep-dive-trie-implementation-details">12. Deep Dive: Trie Implementation Details</a></li><li><a href="#13-deep-dive-aho-corasick-algorithm-in-depth">13. Deep Dive: Aho-Corasick Algorithm in Depth</a></li><li><a href="#14-deep-dive-word-break-ii-optimization">14. Deep Dive: Word Break II Optimization</a></li><li><a href="#15-system-design-search-query-segmentation-viterbi">15. System Design: Search Query Segmentation (Viterbi)</a></li><li><a href="#16-advanced-handling-compound-words-german">16. Advanced: Handling Compound Words (German)</a></li><li><a href="#17-case-study-spell-checker-implementation">17. Case Study: Spell Checker Implementation</a></li><li><a href="#18-deep-dive-suffix-trees-and-suffix-arrays">18. Deep Dive: Suffix Trees and Suffix Arrays</a></li><li><a href="#19-deep-dive-rabin-karp-algorithm-rolling-hash">19. Deep Dive: Rabin-Karp Algorithm (Rolling Hash)</a></li><li><a href="#20-system-design-scalable-autocomplete-system">20. System Design: Scalable Autocomplete System</a></li><li><a href="#21-advanced-parallel-word-break-mapreduce">21. Advanced: Parallel Word Break (MapReduce)</a></li><li><a href="#22-deep-dive-generalized-word-break-2d-grid">22. Deep Dive: Generalized Word Break (2D Grid)</a></li><li><a href="#23-interview-questions-hard">23. Interview Questions (Hard)</a></li><li><a href="#24-interview-questions">24. Interview Questions</a></li><li><a href="#25-common-mistakes">25. Common Mistakes</a></li><li><a href="#26-performance-benchmarking">26. Performance Benchmarking</a></li><li><a href="#27-ethical-considerations">27. Ethical Considerations</a></li><li><a href="#28-further-reading">28. Further Reading</a></li><li><a href="#29-conclusion">29. Conclusion</a></li><li><a href="#30-summary">30. Summary</a></li></ul>
            </nav>
          </aside>
        
        <p><strong>“Making sense of a stream of characters.”</strong></p>

<h2 id="1-problem-statement">1. Problem Statement</h2>

<p>Given a string <code class="language-plaintext highlighter-rouge">s</code> and a dictionary of strings <code class="language-plaintext highlighter-rouge">wordDict</code>, return <code class="language-plaintext highlighter-rouge">true</code> if <code class="language-plaintext highlighter-rouge">s</code> can be segmented into a space-separated sequence of one or more dictionary words.</p>

<p>Note that the same word in the dictionary may be reused multiple times in the segmentation.</p>

<p><strong>Example 1:</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "leetcode", wordDict = ["leet", "code"]
Output: true
Explanation: Return true because "leetcode" can be segmented as "leet code".
</code></pre></div></div>

<p><strong>Example 2:</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "applepenapple", wordDict = ["apple", "pen"]
Output: true
Explanation: Return true because "applepenapple" can be segmented as "apple pen apple".
Note that you are allowed to reuse a dictionary word.
</code></pre></div></div>

<p><strong>Example 3:</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
Output: false
</code></pre></div></div>

<h2 id="2-intuition">2. Intuition</h2>

<p>This problem asks if we can split the string <code class="language-plaintext highlighter-rouge">s</code> into valid substrings. This structure suggests <strong>Dynamic Programming</strong> or <strong>Recursion</strong>.</p>

<p>If we want to know if <code class="language-plaintext highlighter-rouge">s[0...n]</code> is valid, we can check if there exists a split point <code class="language-plaintext highlighter-rouge">j</code> such that <code class="language-plaintext highlighter-rouge">s[0...j]</code> is a valid word AND <code class="language-plaintext highlighter-rouge">s[j...n]</code> can be broken into valid words.</p>

<p>This gives us the optimal substructure property:
<code class="language-plaintext highlighter-rouge">WordBreak(s) = (s[0:i] in Dict) AND WordBreak(s[i:])</code> for some <code class="language-plaintext highlighter-rouge">i</code>.</p>

<h2 id="3-approach-1-recursion-with-memoization-top-down-dp">3. Approach 1: Recursion with Memoization (Top-Down DP)</h2>

<p>We define a function <code class="language-plaintext highlighter-rouge">canBreak(start_index)</code> that returns true if the substring <code class="language-plaintext highlighter-rouge">s[start_index:]</code> can be segmented.</p>

<p><strong>Algorithm:</strong></p>
<ol>
  <li>Base Case: If <code class="language-plaintext highlighter-rouge">start_index == len(s)</code>, we have successfully segmented the entire string. Return <code class="language-plaintext highlighter-rouge">True</code>.</li>
  <li>Recursive Step: Iterate through all possible end indices <code class="language-plaintext highlighter-rouge">end</code> from <code class="language-plaintext highlighter-rouge">start_index + 1</code> to <code class="language-plaintext highlighter-rouge">len(s)</code>.</li>
  <li>Check if <code class="language-plaintext highlighter-rouge">s[start_index:end]</code> is in <code class="language-plaintext highlighter-rouge">wordDict</code>.</li>
  <li>If it is, recursively check <code class="language-plaintext highlighter-rouge">canBreak(end)</code>.</li>
  <li>If both are true, return <code class="language-plaintext highlighter-rouge">True</code>.</li>
  <li>Memoize the result for <code class="language-plaintext highlighter-rouge">start_index</code> to avoid re-computation.</li>
</ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">wordBreak</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">wordDict</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">word_set</span> <span class="o">=</span> <span class="nf">set</span><span class="p">(</span><span class="n">wordDict</span><span class="p">)</span>  <span class="c1"># O(1) lookups
</span>        <span class="n">memo</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">def</span> <span class="nf">backtrack</span><span class="p">(</span><span class="n">start</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">start</span> <span class="o">==</span> <span class="nf">len</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">True</span>
            
            <span class="k">if</span> <span class="n">start</span> <span class="ow">in</span> <span class="n">memo</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">memo</span><span class="p">[</span><span class="n">start</span><span class="p">]</span>
            
            <span class="k">for</span> <span class="n">end</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">word</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">word_set</span> <span class="ow">and</span> <span class="nf">backtrack</span><span class="p">(</span><span class="n">end</span><span class="p">):</span>
                    <span class="n">memo</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="k">return</span> <span class="bp">True</span>
            
            <span class="n">memo</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">return</span> <span class="bp">False</span>
        
        <span class="k">return</span> <span class="nf">backtrack</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</code></pre></div></div>

<p><strong>Complexity:</strong></p>
<ul>
  <li><strong>Time:</strong> $O(N^3)$. There are $N$ states. For each state, we iterate $N$ times. String slicing takes $O(N)$. Total $O(N^3)$.</li>
  <li><strong>Space:</strong> $O(N)$ for recursion stack and memoization.</li>
</ul>

<h2 id="4-approach-2-tabulation-bottom-up-dp">4. Approach 2: Tabulation (Bottom-Up DP)</h2>

<p>We can solve this iteratively. Let <code class="language-plaintext highlighter-rouge">dp[i]</code> be <code class="language-plaintext highlighter-rouge">True</code> if the substring <code class="language-plaintext highlighter-rouge">s[0...i]</code> can be segmented.</p>

<p><strong>Definition:</strong>
<code class="language-plaintext highlighter-rouge">dp[i]</code> = True if <code class="language-plaintext highlighter-rouge">s[0...i]</code> can be broken into valid words.</p>

<p><strong>Transition:</strong>
<code class="language-plaintext highlighter-rouge">dp[i]</code> is True if there exists a <code class="language-plaintext highlighter-rouge">j &lt; i</code> such that <code class="language-plaintext highlighter-rouge">dp[j]</code> is True AND <code class="language-plaintext highlighter-rouge">s[j...i]</code> is in <code class="language-plaintext highlighter-rouge">wordDict</code>.</p>

<p><strong>Initialization:</strong>
<code class="language-plaintext highlighter-rouge">dp[0] = True</code> (Empty string is valid).</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">wordBreak</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">wordDict</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">word_set</span> <span class="o">=</span> <span class="nf">set</span><span class="p">(</span><span class="n">wordDict</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="n">dp</span> <span class="o">=</span> <span class="p">[</span><span class="bp">False</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
                <span class="c1"># If s[0...j] is valid AND s[j...i] is a word
</span>                <span class="k">if</span> <span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="ow">and</span> <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">:</span><span class="n">i</span><span class="p">]</span> <span class="ow">in</span> <span class="n">word_set</span><span class="p">:</span>
                    <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="k">break</span> <span class="c1"># Optimization: found one valid split, move to next i
</span>        
        <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
</code></pre></div></div>

<p><strong>Complexity:</strong></p>
<ul>
  <li><strong>Time:</strong> $O(N^3)$. Nested loops ($N^2$) + substring slicing/hashing ($N$).</li>
  <li><strong>Space:</strong> $O(N)$ for the DP array.</li>
</ul>

<h2 id="5-approach-3-bfs-breadth-first-search">5. Approach 3: BFS (Breadth-First Search)</h2>

<p>We can model this as a graph problem.</p>
<ul>
  <li><strong>Nodes:</strong> Indices <code class="language-plaintext highlighter-rouge">0</code> to <code class="language-plaintext highlighter-rouge">n</code>.</li>
  <li><strong>Edges:</strong> Directed edge from <code class="language-plaintext highlighter-rouge">i</code> to <code class="language-plaintext highlighter-rouge">j</code> if <code class="language-plaintext highlighter-rouge">s[i:j]</code> is a valid word.</li>
  <li><strong>Goal:</strong> Is there a path from <code class="language-plaintext highlighter-rouge">0</code> to <code class="language-plaintext highlighter-rouge">n</code>?</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">deque</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">wordBreak</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">wordDict</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">word_set</span> <span class="o">=</span> <span class="nf">set</span><span class="p">(</span><span class="n">wordDict</span><span class="p">)</span>
        <span class="n">queue</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">}</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        
        <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="nf">popleft</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">start</span> <span class="o">==</span> <span class="n">n</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">True</span>
            
            <span class="k">for</span> <span class="n">end</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">end</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                    <span class="k">continue</span>
                    
                <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span> <span class="ow">in</span> <span class="n">word_set</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">end</span> <span class="o">==</span> <span class="n">n</span><span class="p">:</span>
                        <span class="k">return</span> <span class="bp">True</span>
                    <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">end</span><span class="p">)</span>
                    <span class="n">visited</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="n">end</span><span class="p">)</span>
                    
        <span class="k">return</span> <span class="bp">False</span>
</code></pre></div></div>

<p><strong>Complexity:</strong></p>
<ul>
  <li><strong>Time:</strong> $O(N^3)$ in worst case (dense graph).</li>
  <li><strong>Space:</strong> $O(N)$ for queue and visited set.</li>
</ul>

<h2 id="6-optimization-trie-prefix-tree">6. Optimization: Trie (Prefix Tree)</h2>

<p>Instead of checking every substring <code class="language-plaintext highlighter-rouge">s[j:i]</code>, which involves slicing and hashing, we can use a Trie to efficiently traverse potential words.</p>

<p><strong>Algorithm:</strong></p>
<ol>
  <li>Build a Trie from <code class="language-plaintext highlighter-rouge">wordDict</code>.</li>
  <li>Use DP. For each <code class="language-plaintext highlighter-rouge">i</code> where <code class="language-plaintext highlighter-rouge">dp[i]</code> is True, traverse the Trie starting from <code class="language-plaintext highlighter-rouge">s[i]</code>.</li>
  <li>If we reach a Trie node marked <code class="language-plaintext highlighter-rouge">is_end</code>, we mark <code class="language-plaintext highlighter-rouge">dp[i + length]</code> as True.</li>
</ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">TrieNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">children</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">self</span><span class="p">.</span><span class="n">is_end</span> <span class="o">=</span> <span class="bp">False</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">wordBreak</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">wordDict</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">root</span> <span class="o">=</span> <span class="nc">TrieNode</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">wordDict</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">root</span>
            <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">word</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">char</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">node</span><span class="p">.</span><span class="n">children</span><span class="p">:</span>
                    <span class="n">node</span><span class="p">.</span><span class="n">children</span><span class="p">[</span><span class="n">char</span><span class="p">]</span> <span class="o">=</span> <span class="nc">TrieNode</span><span class="p">()</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">children</span><span class="p">[</span><span class="n">char</span><span class="p">]</span>
            <span class="n">node</span><span class="p">.</span><span class="n">is_end</span> <span class="o">=</span> <span class="bp">True</span>
            
        <span class="n">n</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="n">dp</span> <span class="o">=</span> <span class="p">[</span><span class="bp">False</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="k">continue</span>
            
            <span class="c1"># Traverse Trie starting from s[i]
</span>            <span class="n">node</span> <span class="o">=</span> <span class="n">root</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
                <span class="n">char</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">char</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">node</span><span class="p">.</span><span class="n">children</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">children</span><span class="p">[</span><span class="n">char</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">is_end</span><span class="p">:</span>
                    <span class="n">dp</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
                    
        <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
</code></pre></div></div>

<p><strong>Complexity:</strong></p>
<ul>
  <li><strong>Time:</strong> $O(N^2 + M \cdot K)$, where $M$ is number of words, $K$ is avg word length (Trie build). The DP part is $O(N^2)$ because we don’t do string slicing/hashing.</li>
  <li><strong>Space:</strong> $O(M \cdot K)$ for Trie + $O(N)$ for DP.</li>
  <li><strong>Note:</strong> This is significantly faster if the dictionary is large but words are short.</li>
</ul>

<h2 id="7-deep-dive-word-break-ii-reconstructing-sentences">7. Deep Dive: Word Break II (Reconstructing Sentences)</h2>

<p><strong>Problem:</strong> Return <em>all</em> possible sentences.
<strong>Example:</strong> <code class="language-plaintext highlighter-rouge">s = "catsanddog"</code>, <code class="language-plaintext highlighter-rouge">dict = ["cat", "cats", "and", "sand", "dog"]</code>
<strong>Output:</strong> <code class="language-plaintext highlighter-rouge">["cats and dog", "cat sand dog"]</code></p>

<p><strong>Approach:</strong> Backtracking with Memoization.</p>
<ul>
  <li>Instead of storing <code class="language-plaintext highlighter-rouge">True/False</code>, store the list of valid sentences for each suffix.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">wordBreak</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">wordDict</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="n">word_set</span> <span class="o">=</span> <span class="nf">set</span><span class="p">(</span><span class="n">wordDict</span><span class="p">)</span>
        <span class="n">memo</span> <span class="o">=</span> <span class="p">{}</span>
        
        <span class="k">def</span> <span class="nf">backtrack</span><span class="p">(</span><span class="n">start</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">start</span> <span class="o">==</span> <span class="nf">len</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
                <span class="k">return</span> <span class="p">[</span><span class="sh">""</span><span class="p">]</span>
            
            <span class="k">if</span> <span class="n">start</span> <span class="ow">in</span> <span class="n">memo</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">memo</span><span class="p">[</span><span class="n">start</span><span class="p">]</span>
            
            <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">end</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">word</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">word_set</span><span class="p">:</span>
                    <span class="n">suffixes</span> <span class="o">=</span> <span class="nf">backtrack</span><span class="p">(</span><span class="n">end</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">suffix</span> <span class="ow">in</span> <span class="n">suffixes</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">suffix</span><span class="p">:</span>
                            <span class="n">res</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">word</span> <span class="o">+</span> <span class="sh">"</span><span class="s"> </span><span class="sh">"</span> <span class="o">+</span> <span class="n">suffix</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">res</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>
            
            <span class="n">memo</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span>
            <span class="k">return</span> <span class="n">res</span>
            
        <span class="k">return</span> <span class="nf">backtrack</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</code></pre></div></div>

<p><strong>Complexity:</strong></p>
<ul>
  <li><strong>Time:</strong> $O(N \cdot 2^N)$ in worst case (e.g., <code class="language-plaintext highlighter-rouge">s="aaaaa"</code>, <code class="language-plaintext highlighter-rouge">dict=["a", "aa", "aaa"]</code>).</li>
  <li><strong>Space:</strong> Exponential to store all results.</li>
</ul>

<h2 id="8-real-world-application-search-query-segmentation">8. Real-World Application: Search Query Segmentation</h2>

<p>When you type “newyorktimes” into Google, it understands “new york times”. This is Word Break.</p>

<p><strong>Challenges in Production:</strong></p>
<ol>
  <li><strong>Unknown Words (OOV):</strong> Names, typos, new slang.
    <ul>
      <li><em>Solution:</em> Use statistical language models (n-grams) to score segmentations, not just binary dictionary lookup.</li>
    </ul>
  </li>
  <li><strong>Ambiguity:</strong> “expertsexchange” -&gt; “experts exchange” vs “expert sex change”.
    <ul>
      <li><em>Solution:</em> Use frequency counts. $P(\text{“experts”}) \cdot P(\text{“exchange”}) &gt; P(\text{“expert”}) \cdot P(\text{“sex”}) \cdot P(\text{“change”})$.</li>
    </ul>
  </li>
  <li><strong>Latency:</strong> Must be sub-millisecond.
    <ul>
      <li><em>Solution:</em> Aho-Corasick algorithm or optimized Tries.</li>
    </ul>
  </li>
</ol>

<h2 id="9-deep-dive-aho-corasick-algorithm">9. Deep Dive: Aho-Corasick Algorithm</h2>

<p>For massive scale dictionary matching, <strong>Aho-Corasick</strong> is the gold standard.</p>
<ul>
  <li>It builds a Finite Automaton from the dictionary.</li>
  <li>It adds “failure links” to the Trie.</li>
  <li>Allows finding all dictionary word occurrences in <code class="language-plaintext highlighter-rouge">s</code> in $O(N + \text{matches})$ time.</li>
  <li>Used in <code class="language-plaintext highlighter-rouge">grep</code>, intrusion detection systems (Snort), and virus scanners.</li>
</ul>

<h2 id="10-system-design-spell-checker">10. System Design: Spell Checker</h2>

<p><strong>Scenario:</strong> Build a spell checker that suggests corrections and segmentations.</p>

<p><strong>Components:</strong></p>
<ol>
  <li><strong>Error Model:</strong> Probability of typing <code class="language-plaintext highlighter-rouge">x</code> when you meant <code class="language-plaintext highlighter-rouge">y</code> (Edit Distance).</li>
  <li><strong>Language Model:</strong> Probability of word sequence (N-grams or LSTM/Transformer).</li>
  <li><strong>Candidate Generator:</strong>
    <ul>
      <li>Generate candidates within edit distance 1 or 2.</li>
      <li>Generate segmentation candidates (Word Break).</li>
    </ul>
  </li>
  <li><strong>Ranker:</strong>
    <ul>
      <li>Score = $\log P(\text{Error}) + \log P(\text{Language})$.</li>
      <li>Return top-k.</li>
    </ul>
  </li>
</ol>

<p><strong>Optimization:</strong></p>
<ul>
  <li><strong>Bloom Filter:</strong> Quickly check if a word exists in the dictionary before expensive lookup.</li>
  <li><strong>SymSpell:</strong> Pre-generate all deletions of dictionary words for fast lookup.</li>
</ul>

<h2 id="11-deep-dive-maximum-word-break-max-match">11. Deep Dive: Maximum Word Break (Max Match)</h2>

<p>Sometimes we don’t care about <em>any</em> valid segmentation, but the one with the <strong>longest words</strong> (Max Match) or <strong>most words</strong>.</p>

<p><strong>Max Match Algorithm (Greedy):</strong></p>
<ul>
  <li>Start at index 0.</li>
  <li>Find the longest word in dictionary starting at 0.</li>
  <li>Move index.</li>
  <li><strong>Pros:</strong> Very fast $O(N)$.</li>
  <li><strong>Cons:</strong> Fails on “thetable” -&gt; “theta” “ble” (if “theta” and “ble” are words, but “table” is better).</li>
  <li>
    <p><strong>Use Case:</strong> Chinese/Japanese tokenization baselines.</p>
  </li>
  <li><strong>Use Case:</strong> Chinese/Japanese tokenization baselines.</li>
</ul>

<h2 id="12-deep-dive-trie-implementation-details">12. Deep Dive: Trie Implementation Details</h2>

<p>While the basic Trie is simple, optimizing it for production requires care.</p>

<p><strong>1. Array vs Hash Map:</strong></p>
<ul>
  <li><strong>Hash Map (<code class="language-plaintext highlighter-rouge">dict</code> in Python):</strong> Flexible, handles Unicode. Memory overhead is high.</li>
  <li><strong>Array (<code class="language-plaintext highlighter-rouge">Node[26]</code>):</strong> Fast access, low memory overhead. Only works for ‘a’-‘z’.</li>
</ul>

<p><strong>2. Iterative vs Recursive:</strong></p>
<ul>
  <li><strong>Recursive:</strong> Elegant but risks stack overflow for long words.</li>
  <li><strong>Iterative:</strong> Preferred for production.</li>
</ul>

<p><strong>Optimized Trie Code (Array-based):</strong></p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">TrieNode</span><span class="p">:</span>
    <span class="n">__slots__</span> <span class="o">=</span> <span class="sh">'</span><span class="s">children</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">is_end</span><span class="sh">'</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">children</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span> <span class="o">*</span> <span class="mi">26</span>
        <span class="n">self</span><span class="p">.</span><span class="n">is_end</span> <span class="o">=</span> <span class="bp">False</span>

<span class="k">class</span> <span class="nc">Trie</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">root</span> <span class="o">=</span> <span class="nc">TrieNode</span><span class="p">()</span>
    
    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">word</span><span class="p">):</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">root</span>
        <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">word</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="nf">ord</span><span class="p">(</span><span class="n">char</span><span class="p">)</span> <span class="o">-</span> <span class="nf">ord</span><span class="p">(</span><span class="sh">'</span><span class="s">a</span><span class="sh">'</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="p">.</span><span class="n">children</span><span class="p">[</span><span class="n">idx</span><span class="p">]:</span>
                <span class="n">node</span><span class="p">.</span><span class="n">children</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="nc">TrieNode</span><span class="p">()</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">children</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="n">node</span><span class="p">.</span><span class="n">is_end</span> <span class="o">=</span> <span class="bp">True</span>
</code></pre></div></div>

<p><strong>3. Compressed Trie (Radix Tree):</strong></p>
<ul>
  <li>If a node has only one child, merge them.</li>
  <li><code class="language-plaintext highlighter-rouge">root -&gt; "a" -&gt; "p" -&gt; "p" -&gt; "l" -&gt; "e"</code> becomes <code class="language-plaintext highlighter-rouge">root -&gt; "apple"</code>.</li>
  <li><strong>Benefit:</strong> Reduces depth and memory usage.</li>
</ul>

<h2 id="13-deep-dive-aho-corasick-algorithm-in-depth">13. Deep Dive: Aho-Corasick Algorithm in Depth</h2>

<p>Aho-Corasick generalizes KMP algorithm to multiple patterns.</p>

<p><strong>Key Components:</strong></p>
<ol>
  <li><strong>Trie:</strong> Standard prefix tree of all dictionary words.</li>
  <li><strong>Failure Links:</strong> For each node <code class="language-plaintext highlighter-rouge">u</code> representing string <code class="language-plaintext highlighter-rouge">S</code>, the failure link points to the longest proper suffix of <code class="language-plaintext highlighter-rouge">S</code> that is also a prefix of some pattern in the Trie.</li>
  <li><strong>Output Links:</strong> Shortcut to the nearest “is_end” node reachable via failure links.</li>
</ol>

<p><strong>Construction (BFS):</strong></p>
<ol>
  <li>Root’s failure link points to Root.</li>
  <li>For nodes at depth 1, failure link points to Root.</li>
  <li>For node <code class="language-plaintext highlighter-rouge">v</code> (child of <code class="language-plaintext highlighter-rouge">u</code> via char <code class="language-plaintext highlighter-rouge">c</code>):
    <ul>
      <li>Follow <code class="language-plaintext highlighter-rouge">u</code>’s failure link to <code class="language-plaintext highlighter-rouge">f(u)</code>.</li>
      <li>Check if <code class="language-plaintext highlighter-rouge">f(u)</code> has child via <code class="language-plaintext highlighter-rouge">c</code>.</li>
      <li>If yes, <code class="language-plaintext highlighter-rouge">f(v) = f(u).child(c)</code>.</li>
      <li>If no, recurse up failure links until Root.</li>
    </ul>
  </li>
</ol>

<p><strong>Usage in Word Break:</strong></p>
<ul>
  <li>Instead of restarting search from root for every <code class="language-plaintext highlighter-rouge">i</code>, we follow failure links.</li>
  <li>This allows us to find <em>all</em> matching words ending at <code class="language-plaintext highlighter-rouge">i</code> in $O(1)$ amortized time per character.</li>
  <li><strong>Complexity:</strong> $O(N + \text{Total Occurrences})$.</li>
</ul>

<p><strong>Code Sketch:</strong></p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">build_failure_links</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
    <span class="n">queue</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">char</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">root</span><span class="p">.</span><span class="n">children</span><span class="p">.</span><span class="nf">items</span><span class="p">():</span>
        <span class="n">node</span><span class="p">.</span><span class="n">fail</span> <span class="o">=</span> <span class="n">root</span>
        <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
    
    <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="nf">popleft</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">char</span><span class="p">,</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">curr</span><span class="p">.</span><span class="n">children</span><span class="p">.</span><span class="nf">items</span><span class="p">():</span>
            <span class="c1"># Find failure link for child
</span>            <span class="n">f</span> <span class="o">=</span> <span class="n">curr</span><span class="p">.</span><span class="n">fail</span>
            <span class="k">while</span> <span class="n">f</span> <span class="o">!=</span> <span class="n">root</span> <span class="ow">and</span> <span class="n">char</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">f</span><span class="p">.</span><span class="n">children</span><span class="p">:</span>
                <span class="n">f</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">fail</span>
            <span class="n">child</span><span class="p">.</span><span class="n">fail</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">children</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">char</span><span class="p">,</span> <span class="n">root</span><span class="p">)</span>
            <span class="n">child</span><span class="p">.</span><span class="n">output</span> <span class="o">=</span> <span class="n">child</span> <span class="k">if</span> <span class="n">child</span><span class="p">.</span><span class="n">is_end</span> <span class="k">else</span> <span class="n">child</span><span class="p">.</span><span class="n">fail</span><span class="p">.</span><span class="n">output</span>
            <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="14-deep-dive-word-break-ii-optimization">14. Deep Dive: Word Break II Optimization</h2>

<p>The backtracking solution for Word Break II can be slow.</p>

<p><strong>Pruning:</strong></p>
<ul>
  <li>Before backtracking, run the simple DP (Word Break I) to check if a solution exists.</li>
  <li>If <code class="language-plaintext highlighter-rouge">dp[n]</code> is False, return empty list immediately.</li>
  <li>This avoids exploring the recursion tree for impossible cases.</li>
</ul>

<p><strong>Max Length Optimization:</strong></p>
<ul>
  <li>Let <code class="language-plaintext highlighter-rouge">max_len</code> be the length of the longest word in dictionary.</li>
  <li>When iterating <code class="language-plaintext highlighter-rouge">end</code> from <code class="language-plaintext highlighter-rouge">start + 1</code>, stop at <code class="language-plaintext highlighter-rouge">start + max_len + 1</code>.</li>
  <li>This reduces the inner loop from $O(N)$ to $O(K)$.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">wordBreak</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">wordDict</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="n">word_set</span> <span class="o">=</span> <span class="nf">set</span><span class="p">(</span><span class="n">wordDict</span><span class="p">)</span>
        <span class="n">max_len</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">wordDict</span><span class="p">)</span> <span class="k">if</span> <span class="n">wordDict</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="n">memo</span> <span class="o">=</span> <span class="p">{}</span>
        
        <span class="c1"># Pruning check
</span>        <span class="k">if</span> <span class="ow">not</span> <span class="n">self</span><span class="p">.</span><span class="nf">canBreak</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">word_set</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="k">def</span> <span class="nf">backtrack</span><span class="p">(</span><span class="n">start</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">start</span> <span class="o">==</span> <span class="nf">len</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
                <span class="k">return</span> <span class="p">[</span><span class="sh">""</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">start</span> <span class="ow">in</span> <span class="n">memo</span><span class="p">:</span> <span class="k">return</span> <span class="n">memo</span><span class="p">[</span><span class="n">start</span><span class="p">]</span>
            
            <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># Optimization: Only check up to max_len
</span>            <span class="k">for</span> <span class="n">end</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nf">min</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">start</span> <span class="o">+</span> <span class="n">max_len</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">word</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">word_set</span><span class="p">:</span>
                    <span class="n">suffixes</span> <span class="o">=</span> <span class="nf">backtrack</span><span class="p">(</span><span class="n">end</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">suffix</span> <span class="ow">in</span> <span class="n">suffixes</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">suffix</span><span class="p">:</span> <span class="n">res</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">word</span> <span class="o">+</span> <span class="sh">"</span><span class="s"> </span><span class="sh">"</span> <span class="o">+</span> <span class="n">suffix</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span> <span class="n">res</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>
            <span class="n">memo</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span>
            <span class="k">return</span> <span class="n">res</span>
            
        <span class="k">return</span> <span class="nf">backtrack</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="15-system-design-search-query-segmentation-viterbi">15. System Design: Search Query Segmentation (Viterbi)</h2>

<p><strong>Problem:</strong> User types “newyorktimes”. We want “new york times”.</p>

<p><strong>Probabilistic Model:</strong></p>
<ul>
  <li>
    <table>
      <tbody>
        <tr>
          <td>We want to find segmentation $S = w_1, w_2, …, w_k$ that maximizes $P(S</td>
          <td>\text{input})$.</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>Using Bayes Rule and ignoring denominator: $\text{argmax}_S P(\text{input}</td>
          <td>S) P(S)$.</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>$P(\text{input}</td>
          <td>S) \approx 1$ if concatenation of $S$ equals input.</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>$P(S) \approx \prod P(w_i)$ (Unigram model) or $\prod P(w_i</td>
          <td>w_{i-1})$ (Bigram model).</td>
        </tr>
      </tbody>
    </table>
  </li>
</ul>

<p><strong>Viterbi Algorithm (DP on Log Probabilities):</strong></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">dp[i]</code> = Max log-probability of segmenting <code class="language-plaintext highlighter-rouge">s[0...i]</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">parent[i]</code> = The index of the split that gave this max probability.</li>
</ul>

<p><strong>Data:</strong></p>
<ul>
  <li>Corpus of billions of web pages.</li>
  <li>Count word frequencies.</li>
  <li>$P(w) = \frac{\text{count}(w)}{N}$.</li>
</ul>

<p><strong>Smoothing:</strong></p>
<ul>
  <li>What if a word is not in our dictionary?</li>
  <li>Assign a small probability $\epsilon$ based on character length.</li>
  <li>Or use a character-level language model.</li>
</ul>

<p><strong>Code:</strong></p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">math</span>

<span class="k">class</span> <span class="nc">Segmenter</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">word_counts</span><span class="p">,</span> <span class="n">total_count</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">word_counts</span> <span class="o">=</span> <span class="n">word_counts</span>
        <span class="n">self</span><span class="p">.</span><span class="n">total</span> <span class="o">=</span> <span class="n">total_count</span>
        <span class="n">self</span><span class="p">.</span><span class="n">min_prob</span> <span class="o">=</span> <span class="n">math</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">total_count</span> <span class="o">*</span> <span class="mi">100</span><span class="p">))</span> <span class="c1"># Smoothing
</span>
    <span class="k">def</span> <span class="nf">get_prob</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">word</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">math</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">word_counts</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">math</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">total</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">segment</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="n">dp</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="nf">float</span><span class="p">(</span><span class="sh">'</span><span class="s">inf</span><span class="sh">'</span><span class="p">)]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">parent</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">20</span><span class="p">),</span> <span class="n">i</span><span class="p">):</span> <span class="c1"># Limit word length
</span>                <span class="n">word</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">:</span><span class="n">i</span><span class="p">]</span>
                <span class="n">prob</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">self</span><span class="p">.</span><span class="nf">get_prob</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">prob</span> <span class="o">&gt;</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">prob</span>
                    <span class="n">parent</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span>
        
        <span class="c1"># Reconstruct
</span>        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="n">n</span>
        <span class="k">while</span> <span class="n">curr</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">prev</span> <span class="o">=</span> <span class="n">parent</span><span class="p">[</span><span class="n">curr</span><span class="p">]</span>
            <span class="n">res</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">prev</span><span class="p">:</span><span class="n">curr</span><span class="p">])</span>
            <span class="n">curr</span> <span class="o">=</span> <span class="n">prev</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div></div>

<h2 id="16-advanced-handling-compound-words-german">16. Advanced: Handling Compound Words (German)</h2>

<p><strong>Problem:</strong> German has infinite compound words (“Donaudampfschifffahrtskapitän”).</p>
<ul>
  <li>Dictionary cannot contain all of them.</li>
</ul>

<p><strong>Solution:</strong></p>
<ul>
  <li>Recursive decomposition.</li>
  <li>If a word is not in dictionary, try to split it.</li>
  <li><strong>Morpheme Analysis:</strong> Split into smallest meaningful units.</li>
  <li><strong>Rule-based:</strong> German has “Fugen-s” (connective ‘s’). “Liebe” + “Brief” = “Liebesbrief”.</li>
  <li>The segmenter must handle these connective characters.</li>
</ul>

<h2 id="17-case-study-spell-checker-implementation">17. Case Study: Spell Checker Implementation</h2>

<p><strong>Norvig’s Spell Checker:</strong></p>
<ol>
  <li><strong>Deletions:</strong> “helo” -&gt; “hel”, “heo”, “hlo”, “elo”.</li>
  <li><strong>Transpositions:</strong> “helo” -&gt; “ehlo”, “hleo”, “heol”.</li>
  <li><strong>Replacements:</strong> “helo” -&gt; “aelo”, “belo”…</li>
  <li><strong>Insertions:</strong> “helo” -&gt; “ahelo”, “bhelo”…</li>
</ol>

<p><strong>Integration with Word Break:</strong></p>
<ul>
  <li>If the input is “thequickbrown”, Norvig’s approach fails (too many edits).</li>
  <li>We first run <strong>Word Break</strong>.</li>
  <li>If Word Break fails, we try to correct <em>subsegments</em>.</li>
  <li>“thequikbrown” -&gt; “the” (valid) + “quik” (invalid) + “brown” (valid).</li>
  <li>
    <p>Run spell check on “quik” -&gt; “quick”.</p>
  </li>
  <li><strong>Use Case:</strong> Chinese/Japanese tokenization baselines.</li>
</ul>

<h2 id="18-deep-dive-suffix-trees-and-suffix-arrays">18. Deep Dive: Suffix Trees and Suffix Arrays</h2>

<p>While Tries are great for dictionary lookups, <strong>Suffix Trees</strong> are the ultimate tool for substring problems.</p>

<p><strong>Suffix Tree:</strong></p>
<ul>
  <li>A compressed Trie of <em>all suffixes</em> of a text $T$.</li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>Can check if $P$ is a substring of $T$ in $O(</td>
          <td>P</td>
          <td>)$.</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li><strong>Construction:</strong> Ukkonen’s Algorithm ($O(N)$). Complex to implement.</li>
</ul>

<p><strong>Suffix Array:</strong></p>
<ul>
  <li>An array of integers representing the starting indices of all suffixes of $T$, sorted lexicographically.</li>
  <li><strong>Example:</strong> <code class="language-plaintext highlighter-rouge">banana</code>
    <ul>
      <li>Suffixes: <code class="language-plaintext highlighter-rouge">banana</code>, <code class="language-plaintext highlighter-rouge">anana</code>, <code class="language-plaintext highlighter-rouge">nana</code>, <code class="language-plaintext highlighter-rouge">ana</code>, <code class="language-plaintext highlighter-rouge">na</code>, <code class="language-plaintext highlighter-rouge">a</code>.</li>
      <li>Sorted: <code class="language-plaintext highlighter-rouge">a</code> (5), <code class="language-plaintext highlighter-rouge">ana</code> (3), <code class="language-plaintext highlighter-rouge">anana</code> (1), <code class="language-plaintext highlighter-rouge">banana</code> (0), <code class="language-plaintext highlighter-rouge">na</code> (4), <code class="language-plaintext highlighter-rouge">nana</code> (2).</li>
      <li>SA: <code class="language-plaintext highlighter-rouge">[5, 3, 1, 0, 4, 2]</code>.</li>
    </ul>
  </li>
  <li><strong>LCP Array (Longest Common Prefix):</strong> Stores length of LCP between adjacent suffixes in SA.</li>
  <li><strong>Usage in Word Break:</strong>
    <ul>
      <li>If we concatenate all dictionary words into a mega-string $D$, we can build a Suffix Array.</li>
      <li>We can find occurrences of dictionary words in $S$ using binary search on the SA.</li>
    </ul>
  </li>
</ul>

<h2 id="19-deep-dive-rabin-karp-algorithm-rolling-hash">19. Deep Dive: Rabin-Karp Algorithm (Rolling Hash)</h2>

<p>For the “substring check” step in the DP ($s[j:i] \in \text{Dict}$), we can use hashing.</p>

<p><strong>Rolling Hash:</strong></p>
<ul>
  <li>Compute hash of window $s[j:i]$ in $O(1)$ using the hash of $s[j:i-1]$.</li>
  <li>$H(s[j:i]) = (H(s[j:i-1]) \times B + s[i]) \pmod M$.</li>
</ul>

<p><strong>Algorithm:</strong></p>
<ol>
  <li>Compute hashes of all dictionary words and store in a Set ($O(L)$).</li>
  <li>For each starting position $j$ in $s$:
    <ul>
      <li>Compute rolling hashes for substrings starting at $j$.</li>
      <li>If hash matches, do a full string check (to avoid collisions).</li>
      <li>Update DP.</li>
    </ul>
  </li>
</ol>

<p><strong>Pros:</strong> Faster than slicing if many words have same length.
<strong>Cons:</strong> Hash collisions.</p>

<h2 id="20-system-design-scalable-autocomplete-system">20. System Design: Scalable Autocomplete System</h2>

<p><strong>Scenario:</strong> Type “word br…” -&gt; Suggest “word break”, “word break ii”.</p>

<p><strong>Requirements:</strong></p>
<ul>
  <li><strong>Latency:</strong> &lt; 50ms (p99).</li>
  <li><strong>Throughput:</strong> 50k QPS.</li>
  <li><strong>Freshness:</strong> New trending queries appear within minutes.</li>
</ul>

<p><strong>Architecture:</strong></p>

<ol>
  <li><strong>Data Structure:</strong>
    <ul>
      <li><strong>Trie:</strong> Nodes store characters.</li>
      <li><strong>Top-K Cache:</strong> Each node stores the top 5 most popular completions ending in that subtree.</li>
      <li><strong>Optimization:</strong> Store pointers to DB IDs instead of full strings to save RAM.</li>
    </ul>
  </li>
  <li><strong>Storage:</strong>
    <ul>
      <li><strong>Redis:</strong> In-memory Trie for hot prefixes.</li>
      <li><strong>Cassandra:</strong> Persistent storage of query logs and frequencies.</li>
    </ul>
  </li>
  <li><strong>Ranking Service:</strong>
    <ul>
      <li>Score = $w_1 \cdot \text{Frequency} + w_2 \cdot \text{Recency} + w_3 \cdot \text{Personalization}$.</li>
      <li>Offline job (Spark) updates frequencies hourly.</li>
    </ul>
  </li>
  <li><strong>Handling Typos (Fuzzy Search):</strong>
    <ul>
      <li>If exact prefix not found, search nodes within Edit Distance 1.</li>
      <li>Use <strong>Levenshtein Automata</strong>.</li>
    </ul>
  </li>
</ol>

<h2 id="21-advanced-parallel-word-break-mapreduce">21. Advanced: Parallel Word Break (MapReduce)</h2>

<p><strong>Problem:</strong> Segment a genome string of length $10^9$.</p>
<ul>
  <li>DP is $O(N^2)$, too slow.</li>
  <li>Dependencies: $dp[i]$ depends on $dp[j]$.</li>
</ul>

<p><strong>Parallel Algorithm:</strong></p>
<ol>
  <li><strong>Split:</strong> Divide string into chunks of size $K$ (e.g., 1MB).</li>
  <li><strong>Map:</strong> For each chunk, compute a <strong>Transition Matrix</strong> or <strong>Reachability Graph</strong>.
    <ul>
      <li>Input: Possible start states (offsets into the chunk).</li>
      <li>Output: Possible end states (offsets out of the chunk).</li>
    </ul>
  </li>
  <li><strong>Reduce:</strong> Multiply matrices (or compose graphs) to find reachability from start of string to end.</li>
</ol>

<p><strong>Matrix Multiplication (Tropical Semiring):</strong></p>
<ul>
  <li>$(A \otimes B)<em>{ij} = \max_k (A</em>{ik} + B_{kj})$.</li>
  <li>Allows combining partial segmentations.</li>
</ul>

<h2 id="22-deep-dive-generalized-word-break-2d-grid">22. Deep Dive: Generalized Word Break (2D Grid)</h2>

<p><strong>Problem:</strong> Given a 2D grid of characters (Boggle), find if a word exists.</p>
<ul>
  <li>This is <strong>DFS/Backtracking</strong>, not standard DP.</li>
</ul>

<p><strong>Optimization:</strong></p>
<ul>
  <li>Build Trie of dictionary words.</li>
  <li>Start DFS from every cell.</li>
  <li>Pass current Trie node to neighbor.</li>
  <li><strong>Pruning:</strong> If current path is not a prefix of <em>any</em> word (Trie node is None), stop.</li>
</ul>

<p><strong>Complexity:</strong> $O(R \cdot C \cdot 4^L)$, where $L$ is max word length.</p>

<h2 id="23-interview-questions-hard">23. Interview Questions (Hard)</h2>

<p><strong>Q4: Word Break III - Minimum Cost Segmentation</strong>
<em>Problem:</em> Each word has a cost. Insert spaces to minimize total cost.
<em>Solution:</em> <code class="language-plaintext highlighter-rouge">dp[i] = min(dp[j] + cost(s[j:i]))</code>. Use Trie to find valid <code class="language-plaintext highlighter-rouge">s[j:i]</code>.</p>

<p><strong>Q5: Palindrome Partitioning</strong>
<em>Problem:</em> Split string such that every substring is a palindrome.
<em>Solution:</em> Similar to Word Break. Precompute <code class="language-plaintext highlighter-rouge">isPalindrome[j][i]</code> in $O(N^2)$. Then <code class="language-plaintext highlighter-rouge">dp[i] = min(dp[j] + 1)</code> if <code class="language-plaintext highlighter-rouge">isPalindrome[j][i]</code>.</p>

<p><strong>Q6: Word Break with Wildcards</strong>
<em>Problem:</em> <code class="language-plaintext highlighter-rouge">s</code> contains <code class="language-plaintext highlighter-rouge">?</code> which can be any char.
<em>Solution:</em> Trie traversal matches all children for <code class="language-plaintext highlighter-rouge">?</code>. DP state remains same.</p>

<p><strong>Q7: Streaming Word Break</strong>
<em>Problem:</em> <code class="language-plaintext highlighter-rouge">s</code> comes in as a stream. Return True as soon as a valid segmentation is possible for current prefix.
<em>Solution:</em> Maintain a set of “active” Trie pointers. For each new char, advance all pointers. If any pointer reaches “is_end”, add Root to active set.</p>

<p><strong>Q8: Longest Word in Dictionary that can be built from other words</strong>
<em>Problem:</em> Given list of words, find longest one made of other words in list.
<em>Solution:</em> Sort by length. For each word, run <code class="language-plaintext highlighter-rouge">WordBreak(word, dict \ {word})</code>. First one that returns True is answer.</p>

<h2 id="24-interview-questions">24. Interview Questions</h2>

<p><strong>Q1: How to handle very large dictionaries that don’t fit in RAM?</strong>
<em>Answer:</em></p>
<ul>
  <li><strong>Disk-based Trie:</strong> Store Trie nodes on disk (B-Tree).</li>
  <li><strong>Bloom Filter:</strong> Keep a Bloom filter in RAM to rule out non-existent words quickly.</li>
  <li><strong>Sharding:</strong> Split dictionary by prefix (A-M on Server 1, N-Z on Server 2).</li>
</ul>

<p><strong>Q2: What if the dictionary words have costs? Find min cost segmentation.</strong>
<em>Answer:</em></p>
<ul>
  <li>Modify DP: <code class="language-plaintext highlighter-rouge">dp[i] = min(dp[j] + cost(s[j:i]))</code> for valid <code class="language-plaintext highlighter-rouge">j</code>.</li>
  <li>This becomes a Shortest Path problem on the DAG.</li>
</ul>

<p><strong>Q3: Word Break with a limit on number of words?</strong>
<em>Answer:</em></p>
<ul>
  <li>Add a state to DP: <code class="language-plaintext highlighter-rouge">dp[i][k]</code> = True if <code class="language-plaintext highlighter-rouge">s[0...i]</code> can be segmented into exactly <code class="language-plaintext highlighter-rouge">k</code> words.</li>
</ul>

<h2 id="25-common-mistakes">25. Common Mistakes</h2>
<ol>
  <li><strong>Greedy Approach:</strong> Trying to match the longest word first. Fails for <code class="language-plaintext highlighter-rouge">s="goals"</code>, <code class="language-plaintext highlighter-rouge">dict=["go", "goal", "goals", "ls"]</code>. Greedy takes “goals”, leaves “”. Correct. Wait, <code class="language-plaintext highlighter-rouge">s="aaaa"</code>, <code class="language-plaintext highlighter-rouge">dict=["aaaa", "aaa"]</code>. Greedy takes “aaaa”. Correct.
    <ul>
      <li>Counter-example: <code class="language-plaintext highlighter-rouge">s="abcd"</code>, <code class="language-plaintext highlighter-rouge">dict=["ab", "abc", "cd", "d"]</code>. Greedy takes “abc”, leaves “d”. Valid.</li>
      <li>Counter-example: <code class="language-plaintext highlighter-rouge">s="abcd"</code>, <code class="language-plaintext highlighter-rouge">dict=["a", "abc", "b", "cd"]</code>. Greedy takes “abc”, leaves “d” (fail). Correct is “a”, “b”, “cd”.</li>
    </ul>
  </li>
  <li><strong>Infinite Recursion:</strong> Forgetting to memoize. $O(2^N)$ complexity.</li>
  <li><strong>Off-by-one Errors:</strong> String slicing <code class="language-plaintext highlighter-rouge">s[start:end]</code> vs <code class="language-plaintext highlighter-rouge">s[start:end+1]</code>.</li>
</ol>

<h2 id="26-performance-benchmarking">26. Performance Benchmarking</h2>

<p><strong>Scenario:</strong> <code class="language-plaintext highlighter-rouge">s</code> length 1000, Dictionary size 10,000.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">Approach</th>
      <th style="text-align: left">Time</th>
      <th style="text-align: left">Space</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left"><strong>Recursion (No Memo)</strong></td>
      <td style="text-align: left">Timeout</td>
      <td style="text-align: left">$O(N)$</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>Recursion + Memo</strong></td>
      <td style="text-align: left">50ms</td>
      <td style="text-align: left">$O(N)$</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>Tabulation</strong></td>
      <td style="text-align: left">45ms</td>
      <td style="text-align: left">$O(N)$</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>Trie Optimization</strong></td>
      <td style="text-align: left">15ms</td>
      <td style="text-align: left">$O(M \cdot K)$</td>
    </tr>
  </tbody>
</table>

<p><strong>Takeaway:</strong> Trie optimization is crucial when the dictionary is large and string operations are the bottleneck.</p>

<h2 id="27-ethical-considerations">27. Ethical Considerations</h2>

<p><strong>1. Content Filtering:</strong></p>
<ul>
  <li>Word Break is used to detect “bypassed” profanity (e.g., “assassin” -&gt; “ass assin”).</li>
  <li><strong>Risk:</strong> Scunthorpe problem (blocking valid words).</li>
  <li><strong>Mitigation:</strong> Context-aware filtering, allow-lists.</li>
</ul>

<p><strong>2. Search Segmentation Bias:</strong></p>
<ul>
  <li>If “blacklivesmatter” is segmented as “black lives matter” vs “black lives mattering”, it affects search results.</li>
  <li><strong>Impact:</strong> Can suppress or amplify social movements.</li>
</ul>

<h2 id="28-further-reading">28. Further Reading</h2>

<ol>
  <li><strong>“Speech and Language Processing” (Jurafsky &amp; Martin):</strong> Chapter on N-grams and Tokenization.</li>
  <li><strong>“Introduction to Information Retrieval” (Manning):</strong> Tokenization strategies.</li>
  <li><strong>“Aho-Corasick Algorithm”:</strong> Efficient string matching.</li>
</ol>

<h2 id="29-conclusion">29. Conclusion</h2>

<p>Word Break is more than just a DP problem; it’s the foundation of how computers understand continuous text. Whether it’s a search engine parsing your query, a spell checker fixing your typos, or a content filter scanning for banned words, the ability to segment strings efficiently is critical. By mastering the DP approach and optimizing with Tries, you gain the tools to handle text at scale.</p>

<h2 id="30-summary">30. Summary</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: left">Approach</th>
      <th style="text-align: left">Time</th>
      <th style="text-align: left">Space</th>
      <th style="text-align: left">Notes</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left"><strong>Recursion + Memo</strong></td>
      <td style="text-align: left">$O(N^3)$</td>
      <td style="text-align: left">$O(N)$</td>
      <td style="text-align: left">Easy to implement</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>Tabulation</strong></td>
      <td style="text-align: left">$O(N^3)$</td>
      <td style="text-align: left">$O(N)$</td>
      <td style="text-align: left">Iterative, avoids stack overflow</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>BFS</strong></td>
      <td style="text-align: left">$O(N^3)$</td>
      <td style="text-align: left">$O(N)$</td>
      <td style="text-align: left">Graph perspective</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>Trie</strong></td>
      <td style="text-align: left">$O(N^2)$</td>
      <td style="text-align: left">$O(MK)$</td>
      <td style="text-align: left">Fastest for large dicts</td>
    </tr>
  </tbody>
</table>

<hr />

<p><strong>Originally published at:</strong> <a href="https://www.arunbaby.com/dsa/0039-word-break/">arunbaby.com/dsa/0039-word-break</a></p>

        
      </section>

      <footer class="page__meta">
        
        
  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-tags" aria-hidden="true"></i> Tags: </strong>
    <span itemprop="keywords">
    
      <a href="/tags/#bfs" class="page__taxonomy-item p-category" rel="tag">bfs</a><span class="sep">, </span>
    
      <a href="/tags/#dynamic-programming" class="page__taxonomy-item p-category" rel="tag">dynamic-programming</a><span class="sep">, </span>
    
      <a href="/tags/#string" class="page__taxonomy-item p-category" rel="tag">string</a><span class="sep">, </span>
    
      <a href="/tags/#trie" class="page__taxonomy-item p-category" rel="tag">trie</a>
    
    </span>
  </p>




  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> Categories: </strong>
    <span itemprop="keywords">
    
      <a href="/categories/#dsa" class="page__taxonomy-item p-category" rel="tag">dsa</a>
    
    </span>
  </p>


        
      </footer>

      

      <section class="page__share">
  <h4 class="page__share-title">Share on</h4>

  <a href="https://twitter.com/intent/tweet?via=arunbaby0&text=Word+Break%20https%3A%2F%2Fwww.arunbaby.com%2Fdsa%2F0039-word-break%2F" class="btn btn--twitter" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Twitter"><i class="fab fa-fw fa-twitter" aria-hidden="true"></i><span> Twitter</span></a>

  <a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fwww.arunbaby.com%2Fdsa%2F0039-word-break%2F" class="btn btn--facebook" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Facebook"><i class="fab fa-fw fa-facebook" aria-hidden="true"></i><span> Facebook</span></a>

  <a href="https://www.linkedin.com/shareArticle?mini=true&url=https://www.arunbaby.com/dsa/0039-word-break/" class="btn btn--linkedin" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on LinkedIn"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i><span> LinkedIn</span></a>
</section>


      
  <nav class="pagination">
    
      <a href="/dsa/0038-coin-change/" class="pagination--pager" title="Coin Change (Unbounded Knapsack)">Previous</a>
    
    
      <a href="/dsa/0040-trapping-rain-water/" class="pagination--pager" title="Trapping Rain Water">Next</a>
    
  </nav>


    </div>

    
  </article>

  
  
</div>

      
    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';" role="search">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Enter your search term..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    

    
      
        
          <li><a href="https://twitter.com/arunbaby0" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-twitter-square" aria-hidden="true"></i> Twitter</a></li>
        
      
        
          <li><a href="https://github.com/arunbaby0" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
        
      
        
          <li><a href="https://www.linkedin.com/in/arunbaby0/" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i> LinkedIn</a></li>
        
      
        
          <li><a href="https://scholar.google.co.in/citations?user=6fSYWhkAAAAJ" rel="nofollow noopener noreferrer"><i class="fas fa-fw fa-graduation-cap" aria-hidden="true"></i> Google Scholar</a></li>
        
      
    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 1990 - 2143 <a href="https://www.arunbaby.com">Arun Baby</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>




  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-0JRJPEC9SS"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-0JRJPEC9SS', { 'anonymize_ip': false});
</script>








  </body>
</html>
