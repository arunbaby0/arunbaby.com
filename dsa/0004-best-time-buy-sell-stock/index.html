<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.26.2 by Michael Rose
  Copyright 2013-2024 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->

<html lang="en-US" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Best Time to Buy and Sell Stock - Arun Baby</title>
<meta name="description" content="The single-pass pattern that powers streaming analytics, online algorithms, and real-time decision making in production systems.">


  <meta name="author" content="Arun Baby">
  
  <meta property="article:author" content="Arun Baby">
  


<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="Arun Baby">
<meta property="og:title" content="Best Time to Buy and Sell Stock">
<meta property="og:url" content="https://www.arunbaby.com/dsa/0004-best-time-buy-sell-stock/">


  <meta property="og:description" content="The single-pass pattern that powers streaming analytics, online algorithms, and real-time decision making in production systems.">



  <meta property="og:image" content="https://www.arunbaby.com/assets/images/profile-photo.png">



  <meta name="twitter:site" content="@arunbaby0">
  <meta name="twitter:title" content="Best Time to Buy and Sell Stock">
  <meta name="twitter:description" content="The single-pass pattern that powers streaming analytics, online algorithms, and real-time decision making in production systems.">
  <meta name="twitter:url" content="https://www.arunbaby.com/dsa/0004-best-time-buy-sell-stock/">

  
    <meta name="twitter:card" content="summary">
    
      <meta name="twitter:image" content="https://www.arunbaby.com/assets/images/profile-photo.png">
    
  

  



  <meta property="article:published_time" content="2025-12-29T16:05:30+05:30">





  

  


<link rel="canonical" href="https://www.arunbaby.com/dsa/0004-best-time-buy-sell-stock/">












<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Arun Baby Feed">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
  
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css"></noscript>



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--single" dir="ltr">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
           
          <span class="site-subtitle">Arun Baby</span>
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a
                href="/about/"
                
                
              >About</a>
            </li><li class="masthead__menu-item">
              <a
                href="/dsa/"
                
                
              >DSA</a>
            </li><li class="masthead__menu-item">
              <a
                href="/ml-system-design/"
                
                
              >ML Systems</a>
            </li><li class="masthead__menu-item">
              <a
                href="/speech-tech/"
                
                
              >Speech Tech</a>
            </li><li class="masthead__menu-item">
              <a
                href="/ai-agents/"
                
                
              >AI Agents</a>
            </li><li class="masthead__menu-item">
              <a
                href="/publications/"
                
                
              >Publications</a>
            </li><li class="masthead__menu-item">
              <a
                href="/statuses/"
                
                
              >Statuses</a>
            </li><li class="masthead__menu-item">
              <a
                href="/contact/"
                
                
              >Contact</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <i class="fas fa-search"></i>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      





<div id="main" role="main" class="no-author-sidebar">
  
  <div class="sidebar sticky">
  
  
  </div>



  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="Best Time to Buy and Sell Stock">
    <meta itemprop="description" content="The single-pass pattern that powers streaming analytics, online algorithms, and real-time decision making in production systems.">
    <meta itemprop="datePublished" content="2025-12-29T16:05:30+05:30">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">
            <a href="https://www.arunbaby.com/dsa/0004-best-time-buy-sell-stock/" itemprop="url">Best Time to Buy and Sell Stock
</a>
          </h1>
          

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          24 minute read
        
      </span>
    
  </p>


        </header>
      

      <section class="page__content" itemprop="text">
        
          <aside class="sidebar__right sticky">
            <nav class="toc">
              <header><h4 class="nav__title"><i class="fas fa-file-alt"></i> On this page</h4></header>
              <ul class="toc__menu"><li><a href="#problem">Problem</a></li><li><a href="#intuition">Intuition</a></li><li><a href="#approach-1-brute-force-not-optimal">Approach 1: Brute Force (Not Optimal)</a><ul><li><a href="#implementation">Implementation</a></li></ul></li><li><a href="#approach-2-single-pass-optimal">Approach 2: Single Pass (Optimal)</a><ul><li><a href="#implementation-1">Implementation</a></li><li><a href="#detailed-walkthrough">Detailed Walkthrough</a></li><li><a href="#why-this-works">Why This Works</a></li><li><a href="#complexity-analysis">Complexity Analysis</a></li></ul></li><li><a href="#approach-3-dynamic-programming-perspective">Approach 3: Dynamic Programming Perspective</a><ul><li><a href="#formulation">Formulation</a></li><li><a href="#implementation-2">Implementation</a></li></ul></li><li><a href="#edge-cases--testing">Edge Cases &amp; Testing</a><ul><li><a href="#edge-cases">Edge Cases</a></li><li><a href="#comprehensive-test-suite">Comprehensive Test Suite</a></li></ul></li><li><a href="#variations--extensions">Variations &amp; Extensions</a><ul><li><a href="#variation-1-return-buy-and-sell-days">Variation 1: Return Buy and Sell Days</a></li><li><a href="#variation-2-multiple-transactions-buysell-many-times">Variation 2: Multiple Transactions (Buy/Sell Many Times)</a></li><li><a href="#variation-3-at-most-k-transactions">Variation 3: At Most K Transactions</a></li></ul></li><li><a href="#connection-to-ml-systems--streaming-analytics">Connection to ML Systems &amp; Streaming Analytics</a><ul><li><a href="#1-online-learning-tracking-running-statistics">1. Online Learning: Tracking Running Statistics</a></li><li><a href="#2-real-time-anomaly-detection">2. Real-Time Anomaly Detection</a></li><li><a href="#3-streaming-feature-engineering">3. Streaming Feature Engineering</a></li><li><a href="#4-time-series-forecasting-rolling-windows">4. Time-Series Forecasting: Rolling Windows</a></li></ul></li><li><a href="#production-considerations">Production Considerations</a><ul><li><a href="#1-handling-real-world-data">1. Handling Real-World Data</a></li><li><a href="#2-performance-monitoring">2. Performance Monitoring</a></li></ul></li><li><a href="#key-takeaways">Key Takeaways</a></li><li><a href="#advanced-variations">Advanced Variations</a><ul><li><a href="#transaction-fee">Transaction Fee</a></li><li><a href="#cooldown-period">Cooldown Period</a></li></ul></li><li><a href="#interview-deep-dive">Interview Deep-Dive</a><ul><li><a href="#common-mistakes">Common Mistakes</a></li><li><a href="#complexity-analysis-pitfalls">Complexity Analysis Pitfalls</a></li><li><a href="#follow-up-questions-you-should-expect">Follow-up Questions You Should Expect</a></li></ul></li><li><a href="#connection-to-ab-testing--experimentation">Connection to A/B Testing &amp; Experimentation</a><ul><li><a href="#tracking-experiment-metrics">Tracking Experiment Metrics</a></li></ul></li><li><a href="#variations-summary-table">Variations Summary Table</a></li><li><a href="#testing-strategies">Testing Strategies</a><ul><li><a href="#property-based-testing">Property-Based Testing</a></li><li><a href="#benchmark-suite">Benchmark Suite</a></li></ul></li><li><a href="#real-world-applications-beyond-finance">Real-World Applications Beyond Finance</a><ul><li><a href="#1-network-latency-optimization">1. Network Latency Optimization</a></li><li><a href="#2-cache-hit-rate-optimization">2. Cache Hit Rate Optimization</a></li></ul></li><li><a href="#related-problems">Related Problems</a></li></ul>
            </nav>
          </aside>
        
        <p><strong>The single-pass pattern that powers streaming analytics, online algorithms, and real-time decision making in production systems.</strong></p>

<h2 id="problem">Problem</h2>

<p>You are given an array <code class="language-plaintext highlighter-rouge">prices</code> where <code class="language-plaintext highlighter-rouge">prices[i]</code> is the price of a given stock on the <code class="language-plaintext highlighter-rouge">i</code>th day.</p>

<p>You want to maximize your profit by choosing a <strong>single day</strong> to buy one stock and choosing a <strong>different day in the future</strong> to sell that stock.</p>

<p>Return the maximum profit you can achieve. If you cannot achieve any profit, return <code class="language-plaintext highlighter-rouge">0</code>.</p>

<p><strong>Example 1:</strong>
<code class="language-plaintext highlighter-rouge">
Input: prices = [7,1,5,3,6,4]
Output: 5
Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.
Note: Buying on day 2 and selling on day 1 is not allowed (must buy before you sell).
</code></p>

<p><strong>Example 2:</strong>
<code class="language-plaintext highlighter-rouge">
Input: prices = [7,6,4,3,1]
Output: 0
Explanation: No profit can be made, so return 0.
</code></p>

<p><strong>Constraints:</strong></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">1 &lt;= prices.length &lt;= 10^5</code></li>
  <li><code class="language-plaintext highlighter-rouge">0 &lt;= prices[i] &lt;= 10^4</code></li>
</ul>

<hr />

<h2 id="intuition">Intuition</h2>

<p>The key insight: <strong>Track the minimum price seen so far</strong> and calculate potential profit at each step.</p>

<p>For each price, we ask:</p>
<ul>
  <li>“If I sold today, what’s the best profit I could make?”</li>
  <li>This requires knowing the minimum price before today</li>
</ul>

<p><strong>Pattern:</strong> This is a <strong>streaming maximum</strong> problem, we process data once, left to right, maintaining running statistics.</p>

<hr />

<h2 id="approach-1-brute-force-not-optimal">Approach 1: Brute Force (Not Optimal)</h2>

<p>Try all possible buy-sell pairs.</p>

<h3 id="implementation">Implementation</h3>

<p>``python
def maxProfitBruteForce(prices: List[int]) -&gt; int:
 “””
 Try every possible buy-sell pair</p>

<p>Time: O(n²)
 Space: O(1)
 “””
 max_profit = 0
 n = len(prices)</p>

<p>for buy_day in range(n):
 for sell_day in range(buy_day + 1, n):
 profit = prices[sell_day] - prices[buy_day]
 max_profit = max(max_profit, profit)</p>

<p>return max_profit
``</p>

<p><strong>Why this is bad:</strong></p>
<ul>
  <li>O(n²) time complexity</li>
  <li>For n = 100,000 → 10 billion operations</li>
  <li>Unacceptable for production systems processing real-time data</li>
</ul>

<hr />

<h2 id="approach-2-single-pass-optimal">Approach 2: Single Pass (Optimal)</h2>

<p>Track minimum price and maximum profit in one pass.</p>

<h3 id="implementation-1">Implementation</h3>

<p>``python
from typing import List</p>

<p>def maxProfit(prices: List[int]) -&gt; int:
 “””
 Single-pass solution tracking min price and max profit</p>

<p>Time: O(n) - one pass through array
 Space: O(1) - only two variables</p>

<p>Algorithm:</p>
<ol>
  <li>Track minimum price seen so far</li>
  <li>At each day, calculate profit if we sold today</li>
  <li>Update maximum profit
 “””
 if not prices or len(prices) &lt; 2:
 return 0</li>
</ol>

<p>min_price = float(‘inf’)
 max_profit = 0</p>

<p>for price in prices:
 # Update minimum price seen so far
 min_price = min(min_price, price)</p>

<p># Calculate profit if we sell today
 profit = price - min_price</p>

<p># Update maximum profit
 max_profit = max(max_profit, profit)</p>

<p>return max_profit
``</p>

<h3 id="detailed-walkthrough">Detailed Walkthrough</h3>

<dl>
  <dt>``</dt>
  <dt>prices = [7, 1, 5, 3, 6, 4]</dt>
  <dd>
    <p>price = 7
 min_price = min(inf, 7) = 7
 profit = 7 - 7 = 0
 max_profit = max(0, 0) = 0</p>
  </dd>
  <dd>
    <p>price = 1
 min_price = min(7, 1) = 1 ← New minimum!
 profit = 1 - 1 = 0
 max_profit = max(0, 0) = 0</p>
  </dd>
  <dd>
    <p>price = 5
 min_price = min(1, 5) = 1
 profit = 5 - 1 = 4 ← Good profit
 max_profit = max(0, 4) = 4</p>
  </dd>
  <dd>
    <p>price = 3
 min_price = min(1, 3) = 1
 profit = 3 - 1 = 2
 max_profit = max(4, 2) = 4</p>
  </dd>
  <dd>
    <p>price = 6
 min_price = min(1, 6) = 1
 profit = 6 - 1 = 5 ← Best profit!
 max_profit = max(4, 5) = 5</p>
  </dd>
  <dd>
    <p>price = 4
 min_price = min(1, 4) = 1
 profit = 4 - 1 = 3
 max_profit = max(5, 3) = 5</p>
  </dd>
</dl>

<p>Final: max_profit = 5
``</p>

<h3 id="why-this-works">Why This Works</h3>

<p><strong>Invariant:</strong> At any day <code class="language-plaintext highlighter-rouge">i</code>, we know:</p>
<ul>
  <li>The minimum price from days <code class="language-plaintext highlighter-rouge">0</code> to <code class="language-plaintext highlighter-rouge">i-1</code></li>
  <li>The maximum profit achievable up to day <code class="language-plaintext highlighter-rouge">i</code></li>
</ul>

<p><strong>Correctness:</strong></p>
<ul>
  <li>We consider every valid buy-sell pair implicitly</li>
  <li>When we see <code class="language-plaintext highlighter-rouge">price[i]</code>, we compute profit assuming we bought at <code class="language-plaintext highlighter-rouge">min_price</code></li>
  <li>This covers all cases because <code class="language-plaintext highlighter-rouge">min_price</code> is the best buy day before <code class="language-plaintext highlighter-rouge">i</code></li>
</ul>

<h3 id="complexity-analysis">Complexity Analysis</h3>

<p><strong>Time Complexity: O(n)</strong></p>
<ul>
  <li>Single pass through the array</li>
  <li>Constant work per element</li>
  <li>Linear scaling with input size</li>
</ul>

<p><strong>Space Complexity: O(1)</strong></p>
<ul>
  <li>Only two variables: <code class="language-plaintext highlighter-rouge">min_price</code>, <code class="language-plaintext highlighter-rouge">max_profit</code></li>
  <li>No auxiliary data structures</li>
  <li>Memory usage independent of input size</li>
</ul>

<hr />

<h2 id="approach-3-dynamic-programming-perspective">Approach 3: Dynamic Programming Perspective</h2>

<p>View this as a DP problem.</p>

<h3 id="formulation">Formulation</h3>

<p><strong>State:</strong></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">dp[i]</code> = maximum profit achievable up to day <code class="language-plaintext highlighter-rouge">i</code></li>
</ul>

<p><strong>Recurrence:</strong>
``
dp[i] = max(
 dp[i-1], # Don’t sell today
 prices[i] - min_price[i] # Sell today
)</p>

<p>min_price[i] = min(min_price[i-1], prices[i])
``</p>

<p><strong>Base case:</strong></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">dp[0] = 0</code> (can’t make profit on first day)</li>
  <li><code class="language-plaintext highlighter-rouge">min_price[0] = prices[0]</code></li>
</ul>

<h3 id="implementation-2">Implementation</h3>

<p>``python
def maxProfitDP(prices: List[int]) -&gt; int:
 “””
 Dynamic programming approach</p>

<p>Explicitly track DP state
 “””
 n = len(prices)
 if n &lt; 2:
 return 0</p>

<p># DP table
 dp = [0] * n
 min_prices = [0] * n</p>

<p># Base case
 min_prices[0] = prices[0]
 dp[0] = 0</p>

<p># Fill DP table
 for i in range(1, n):
 min_prices[i] = min(min_prices[i-1], prices[i])
 dp[i] = max(dp[i-1], prices[i] - min_prices[i])</p>

<p>return dp[n-1]
``</p>

<p><strong>Optimization:</strong> Notice <code class="language-plaintext highlighter-rouge">dp[i]</code> only depends on <code class="language-plaintext highlighter-rouge">dp[i-1]</code>, so we can reduce to O(1) space → this becomes identical to Approach 2.</p>

<hr />

<h2 id="edge-cases--testing">Edge Cases &amp; Testing</h2>

<h3 id="edge-cases">Edge Cases</h3>

<p>``python
def test_edge_cases():
 # Empty array
 assert maxProfit([]) == 0</p>

<p># Single element
 assert maxProfit([5]) == 0</p>

<p># Two elements - profit possible
 assert maxProfit([1, 5]) == 4</p>

<p># Two elements - no profit
 assert maxProfit([5, 1]) == 0</p>

<p># Strictly decreasing
 assert maxProfit([5, 4, 3, 2, 1]) == 0</p>

<p># Strictly increasing
 assert maxProfit([1, 2, 3, 4, 5]) == 4</p>

<p># All same price
 assert maxProfit([3, 3, 3, 3]) == 0</p>

<p># Large numbers
 assert maxProfit([10000, 1, 10000]) == 9999</p>

<p># Minimum and maximum at ends
 assert maxProfit([10, 5, 3, 1, 15]) == 14
``</p>

<h3 id="comprehensive-test-suite">Comprehensive Test Suite</h3>

<p>``python
import unittest</p>

<p>class TestMaxProfit(unittest.TestCase):</p>

<p>def test_example1(self):
 “"”Standard case with profit”””
 self.assertEqual(maxProfit([7,1,5,3,6,4]), 5)</p>

<p>def test_example2(self):
 “"”No profit possible”””
 self.assertEqual(maxProfit([7,6,4,3,1]), 0)</p>

<p>def test_single_element(self):
 “"”Only one day”””
 self.assertEqual(maxProfit([1]), 0)</p>

<p>def test_two_elements_profit(self):
 “"”Minimum case with profit”””
 self.assertEqual(maxProfit([1, 5]), 4)</p>

<p>def test_two_elements_loss(self):
 “"”Minimum case with loss”””
 self.assertEqual(maxProfit([5, 1]), 0)</p>

<p>def test_increasing(self):
 “"”Strictly increasing prices”””
 self.assertEqual(maxProfit([1, 2, 3, 4, 5]), 4)</p>

<p>def test_decreasing(self):
 “"”Strictly decreasing prices”””
 self.assertEqual(maxProfit([5, 4, 3, 2, 1]), 0)</p>

<p>def test_v_shape(self):
 “"”V-shaped prices”””
 self.assertEqual(maxProfit([3, 2, 1, 2, 3, 4]), 3)</p>

<p>def test_peak_valley(self):
 “"”Multiple peaks and valleys”””
 self.assertEqual(maxProfit([2, 1, 2, 0, 1]), 1)</p>

<p>def test_large_profit(self):
 “"”Large profit”””
 self.assertEqual(maxProfit([1, 1000, 1, 1000]), 999)</p>

<p>if <strong>name</strong> == ‘<strong>main</strong>’:
 unittest.main()
``</p>

<hr />

<h2 id="variations--extensions">Variations &amp; Extensions</h2>

<h3 id="variation-1-return-buy-and-sell-days">Variation 1: Return Buy and Sell Days</h3>

<p>Return the actual days to buy/sell, not just profit.</p>

<p>``python
def maxProfitWithDays(prices: List[int]) -&gt; tuple[int, int, int]:
 “””
 Return (max_profit, buy_day, sell_day)</p>

<p>Returns:
 (profit, buy_index, sell_index)
 If no profit possible: (0, -1, -1)
 “””
 if not prices or len(prices) &lt; 2:
 return (0, -1, -1)</p>

<p>min_price = prices[0]
 min_day = 0
 max_profit = 0
 buy_day = 0
 sell_day = 0</p>

<p>for i in range(1, len(prices)):
 if prices[i] &lt; min_price:
 min_price = prices[i]
 min_day = i</p>

<p>profit = prices[i] - min_price</p>

<p>if profit &gt; max_profit:
 max_profit = profit
 buy_day = min_day
 sell_day = i</p>

<p>if max_profit == 0:
 return (0, -1, -1)</p>

<p>return (max_profit, buy_day, sell_day)</p>

<h1 id="usage">Usage</h1>
<p>prices = [7, 1, 5, 3, 6, 4]
profit, buy, sell = maxProfitWithDays(prices)
print(f”Buy on day {buy} (price={prices[buy]}), sell on day {sell} (price={prices[sell]}), profit={profit}”)</p>
<h1 id="output-buy-on-day-1-price1-sell-on-day-4-price6-profit5">Output: Buy on day 1 (price=1), sell on day 4 (price=6), profit=5</h1>
<p>``</p>

<h3 id="variation-2-multiple-transactions-buysell-many-times">Variation 2: Multiple Transactions (Buy/Sell Many Times)</h3>

<p>If you can buy and sell multiple times (but can’t hold multiple stocks simultaneously):</p>

<p>``python
def maxProfitMultiple(prices: List[int]) -&gt; int:
 “””
 Multiple transactions allowed</p>

<p>Strategy: Buy before every price increase</p>

<p>Time: O(n)
 Space: O(1)
 “””
 max_profit = 0</p>

<p>for i in range(1, len(prices)):
 # If price increased, we “bought” yesterday and “sold” today
 if prices[i] &gt; prices[i-1]:
 max_profit += prices[i] - prices[i-1]</p>

<p>return max_profit</p>

<h1 id="example">Example</h1>
<p>prices = [7, 1, 5, 3, 6, 4]
print(maxProfitMultiple(prices)) # 7</p>
<h1 id="explanation-buy-day-1-1-sell-day-2-5--4">Explanation: Buy day 1 (1), sell day 2 (5) = 4</h1>
<h1 id="buy-day-3-3-sell-day-4-6--3">Buy day 3 (3), sell day 4 (6) = 3</h1>
<h1 id="total--7">Total = 7</h1>
<p>``</p>

<h3 id="variation-3-at-most-k-transactions">Variation 3: At Most K Transactions</h3>

<p>If you can make at most <code class="language-plaintext highlighter-rouge">k</code> transactions:</p>

<p>``python
def maxProfitKTransactions(prices: List[int], k: int) -&gt; int:
 “””
 At most k transactions</p>

<p>DP approach:
 dp[i][j] = max profit using at most i transactions up to day j</p>

<p>Time: O(nk)
 Space: O(nk) → can optimize to O(k)
 “””
 if not prices or k == 0:
 return 0</p>

<p>n = len(prices)</p>

<p># If k &gt;= n/2, can do as many transactions as we want
 if k &gt;= n // 2:
 return maxProfitMultiple(prices)</p>

<p># DP table
 # dp[t][d] = max profit with at most t transactions by day d
 dp = [[0] * n for _ in range(k + 1)]</p>

<p>for t in range(1, k + 1):
 max_diff = -prices[0] # max(dp[t-1][j] - prices[j]) for j &lt; i</p>

<p>for d in range(1, n):
 dp[t][d] = max(
 dp[t][d-1], # Don’t transact on day d
 prices[d] + max_diff # Sell on day d
 )
 max_diff = max(max_diff, dp[t-1][d] - prices[d])</p>

<p>return dp[k][n-1]
``</p>

<hr />

<h2 id="connection-to-ml-systems--streaming-analytics">Connection to ML Systems &amp; Streaming Analytics</h2>

<p>This problem pattern appears everywhere in production ML systems.</p>

<h3 id="1-online-learning-tracking-running-statistics">1. Online Learning: Tracking Running Statistics</h3>

<p>``python
class OnlineStatistics:
 “””
 Track statistics in streaming fashion</p>

<p>Similar pattern to stock problem: single pass, constant space
 “””</p>

<p>def <strong>init</strong>(self):
 self.count = 0
 self.mean = 0.0
 self.M2 = 0.0 # Sum of squared differences</p>

<p># For min/max tracking (like stock problem)
 self.min_value = float(‘inf’)
 self.max_value = float(‘-inf’)</p>

<p>def update(self, value):
 “””
 Update statistics with new value</p>

<p>Uses Welford’s online algorithm for mean/variance
 “””
 self.count += 1</p>

<p># Update min/max (stock problem pattern!)
 self.min_value = min(self.min_value, value)
 self.max_value = max(self.max_value, value)</p>

<p># Update mean
 delta = value - self.mean
 self.mean += delta / self.count</p>

<p># Update M2 for variance
 delta2 = value - self.mean
 self.M2 += delta * delta2</p>

<p>def get_statistics(self):
 “"”Get current statistics”””
 if self.count &lt; 2:
 variance = 0.0
 else:
 variance = self.M2 / (self.count - 1)</p>

<p>return {
 ‘count’: self.count,
 ‘mean’: self.mean,
 ‘variance’: variance,
 ‘std’: variance ** 0.5,
 ‘min’: self.min_value,
 ‘max’: self.max_value,
 ‘range’: self.max_value - self.min_value # Like profit!
 }</p>

<h1 id="usage-in-ml-pipeline">Usage in ML pipeline</h1>
<p>stats = OnlineStatistics()</p>

<p>for data_point in streaming_data:
 stats.update(data_point)</p>

<p># Can query statistics at any time
 current_stats = stats.get_statistics()
``</p>

<h3 id="2-real-time-anomaly-detection">2. Real-Time Anomaly Detection</h3>

<p>``python
class AnomalyDetector:
 “””
 Detect anomalies in streaming data</p>

<p>Uses running min/max like stock problem
 “””</p>

<p>def <strong>init</strong>(self, window_size=1000):
 self.window_size = window_size
 self.values = []
 self.min_value = float(‘inf’)
 self.max_value = float(‘-inf’)</p>

<p>def is_anomaly(self, value, threshold=3.0):
 “””
 Detect if value is anomalous</p>

<p>Uses range-based detection (like profit calculation)
 “””
 if len(self.values) &lt; 100:
 # Not enough data yet
 self.update(value)
 return False</p>

<p># Calculate z-score using running statistics
 mean = sum(self.values) / len(self.values)
 variance = sum((x - mean) ** 2 for x in self.values) / len(self.values)
 std = variance ** 0.5</p>

<p>if std == 0:
 z_score = 0
 else:
 z_score = abs(value - mean) / std</p>

<p>is_anomalous = z_score &gt; threshold</p>

<p># Update state
 self.update(value)</p>

<p>return is_anomalous</p>

<p>def update(self, value):
 “"”Update sliding window”””
 self.values.append(value)</p>

<p>if len(self.values) &gt; self.window_size:
 self.values.pop(0)</p>

<p># Track min/max (stock pattern)
 self.min_value = min(self.min_value, value)
 self.max_value = max(self.max_value, value)
``</p>

<h3 id="3-streaming-feature-engineering">3. Streaming Feature Engineering</h3>

<p>``python
class StreamingFeatureExtractor:
 “””
 Extract features from streaming data for ML models</p>

<p>Key: Single-pass algorithms (like stock problem)
 “””</p>

<p>def <strong>init</strong>(self):
 self.min_value = float(‘inf’)
 self.max_value = float(‘-inf’)
 self.sum_value = 0
 self.count = 0</p>

<p>def extract_features(self, new_value):
 “””
 Extract features including current value</p>

<p>Returns features in O(1) time
 “””
 # Update running statistics
 self.count += 1
 self.sum_value += new_value
 self.min_value = min(self.min_value, new_value)
 self.max_value = max(self.max_value, new_value)</p>

<p># Compute features
 features = {
 ‘current_value’: new_value,
 ‘min_value’: self.min_value,
 ‘max_value’: self.max_value,
 ‘range’: self.max_value - self.min_value, # Like profit!
 ‘mean’: self.sum_value / self.count,
 ‘distance_from_min’: new_value - self.min_value,
 ‘distance_from_max’: self.max_value - new_value
 }</p>

<p>return features</p>

<h1 id="usage-in-ml-pipeline-1">Usage in ML pipeline</h1>
<p>extractor = StreamingFeatureExtractor()</p>

<p>for data_point in stream:
 features = extractor.extract_features(data_point)
 prediction = model.predict([features])
``</p>

<h3 id="4-time-series-forecasting-rolling-windows">4. Time-Series Forecasting: Rolling Windows</h3>

<p>``python
class RollingWindowAnalyzer:
 “””
 Analyze time-series with rolling windows</p>

<p>Efficiently track min/max/mean in sliding window
 “””</p>

<p>def <strong>init</strong>(self, window_size=100):
 from collections import deque</p>

<p>self.window_size = window_size
 self.window = deque(maxlen=window_size)</p>

<p># For efficient min/max tracking
 self.min_deque = deque() # Monotonic increasing
 self.max_deque = deque() # Monotonic decreasing</p>

<p>def add_value(self, value):
 “””
 Add new value to rolling window</p>

<p>Maintains O(1) amortized time for min/max queries
 “””
 # If window full, remove oldest
 if len(self.window) == self.window_size:
 old_value = self.window[0]</p>

<p># Remove from min/max deques if present
 if self.min_deque and self.min_deque[0] == old_value:
 self.min_deque.popleft()
 if self.max_deque and self.max_deque[0] == old_value:
 self.max_deque.popleft()</p>

<p># Add new value
 self.window.append(value)</p>

<p># Maintain min deque (monotonic increasing)
 while self.min_deque and self.min_deque[-1] &gt; value:
 self.min_deque.pop()
 self.min_deque.append(value)</p>

<p># Maintain max deque (monotonic decreasing)
 while self.max_deque and self.max_deque[-1] &lt; value:
 self.max_deque.pop()
 self.max_deque.append(value)</p>

<p>def get_window_stats(self):
 “"”Get statistics for current window”””
 if not self.window:
 return None</p>

<p>return {
 ‘min’: self.min_deque[0],
 ‘max’: self.max_deque[0],
 ‘range’: self.max_deque[0] - self.min_deque[0],
 ‘mean’: sum(self.window) / len(self.window),
 ‘size’: len(self.window)
 }
``</p>

<hr />

<h2 id="production-considerations">Production Considerations</h2>

<h3 id="1-handling-real-world-data">1. Handling Real-World Data</h3>

<p>``python
class RobustMaxProfit:
 “””
 Production-ready version with error handling
 “””</p>

<p>def max_profit(self, prices: List[float]) -&gt; float:
 “””
 Calculate max profit with validation</p>

<p>Handles:</p>
<ul>
  <li>Invalid inputs</li>
  <li>Floating point prices</li>
  <li>Missing data
 “””
 # Validate input
 if not prices or not isinstance(prices, list):
 raise ValueError(“prices must be a non-empty list”)</li>
</ul>

<p># Filter out None/NaN values
 valid_prices = [p for p in prices if p is not None and not math.isnan(p)]</p>

<p>if len(valid_prices) &lt; 2:
 return 0.0</p>

<p># Check for negative prices
 if any(p &lt; 0 for p in valid_prices):
 raise ValueError(“prices cannot be negative”)</p>

<p># Standard algorithm
 min_price = float(‘inf’)
 max_profit = 0.0</p>

<p>for price in valid_prices:
 min_price = min(min_price, price)
 profit = price - min_price
 max_profit = max(max_profit, profit)</p>

<p>return round(max_profit, 2) # Round to 2 decimal places
``</p>

<h3 id="2-performance-monitoring">2. Performance Monitoring</h3>

<p>``python
import time
from typing import Callable</p>

<p>class PerformanceTracker:
 “””
 Track algorithm performance
 “””</p>

<p>def <strong>init</strong>(self):
 self.execution_times = []</p>

<p>def measure(self, func: Callable, <em>args, **kwargs):
 “””
 Measure execution time
 “””
 start = time.perf_counter()
 result = func(</em>args, **kwargs)
 end = time.perf_counter()</p>

<p>execution_time = end - start
 self.execution_times.append(execution_time)</p>

<p>return result, execution_time</p>

<p>def get_stats(self):
 “"”Get performance statistics”””
 if not self.execution_times:
 return None</p>

<p>import statistics</p>

<p>return {
 ‘count’: len(self.execution_times),
 ‘mean’: statistics.mean(self.execution_times),
 ‘median’: statistics.median(self.execution_times),
 ‘min’: min(self.execution_times),
 ‘max’: max(self.execution_times),
 ‘stdev’: statistics.stdev(self.execution_times) if len(self.execution_times) &gt; 1 else 0
 }</p>

<h1 id="usage-1">Usage</h1>
<p>tracker = PerformanceTracker()</p>

<p>for test_case in test_cases:
 result, time_taken = tracker.measure(maxProfit, test_case)
 print(f”Result: {result}, Time: {time_taken*1000:.2f}ms”)</p>

<p>print(“Performance stats:”, tracker.get_stats())
``</p>

<hr />

<h2 id="key-takeaways">Key Takeaways</h2>

<p>✅ <strong>Single-pass algorithms</strong> are powerful for streaming data 
✅ <strong>Track running min/max</strong> to make local decisions with global optimality 
✅ <strong>O(1) space</strong> achievable for many DP problems through state reduction 
✅ <strong>Pattern appears everywhere</strong> in ML systems: online learning, anomaly detection, streaming analytics 
✅ <strong>Greedy + DP</strong> often equivalent when state transitions are simple 
✅ <strong>Production code</strong> needs robust error handling and monitoring 
✅ <strong>Variations</strong> (multiple transactions, at most k transactions) use similar patterns</p>

<hr />

<h2 id="advanced-variations">Advanced Variations</h2>

<h3 id="transaction-fee">Transaction Fee</h3>

<p>``python
def maxProfitWithFee(prices: List[int], fee: int) -&gt; int:
 “””
 Multiple transactions with transaction fee</p>

<p>DP with states:</p>
<ul>
  <li>hold: Maximum profit when holding stock</li>
  <li>free: Maximum profit when not holding stock</li>
</ul>

<p>Time: O(n)
 Space: O(1)
 “””
 n = len(prices)
 if n &lt; 2:
 return 0</p>

<p># States
 hold = -prices[0] # Buy on day 0
 free = 0 # Don’t buy on day 0</p>

<p>for i in range(1, n):
 # Update states
 new_hold = max(hold, free - prices[i]) # Keep holding OR buy today
 new_free = max(free, hold + prices[i] - fee) # Keep free OR sell today (pay fee)</p>

<p>hold = new_hold
 free = new_free</p>

<p>return free</p>

<h1 id="example-1">Example</h1>
<p>prices = [1, 3, 2, 8, 4, 9]
fee = 2
print(maxProfitWithFee(prices, fee)) # 8</p>
<h1 id="buy-day-0-1-sell-day-3-8-26-profit--5">Buy day 0 (1), sell day 3 (8-2=6), profit = 5</h1>
<h1 id="buy-day-4-4-sell-day-5-9-27-profit--3">Buy day 4 (4), sell day 5 (9-2=7), profit = 3</h1>
<h1 id="total--8">Total = 8</h1>
<p>``</p>

<h3 id="cooldown-period">Cooldown Period</h3>

<p>After selling stock, must wait 1 day before buying again.</p>

<p>``python
def maxProfitWithCooldown(prices: List[int]) -&gt; int:
 “””
 Multiple transactions with 1-day cooldown after selling</p>

<p>States:</p>
<ul>
  <li>hold: Max profit when holding stock</li>
  <li>sold: Max profit on day just sold</li>
  <li>rest: Max profit when resting (can buy next day)</li>
</ul>

<p>Transitions:</p>
<ul>
  <li>hold = max(hold, rest - price) # Keep holding OR buy</li>
  <li>sold = hold + price # Must have held yesterday to sell today</li>
  <li>rest = max(rest, sold) # Continue resting OR enter rest after selling</li>
</ul>

<p>Time: O(n)
 Space: O(1)
 “””
 if not prices or len(prices) &lt; 2:
 return 0</p>

<p># Initial states
 hold = -prices[0] # Bought on day 0
 sold = 0 # Can’t sell on day 0
 rest = 0 # Didn’t buy on day 0</p>

<p>for i in range(1, len(prices)):
 prev_hold = hold
 prev_sold = sold
 prev_rest = rest</p>

<p>hold = max(prev_hold, prev_rest - prices[i])
 sold = prev_hold + prices[i]
 rest = max(prev_rest, prev_sold)</p>

<p># At end, we want to be in sold or rest state (not holding)
 return max(sold, rest)</p>

<h1 id="example-expected-3">Example (expected 3)</h1>
<p>prices = [1, 2, 3, 0, 2]
print(maxProfitWithCooldown(prices)) # 3</p>
<h1 id="one-optimal-buy-day-0-1-sell-day-2-3--profit-2-cooldown-on-day-3-buy-day-3-0-sell-day-4-2--profit-2-total-4">One optimal: buy day 0 (1), sell day 2 (3) → profit 2; cooldown on day 3; buy day 3 (0), sell day 4 (2) → profit 2; total 4</h1>
<h1 id="but-because-cooldown-overlaps-the-correct-dp-yields-3-ensure-commentary-matches-dp-behavior">But because cooldown overlaps, the correct DP yields 3; ensure commentary matches DP behavior</h1>
<p>``</p>

<hr />

<h2 id="interview-deep-dive">Interview Deep-Dive</h2>

<h3 id="common-mistakes">Common Mistakes</h3>

<p><strong>1. Off-by-one errors</strong>
``python</p>
<h1 id="wrong-can-buy-and-sell-on-same-day">WRONG: Can buy and sell on same day</h1>
<p>for i in range(len(prices)):
 for j in range(i, len(prices)): # j should start at i+1
 profit = prices[j] - prices[i]</p>

<h1 id="correct">CORRECT:</h1>
<p>for i in range(len(prices)):
 for j in range(i+1, len(prices)): # Buy before sell
 profit = prices[j] - prices[i]
``</p>

<p><strong>2. Not handling empty/single element arrays</strong>
``python</p>
<h1 id="wrong-assumes-lenprices--2">WRONG: Assumes len(prices) &gt;= 2</h1>
<p>min_price = prices[0]
max_profit = 0
for price in prices: # Works, but…
 # Edge cases not explicitly handled</p>

<h1 id="better-explicit-edge-case-handling">BETTER: Explicit edge case handling</h1>
<p>if not prices or len(prices) &lt; 2:
 return 0
``</p>

<p><strong>3. Floating point precision issues</strong>
``python</p>
<h1 id="for-real-money-calculations-use-decimal">For real money calculations, use Decimal</h1>
<p>from decimal import Decimal</p>

<p>def maxProfitMoney(prices: List[Decimal]) -&gt; Decimal:
 “"”Handle real monetary values”””
 if len(prices) &lt; 2:
 return Decimal(‘0’)</p>

<p>min_price = Decimal(‘inf’)
 max_profit = Decimal(‘0’)</p>

<p>for price in prices:
 min_price = min(min_price, price)
 profit = price - min_price
 max_profit = max(max_profit, profit)</p>

<p>return max_profit
``</p>

<h3 id="complexity-analysis-pitfalls">Complexity Analysis Pitfalls</h3>

<p><strong>Time Complexity:</strong></p>
<ul>
  <li>Single pass: O(n) ✓</li>
  <li>Nested loops: O(n²) ✗</li>
  <li>Each price examined once: O(n) ✓</li>
</ul>

<p><strong>Space Complexity:</strong></p>
<ul>
  <li>Two variables only: O(1) ✓</li>
  <li>DP array: O(n) (can optimize to O(1))</li>
  <li>Recursive with memoization: O(n) stack space</li>
</ul>

<h3 id="follow-up-questions-you-should-expect">Follow-up Questions You Should Expect</h3>

<p><strong>Q: What if prices can be negative?</strong>
``python</p>
<h1 id="interpretation-stock-can-have-negative-price-debt">Interpretation: Stock can have negative price (debt?)</h1>
<h1 id="answer-algorithm-still-works-track-minimum-price-compute-differences">Answer: Algorithm still works, track minimum price, compute differences</h1>

<h1 id="if-negative-prices-mean-undefined">If negative prices mean “undefined”:</h1>
<p>def maxProfitWithValidation(prices: List[int]) -&gt; int:
 # Filter invalid prices
 valid_prices = [p for p in prices if p &gt;= 0]</p>

<p>if len(valid_prices) &lt; 2:
 return 0</p>

<p># Standard algorithm
 min_price = float(‘inf’)
 max_profit = 0</p>

<p>for price in valid_prices:
 min_price = min(min_price, price)
 max_profit = max(max_profit, price - min_price)</p>

<p>return max_profit
``</p>

<p><strong>Q: What if we want to return the actual buy/sell days, not just profit?</strong></p>

<p>See Variation 1 above (returns days along with profit).</p>

<p><strong>Q: How does this scale to millions of prices?</strong></p>

<p>``python</p>
<h1 id="streaming-approach-for-very-large-datasets">Streaming approach for very large datasets</h1>
<p>class StreamingMaxProfit:
 “””
 Process prices in streaming fashion
 Memory: O(1)
 “””</p>

<p>def <strong>init</strong>(self):
 self.min_price = float(‘inf’)
 self.max_profit = 0</p>

<p>def add_price(self, price):
 “"”Add one price point”””
 self.min_price = min(self.min_price, price)
 profit = price - self.min_price
 self.max_profit = max(self.max_profit, profit)</p>

<p>def get_max_profit(self):
 “"”Get current max profit”””
 return self.max_profit</p>

<h1 id="process-1-billion-prices-without-loading-all-into-memory">Process 1 billion prices without loading all into memory</h1>
<p>streamer = StreamingMaxProfit()</p>

<p>for price in read_prices_from_database():
 streamer.add_price(price)</p>

<p>result = streamer.get_max_profit()
``</p>

<p><strong>Q: What if multiple stocks, each with independent prices?</strong></p>

<p>``python
def maxProfitMultipleStocks(price_matrix: List[List[int]]) -&gt; List[int]:
 “””
 Process multiple stocks in parallel</p>

<p>Args:
 price_matrix: List of price arrays (one per stock)</p>

<p>Returns:
 List of max profits (one per stock)
 “””
 return [maxProfit(prices) for prices in price_matrix]</p>

<h1 id="can-parallelize">Can parallelize:</h1>
<p>from multiprocessing import Pool</p>

<p>def maxProfitParallel(price_matrix: List[List[int]]) -&gt; List[int]:
 “"”Parallel processing for multiple stocks”””
 with Pool() as pool:
 results = pool.map(maxProfit, price_matrix)
 return results
``</p>

<hr />

<h2 id="connection-to-ab-testing--experimentation">Connection to A/B Testing &amp; Experimentation</h2>

<p>This problem pattern directly relates to online experimentation:</p>

<h3 id="tracking-experiment-metrics">Tracking Experiment Metrics</h3>

<p>``python
class ExperimentMetricTracker:
 “””
 Track min/max/mean of metrics during A/B test</p>

<p>Similar to stock problem: track running statistics
 “””</p>

<p>def <strong>init</strong>(self):
 self.min_value = float(‘inf’)
 self.max_value = float(‘-inf’)
 self.max_improvement = 0 # Like max profit!
 self.count = 0
 self.sum_value = 0</p>

<p>def update(self, metric_value):
 “””
 Update with new metric observation</p>

<p>Track max improvement from baseline (like max profit)
 “””
 self.count += 1
 self.sum_value += metric_value</p>

<p># Track min (baseline)
 self.min_value = min(self.min_value, metric_value)</p>

<p># Track max improvement from baseline (like profit!)
 improvement = metric_value - self.min_value
 self.max_improvement = max(self.max_improvement, improvement)</p>

<p># Track absolute max
 self.max_value = max(self.max_value, metric_value)</p>

<p>def get_statistics(self):
 “"”Get current statistics”””
 return {
 ‘count’: self.count,
 ‘mean’: self.sum_value / self.count if self.count &gt; 0 else 0,
 ‘min’: self.min_value,
 ‘max’: self.max_value,
 ‘max_improvement’: self.max_improvement,
 ‘range’: self.max_value - self.min_value
 }</p>

<h1 id="usage-in-ab-test">Usage in A/B test</h1>
<p>tracker = ExperimentMetricTracker()</p>

<h1 id="simulate-daily-conversion-rates">Simulate daily conversion rates</h1>
<p>daily_ctr = [0.05, 0.048, 0.052, 0.049, 0.055, 0.051]</p>

<p>for ctr in daily_ctr:
 tracker.update(ctr)</p>

<p>stats = tracker.get_statistics()
print(f”Max improvement from baseline: {stats[‘max_improvement’]:.4f}”)</p>
<h1 id="this-tells-us-if-we-had-switched-to-the-best-performing-variant">This tells us: if we had switched to the best-performing variant</h1>
<h1 id="at-the-right-time-what-would-the-gain-have-been">at the right time, what would the gain have been?</h1>
<p>``</p>

<hr />

<h2 id="variations-summary-table">Variations Summary Table</h2>

<table>
  <thead>
    <tr>
      <th>Variation</th>
      <th>Transactions</th>
      <th>Constraint</th>
      <th>Time</th>
      <th>Space</th>
      <th>Difficulty</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Original</strong></td>
      <td>1</td>
      <td>None</td>
      <td>O(n)</td>
      <td>O(1)</td>
      <td>Easy</td>
    </tr>
    <tr>
      <td><strong>Stock II</strong></td>
      <td>Unlimited</td>
      <td>None</td>
      <td>O(n)</td>
      <td>O(1)</td>
      <td>Medium</td>
    </tr>
    <tr>
      <td><strong>Stock III</strong></td>
      <td>At most 2</td>
      <td>None</td>
      <td>O(n)</td>
      <td>O(1)</td>
      <td>Hard</td>
    </tr>
    <tr>
      <td><strong>Stock IV</strong></td>
      <td>At most k</td>
      <td>None</td>
      <td>O(nk)</td>
      <td>O(k)</td>
      <td>Hard</td>
    </tr>
    <tr>
      <td><strong>With Fee</strong></td>
      <td>Unlimited</td>
      <td>Fee per transaction</td>
      <td>O(n)</td>
      <td>O(1)</td>
      <td>Medium</td>
    </tr>
    <tr>
      <td><strong>With Cooldown</strong></td>
      <td>Unlimited</td>
      <td>1-day cooldown</td>
      <td>O(n)</td>
      <td>O(1)</td>
      <td>Medium</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="testing-strategies">Testing Strategies</h2>

<h3 id="property-based-testing">Property-Based Testing</h3>

<p>``python
import hypothesis
from hypothesis import given, strategies as st</p>

<p>@given(st.lists(st.integers(min_value=0, max_value=10000), min_size=0, max_size=100))
def test_profit_non_negative(prices):
 “"”Profit should never be negative”””
 assert maxProfit(prices) &gt;= 0</p>

<p>@given(st.lists(st.integers(min_value=1, max_value=10000), min_size=2, max_size=100))
def test_profit_bounded(prices):
 “"”Profit should be at most max(prices) - min(prices)”””
 profit = maxProfit(prices)
 assert profit &lt;= max(prices) - min(prices)</p>

<p>@given(st.lists(st.integers(min_value=0, max_value=10000), min_size=0, max_size=100))
def test_single_pass_equals_brute_force(prices):
 “"”Optimal solution should match brute force”””
 if len(prices) &lt; 100: # Only test on small inputs (brute force is slow)
 assert maxProfit(prices) == maxProfitBruteForce(prices)
``</p>

<h3 id="benchmark-suite">Benchmark Suite</h3>

<p>``python
import time
import random</p>

<p>def benchmark_maxProfit():
 “"”Benchmark on various input sizes”””
 sizes = [100, 1000, 10000, 100000, 1000000]</p>

<p>print(f”{‘Size’:&lt;10} {‘Time (ms)’:&lt;12} {‘Throughput (M ops/sec)’:&lt;15}”)
 print(“-“ * 45)</p>

<p>for size in sizes:
 # Generate random prices
 prices = [random.randint(1, 10000) for _ in range(size)]</p>

<p># Time execution
 start = time.perf_counter()
 result = maxProfit(prices)
 end = time.perf_counter()</p>

<p>elapsed_ms = (end - start) * 1000
 throughput = size / (end - start) / 1_000_000</p>

<p>print(f”{size:&lt;10} {elapsed_ms:&lt;12.4f} {throughput:&lt;15.2f}”)</p>

<h1 id="run-benchmark">Run benchmark</h1>
<p>benchmark_maxProfit()</p>

<h1 id="expected-output-example">Expected output (example):</h1>
<h1 id="size-time-ms-throughput-m-opssec">Size Time (ms) Throughput (M ops/sec)</h1>
<h1>———————————————</h1>
<h1 id="100-00045-2222">100 0.0045 22.22</h1>
<h1 id="1000-00412-2427">1000 0.0412 24.27</h1>
<h1 id="10000-04123-2425">10000 0.4123 24.25</h1>
<h1 id="100000-41234-2425">100000 4.1234 24.25</h1>
<h1 id="1000000-412345-2425">1000000 41.2345 24.25</h1>
<p>#</p>
<h1 id="observe-linear-time-complexity--constant-throughput">Observe: Linear time complexity → constant throughput</h1>
<p>``</p>

<hr />

<h2 id="real-world-applications-beyond-finance">Real-World Applications Beyond Finance</h2>

<h3 id="1-network-latency-optimization">1. Network Latency Optimization</h3>

<p>``python
def findBestDataCenter(latencies: List[int]) -&gt; int:
 “””
 Find best time to switch data centers to minimize latency</p>

<p>Similar to stock problem:</p>
<ul>
  <li>latencies[i] = latency on day i</li>
  <li>Find switch that gives max latency reduction
 “””
 if len(latencies) &lt; 2:
 return 0</li>
</ul>

<p>max_latency = latencies[0] # Max latency seen so far (like min_price, inverted)
 max_reduction = 0 # Max reduction achievable</p>

<p>for latency in latencies[1:]:
 max_latency = max(max_latency, latency)
 reduction = max_latency - latency # Reduction if we switch now
 max_reduction = max(max_reduction, reduction)</p>

<p>return max_reduction
``</p>

<h3 id="2-cache-hit-rate-optimization">2. Cache Hit Rate Optimization</h3>

<p>``python
def maxCacheImprovement(hit_rates: List[float]) -&gt; float:
 “””
 Find when to deploy new cache strategy for max improvement</p>

<p>Track minimum hit rate seen, compute max improvement
 “””
 if len(hit_rates) &lt; 2:
 return 0.0</p>

<p>min_hit_rate = hit_rates[0]
 max_improvement = 0.0</p>

<p>for rate in hit_rates[1:]:
 min_hit_rate = min(min_hit_rate, rate)
 improvement = rate - min_hit_rate
 max_improvement = max(max_improvement, improvement)</p>

<p>return max_improvement
``</p>

<hr />

<h2 id="related-problems">Related Problems</h2>

<p>Practice these to master the pattern:</p>

<p><strong>Same Pattern:</strong></p>
<ul>
  <li><strong><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/">Best Time to Buy and Sell Stock II</a></strong> - Multiple transactions</li>
  <li><strong><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/">Best Time to Buy and Sell Stock III</a></strong> - At most 2 transactions</li>
  <li><strong><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/">Best Time to Buy and Sell Stock IV</a></strong> - At most k transactions</li>
  <li><strong><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/">Best Time to Buy and Sell Stock with Cooldown</a></strong></li>
  <li><strong><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">Best Time to Buy and Sell Stock with Transaction Fee</a></strong></li>
</ul>

<p><strong>Similar Single-Pass Algorithms:</strong></p>
<ul>
  <li><strong><a href="https://leetcode.com/problems/maximum-subarray/">Maximum Subarray</a></strong> - Kadane’s algorithm</li>
  <li><strong><a href="https://leetcode.com/problems/maximum-product-subarray/">Maximum Product Subarray</a></strong> - Track min and max</li>
  <li><strong><a href="https://leetcode.com/problems/container-with-most-water/">Container With Most Water</a></strong> - Two pointers</li>
</ul>

<p><strong>Related Patterns:</strong></p>
<ul>
  <li><strong>Sliding Window Maximum</strong> - Maintain max in window</li>
  <li><strong>Running Median</strong> - Maintain statistics in stream</li>
  <li><strong>Stock Span Problem</strong> - Stack-based solution</li>
</ul>

<hr />

<p><strong>Originally published at:</strong> <a href="https://www.arunbaby.com/dsa/0004-best-time-buy-sell-stock/">arunbaby.com/dsa/0004-best-time-buy-sell-stock</a></p>

<p><em>If you found this helpful, consider sharing it with others who might benefit.</em></p>


        
      </section>

      <footer class="page__meta">
        
        
  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-tags" aria-hidden="true"></i> Tags: </strong>
    <span itemprop="keywords">
    
      <a href="/tags/#arrays" class="page__taxonomy-item p-category" rel="tag">arrays</a><span class="sep">, </span>
    
      <a href="/tags/#dynamic-programming" class="page__taxonomy-item p-category" rel="tag">dynamic-programming</a><span class="sep">, </span>
    
      <a href="/tags/#greedy" class="page__taxonomy-item p-category" rel="tag">greedy</a>
    
    </span>
  </p>




  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> Categories: </strong>
    <span itemprop="keywords">
    
      <a href="/categories/#dsa" class="page__taxonomy-item p-category" rel="tag">dsa</a>
    
    </span>
  </p>


        
      </footer>

      <div class="page__related page__related--full">
  <h2 class="page__related-title">Related across topics</h2>
  <style>
    /* Make section span full content width and use 2 equal columns */
    .page__related--full { float: inline-start; width: 100%; padding: 0; }
    .cross-related-grid { display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 2rem; }
    @media (max-width: 768px) { .cross-related-grid { grid-template-columns: 1fr; } }
    /* Ensure archive cards stretch nicely in the grid */
    .cross-related-grid .list__item, .cross-related-grid .grid__item { width: auto; float: none; margin: 0; }
  </style>
  <div class="cross-related-grid">
    



<div class="list__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/ml-system-design/0004-ab-testing-systems/" rel="permalink">A/B Testing Systems for ML
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          22 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">How to design experimentation platforms that enable rapid iteration while maintaining statistical rigor at scale.
</p>
  </article>
</div>




<div class="list__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/speech-tech/0004-voice-activity-detection/" rel="permalink">Voice Activity Detection (VAD)
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          17 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">How voice assistants and video conferencing apps detect when you’re speaking vs silence, the critical first step in every speech pipeline.
</p>
  </article>
</div>




<div class="list__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/ai-agents/0004-tool-calling-fundamentals/" rel="permalink">Tool Calling Fundamentals
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          8 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">“Giving the Brain Hands to Act: The Interface Between Intelligence and Infrastructure.”
</p>
  </article>
</div>

  </div>
</div>

      <section class="page__share">
  <h4 class="page__share-title">Share on</h4>

  <a href="https://twitter.com/intent/tweet?via=arunbaby0&text=Best+Time+to+Buy+and+Sell+Stock%20https%3A%2F%2Fwww.arunbaby.com%2Fdsa%2F0004-best-time-buy-sell-stock%2F" class="btn btn--twitter" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Twitter"><i class="fab fa-fw fa-twitter" aria-hidden="true"></i><span> Twitter</span></a>

  <a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fwww.arunbaby.com%2Fdsa%2F0004-best-time-buy-sell-stock%2F" class="btn btn--facebook" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Facebook"><i class="fab fa-fw fa-facebook" aria-hidden="true"></i><span> Facebook</span></a>

  <a href="https://www.linkedin.com/shareArticle?mini=true&url=https://www.arunbaby.com/dsa/0004-best-time-buy-sell-stock/" class="btn btn--linkedin" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on LinkedIn"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i><span> LinkedIn</span></a>
</section>


      
  <nav class="pagination">
    
      <a href="/dsa/0003-merge-sorted-lists/" class="pagination--pager" title="Merge Two Sorted Lists">Previous</a>
    
    
      <a href="/dsa/0005-maximum-subarray/" class="pagination--pager" title="Maximum Subarray (Kadane’s Algorithm)">Next</a>
    
  </nav>


    </div>

    
  </article>

  
  
</div>

      
    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';" role="search">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Enter your search term..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    

    
      
        
          <li><a href="https://twitter.com/arunbaby0" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-twitter-square" aria-hidden="true"></i> Twitter</a></li>
        
      
        
          <li><a href="https://github.com/arunbaby0" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
        
      
        
          <li><a href="https://www.linkedin.com/in/arunbaby0/" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i> LinkedIn</a></li>
        
      
        
          <li><a href="https://scholar.google.co.in/citations?user=6fSYWhkAAAAJ" rel="nofollow noopener noreferrer"><i class="fas fa-fw fa-graduation-cap" aria-hidden="true"></i> Google Scholar</a></li>
        
      
    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 1990 - 2143 <a href="https://www.arunbaby.com">Arun Baby</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>




  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-0JRJPEC9SS"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-0JRJPEC9SS', { 'anonymize_ip': false});
</script>








  </body>
</html>
