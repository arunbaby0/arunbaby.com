<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.26.2 by Michael Rose
  Copyright 2013-2024 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->

<html lang="en-US" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Minimum Path Sum - Arun Baby</title>
<meta name="description" content="The classic grid optimization problem that bridges the gap between simple recursion and 2D Dynamic Programming.">


  <meta name="author" content="Arun Baby">
  
  <meta property="article:author" content="Arun Baby">
  


<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="Arun Baby">
<meta property="og:title" content="Minimum Path Sum">
<meta property="og:url" content="https://www.arunbaby.com/dsa/0022-minimum-path-sum/">


  <meta property="og:description" content="The classic grid optimization problem that bridges the gap between simple recursion and 2D Dynamic Programming.">



  <meta property="og:image" content="https://www.arunbaby.com/assets/images/profile-photo.png">



  <meta name="twitter:site" content="@arunbaby0">
  <meta name="twitter:title" content="Minimum Path Sum">
  <meta name="twitter:description" content="The classic grid optimization problem that bridges the gap between simple recursion and 2D Dynamic Programming.">
  <meta name="twitter:url" content="https://www.arunbaby.com/dsa/0022-minimum-path-sum/">

  
    <meta name="twitter:card" content="summary">
    
      <meta name="twitter:image" content="https://www.arunbaby.com/assets/images/profile-photo.png">
    
  

  



  <meta property="article:published_time" content="2025-12-01T10:50:00+05:30">





  

  


<link rel="canonical" href="https://www.arunbaby.com/dsa/0022-minimum-path-sum/">












<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Arun Baby Feed">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
  
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css"></noscript>



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--single" dir="ltr">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
           
          <span class="site-subtitle">Arun Baby</span>
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a
                href="/about/"
                
                
              >About</a>
            </li><li class="masthead__menu-item">
              <a
                href="/dsa/"
                
                
              >DSA</a>
            </li><li class="masthead__menu-item">
              <a
                href="/ml-system-design/"
                
                
              >ML Systems</a>
            </li><li class="masthead__menu-item">
              <a
                href="/speech-tech/"
                
                
              >Speech Tech</a>
            </li><li class="masthead__menu-item">
              <a
                href="/publications/"
                
                
              >Publications</a>
            </li><li class="masthead__menu-item">
              <a
                href="/statuses/"
                
                
              >Statuses</a>
            </li><li class="masthead__menu-item">
              <a
                href="/contact/"
                
                
              >Contact</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <i class="fas fa-search"></i>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      





<div id="main" role="main" class="no-author-sidebar">
  
  <div class="sidebar sticky">
  
  
  </div>



  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="Minimum Path Sum">
    <meta itemprop="description" content="The classic grid optimization problem that bridges the gap between simple recursion and 2D Dynamic Programming.">
    <meta itemprop="datePublished" content="2025-12-01T10:50:00+05:30">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">
            <a href="https://www.arunbaby.com/dsa/0022-minimum-path-sum/" itemprop="url">Minimum Path Sum
</a>
          </h1>
          

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          21 minute read
        
      </span>
    
  </p>


        </header>
      

      <section class="page__content" itemprop="text">
        
          <aside class="sidebar__right sticky">
            <nav class="toc">
              <header><h4 class="nav__title"><i class="fas fa-file-alt"></i> On this page</h4></header>
              <ul class="toc__menu"><li><a href="#problem">Problem</a></li><li><a href="#thematic-connection-path-finding-and-cost-minimization">Thematic Connection: Path Finding and Cost Minimization</a></li><li><a href="#mathematical-foundation">Mathematical Foundation</a><ul><li><a href="#1-optimal-substructure">1. Optimal Substructure</a></li><li><a href="#2-overlapping-subproblems">2. Overlapping Subproblems</a></li></ul></li><li><a href="#approach-1-brute-force-recursion">Approach 1: Brute Force Recursion</a><ul><li><a href="#base-cases">Base Cases</a></li><li><a href="#python-implementation-recursive">Python Implementation (Recursive)</a></li><li><a href="#complexity-analysis">Complexity Analysis</a></li><li><a href="#why-is-it-slow">Why is it slow?</a></li></ul></li><li><a href="#approach-2-recursion-with-memoization-top-down-dp">Approach 2: Recursion with Memoization (Top-Down DP)</a><ul><li><a href="#python-implementation-memoization">Python Implementation (Memoization)</a></li><li><a href="#complexity-analysis-1">Complexity Analysis</a></li></ul></li><li><a href="#approach-3-iterative-dynamic-programming-bottom-up">Approach 3: Iterative Dynamic Programming (Bottom-Up)</a><ul><li><a href="#visualization-of-the-dp-table">Visualization of the DP Table</a></li><li><a href="#python-implementation-iterative">Python Implementation (Iterative)</a></li><li><a href="#complexity-analysis-2">Complexity Analysis</a></li></ul></li><li><a href="#approach-4-space-optimization-in-place">Approach 4: Space Optimization (In-Place)</a></li><li><a href="#approach-5-space-optimization-1d-array">Approach 5: Space Optimization (1D Array)</a></li><li><a href="#multi-language-implementations">Multi-Language Implementations</a><ul><li><a href="#c-implementation">C++ Implementation</a></li><li><a href="#java-implementation">Java Implementation</a></li></ul></li><li><a href="#interview-simulation-the-dialogue">Interview Simulation: The Dialogue</a></li><li><a href="#related-problems-the-grid-dp-family">Related Problems: The Grid DP Family</a><ul><li><a href="#1-unique-paths-leetcode-62">1. Unique Paths (LeetCode 62)</a></li><li><a href="#2-unique-paths-ii-leetcode-63">2. Unique Paths II (LeetCode 63)</a></li><li><a href="#3-dungeon-game-leetcode-174">3. Dungeon Game (LeetCode 174)</a></li><li><a href="#4-cherry-pickup-leetcode-741">4. Cherry Pickup (LeetCode 741)</a></li><li><a href="#5-maximum-path-sum">5. Maximum Path Sum</a></li></ul></li><li><a href="#debugging-guide-common-mistakes">Debugging Guide: Common Mistakes</a><ul><li><a href="#1-the-off-by-one-error">1. The “Off-by-One” Error</a></li><li><a href="#2-the-greedy-trap">2. The “Greedy” Trap</a></li><li><a href="#3-the-uninitialized-dp-table">3. The “Uninitialized DP Table”</a></li></ul></li><li><a href="#real-world-application-seam-carving">Real-World Application: Seam Carving</a></li><li><a href="#conclusion">Conclusion</a></li></ul>
            </nav>
          </aside>
        
        <p><strong>The classic grid optimization problem that bridges the gap between simple recursion and 2D Dynamic Programming.</strong></p>

<h2 id="problem">Problem</h2>

<p>Given a <code class="language-plaintext highlighter-rouge">m x n</code> grid filled with non-negative numbers, find a path from the <strong>top-left</strong> cell to the <strong>bottom-right</strong> cell which minimizes the sum of all numbers along its path.</p>

<p><strong>Constraints:</strong></p>
<ul>
  <li>You can only move either <strong>down</strong> or <strong>right</strong> at any point in time.</li>
  <li><code class="language-plaintext highlighter-rouge">m</code> and <code class="language-plaintext highlighter-rouge">n</code> are the dimensions of the grid.</li>
  <li>The numbers in the grid are non-negative.</li>
</ul>

<p><strong>Example 1:</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: grid = [
  [1, 3, 1],
  [1, 5, 1],
  [4, 2, 1]
]
Output: 7
</code></pre></div></div>

<p><strong>Explanation:</strong>
The path is <code class="language-plaintext highlighter-rouge">1 → 3 → 1 → 1 → 1</code>.
Sum: <code class="language-plaintext highlighter-rouge">1 + 3 + 1 + 1 + 1 = 7</code>.</p>

<p>Let’s visualize the grid and the path:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[1] -&gt; [3] -&gt; [1]
               |
              [1] -&gt; [1]
</code></pre></div></div>
<p>Wait, looking at the grid:
(0,0)=1 -&gt; (0,1)=3 -&gt; (0,2)=1 -&gt; (1,2)=1 -&gt; (2,2)=1.
Total = 7.</p>

<p>Is there any other path?</p>
<ul>
  <li>Down, Down, Right, Right: <code class="language-plaintext highlighter-rouge">1 -&gt; 1 -&gt; 4 -&gt; 2 -&gt; 1</code> = 9.</li>
  <li>Down, Right, Down, Right: <code class="language-plaintext highlighter-rouge">1 -&gt; 1 -&gt; 5 -&gt; 2 -&gt; 1</code> = 10.</li>
  <li>Right, Down, Down, Right: <code class="language-plaintext highlighter-rouge">1 -&gt; 3 -&gt; 5 -&gt; 2 -&gt; 1</code> = 12.</li>
</ul>

<p>Clearly, 7 is the minimum.</p>

<h2 id="thematic-connection-path-finding-and-cost-minimization">Thematic Connection: Path Finding and Cost Minimization</h2>

<p>Before we dive into the code, let’s pause and appreciate why this problem matters.</p>

<p>In <strong>Machine Learning System Design</strong>, we often face choices that can be modeled as a directed graph or a grid. For example, when designing a data pipeline, we might have multiple stages (preprocessing, training, evaluation). Each stage has a “cost” (time, money, compute resources). Finding the most efficient pipeline configuration is mathematically similar to finding the minimum path sum.</p>

<p>In <strong>Speech Technology</strong>, the Viterbi algorithm used in Hidden Markov Models (HMMs) for speech recognition is essentially finding the most likely (minimum cost) sequence of hidden states that generate the observed audio. The “grid” there is formed by time steps on one axis and possible states (phonemes) on the other.</p>

<p>So, mastering this grid optimization logic gives you the mental framework to solve complex system optimization problems later.</p>

<h2 id="mathematical-foundation">Mathematical Foundation</h2>

<p>To truly understand Dynamic Programming, we need to understand two key properties: <strong>Optimal Substructure</strong> and <strong>Overlapping Subproblems</strong>.</p>

<h3 id="1-optimal-substructure">1. Optimal Substructure</h3>
<p>A problem has optimal substructure if an optimal solution can be constructed from optimal solutions of its subproblems.</p>

<p><strong>Proof:</strong>
Let <code class="language-plaintext highlighter-rouge">Cost(i, j)</code> be the minimum cost to reach cell <code class="language-plaintext highlighter-rouge">(i, j)</code>.
To reach <code class="language-plaintext highlighter-rouge">(i, j)</code>, we must have come from either <code class="language-plaintext highlighter-rouge">(i-1, j)</code> (top) or <code class="language-plaintext highlighter-rouge">(i, j-1)</code> (left).
Suppose the path coming from the top is the optimal one. Then, the path from <code class="language-plaintext highlighter-rouge">(0, 0)</code> to <code class="language-plaintext highlighter-rouge">(i-1, j)</code> <em>must</em> also be the minimum cost path to reach <code class="language-plaintext highlighter-rouge">(i-1, j)</code>.
<strong>Why?</strong> Proof by Contradiction:
Assume there exists a path to <code class="language-plaintext highlighter-rouge">(i-1, j)</code> with a lower cost than our current “optimal” path. Then we could simply take that lower-cost path to <code class="language-plaintext highlighter-rouge">(i-1, j)</code> and then move down to <code class="language-plaintext highlighter-rouge">(i, j)</code>, resulting in a total cost strictly less than our supposed optimal cost. This contradicts the assumption that we had the optimal path.
Therefore, <code class="language-plaintext highlighter-rouge">Cost(i, j) = grid[i][j] + min(Cost(i-1, j), Cost(i, j-1))</code>.</p>

<h3 id="2-overlapping-subproblems">2. Overlapping Subproblems</h3>
<p>A problem has overlapping subproblems if the recursive algorithm visits the same subproblems repeatedly.</p>

<p>In our grid, to calculate <code class="language-plaintext highlighter-rouge">Cost(i, j)</code>, we need <code class="language-plaintext highlighter-rouge">Cost(i-1, j)</code> and <code class="language-plaintext highlighter-rouge">Cost(i, j-1)</code>.
To calculate <code class="language-plaintext highlighter-rouge">Cost(i-1, j+1)</code>, we need <code class="language-plaintext highlighter-rouge">Cost(i-2, j+1)</code> and <code class="language-plaintext highlighter-rouge">Cost(i-1, j)</code>.
Notice that <code class="language-plaintext highlighter-rouge">Cost(i-1, j)</code> is needed by both <code class="language-plaintext highlighter-rouge">(i, j)</code> and <code class="language-plaintext highlighter-rouge">(i-1, j+1)</code>.
In a large grid, this overlap happens exponentially often. This is why simple recursion fails and why we need DP.</p>

<h2 id="approach-1-brute-force-recursion">Approach 1: Brute Force Recursion</h2>

<p>Let’s start with the most intuitive approach. If we are at any cell <code class="language-plaintext highlighter-rouge">(i, j)</code>, what are our choices?</p>
<ol>
  <li>Move <strong>Right</strong> to <code class="language-plaintext highlighter-rouge">(i, j+1)</code></li>
  <li>Move <strong>Down</strong> to <code class="language-plaintext highlighter-rouge">(i+1, j)</code></li>
</ol>

<p>We want to choose the move that eventually leads to the smallest total sum. This sounds like a recursive definition!</p>

<p>Let <code class="language-plaintext highlighter-rouge">minPath(i, j)</code> be the minimum cost to reach the bottom-right corner <code class="language-plaintext highlighter-rouge">(m-1, n-1)</code> starting from cell <code class="language-plaintext highlighter-rouge">(i, j)</code>.</p>

<p>The cost of the current cell <code class="language-plaintext highlighter-rouge">grid[i][j]</code> is always added. Then we need to add the minimum of the rest of the path.
<code class="language-plaintext highlighter-rouge">minPath(i, j) = grid[i][j] + min(minPath(i, j+1), minPath(i+1, j))</code></p>

<h3 id="base-cases">Base Cases</h3>
<ol>
  <li><strong>Destination Reached:</strong> If we are at <code class="language-plaintext highlighter-rouge">(m-1, n-1)</code>, the cost is just <code class="language-plaintext highlighter-rouge">grid[m-1][n-1]</code>. We have nowhere else to go.</li>
  <li><strong>Out of Bounds:</strong> If <code class="language-plaintext highlighter-rouge">i &gt;= m</code> or <code class="language-plaintext highlighter-rouge">j &gt;= n</code>, this is an invalid path. We should return “Infinity” so that the <code class="language-plaintext highlighter-rouge">min()</code> function never chooses this path.</li>
</ol>

<h3 id="python-implementation-recursive">Python Implementation (Recursive)</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">math</span>

<span class="k">def</span> <span class="nf">minPathSum_recursive</span><span class="p">(</span><span class="n">grid</span><span class="p">):</span>
    <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">grid</span><span class="p">),</span> <span class="nf">len</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    
    <span class="k">def</span> <span class="nf">calculate</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
        <span class="c1"># Base Case: Reached bottom-right
</span>        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">==</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
        
        <span class="c1"># Base Case: Out of bounds
</span>        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">m</span> <span class="ow">or</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">math</span><span class="p">.</span><span class="n">inf</span>
        
        <span class="c1"># Recursive Step
</span>        <span class="n">move_right</span> <span class="o">=</span> <span class="nf">calculate</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">move_down</span> <span class="o">=</span> <span class="nf">calculate</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="nf">min</span><span class="p">(</span><span class="n">move_right</span><span class="p">,</span> <span class="n">move_down</span><span class="p">)</span>

    <span class="k">return</span> <span class="nf">calculate</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="complexity-analysis">Complexity Analysis</h3>
<ul>
  <li><strong>Time Complexity:</strong> (O(2^{m+n})). At each step, we branch into two possibilities. The depth of the recursion is (m+n). This is exponential and extremely slow for large grids.</li>
  <li><strong>Space Complexity:</strong> (O(m+n)) for the recursion stack.</li>
</ul>

<h3 id="why-is-it-slow">Why is it slow?</h3>
<p>Let’s trace the calls for a simple 2x2 grid.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(0,0)
  |-- (0,1)
  |     |-- (0,2) [Out]
  |     |-- (1,1) [Target]
  |
  |-- (1,0)
        |-- (1,1) [Target]
        |-- (2,0) [Out]
</code></pre></div></div>
<p>Notice that <code class="language-plaintext highlighter-rouge">(1,1)</code> is reached from <code class="language-plaintext highlighter-rouge">(0,1)</code> AND from <code class="language-plaintext highlighter-rouge">(1,0)</code>. In a larger grid, the number of overlapping subproblems explodes. We are re-calculating the minimum path for the same cells over and over again.</p>

<h2 id="approach-2-recursion-with-memoization-top-down-dp">Approach 2: Recursion with Memoization (Top-Down DP)</h2>

<p>To fix the overlapping subproblems, we can store the result of <code class="language-plaintext highlighter-rouge">calculate(i, j)</code> in a cache (memoization table). If we encounter the same <code class="language-plaintext highlighter-rouge">(i, j)</code> again, we just return the stored value.</p>

<h3 id="python-implementation-memoization">Python Implementation (Memoization)</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">minPathSum_memo</span><span class="p">(</span><span class="n">grid</span><span class="p">):</span>
    <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">grid</span><span class="p">),</span> <span class="nf">len</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">memo</span> <span class="o">=</span> <span class="p">{}</span>
    
    <span class="k">def</span> <span class="nf">calculate</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
        <span class="c1"># Check cache first
</span>        <span class="nf">if </span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="ow">in</span> <span class="n">memo</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">memo</span><span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)]</span>
        
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">==</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">m</span> <span class="ow">or</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="p">:</span>
            <span class="k">return</span> <span class="nf">float</span><span class="p">(</span><span class="sh">'</span><span class="s">inf</span><span class="sh">'</span><span class="p">)</span>
        
        <span class="n">res</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="nf">min</span><span class="p">(</span><span class="nf">calculate</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="nf">calculate</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>
        
        <span class="c1"># Store in cache
</span>        <span class="n">memo</span><span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)]</span> <span class="o">=</span> <span class="n">res</span>
        <span class="k">return</span> <span class="n">res</span>

    <span class="k">return</span> <span class="nf">calculate</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="complexity-analysis-1">Complexity Analysis</h3>
<ul>
  <li><strong>Time Complexity:</strong> (O(m \times n)). There are (m \times n) unique states (cells). Each state is computed once.</li>
  <li><strong>Space Complexity:</strong> (O(m \times n)) for the memoization table + (O(m + n)) for recursion stack.</li>
</ul>

<p>This is much better! But we can do even better by removing the recursion overhead.</p>

<h2 id="approach-3-iterative-dynamic-programming-bottom-up">Approach 3: Iterative Dynamic Programming (Bottom-Up)</h2>

<p>Recursion starts from the top-left and asks “what’s the cost to the end?”. Iterative DP usually starts from the end (or the beginning) and builds the solution up.</p>

<p>Let’s flip the definition. Let <code class="language-plaintext highlighter-rouge">dp[i][j]</code> be the minimum path sum <strong>to reach</strong> cell <code class="language-plaintext highlighter-rouge">(i, j)</code> <strong>from</strong> the top-left <code class="language-plaintext highlighter-rouge">(0, 0)</code>.</p>

<p><strong>Recurrence Relation:</strong>
To reach <code class="language-plaintext highlighter-rouge">(i, j)</code>, we must have come from either:</p>
<ol>
  <li>Top: <code class="language-plaintext highlighter-rouge">(i-1, j)</code></li>
  <li>Left: <code class="language-plaintext highlighter-rouge">(i, j-1)</code></li>
</ol>

<p>So, <code class="language-plaintext highlighter-rouge">dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1])</code>.</p>

<p><strong>Boundary Conditions:</strong></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">dp[0][0] = grid[0][0]</code></li>
  <li>First Row <code class="language-plaintext highlighter-rouge">(i=0)</code>: We can only come from the left. <code class="language-plaintext highlighter-rouge">dp[0][j] = dp[0][j-1] + grid[0][j]</code>.</li>
  <li>First Column <code class="language-plaintext highlighter-rouge">(j=0)</code>: We can only come from above. <code class="language-plaintext highlighter-rouge">dp[i][0] = dp[i-1][0] + grid[i][0]</code>.</li>
</ul>

<h3 id="visualization-of-the-dp-table">Visualization of the DP Table</h3>

<p>Input:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1 3 1
1 5 1
4 2 1
</code></pre></div></div>

<p><strong>Step 1: Initialize (0,0)</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1 . .
. . .
. . .
</code></pre></div></div>

<p><strong>Step 2: Fill First Row</strong>
<code class="language-plaintext highlighter-rouge">dp[0][1] = 1 + 3 = 4</code>
<code class="language-plaintext highlighter-rouge">dp[0][2] = 4 + 1 = 5</code></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1 4 5
. . .
. . .
</code></pre></div></div>

<p><strong>Step 3: Fill First Column</strong>
<code class="language-plaintext highlighter-rouge">dp[1][0] = 1 + 1 = 2</code>
<code class="language-plaintext highlighter-rouge">dp[2][0] = 2 + 4 = 6</code></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1 4 5
2 . .
6 . .
</code></pre></div></div>

<p><strong>Step 4: Fill Inner Cells</strong>
<code class="language-plaintext highlighter-rouge">dp[1][1] = grid[1][1] + min(dp[0][1], dp[1][0])</code>
<code class="language-plaintext highlighter-rouge">dp[1][1] = 5 + min(4, 2) = 5 + 2 = 7</code></p>

<p><code class="language-plaintext highlighter-rouge">dp[1][2] = grid[1][2] + min(dp[0][2], dp[1][1])</code>
<code class="language-plaintext highlighter-rouge">dp[1][2] = 1 + min(5, 7) = 1 + 5 = 6</code></p>

<p><code class="language-plaintext highlighter-rouge">dp[2][1] = grid[2][1] + min(dp[1][1], dp[2][0])</code>
<code class="language-plaintext highlighter-rouge">dp[2][1] = 2 + min(7, 6) = 2 + 6 = 8</code></p>

<p><code class="language-plaintext highlighter-rouge">dp[2][2] = grid[2][2] + min(dp[1][2], dp[2][1])</code>
<code class="language-plaintext highlighter-rouge">dp[2][2] = 1 + min(6, 8) = 1 + 6 = 7</code></p>

<p>Final DP Table:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1 4 5
2 7 6
6 8 7
</code></pre></div></div>
<p>The answer is <code class="language-plaintext highlighter-rouge">dp[2][2] = 7</code>.</p>

<h3 id="python-implementation-iterative">Python Implementation (Iterative)</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">minPathSum_iterative</span><span class="p">(</span><span class="n">grid</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">grid</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
    
    <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">grid</span><span class="p">),</span> <span class="nf">len</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">dp</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">m</span><span class="p">)]</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># First row, can only come from left
</span>                <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># First column, can only come from top
</span>                <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Inner cell, choose min of top or left
</span>                <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nf">min</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
                
    <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div></div>

<h3 id="complexity-analysis-2">Complexity Analysis</h3>
<ul>
  <li><strong>Time Complexity:</strong> (O(m \times n)). We iterate through the grid once.</li>
  <li><strong>Space Complexity:</strong> (O(m \times n)) for the <code class="language-plaintext highlighter-rouge">dp</code> table.</li>
</ul>

<h2 id="approach-4-space-optimization-in-place">Approach 4: Space Optimization (In-Place)</h2>

<p>Do we really need a separate <code class="language-plaintext highlighter-rouge">dp</code> table? Look at the recurrence again:
<code class="language-plaintext highlighter-rouge">dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1])</code></p>

<p>We are just adding values to the original grid values. If the interviewer allows modifying the input, we can store the DP values directly in <code class="language-plaintext highlighter-rouge">grid</code>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">minPathSum_inplace</span><span class="p">(</span><span class="n">grid</span><span class="p">):</span>
    <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">grid</span><span class="p">),</span> <span class="nf">len</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">elif</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="nf">min</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                
    <span class="k">return</span> <span class="n">grid</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div></div>

<ul>
  <li><strong>Space Complexity:</strong> (O(1)).</li>
</ul>

<h2 id="approach-5-space-optimization-1d-array">Approach 5: Space Optimization (1D Array)</h2>

<p>What if we cannot modify the input (e.g., the grid is read-only or shared)? Do we still need <code class="language-plaintext highlighter-rouge">O(m*n)</code> space?</p>

<p>Notice that to calculate row <code class="language-plaintext highlighter-rouge">i</code>, we only need the values from row <code class="language-plaintext highlighter-rouge">i</code> (which we are currently computing) and row <code class="language-plaintext highlighter-rouge">i-1</code> (the previous row). We don’t need row <code class="language-plaintext highlighter-rouge">i-2</code> or anything before that.</p>

<p>So, we can just keep two rows: <code class="language-plaintext highlighter-rouge">prev_row</code> and <code class="language-plaintext highlighter-rouge">curr_row</code>.
Actually, we can do even better. We can use a single 1D array!</p>

<p>Let <code class="language-plaintext highlighter-rouge">dp[j]</code> represent the minimum path sum to reach the cell at column <code class="language-plaintext highlighter-rouge">j</code> in the <em>current</em> row we are processing.</p>

<p>When we are at <code class="language-plaintext highlighter-rouge">grid[i][j]</code>:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">dp[j]</code> currently holds the value for <code class="language-plaintext highlighter-rouge">grid[i-1][j]</code> (value from above).</li>
  <li><code class="language-plaintext highlighter-rouge">dp[j-1]</code> holds the value for <code class="language-plaintext highlighter-rouge">grid[i][j-1]</code> (value from left, which we just updated).</li>
</ul>

<p>So: <code class="language-plaintext highlighter-rouge">dp[j] = grid[i][j] + min(dp[j], dp[j-1])</code>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">minPathSum_1d</span><span class="p">(</span><span class="n">grid</span><span class="p">):</span>
    <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">grid</span><span class="p">),</span> <span class="nf">len</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">dp</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>
    
    <span class="c1"># Initialize first value
</span>    <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="c1"># Initialize first row
</span>    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
        
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
        <span class="c1"># Handle first column of current row
</span>        <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
            <span class="c1"># dp[j] is value from top
</span>            <span class="c1"># dp[j-1] is value from left
</span>            <span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="nf">min</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            
    <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div></div>

<ul>
  <li><strong>Space Complexity:</strong> (O(n)). This is the most optimal space complexity without modifying input.</li>
</ul>

<h2 id="multi-language-implementations">Multi-Language Implementations</h2>

<p>As a junior engineer, you might be working in a codebase that uses Java or C++. It’s important to be fluent in multiple syntaxes.</p>

<h3 id="c-implementation">C++ Implementation</h3>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">minPathSum</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">grid</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">grid</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">grid</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">();</span>
        
        <span class="c1">// We will use the in-place approach for C++</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
                
                <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
                <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">min</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]);</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">grid</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="java-implementation">Java Implementation</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">minPathSum</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">grid</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">grid</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">grid</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">grid</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span>
        
        <span class="c1">// Using 1D array approach for Java</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        
        <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">grid</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span>
        
        <span class="c1">// Initialize first row</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">dp</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">dp</span><span class="o">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="n">grid</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="n">j</span><span class="o">];</span>
        <span class="o">}</span>
        
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// First column of current row</span>
            <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+=</span> <span class="n">grid</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span>
            
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">dp</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">j</span><span class="o">],</span> <span class="n">dp</span><span class="o">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">])</span> <span class="o">+</span> <span class="n">grid</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">];</span>
            <span class="o">}</span>
        <span class="o">}</span>
        
        <span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="interview-simulation-the-dialogue">Interview Simulation: The Dialogue</h2>

<p>To help you prepare, let’s simulate how a real interview conversation might go.</p>

<p><strong>Interviewer:</strong> “Okay, here’s the problem. You have a grid of numbers. You start at top-left, end at bottom-right. You can only go down or right. Find the path with the minimum sum.”</p>

<p><strong>Candidate (You):</strong> “Understood. Just to clarify, are the numbers always positive?”</p>

<p><strong>Interviewer:</strong> “Yes, non-negative integers.”</p>

<p><strong>Candidate:</strong> “And if the grid is empty, should I return 0?”</p>

<p><strong>Interviewer:</strong> “Yes, assume valid input generally, but 0 for empty is fine.”</p>

<p><strong>Candidate:</strong> “Great. My first thought is that this looks like a shortest path problem. Since we can only move down and right, there are no cycles. This suggests a Dynamic Programming approach because the decision at any cell depends on the optimal decisions made for previous cells. Specifically, to reach cell <code class="language-plaintext highlighter-rouge">(i, j)</code> with minimal cost, I must have come from either the cell above it or the cell to the left of it.”</p>

<p><strong>Interviewer:</strong> “That sounds correct. Can you define the recurrence relation?”</p>

<p><strong>Candidate:</strong> “Sure. Let <code class="language-plaintext highlighter-rouge">dp[i][j]</code> be the min path sum to reach <code class="language-plaintext highlighter-rouge">(i, j)</code>. Then <code class="language-plaintext highlighter-rouge">dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1])</code>. The base case is <code class="language-plaintext highlighter-rouge">dp[0][0] = grid[0][0]</code>.”</p>

<p><strong>Interviewer:</strong> “Good. What about the first row and first column?”</p>

<p><strong>Candidate:</strong> “Ah, yes. For the first row, we can only come from the left, so <code class="language-plaintext highlighter-rouge">dp[0][j] = dp[0][j-1] + grid[0][j]</code>. Similarly for the first column, we can only come from above, so <code class="language-plaintext highlighter-rouge">dp[i][0] = dp[i-1][0] + grid[i][0]</code>.”</p>

<p><strong>Interviewer:</strong> “Excellent. Go ahead and code it.”</p>

<p><em>(Candidate writes the code…)</em></p>

<p><strong>Interviewer:</strong> “Looks good. What is the space complexity?”</p>

<p><strong>Candidate:</strong> “I used a 2D array, so it’s <code class="language-plaintext highlighter-rouge">O(m*n)</code>. But looking at the recurrence, I only need the previous row to calculate the current row. So I could optimize this to <code class="language-plaintext highlighter-rouge">O(n)</code> space using a 1D array.”</p>

<p><strong>Interviewer:</strong> “Can you do it in <code class="language-plaintext highlighter-rouge">O(1)</code> space?”</p>

<p><strong>Candidate:</strong> “If I am allowed to modify the input grid, I can store the cumulative sums directly in the grid cells. That would be <code class="language-plaintext highlighter-rouge">O(1)</code> auxiliary space.”</p>

<p><strong>Interviewer:</strong> “Perfect. Let’s assume the input is read-only. How would you handle a case where the grid is extremely wide but not very tall (e.g., 10 rows, 1,000,000 columns)?”</p>

<p><strong>Candidate:</strong> “That’s a great edge case. If <code class="language-plaintext highlighter-rouge">n</code> is much larger than <code class="language-plaintext highlighter-rouge">m</code>, my <code class="language-plaintext highlighter-rouge">O(n)</code> space solution would use a lot of memory. I should check which dimension is smaller. If <code class="language-plaintext highlighter-rouge">m &lt; n</code>, I can treat columns as rows and iterate column by column, using an array of size <code class="language-plaintext highlighter-rouge">m</code> instead. So the space complexity would be <code class="language-plaintext highlighter-rouge">O(min(m, n))</code>.”</p>

<p><strong>Interviewer:</strong> “Very impressive. One last question: What if we could move diagonally?”</p>

<p><strong>Candidate:</strong> “If we can move diagonally (down-right), then I would just add a third term to the min function: <code class="language-plaintext highlighter-rouge">min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])</code>. The rest of the logic stays the same.”</p>

<h2 id="related-problems-the-grid-dp-family">Related Problems: The Grid DP Family</h2>

<p>Once you master Minimum Path Sum, you can solve a whole family of problems. Let’s look at 5 of them in detail.</p>

<h3 id="1-unique-paths-leetcode-62">1. Unique Paths (LeetCode 62)</h3>
<ul>
  <li><strong>Problem:</strong> Count the number of unique paths from top-left to bottom-right.</li>
  <li><strong>Difference:</strong> Instead of <code class="language-plaintext highlighter-rouge">min()</code>, we use <code class="language-plaintext highlighter-rouge">sum()</code>.</li>
  <li><strong>Recurrence:</strong> <code class="language-plaintext highlighter-rouge">dp[i][j] = dp[i-1][j] + dp[i][j-1]</code>.</li>
  <li><strong>Code Snippet:</strong>
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">uniquePaths</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
  <span class="n">dp</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
      <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
          <span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
  <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="2-unique-paths-ii-leetcode-63">2. Unique Paths II (LeetCode 63)</h3>
<ul>
  <li><strong>Problem:</strong> Same as above, but with obstacles.</li>
  <li><strong>Difference:</strong> If <code class="language-plaintext highlighter-rouge">grid[i][j] == obstacle</code>, then <code class="language-plaintext highlighter-rouge">dp[i][j] = 0</code>.</li>
  <li><strong>Key Insight:</strong> An obstacle blocks all flow through that cell.</li>
  <li><strong>Code Snippet:</strong>
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">uniquePathsWithObstacles</span><span class="p">(</span><span class="n">obstacleGrid</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">obstacleGrid</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="k">return</span> <span class="mi">0</span>
  <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">obstacleGrid</span><span class="p">),</span> <span class="nf">len</span><span class="p">(</span><span class="n">obstacleGrid</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
  <span class="n">dp</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>
  <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
      <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
          <span class="k">if</span> <span class="n">obstacleGrid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
              <span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
          <span class="k">elif</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
              <span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
  <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="3-dungeon-game-leetcode-174">3. Dungeon Game (LeetCode 174)</h3>
<ul>
  <li><strong>Problem:</strong> Start with health <code class="language-plaintext highlighter-rouge">H</code>. Some cells decrease health (monsters), some increase it (potions). Find min initial health to survive.</li>
  <li><strong>Difference:</strong> This is a “reverse” DP. You start from the bottom-right and work your way back to the top-left.</li>
  <li><strong>Recurrence:</strong> <code class="language-plaintext highlighter-rouge">dp[i][j] = max(1, min(dp[i+1][j], dp[i][j+1]) - grid[i][j])</code>.</li>
  <li><strong>Why Reverse?</strong> Because the decision at <code class="language-plaintext highlighter-rouge">(i, j)</code> depends on the <em>future</em> requirement at <code class="language-plaintext highlighter-rouge">(i+1, j)</code> or <code class="language-plaintext highlighter-rouge">(i, j+1)</code>. If we went forward, we wouldn’t know if a future potion would save us.</li>
</ul>

<h3 id="4-cherry-pickup-leetcode-741">4. Cherry Pickup (LeetCode 741)</h3>
<ul>
  <li><strong>Problem:</strong> Go from top-left to bottom-right, then back to top-left, collecting maximum cherries.</li>
  <li><strong>Difference:</strong> This requires two simultaneous paths. The state becomes <code class="language-plaintext highlighter-rouge">dp[r1][c1][r2]</code>. It’s a Hard problem, but built on the same principles.</li>
  <li><strong>Complexity:</strong> <code class="language-plaintext highlighter-rouge">O(N^3)</code>.</li>
</ul>

<h3 id="5-maximum-path-sum">5. Maximum Path Sum</h3>
<ul>
  <li><strong>Problem:</strong> Find the path with the maximum sum.</li>
  <li><strong>Difference:</strong> Just change <code class="language-plaintext highlighter-rouge">min</code> to <code class="language-plaintext highlighter-rouge">max</code>.</li>
  <li><strong>Application:</strong> Finding the most profitable route for a salesperson.</li>
</ul>

<h2 id="debugging-guide-common-mistakes">Debugging Guide: Common Mistakes</h2>

<p>Even experienced engineers make mistakes with DP. Here are the most common ones and how to spot them.</p>

<h3 id="1-the-off-by-one-error">1. The “Off-by-One” Error</h3>
<ul>
  <li><strong>Symptom:</strong> <code class="language-plaintext highlighter-rouge">IndexError: list index out of range</code>.</li>
  <li><strong>Cause:</strong> Iterating up to <code class="language-plaintext highlighter-rouge">m</code> instead of <code class="language-plaintext highlighter-rouge">m-1</code>, or accessing <code class="language-plaintext highlighter-rouge">dp[i-1]</code> when <code class="language-plaintext highlighter-rouge">i=0</code>.</li>
  <li><strong>Fix:</strong> Always handle the first row and first column separately, or pad the DP table with an extra row/column of “Infinity” values.</li>
</ul>

<h3 id="2-the-greedy-trap">2. The “Greedy” Trap</h3>
<ul>
  <li><strong>Symptom:</strong> Wrong answer on complex test cases.</li>
  <li><strong>Cause:</strong> Thinking “I should just pick the smaller number at each step”.</li>
  <li><strong>Example:</strong>
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1 100 1
1   1 1
</code></pre></div>    </div>
    <p>Greedy would go Right (1 -&gt; 100) because 100 is… wait, Greedy minimizes.
Example:</p>
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1 2 5
9 1 1
</code></pre></div>    </div>
    <p>Greedy at (0,0): Right (2) vs Down (9). Picks Right.
Path: 1 -&gt; 2 -&gt; 5. Sum = 8.
Optimal: Down (9) -&gt; Right (1) -&gt; Right (1). Sum = 12. (Wait, this is max path).
For Min Path:</p>
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1 9 9
5 1 1
</code></pre></div>    </div>
    <p>Greedy at (0,0): Down (5) vs Right (9). Picks Down.
Path: 1 -&gt; 5 -&gt; 1 -&gt; 1. Sum = 8.
Optimal: 1 -&gt; 9 -&gt; 9… wait.
Actually, Greedy fails because it doesn’t look ahead.
Correct Example:</p>
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1 5 100
1 1 1
</code></pre></div>    </div>
    <p>Greedy at (0,0): Right (5) vs Down (1). Picks Down.
Path: 1 -&gt; 1 -&gt; 1 -&gt; 1. Sum = 4.
Path 2: 1 -&gt; 5 -&gt; 100. Sum = 106.
Here Greedy worked.
Counter-Example for Greedy Min Path:</p>
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1 10 10
1  1  1
</code></pre></div>    </div>
    <p>Greedy at (0,0): Right (10) vs Down (1). Picks Down.
Path: 1 -&gt; 1 -&gt; 1 -&gt; 1. Sum = 4.
Path 2: 1 -&gt; 10 -&gt; 10. Sum = 21.
Greedy works often on simple grids, but fails when a “locally bad” move leads to a “globally good” path.
Imagine:</p>
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1  100 1
10 100 1
</code></pre></div>    </div>
    <p>Start (0,0).
Right: 100. Down: 10.
Greedy picks Down.
Path: 1 -&gt; 10 -&gt; 100 -&gt; 1 = 112.
Optimal: 1 -&gt; 100 -&gt; 1 -&gt; 1… wait.
Let’s construct a proper counter-example.</p>
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1 1 10
5 1 1
</code></pre></div>    </div>
    <p>Start (0,0).
Right (1) vs Down (5). Greedy picks Right.
Path: 1 -&gt; 1 -&gt; 10 -&gt; 1 (forced). Sum = 13.
Optimal: 1 -&gt; 5 -&gt; 1 -&gt; 1. Sum = 8.
<strong>Fix:</strong> Never use Greedy on grids unless you prove the “Greedy Choice Property”. Use DP.</p>
  </li>
</ul>

<h3 id="3-the-uninitialized-dp-table">3. The “Uninitialized DP Table”</h3>
<ul>
  <li><strong>Symptom:</strong> Random huge numbers or zeros.</li>
  <li><strong>Cause:</strong> Forgetting to set the base case <code class="language-plaintext highlighter-rouge">dp[0][0]</code>.</li>
  <li><strong>Fix:</strong> Always initialize the start point before the loops.</li>
</ul>

<h2 id="real-world-application-seam-carving">Real-World Application: Seam Carving</h2>

<p>One fascinating application of this algorithm is <strong>Seam Carving</strong> for content-aware image resizing.</p>
<ul>
  <li><strong>Goal:</strong> Resize an image (reduce width) without distorting important objects.</li>
  <li><strong>Method:</strong> Find a “seam” (a path of pixels from top to bottom) that has the least “energy” (least importance/detail) and remove it.</li>
  <li><strong>Algorithm:</strong>
    <ol>
      <li>Calculate “energy” of each pixel (e.g., gradient magnitude).</li>
      <li>Use the Minimum Path Sum algorithm (allowing diagonal moves) to find the vertical seam with the lowest total energy.</li>
      <li>Remove that seam.</li>
      <li>Repeat.</li>
    </ol>
  </li>
</ul>

<p>This is exactly the same logic! You are finding a path through a grid of pixels to minimize the sum of energies.</p>

<h2 id="conclusion">Conclusion</h2>

<p>The Minimum Path Sum problem is a cornerstone of Dynamic Programming. It teaches you:</p>
<ol>
  <li><strong>State Definition:</strong> How to represent the problem at step <code class="language-plaintext highlighter-rouge">(i, j)</code>.</li>
  <li><strong>Transition:</strong> How to move from previous states to the current state.</li>
  <li><strong>Optimization:</strong> How to reduce space from <code class="language-plaintext highlighter-rouge">O(m*n)</code> to <code class="language-plaintext highlighter-rouge">O(n)</code>.</li>
</ol>

<p>Mastering this gives you the tools to solve harder variations like “Dungeon Game”, “Unique Paths II”, and “Cherry Pickup”.</p>

<p><strong>Practice Problems:</strong></p>
<ul>
  <li><a href="https://leetcode.com/problems/unique-paths/">Unique Paths</a></li>
  <li><a href="https://leetcode.com/problems/unique-paths-ii/">Unique Paths II</a></li>
  <li><a href="https://leetcode.com/problems/dungeon-game/">Dungeon Game</a></li>
  <li><a href="https://leetcode.com/problems/cherry-pickup/">Cherry Pickup</a></li>
</ul>

<p>Happy Coding!</p>

<hr />

<p><strong>Originally published at:</strong> <a href="https://www.arunbaby.com/dsa/0022-minimum-path-sum/">arunbaby.com/dsa/0022-minimum-path-sum</a></p>

<p><em>If you found this helpful, consider sharing it with others who might benefit.</em></p>


        
      </section>

      <footer class="page__meta">
        
        
  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-tags" aria-hidden="true"></i> Tags: </strong>
    <span itemprop="keywords">
    
      <a href="/tags/#dynamic-programming" class="page__taxonomy-item p-category" rel="tag">dynamic-programming</a><span class="sep">, </span>
    
      <a href="/tags/#grid" class="page__taxonomy-item p-category" rel="tag">grid</a><span class="sep">, </span>
    
      <a href="/tags/#matrix" class="page__taxonomy-item p-category" rel="tag">matrix</a><span class="sep">, </span>
    
      <a href="/tags/#medium" class="page__taxonomy-item p-category" rel="tag">medium</a><span class="sep">, </span>
    
      <a href="/tags/#optimization" class="page__taxonomy-item p-category" rel="tag">optimization</a>
    
    </span>
  </p>




  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> Categories: </strong>
    <span itemprop="keywords">
    
      <a href="/categories/#dsa" class="page__taxonomy-item p-category" rel="tag">dsa</a>
    
    </span>
  </p>


        
      </footer>

      <div class="page__related page__related--full">
  <h2 class="page__related-title">Related across topics</h2>
  <style>
    /* Make section span full content width and use 2 equal columns */
    .page__related--full { float: inline-start; width: 100%; padding: 0; }
    .cross-related-grid { display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 2rem; }
    @media (max-width: 768px) { .cross-related-grid { grid-template-columns: 1fr; } }
    /* Ensure archive cards stretch nicely in the grid */
    .cross-related-grid .list__item, .cross-related-grid .grid__item { width: auto; float: none; margin: 0; }
  </style>
  <div class="cross-related-grid">
    



<div class="list__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/ml-system-design/0022-cost-optimization-for-ml/" rel="permalink">Cost Optimization for ML
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          15 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">A comprehensive guide to FinOps for Machine Learning: reducing TCO without compromising accuracy or latency.
</p>
  </article>
</div>




<div class="list__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/speech-tech/0022-cost-efficient-speech-systems/" rel="permalink">Cost-efficient Speech Systems
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          11 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">Strategies for building profitable speech recognition systems by optimizing the entire pipeline from signal processing to hardware.
</p>
  </article>
</div>

  </div>
</div>

      <section class="page__share">
  <h4 class="page__share-title">Share on</h4>

  <a href="https://twitter.com/intent/tweet?via=arunbaby0&text=Minimum+Path+Sum%20https%3A%2F%2Fwww.arunbaby.com%2Fdsa%2F0022-minimum-path-sum%2F" class="btn btn--twitter" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Twitter"><i class="fab fa-fw fa-twitter" aria-hidden="true"></i><span> Twitter</span></a>

  <a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fwww.arunbaby.com%2Fdsa%2F0022-minimum-path-sum%2F" class="btn btn--facebook" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Facebook"><i class="fab fa-fw fa-facebook" aria-hidden="true"></i><span> Facebook</span></a>

  <a href="https://www.linkedin.com/shareArticle?mini=true&url=https://www.arunbaby.com/dsa/0022-minimum-path-sum/" class="btn btn--linkedin" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on LinkedIn"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i><span> LinkedIn</span></a>
</section>


      
  <nav class="pagination">
    
      <a href="/dsa/0021-unique-paths/" class="pagination--pager" title="Unique Paths">Previous</a>
    
    
      <a href="/dsa/0023-decode-ways/" class="pagination--pager" title="Decode Ways">Next</a>
    
  </nav>


    </div>

    
  </article>

  
  
</div>

      
    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';" role="search">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Enter your search term..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    

    
      
        
          <li><a href="https://twitter.com/arunbaby0" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-twitter-square" aria-hidden="true"></i> Twitter</a></li>
        
      
        
          <li><a href="https://github.com/arunbaby0" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
        
      
        
          <li><a href="https://www.linkedin.com/in/arunbaby0/" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i> LinkedIn</a></li>
        
      
        
          <li><a href="https://scholar.google.co.in/citations?user=6fSYWhkAAAAJ" rel="nofollow noopener noreferrer"><i class="fas fa-fw fa-graduation-cap" aria-hidden="true"></i> Google Scholar</a></li>
        
      
    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 1990 - 2143 <a href="https://www.arunbaby.com">Arun Baby</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>




  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-0JRJPEC9SS"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-0JRJPEC9SS', { 'anonymize_ip': false});
</script>








  </body>
</html>
