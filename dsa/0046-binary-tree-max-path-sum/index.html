<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.26.2 by Michael Rose
  Copyright 2013-2024 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->

<html lang="en-US" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Binary Tree Maximum Path Sum - Arun Baby</title>
<meta name="description" content="“Every path has a peak—find the one with the maximum sum.”">


  <meta name="author" content="Arun Baby">
  
  <meta property="article:author" content="Arun Baby">
  


<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="Arun Baby">
<meta property="og:title" content="Binary Tree Maximum Path Sum">
<meta property="og:url" content="https://www.arunbaby.com/dsa/0046-binary-tree-max-path-sum/">


  <meta property="og:description" content="“Every path has a peak—find the one with the maximum sum.”">



  <meta property="og:image" content="https://www.arunbaby.com/assets/images/profile-photo.png">



  <meta name="twitter:site" content="@arunbaby0">
  <meta name="twitter:title" content="Binary Tree Maximum Path Sum">
  <meta name="twitter:description" content="“Every path has a peak—find the one with the maximum sum.”">
  <meta name="twitter:url" content="https://www.arunbaby.com/dsa/0046-binary-tree-max-path-sum/">

  
    <meta name="twitter:card" content="summary">
    
      <meta name="twitter:image" content="https://www.arunbaby.com/assets/images/profile-photo.png">
    
  

  



  <meta property="article:published_time" content="2025-12-22T11:01:30+05:30">





  

  


<link rel="canonical" href="https://www.arunbaby.com/dsa/0046-binary-tree-max-path-sum/">












<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Arun Baby Feed">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
  
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css"></noscript>



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--single" dir="ltr">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
           
          <span class="site-subtitle">Arun Baby</span>
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a
                href="/about/"
                
                
              >About</a>
            </li><li class="masthead__menu-item">
              <a
                href="/dsa/"
                
                
              >DSA</a>
            </li><li class="masthead__menu-item">
              <a
                href="/ml-system-design/"
                
                
              >ML Systems</a>
            </li><li class="masthead__menu-item">
              <a
                href="/speech-tech/"
                
                
              >Speech Tech</a>
            </li><li class="masthead__menu-item">
              <a
                href="/ai-agents/"
                
                
              >AI Agents</a>
            </li><li class="masthead__menu-item">
              <a
                href="/publications/"
                
                
              >Publications</a>
            </li><li class="masthead__menu-item">
              <a
                href="/statuses/"
                
                
              >Statuses</a>
            </li><li class="masthead__menu-item">
              <a
                href="/contact/"
                
                
              >Contact</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <i class="fas fa-search"></i>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      





<div id="main" role="main" class="no-author-sidebar">
  
  <div class="sidebar sticky">
  
  
  </div>



  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="Binary Tree Maximum Path Sum">
    <meta itemprop="description" content="“Every path has a peak—find the one with the maximum sum.”">
    <meta itemprop="datePublished" content="2025-12-22T11:01:30+05:30">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">
            <a href="https://www.arunbaby.com/dsa/0046-binary-tree-max-path-sum/" itemprop="url">Binary Tree Maximum Path Sum
</a>
          </h1>
          

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          13 minute read
        
      </span>
    
  </p>


        </header>
      

      <section class="page__content" itemprop="text">
        
          <aside class="sidebar__right sticky">
            <nav class="toc">
              <header><h4 class="nav__title"><i class="fas fa-file-alt"></i> On this page</h4></header>
              <ul class="toc__menu"><li><a href="#1-introduction-why-this-problem-matters">1. Introduction: Why This Problem Matters</a></li><li><a href="#2-understanding-the-problem">2. Understanding the Problem</a><ul><li><a href="#21-what-is-a-path-in-a-binary-tree">2.1 What is a “Path” in a Binary Tree?</a></li><li><a href="#22-the-problem-statement">2.2 The Problem Statement</a></li><li><a href="#23-why-this-problem-is-tricky">2.3 Why This Problem is Tricky</a></li></ul></li><li><a href="#3-building-intuition-the-arc-concept">3. Building Intuition: The Arc Concept</a><ul><li><a href="#31-every-path-is-an-arc-with-a-peak">3.1 Every Path is an “Arc” with a Peak</a></li><li><a href="#32-two-different-questions-at-each-node">3.2 Two Different Questions at Each Node</a></li></ul></li><li><a href="#4-the-algorithm-step-by-step">4. The Algorithm: Step by Step</a><ul><li><a href="#41-high-level-approach">4.1 High-Level Approach</a></li><li><a href="#42-handling-negative-contributions">4.2 Handling Negative Contributions</a></li><li><a href="#43-the-key-formulas">4.3 The Key Formulas</a></li><li><a href="#44-visual-walkthrough">4.4 Visual Walkthrough</a></li></ul></li><li><a href="#5-the-solution">5. The Solution</a><ul><li><a href="#51-why-use-a-list-for-max_sum">5.1 Why Use a List for max_sum?</a></li></ul></li><li><a href="#6-common-mistakes-and-edge-cases">6. Common Mistakes and Edge Cases</a><ul><li><a href="#61-mistake-including-negative-paths">6.1 Mistake: Including Negative Paths</a></li><li><a href="#62-mistake-returning-the-complete-path-instead-of-contribution">6.2 Mistake: Returning the Complete Path Instead of Contribution</a></li><li><a href="#63-edge-case-all-negative-values">6.3 Edge Case: All Negative Values</a></li><li><a href="#64-edge-case-single-node">6.4 Edge Case: Single Node</a></li></ul></li><li><a href="#7-complexity-analysis">7. Complexity Analysis</a><ul><li><a href="#time-complexity-on">Time Complexity: O(N)</a></li><li><a href="#space-complexity-oh-where-h-is-the-tree-height">Space Complexity: O(H) where H is the tree height</a></li></ul></li><li><a href="#8-why-this-pattern-matters-connection-to-transfer-learning">8. Why This Pattern Matters: Connection to Transfer Learning</a></li><li><a href="#9-interview-tips">9. Interview Tips</a><ul><li><a href="#91-how-to-approach-this-in-an-interview">9.1 How to Approach This in an Interview</a></li><li><a href="#92-common-follow-up-questions">9.2 Common Follow-Up Questions</a></li></ul></li><li><a href="#10-practice-problems">10. Practice Problems</a></li><li><a href="#11-summary">11. Summary</a></li></ul>
            </nav>
          </aside>
        
        <p><strong>“Every path has a peak—find the one with the maximum sum.”</strong></p>

<h2 id="1-introduction-why-this-problem-matters">1. Introduction: Why This Problem Matters</h2>

<p>Imagine you’re analyzing a network of servers, where each server has a “value” representing its processing capacity (positive) or its overhead cost (negative). You want to find the most valuable path through this network—a sequence of connected servers that maximizes the total value.</p>

<p>This is exactly what the <strong>Binary Tree Maximum Path Sum</strong> problem asks us to solve. It’s a classic interview question at top tech companies because it tests your understanding of:</p>

<ul>
  <li><strong>Tree traversal and recursion</strong>: How to think about problems in terms of subproblems</li>
  <li><strong>Dynamic programming on trees</strong>: How to carry information up and down a tree</li>
  <li><strong>The distinction between “contribution” and “completion”</strong>: A subtle but crucial concept</li>
</ul>

<p>What makes this problem tricky is that the maximum path doesn’t have to go through the root. It can start and end anywhere in the tree. This seemingly small detail completely changes how we need to approach the problem.</p>

<hr />

<h2 id="2-understanding-the-problem">2. Understanding the Problem</h2>

<h3 id="21-what-is-a-path-in-a-binary-tree">2.1 What is a “Path” in a Binary Tree?</h3>

<p>Before we dive into the solution, let’s make sure we understand exactly what we’re looking for.</p>

<p>A <strong>path</strong> in a binary tree is:</p>
<ul>
  <li>A sequence of nodes where each consecutive pair is connected by an edge</li>
  <li>The path can start at any node and end at any node</li>
  <li><strong>Crucially</strong>: The path cannot branch. Once you go down a path, you can’t split and go both left and right.</li>
</ul>

<p>Let me illustrate this with a visual:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Valid paths:        Invalid path (branches):
    
    1                      1
   / \                    /|\
  2   3                  2 1 3   ← Can't go both ways!
     / \                    
    4   5              
    
Paths: [2,1,3], [4,3,5], [1,3,4], etc.
</code></pre></div></div>

<h3 id="22-the-problem-statement">2.2 The Problem Statement</h3>

<p>Given a binary tree, find the <strong>maximum path sum</strong>. The path:</p>
<ul>
  <li>Must contain at least one node</li>
  <li>Can start and end at any nodes</li>
  <li>Follows parent-child connections (no jumping)</li>
</ul>

<p><strong>Example 1: Simple case</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    1
   / \
  2   3

Maximum path sum: 6 (path: 2 → 1 → 3)
</code></pre></div></div>

<p><strong>Example 2: With negative values</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>       -10
       /  \
      9   20
         /  \
        15   7

Maximum path sum: 42 (path: 15 → 20 → 7)
</code></pre></div></div>

<p>Notice in Example 2 that the maximum path doesn’t include the root (-10) because including it would reduce the sum!</p>

<h3 id="23-why-this-problem-is-tricky">2.3 Why This Problem is Tricky</h3>

<p>At first glance, you might think: “Just find the path from any node to any other node with the maximum sum.” But there are <strong>exponentially many paths</strong> in a tree! For a tree with N nodes, checking all possible paths would take O(N²) or worse.</p>

<p>The key insight is that we need to think about this problem differently—not as “finding paths” but as “computing values at each node that help us track the global maximum.”</p>

<hr />

<h2 id="3-building-intuition-the-arc-concept">3. Building Intuition: The Arc Concept</h2>

<h3 id="31-every-path-is-an-arc-with-a-peak">3.1 Every Path is an “Arc” with a Peak</h3>

<p>Here’s the mental model that unlocks this problem: <strong>every path in a tree forms an arc with exactly one highest point</strong> (we’ll call it the “peak” or “turning point”).</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        Peak
       /    \
      ↗      ↘
    Left    Right
   branch   branch
</code></pre></div></div>

<p>At any node in the tree, a path passing through that node can:</p>
<ol>
  <li>Come up from the left subtree</li>
  <li>Pass through this node (the peak)</li>
  <li>Go down into the right subtree</li>
</ol>

<p>Or it could only go left, or only go right, or just be the node itself.</p>

<h3 id="32-two-different-questions-at-each-node">3.2 Two Different Questions at Each Node</h3>

<p>This leads us to ask <strong>two different questions</strong> at each node:</p>

<p><strong>Question 1: What’s the maximum path that “peaks” at this node?</strong>
This is a path that might use both left and right children. This value helps us update our global maximum.</p>

<p><strong>Question 2: What’s the maximum contribution this subtree can make to a path that peaks higher up?</strong>
This is the value we return to the parent. It can only go in ONE direction (left or right, not both), because the path can’t branch.</p>

<p>Let me illustrate:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        A  ← Parent asking: "What can child B contribute to me?"
       /
      B  ← B can contribute: B.val + max(left_contribution, right_contribution)
     / \           BUT NOT: B.val + left + right (that would branch!)
    L   R
</code></pre></div></div>

<p>This distinction between “complete path at this node” and “contribution to parent” is the crux of the solution.</p>

<hr />

<h2 id="4-the-algorithm-step-by-step">4. The Algorithm: Step by Step</h2>

<h3 id="41-high-level-approach">4.1 High-Level Approach</h3>

<p>We’ll use <strong>post-order traversal</strong> (process children before parent) with a clever twist:</p>

<ol>
  <li>At each node, compute the maximum contribution this subtree can offer to its parent</li>
  <li>While doing this, also compute the maximum complete path that peaks at this node</li>
  <li>Keep track of the global maximum path sum across all nodes</li>
</ol>

<h3 id="42-handling-negative-contributions">4.2 Handling Negative Contributions</h3>

<p>What if a child’s contribution is negative? Should we include it?</p>

<p><strong>No!</strong> If a subtree contributes a negative value, we’re better off not including it at all. We use <code class="language-plaintext highlighter-rouge">max(0, child_contribution)</code> to handle this elegantly.</p>

<p>For example:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      5
     / \
   -3   2

Left contribution: max(0, -3) = 0  (ignore the left child)
Right contribution: max(0, 2) = 2  (include the right child)

Maximum path at node 5: 5 + 0 + 2 = 7
Contribution to parent: 5 + max(0, 2) = 7
</code></pre></div></div>

<h3 id="43-the-key-formulas">4.3 The Key Formulas</h3>

<p>At each node, we compute:</p>

<p><strong>1. Gain from left child:</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>left_gain = max(0, left_child_contribution)
</code></pre></div></div>

<p><strong>2. Gain from right child:</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>right_gain = max(0, right_child_contribution)
</code></pre></div></div>

<p><strong>3. Maximum complete path peaking at this node:</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>peak_path_sum = node.val + left_gain + right_gain
</code></pre></div></div>
<p>This is a complete path that uses both children (if beneficial).</p>

<p><strong>4. Contribution to parent:</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>contribution_to_parent = node.val + max(left_gain, right_gain)
</code></pre></div></div>
<p>This can only go in ONE direction to avoid branching.</p>

<h3 id="44-visual-walkthrough">4.4 Visual Walkthrough</h3>

<p>Let’s trace through Example 2:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>       -10
       /  \
      9   20
         /  \
        15   7
</code></pre></div></div>

<p><strong>Processing order</strong> (post-order): 9, 15, 7, 20, -10</p>

<p><strong>Step 1: Process node 9 (leaf)</strong></p>
<ul>
  <li>Left gain: 0 (no left child)</li>
  <li>Right gain: 0 (no right child)</li>
  <li>Peak path sum: 9 + 0 + 0 = 9</li>
  <li>Global max so far: 9</li>
  <li>Contribution to parent: 9 + max(0, 0) = 9</li>
</ul>

<p><strong>Step 2: Process node 15 (leaf)</strong></p>
<ul>
  <li>Left gain: 0</li>
  <li>Right gain: 0</li>
  <li>Peak path sum: 15</li>
  <li>Global max so far: max(9, 15) = 15</li>
  <li>Contribution to parent: 15</li>
</ul>

<p><strong>Step 3: Process node 7 (leaf)</strong></p>
<ul>
  <li>Left gain: 0</li>
  <li>Right gain: 0</li>
  <li>Peak path sum: 7</li>
  <li>Global max so far: max(15, 7) = 15</li>
  <li>Contribution to parent: 7</li>
</ul>

<p><strong>Step 4: Process node 20</strong></p>
<ul>
  <li>Left gain: max(0, 15) = 15</li>
  <li>Right gain: max(0, 7) = 7</li>
  <li>Peak path sum: 20 + 15 + 7 = <strong>42</strong> ✨</li>
  <li>Global max so far: max(15, 42) = 42</li>
  <li>Contribution to parent: 20 + max(15, 7) = 35</li>
</ul>

<p><strong>Step 5: Process node -10 (root)</strong></p>
<ul>
  <li>Left gain: max(0, 9) = 9</li>
  <li>Right gain: max(0, 35) = 35</li>
  <li>Peak path sum: -10 + 9 + 35 = 34</li>
  <li>Global max so far: max(42, 34) = <strong>42</strong> (unchanged)</li>
  <li>Contribution to parent: N/A (this is the root)</li>
</ul>

<p><strong>Final answer: 42</strong> (the path 15 → 20 → 7)</p>

<hr />

<h2 id="5-the-solution">5. The Solution</h2>

<p>Now that we understand the algorithm, let’s look at the implementation. Notice how concise it is—the complexity is in the thinking, not the code!</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">TreeNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="n">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="n">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>


<span class="k">def</span> <span class="nf">maxPathSum</span><span class="p">(</span><span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">
    Find the maximum path sum in a binary tree.
    
    The key insight is distinguishing between:
    1. The max path </span><span class="sh">"</span><span class="s">peaking</span><span class="sh">"</span><span class="s"> at each node (for global max)
    2. The max </span><span class="sh">"</span><span class="s">contribution</span><span class="sh">"</span><span class="s"> to parent (for recursion)
    </span><span class="sh">"""</span>
    <span class="c1"># We use a list to allow modification in nested function
</span>    <span class="n">max_sum</span> <span class="o">=</span> <span class="p">[</span><span class="nf">float</span><span class="p">(</span><span class="sh">'</span><span class="s">-inf</span><span class="sh">'</span><span class="p">)]</span>
    
    <span class="k">def</span> <span class="nf">compute_max_contribution</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">
        Returns the maximum contribution this subtree can make
        to a path that extends upward to the parent.
        
        Side effect: Updates max_sum if we find a better path.
        </span><span class="sh">"""</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        
        <span class="c1"># Recursively get contributions from children
</span>        <span class="c1"># Use max(0, ...) to ignore negative contributions
</span>        <span class="n">left_gain</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nf">compute_max_contribution</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">))</span>
        <span class="n">right_gain</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nf">compute_max_contribution</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">))</span>
        
        <span class="c1"># The best complete path through this node
</span>        <span class="n">peak_path_sum</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">val</span> <span class="o">+</span> <span class="n">left_gain</span> <span class="o">+</span> <span class="n">right_gain</span>
        
        <span class="c1"># Update global maximum
</span>        <span class="n">max_sum</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="n">max_sum</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">peak_path_sum</span><span class="p">)</span>
        
        <span class="c1"># Return contribution to parent (can only go one direction)
</span>        <span class="k">return</span> <span class="n">node</span><span class="p">.</span><span class="n">val</span> <span class="o">+</span> <span class="nf">max</span><span class="p">(</span><span class="n">left_gain</span><span class="p">,</span> <span class="n">right_gain</span><span class="p">)</span>
    
    <span class="nf">compute_max_contribution</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">max_sum</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</code></pre></div></div>

<h3 id="51-why-use-a-list-for-max_sum">5.1 Why Use a List for max_sum?</h3>

<p>You might wonder why we use <code class="language-plaintext highlighter-rouge">max_sum = [float('-inf')]</code> instead of just <code class="language-plaintext highlighter-rouge">max_sum = float('-inf')</code>.</p>

<p>In Python, when you assign a new value to a variable inside a nested function, Python treats it as a new local variable. Using a list (or <code class="language-plaintext highlighter-rouge">nonlocal</code> keyword) lets us modify the outer variable.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># This doesn't work:
</span><span class="n">max_sum</span> <span class="o">=</span> <span class="nf">float</span><span class="p">(</span><span class="sh">'</span><span class="s">-inf</span><span class="sh">'</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">inner</span><span class="p">():</span>
    <span class="n">max_sum</span> <span class="o">=</span> <span class="mi">10</span>  <span class="c1"># Creates a NEW local variable!
</span>
<span class="c1"># This works:
</span><span class="n">max_sum</span> <span class="o">=</span> <span class="p">[</span><span class="nf">float</span><span class="p">(</span><span class="sh">'</span><span class="s">-inf</span><span class="sh">'</span><span class="p">)]</span>
<span class="k">def</span> <span class="nf">inner</span><span class="p">():</span>
    <span class="n">max_sum</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span>  <span class="c1"># Modifies the existing list
</span></code></pre></div></div>

<hr />

<h2 id="6-common-mistakes-and-edge-cases">6. Common Mistakes and Edge Cases</h2>

<h3 id="61-mistake-including-negative-paths">6.1 Mistake: Including Negative Paths</h3>

<p><strong>Wrong thinking</strong>: “I should include all children in the path.”</p>

<p><strong>Correct thinking</strong>: Use <code class="language-plaintext highlighter-rouge">max(0, child_contribution)</code> to exclude negative contributions.</p>

<h3 id="62-mistake-returning-the-complete-path-instead-of-contribution">6.2 Mistake: Returning the Complete Path Instead of Contribution</h3>

<p><strong>Wrong thinking</strong>: “Return <code class="language-plaintext highlighter-rouge">node.val + left + right</code> to the parent.”</p>

<p><strong>Correct thinking</strong>: Return <code class="language-plaintext highlighter-rouge">node.val + max(left, right)</code> because paths can’t branch.</p>

<h3 id="63-edge-case-all-negative-values">6.3 Edge Case: All Negative Values</h3>

<p>What if every node has a negative value?</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      -3
     /  \
   -2   -1
</code></pre></div></div>

<p>The answer should be <strong>-1</strong> (just the node with the largest value, since we must include at least one node).</p>

<p>Our algorithm handles this correctly because:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">max_sum</code> starts at negative infinity</li>
  <li>We always update it with <code class="language-plaintext highlighter-rouge">peak_path_sum</code> which includes at least the node’s value</li>
  <li>The maximum single node (-1) becomes our answer</li>
</ul>

<h3 id="64-edge-case-single-node">6.4 Edge Case: Single Node</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    5

Answer: 5
</code></pre></div></div>

<p>Our algorithm handles this: left_gain = 0, right_gain = 0, peak_path_sum = 5.</p>

<hr />

<h2 id="7-complexity-analysis">7. Complexity Analysis</h2>

<h3 id="time-complexity-on">Time Complexity: O(N)</h3>

<p>We visit each node exactly once during the post-order traversal. At each node, we do O(1) work (a few comparisons and additions).</p>

<h3 id="space-complexity-oh-where-h-is-the-tree-height">Space Complexity: O(H) where H is the tree height</h3>

<p>The space is used by the recursion stack. In the worst case (a completely skewed tree), H = N, so space is O(N). For a balanced tree, H = log(N), so space is O(log N).</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Skewed tree (H = N):     Balanced tree (H = log N):
    1                           4
     \                        /   \
      2                      2     6
       \                    / \   / \
        3                  1   3 5   7
</code></pre></div></div>

<hr />

<h2 id="8-why-this-pattern-matters-connection-to-transfer-learning">8. Why This Pattern Matters: Connection to Transfer Learning</h2>

<p>This problem teaches a pattern that appears throughout computer science and machine learning: <strong>the distinction between local computation and global tracking</strong>.</p>

<p>In the context of <strong>Transfer Learning</strong> (Day 46 ML topic):</p>

<table>
  <thead>
    <tr>
      <th>Binary Tree Max Path Sum</th>
      <th>Transfer Learning</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Local contribution to parent</td>
      <td>Layer-specific features</td>
    </tr>
    <tr>
      <td>Global maximum path</td>
      <td>End-to-end model performance</td>
    </tr>
    <tr>
      <td>Choosing max(left, right)</td>
      <td>Selecting which features to transfer</td>
    </tr>
    <tr>
      <td>Ignoring negative contributions</td>
      <td>Filtering out harmful knowledge transfer</td>
    </tr>
  </tbody>
</table>

<p>Just as we track a global maximum while computing local contributions, transfer learning tracks global model performance while deciding which layer-specific knowledge to reuse.</p>

<hr />

<h2 id="9-interview-tips">9. Interview Tips</h2>

<h3 id="91-how-to-approach-this-in-an-interview">9.1 How to Approach This in an Interview</h3>

<ol>
  <li><strong>Start with examples</strong>: Draw a small tree and manually trace through what paths exist</li>
  <li><strong>Identify the insight</strong>: Explain the distinction between “peak path” and “contribution”</li>
  <li><strong>State the recurrence</strong>: Write out the formulas before coding</li>
  <li><strong>Handle edge cases</strong>: Mention negative values and single nodes</li>
  <li><strong>Analyze complexity</strong>: Time O(N), Space O(H)</li>
</ol>

<h3 id="92-common-follow-up-questions">9.2 Common Follow-Up Questions</h3>

<p><strong>Q: What if we need to return the actual path, not just the sum?</strong>
A: Track the nodes as we traverse. When we update the global max, also store the path.</p>

<p><strong>Q: What if we want the k largest path sums?</strong>
A: Use a min-heap of size k. Push each peak_path_sum and maintain heap size.</p>

<p><strong>Q: Can you solve this iteratively?</strong>
A: Yes, using a stack for post-order traversal, but it’s more complex and less intuitive.</p>

<hr />

<h2 id="10-practice-problems">10. Practice Problems</h2>

<p>Once you understand this pattern, try these related problems:</p>

<ol>
  <li><strong>Binary Tree Diameter</strong> - Similar concept, but counting edges instead of summing values</li>
  <li><strong>Path Sum III</strong> - Count paths that sum to a target (uses prefix sums)</li>
  <li><strong>Longest Univalue Path</strong> - Same pattern, different condition for extension</li>
</ol>

<hr />

<h2 id="11-summary">11. Summary</h2>

<p>The Binary Tree Maximum Path Sum problem teaches us a powerful pattern:</p>

<ol>
  <li>
    <p><strong>Think in terms of “contribution” vs “completion”</strong>: What value do we pass up to the parent vs. what value completes a path at this node?</p>
  </li>
  <li>
    <p><strong>Use post-order traversal for tree DP</strong>: Process children first, then use their results to compute the parent’s values.</p>
  </li>
  <li>
    <p><strong>Track global state while computing local values</strong>: The recursion computes contributions, but we update a global variable for the answer.</p>
  </li>
  <li>
    <p><strong>Handle negative values gracefully</strong>: Using <code class="language-plaintext highlighter-rouge">max(0, child)</code> elegantly handles the case where including a subtree would hurt our sum.</p>
  </li>
</ol>

<p>This pattern—computing local values while tracking a global optimum—appears in many contexts: network routing, game theory, and yes, transfer learning in machine learning.</p>

<hr />

<p><strong>Originally published at:</strong> <a href="https://www.arunbaby.com/dsa/0046-binary-tree-max-path-sum/">arunbaby.com/dsa/0046-binary-tree-max-path-sum</a></p>

<p><em>If you found this helpful, consider sharing it with others who might benefit.</em></p>

        
      </section>

      <footer class="page__meta">
        
        
  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-tags" aria-hidden="true"></i> Tags: </strong>
    <span itemprop="keywords">
    
      <a href="/tags/#binary-tree" class="page__taxonomy-item p-category" rel="tag">binary-tree</a><span class="sep">, </span>
    
      <a href="/tags/#dfs" class="page__taxonomy-item p-category" rel="tag">dfs</a><span class="sep">, </span>
    
      <a href="/tags/#dynamic-programming" class="page__taxonomy-item p-category" rel="tag">dynamic-programming</a><span class="sep">, </span>
    
      <a href="/tags/#hard" class="page__taxonomy-item p-category" rel="tag">hard</a><span class="sep">, </span>
    
      <a href="/tags/#path-finding" class="page__taxonomy-item p-category" rel="tag">path-finding</a><span class="sep">, </span>
    
      <a href="/tags/#recursion" class="page__taxonomy-item p-category" rel="tag">recursion</a><span class="sep">, </span>
    
      <a href="/tags/#tree-dp" class="page__taxonomy-item p-category" rel="tag">tree-dp</a>
    
    </span>
  </p>




  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> Categories: </strong>
    <span itemprop="keywords">
    
      <a href="/categories/#dsa" class="page__taxonomy-item p-category" rel="tag">dsa</a>
    
    </span>
  </p>


        
      </footer>

      <div class="page__related page__related--full">
  <h2 class="page__related-title">Related across topics</h2>
  <style>
    /* Make section span full content width and use 2 equal columns */
    .page__related--full { float: inline-start; width: 100%; padding: 0; }
    .cross-related-grid { display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 2rem; }
    @media (max-width: 768px) { .cross-related-grid { grid-template-columns: 1fr; } }
    /* Ensure archive cards stretch nicely in the grid */
    .cross-related-grid .list__item, .cross-related-grid .grid__item { width: auto; float: none; margin: 0; }
  </style>
  <div class="cross-related-grid">
    



<div class="list__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/ml-system-design/0046-transfer-learning/" rel="permalink">Transfer Learning Systems
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          14 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">“Why train from scratch when you can stand on the shoulders of giants?”
</p>
  </article>
</div>




<div class="list__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/speech-tech/0046-cross-lingual-speech-transfer/" rel="permalink">Cross-Lingual Speech Transfer
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          14 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">“A child learns their first language in years; their second language in months. Speech models can do the same.”
</p>
  </article>
</div>




<div class="list__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/ai-agents/0046-token-efficiency-optimization/" rel="permalink">Token Efficiency Optimization
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          15 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">“Every token costs money. Every wasted token is wasted money.”
</p>
  </article>
</div>

  </div>
</div>

      <section class="page__share">
  <h4 class="page__share-title">Share on</h4>

  <a href="https://twitter.com/intent/tweet?via=arunbaby0&text=Binary+Tree+Maximum+Path+Sum%20https%3A%2F%2Fwww.arunbaby.com%2Fdsa%2F0046-binary-tree-max-path-sum%2F" class="btn btn--twitter" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Twitter"><i class="fab fa-fw fa-twitter" aria-hidden="true"></i><span> Twitter</span></a>

  <a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fwww.arunbaby.com%2Fdsa%2F0046-binary-tree-max-path-sum%2F" class="btn btn--facebook" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Facebook"><i class="fab fa-fw fa-facebook" aria-hidden="true"></i><span> Facebook</span></a>

  <a href="https://www.linkedin.com/shareArticle?mini=true&url=https://www.arunbaby.com/dsa/0046-binary-tree-max-path-sum/" class="btn btn--linkedin" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on LinkedIn"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i><span> LinkedIn</span></a>
</section>


      
  <nav class="pagination">
    
      <a href="/dsa/0045-sliding-window-maximum/" class="pagination--pager" title="Sliding Window Maximum">Previous</a>
    
    
      <a href="/dsa/0047-serialize-deserialize-tree/" class="pagination--pager" title="Serialize and Deserialize Binary Tree">Next</a>
    
  </nav>


    </div>

    
  </article>

  
  
</div>

      
    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';" role="search">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Enter your search term..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    

    
      
        
          <li><a href="https://twitter.com/arunbaby0" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-twitter-square" aria-hidden="true"></i> Twitter</a></li>
        
      
        
          <li><a href="https://github.com/arunbaby0" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
        
      
        
          <li><a href="https://www.linkedin.com/in/arunbaby0/" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i> LinkedIn</a></li>
        
      
        
          <li><a href="https://scholar.google.co.in/citations?user=6fSYWhkAAAAJ" rel="nofollow noopener noreferrer"><i class="fas fa-fw fa-graduation-cap" aria-hidden="true"></i> Google Scholar</a></li>
        
      
    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 1990 - 2143 <a href="https://www.arunbaby.com">Arun Baby</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>




  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-0JRJPEC9SS"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-0JRJPEC9SS', { 'anonymize_ip': false});
</script>








  </body>
</html>
