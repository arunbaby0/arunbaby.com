<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.26.2 by Michael Rose
  Copyright 2013-2024 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->

<html lang="en-US" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Wildcard Matching - Arun Baby</title>
<meta name="description" content="“Wildcard matching is more than a string puzzle—it is the foundation of every file system glob, every firewall rule, and every log-routing engine you use today.”">


  <meta name="author" content="Arun Baby">
  
  <meta property="article:author" content="Arun Baby">
  


<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="Arun Baby">
<meta property="og:title" content="Wildcard Matching">
<meta property="og:url" content="https://www.arunbaby.com/dsa/0054-wildcard-matching/">


  <meta property="og:description" content="“Wildcard matching is more than a string puzzle—it is the foundation of every file system glob, every firewall rule, and every log-routing engine you use today.”">



  <meta property="og:image" content="https://www.arunbaby.com/assets/images/profile-photo.png">



  <meta name="twitter:site" content="@arunbaby0">
  <meta name="twitter:title" content="Wildcard Matching">
  <meta name="twitter:description" content="“Wildcard matching is more than a string puzzle—it is the foundation of every file system glob, every firewall rule, and every log-routing engine you use today.”">
  <meta name="twitter:url" content="https://www.arunbaby.com/dsa/0054-wildcard-matching/">

  
    <meta name="twitter:card" content="summary">
    
      <meta name="twitter:image" content="https://www.arunbaby.com/assets/images/profile-photo.png">
    
  

  



  <meta property="article:published_time" content="2025-12-31T09:51:02+05:30">





  

  


<link rel="canonical" href="https://www.arunbaby.com/dsa/0054-wildcard-matching/">












<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Arun Baby Feed">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
  
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css"></noscript>



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--single" dir="ltr">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
           
          <span class="site-subtitle">Arun Baby</span>
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a
                href="/about/"
                
                
              >About</a>
            </li><li class="masthead__menu-item">
              <a
                href="/dsa/"
                
                
              >DSA</a>
            </li><li class="masthead__menu-item">
              <a
                href="/ml-system-design/"
                
                
              >ML Systems</a>
            </li><li class="masthead__menu-item">
              <a
                href="/speech-tech/"
                
                
              >Speech Tech</a>
            </li><li class="masthead__menu-item">
              <a
                href="/ai-agents/"
                
                
              >AI Agents</a>
            </li><li class="masthead__menu-item">
              <a
                href="/publications/"
                
                
              >Publications</a>
            </li><li class="masthead__menu-item">
              <a
                href="/statuses/"
                
                
              >Statuses</a>
            </li><li class="masthead__menu-item">
              <a
                href="/contact/"
                
                
              >Contact</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <i class="fas fa-search"></i>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      





<div id="main" role="main" class="no-author-sidebar">
  
  <div class="sidebar sticky">
  
  
  </div>



  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="Wildcard Matching">
    <meta itemprop="description" content="“Wildcard matching is more than a string puzzle—it is the foundation of every file system glob, every firewall rule, and every log-routing engine you use today.”">
    <meta itemprop="datePublished" content="2025-12-31T09:51:02+05:30">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">
            <a href="https://www.arunbaby.com/dsa/0054-wildcard-matching/" itemprop="url">Wildcard Matching
</a>
          </h1>
          

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          20 minute read
        
      </span>
    
  </p>


        </header>
      

      <section class="page__content" itemprop="text">
        
          <aside class="sidebar__right sticky">
            <nav class="toc">
              <header><h4 class="nav__title"><i class="fas fa-file-alt"></i> On this page</h4></header>
              <ul class="toc__menu"><li><a href="#1-problem-statement">1. Problem Statement</a><ul><li><a href="#11-formal-definition">1.1 Formal Definition</a></li></ul></li><li><a href="#2-understanding-the-problem">2. Understanding the Problem</a><ul><li><a href="#21-the-nature-of-wildcards">2.1 The Nature of Wildcards</a></li><li><a href="#22-why-this-problem-is-hard">2.2 Why This Problem is Hard</a></li><li><a href="#23-visualizing-the-state-machine">2.3 Visualizing the State Machine</a></li><li><a href="#24-thematic-link-pattern-recognition-and-determinism">2.4 Thematic link: Pattern Recognition and Determinism</a></li></ul></li><li><a href="#3-approach-1-recursive-backtracking-brute-force">3. Approach 1: Recursive Backtracking (Brute Force)</a><ul><li><a href="#31-the-logic">3.1 The Logic</a></li><li><a href="#32-complexity-analysis">3.2 Complexity Analysis</a></li><li><a href="#33-adding-memoization-top-down-dp">3.3 Adding Memoization (Top-Down DP)</a></li></ul></li><li><a href="#4-approach-2-dynamic-programming-bottom-up">4. Approach 2: Dynamic Programming (Bottom-Up)</a><ul><li><a href="#41-the-dp-state">4.1 The DP State</a></li><li><a href="#42-base-cases">4.2 Base Cases</a></li><li><a href="#43-transitions">4.3 Transitions</a></li><li><a href="#44-ascii-visualization-of-dp-table">4.4 ASCII Visualization of DP Table</a></li></ul></li><li><a href="#5-space-optimization-the-1d-rolling-array">5. Space Optimization: The 1D Rolling Array</a></li><li><a href="#6-theory-automata-and-non-determinism">6. Theory: Automata and Non-Determinism</a><ul><li><a href="#61-nfa-vs-dfa">6.1 NFA vs DFA</a></li><li><a href="#62-thompsons-construction">6.2 Thompson’s Construction</a></li></ul></li><li><a href="#7-approach-3-greedy-two-pointer-the-optimal-interview-answer">7. Approach 3: Greedy Two-Pointer (The “Optimal” Interview Answer)</a><ul><li><a href="#71-the-logic">7.1 The Logic</a></li><li><a href="#72-why-this-works">7.2 Why this works</a></li></ul></li><li><a href="#8-implementation">8. Implementation</a><ul><li><a href="#81-approach-1-top-down-recursion-with-memoization">8.1 Approach 1: Top-Down Recursion with Memoization</a></li><li><a href="#82-approach-2-bottom-up-dynamic-programming-standard">8.2 Approach 2: Bottom-Up Dynamic Programming (Standard)</a></li><li><a href="#83-approach-3-greedy-two-pointer-optimal-space">8.3 Approach 3: Greedy Two-Pointer (Optimal Space)</a></li></ul></li><li><a href="#9-advanced-the-bitap-algorithm">9. Advanced: The Bitap Algorithm</a><ul><li><a href="#91-how-it-works">9.1 How it Works</a></li><li><a href="#92-why-use-it">9.2 Why use it?</a></li></ul></li><li><a href="#10-complexity-analysis">10. Complexity Analysis</a></li><li><a href="#11-production-considerations">11. Production Considerations</a><ul><li><a href="#111-history-unix-globs">11.1 History: Unix Globs</a></li><li><a href="#112-pattern-normalization-optimization">11.2 Pattern Normalization (Optimization)</a></li><li><a href="#113-security-avoiding-redos-regex-denial-of-service">11.3 Security: Avoiding ReDoS (Regex Denial of Service)</a></li><li><a href="#114-wildcards-in-databases-sql-like">11.4 Wildcards in Databases: SQL LIKE</a></li><li><a href="#115-compilation-to-machine-code">11.5 Compilation to Machine Code</a></li><li><a href="#116-case-study-aws-iam-policy-evaluation">11.6 Case Study: AWS IAM Policy Evaluation</a></li></ul></li><li><a href="#12-implementation-deep-dive-line-by-line">12. Implementation Deep Dive: Line-by-Line</a><ul><li><a href="#121-explaining-the-dp-implementation">12.1 Explaining the DP Implementation</a></li><li><a href="#122-explaining-the-greedy-implementation">12.2 Explaining the Greedy Implementation</a></li></ul></li><li><a href="#13-connections-to-ml-systems">13. Connections to ML Systems</a><ul><li><a href="#131-dynamic-matching-in-feature-engineering">13.1 Dynamic Matching in Feature Engineering</a></li><li><a href="#132-data-validation-guardrails">13.2 Data Validation Guardrails</a></li><li><a href="#133-search-and-retrieval">13.3 Search and Retrieval</a></li></ul></li><li><a href="#14-key-takeaways">14. Key Takeaways</a></li></ul>
            </nav>
          </aside>
        
        <p><strong>“Wildcard matching is more than a string puzzle—it is the foundation of every file system glob, every firewall rule, and every log-routing engine you use today.”</strong></p>

<h2 id="1-problem-statement">1. Problem Statement</h2>

<p>Given an input string <code class="language-plaintext highlighter-rouge">s</code> and a pattern <code class="language-plaintext highlighter-rouge">p</code>, implement wildcard matching with support for <code class="language-plaintext highlighter-rouge">?</code> and <code class="language-plaintext highlighter-rouge">*</code>.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">?</code> matches any single character.</li>
  <li><code class="language-plaintext highlighter-rouge">*</code> matches any sequence of characters (including the empty sequence).</li>
</ul>

<p>The matching must cover the entire input string (not just a substring).</p>

<h3 id="11-formal-definition">1.1 Formal Definition</h3>
<p>Given:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">S = s_1 s_2 \dots s_m</code></li>
  <li><code class="language-plaintext highlighter-rouge">P = p_1 p_2 \dots p_n</code></li>
</ul>

<p>Determine if <code class="language-plaintext highlighter-rouge">S</code> matches <code class="language-plaintext highlighter-rouge">P</code>.</p>

<p><strong>Example 1</strong></p>
<ul>
  <li>Input: <code class="language-plaintext highlighter-rouge">s = "aa"</code>, <code class="language-plaintext highlighter-rouge">p = "a"</code></li>
  <li>Output: <code class="language-plaintext highlighter-rouge">false</code></li>
  <li>Explanation: “a” does not match the entire string “aa”.</li>
</ul>

<p><strong>Example 2</strong></p>
<ul>
  <li>Input: <code class="language-plaintext highlighter-rouge">s = "aa"</code>, <code class="language-plaintext highlighter-rouge">p = "*"</code></li>
  <li>Output: <code class="language-plaintext highlighter-rouge">true</code></li>
  <li>Explanation: ‘*’ matches any sequence.</li>
</ul>

<p><strong>Example 3</strong></p>
<ul>
  <li>Input: <code class="language-plaintext highlighter-rouge">s = "cb"</code>, <code class="language-plaintext highlighter-rouge">p = "?a"</code></li>
  <li>Output: <code class="language-plaintext highlighter-rouge">false</code></li>
  <li>Explanation: ‘?’ matches ‘c’, but ‘a’ does not match ‘b’.</li>
</ul>

<p><strong>Example 4</strong></p>
<ul>
  <li>Input: <code class="language-plaintext highlighter-rouge">s = "adceb"</code>, <code class="language-plaintext highlighter-rouge">p = "*a*b"</code></li>
  <li>Output: <code class="language-plaintext highlighter-rouge">true</code></li>
  <li>Explanation: The first ‘<em>’ matches the empty string, ‘a’ matches ‘a’, the second ‘</em>’ matches “dce”, and ‘b’ matches ‘b’.</li>
</ul>

<hr />

<h2 id="2-understanding-the-problem">2. Understanding the Problem</h2>

<h3 id="21-the-nature-of-wildcards">2.1 The Nature of Wildcards</h3>
<p>In the world of computer science, wildcard matching is a subset of Regular Expression matching. While full regex (PCRE, POSIX) supports complex quantifiers like <code class="language-plaintext highlighter-rouge">+</code>, <code class="language-plaintext highlighter-rouge">{n,m}</code>, and lookaheads, wildcards (often called <strong>globbing</strong>) are simpler and more prevalent in shell environments (e.g., <code class="language-plaintext highlighter-rouge">rm *.txt</code>).</p>

<p>The simplicity of wildcards often masks their computational complexity. The <code class="language-plaintext highlighter-rouge">*</code> character introduced <strong>non-determinism</strong>. When a matcher encounters a <code class="language-plaintext highlighter-rouge">*</code>, it doesn’t know how many characters to consume. It could consume zero, one, or one hundred. This creates a branching path of possibilities.</p>

<h3 id="22-why-this-problem-is-hard">2.2 Why This Problem is Hard</h3>
<p>The difficulty lies entirely in the <code class="language-plaintext highlighter-rouge">*</code> operator.</p>
<ul>
  <li>If we only had literal characters, we would just use a single loop.</li>
  <li>If we only had <code class="language-plaintext highlighter-rouge">?</code>, we would still use a single loop (checking for equality or <code class="language-plaintext highlighter-rouge">?</code>).</li>
  <li>With <code class="language-plaintext highlighter-rouge">*</code>, we face an <strong>ambiguity</strong> that requires exploring multiple futures. If we choose to let <code class="language-plaintext highlighter-rouge">*</code> match “a” but it should have matched “ab”, our linear scan fails.</li>
</ul>

<h3 id="23-visualizing-the-state-machine">2.3 Visualizing the State Machine</h3>
<p>Imagine a state machine where each character in the pattern is a state.</p>

<p>``text
Pattern: a * b</p>

<p>State 0: Start
State 1: Matched ‘a’
State 2: The ‘*’ loop (can stay here for any character)
State 3: Matched ‘b’ (Final State)</p>

<p>Transitions:
(S0) –‘a’–&gt; (S1)
(S1) –empty–&gt; (S2)
(S2) –any char–&gt; (S2)
(S2) –‘b’–&gt; (S3)
``</p>

<p>In the state machine above, when we are in State 2, we have a choice: stay in State 2 (consuming a character) or move to State 3 if the current character is ‘b’. This choice is what leads to the need for Dynamic Programming or backtracking.</p>

<h3 id="24-thematic-link-pattern-recognition-and-determinism">2.4 Thematic link: Pattern Recognition and Determinism</h3>
<p>Today’s shared theme across tracks is <strong>Pattern Matching and State Machines</strong>:</p>
<ul>
  <li><strong>DSA</strong>: We are building a discrete pattern matcher for strings.</li>
  <li><strong>ML System Design</strong>: Pattern matching is used in feature engineering (detecting sequences in time-series) and data validation (regex-based schema checks).</li>
  <li><strong>Speech Tech</strong>: Acoustic pattern matching (finding a specific wake-word like “Hey Siri”) uses HMMs (Hidden Markov Models) which are essentially probabilistic state machines.</li>
  <li><strong>Agents</strong>: Scaling multi-agent systems requires agents to match message patterns to internal handlers (a form of “routing” or “dispatching”).</li>
</ul>

<hr />

<h2 id="3-approach-1-recursive-backtracking-brute-force">3. Approach 1: Recursive Backtracking (Brute Force)</h2>

<h3 id="31-the-logic">3.1 The Logic</h3>
<p>A natural way to solve this is to define a recursive function <code class="language-plaintext highlighter-rouge">isMatch(s_idx, p_idx)</code>.</p>

<ol>
  <li>If both indices reach the end, return <code class="language-plaintext highlighter-rouge">True</code>.</li>
  <li>If the pattern ends but the string doesn’t, return <code class="language-plaintext highlighter-rouge">False</code>.</li>
  <li>If the string ends but the pattern remains:
    <ul>
      <li>If the remaining pattern characters are all <code class="language-plaintext highlighter-rouge">*</code>, return <code class="language-plaintext highlighter-rouge">True</code> (as <code class="language-plaintext highlighter-rouge">*</code> can match empty).</li>
      <li>Otherwise, return <code class="language-plaintext highlighter-rouge">False</code>.</li>
    </ul>
  </li>
  <li>If <code class="language-plaintext highlighter-rouge">p[p_idx]</code> is a literal or <code class="language-plaintext highlighter-rouge">?</code>:
    <ul>
      <li>Match if <code class="language-plaintext highlighter-rouge">s[s_idx] == p[p_idx]</code> or <code class="language-plaintext highlighter-rouge">p[p_idx] == '?'</code>.</li>
      <li>Recurse to <code class="language-plaintext highlighter-rouge">isMatch(s_idx + 1, p_idx + 1)</code>.</li>
    </ul>
  </li>
  <li>If <code class="language-plaintext highlighter-rouge">p[p_idx]</code> is <code class="language-plaintext highlighter-rouge">*</code>:
    <ul>
      <li>Choice A: <code class="language-plaintext highlighter-rouge">*</code> matches empty. Recurse to <code class="language-plaintext highlighter-rouge">isMatch(s_idx, p_idx + 1)</code>.</li>
      <li>Choice B: <code class="language-plaintext highlighter-rouge">*</code> matches the current character and potentially more. Recurse to <code class="language-plaintext highlighter-rouge">isMatch(s_idx + 1, p_idx)</code>.</li>
    </ul>
  </li>
</ol>

<h3 id="32-complexity-analysis">3.2 Complexity Analysis</h3>
<ul>
  <li><strong>Time</strong>: O(2^{M+N}) in the worst case (e.g., <code class="language-plaintext highlighter-rouge">s = "aaaaa"</code>, <code class="language-plaintext highlighter-rouge">p = "*****b"</code>). Every <code class="language-plaintext highlighter-rouge">*</code> creates two branches.</li>
  <li><strong>Space</strong>: O(M+N) for the recursion stack.</li>
</ul>

<h3 id="33-adding-memoization-top-down-dp">3.3 Adding Memoization (Top-Down DP)</h3>
<p>To optimize, we cache the results of <code class="language-plaintext highlighter-rouge">(s_idx, p_idx)</code>. There are only <code class="language-plaintext highlighter-rouge">M \times N</code> possible states.</p>
<ul>
  <li><strong>Time</strong>: O(M \times N).</li>
  <li><strong>Space</strong>: O(M \times N).</li>
</ul>

<hr />

<h2 id="4-approach-2-dynamic-programming-bottom-up">4. Approach 2: Dynamic Programming (Bottom-Up)</h2>

<p>Bottom-up DP is often preferred in high-performance systems to avoid recursion depth issues and to leverage cache locality.</p>

<h3 id="41-the-dp-state">4.1 The DP State</h3>
<p>Let <code class="language-plaintext highlighter-rouge">dp[i][j]</code> be a boolean indicating whether <code class="language-plaintext highlighter-rouge">s[0...i-1]</code> matches <code class="language-plaintext highlighter-rouge">p[0...j-1]</code>.</p>

<p>The table size will be <code class="language-plaintext highlighter-rouge">(len(s) + 1) x (len(p) + 1)</code>.</p>

<h3 id="42-base-cases">4.2 Base Cases</h3>
<ol>
  <li><code class="language-plaintext highlighter-rouge">dp[0][0] = True</code>: An empty string matches an empty pattern.</li>
  <li><code class="language-plaintext highlighter-rouge">dp[i][0] = False</code> for <code class="language-plaintext highlighter-rouge">i &gt; 0</code>: A non-empty string cannot match an empty pattern.</li>
  <li><code class="language-plaintext highlighter-rouge">dp[0][j]</code>: An empty string can only match a pattern if it consists entirely of <code class="language-plaintext highlighter-rouge">*</code>.
    <ul>
      <li><code class="language-plaintext highlighter-rouge">dp[0][j] = dp[0][j-1]</code> if <code class="language-plaintext highlighter-rouge">p[j-1] == '*'</code>.</li>
    </ul>
  </li>
</ol>

<h3 id="43-transitions">4.3 Transitions</h3>
<p>For <code class="language-plaintext highlighter-rouge">dp[i][j]</code>, check <code class="language-plaintext highlighter-rouge">p[j-1]</code>:</p>

<ol>
  <li><strong>If <code class="language-plaintext highlighter-rouge">p[j-1]</code> is a literal or <code class="language-plaintext highlighter-rouge">?</code></strong>:
    <ul>
      <li>We match if the current characters match AND the previous prefixes matched.</li>
      <li><code class="language-plaintext highlighter-rouge">dp[i][j] = dp[i-1][j-1]</code> and (<code class="language-plaintext highlighter-rouge">p[j-1] == s[i-1]</code> or <code class="language-plaintext highlighter-rouge">p[j-1] == '?'</code>)</li>
    </ul>
  </li>
  <li><strong>If <code class="language-plaintext highlighter-rouge">p[j-1]</code> is <code class="language-plaintext highlighter-rouge">*</code></strong>:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">*</code> acts as empty: <code class="language-plaintext highlighter-rouge">dp[i][j] = dp[i][j-1]</code></li>
      <li><code class="language-plaintext highlighter-rouge">*</code> acts as one or more characters: <code class="language-plaintext highlighter-rouge">dp[i][j] = dp[i-1][j]</code></li>
      <li>Combining them: <code class="language-plaintext highlighter-rouge">dp[i][j] = dp[i][j-1] or dp[i-1][j]</code></li>
    </ul>
  </li>
</ol>

<h3 id="44-ascii-visualization-of-dp-table">4.4 ASCII Visualization of DP Table</h3>
<p>Let’s match <code class="language-plaintext highlighter-rouge">s = "adceb"</code>, <code class="language-plaintext highlighter-rouge">p = "*a*b"</code>.</p>

<table>
  <thead>
    <tr>
      <th> </th>
      <th>’’</th>
      <th>*</th>
      <th>a</th>
      <th>*</th>
      <th>b</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>’‘</strong></td>
      <td>T</td>
      <td>T</td>
      <td>F</td>
      <td>F</td>
      <td>F</td>
    </tr>
    <tr>
      <td><strong>a</strong></td>
      <td>F</td>
      <td>T</td>
      <td>T</td>
      <td>T</td>
      <td>F</td>
    </tr>
    <tr>
      <td><strong>d</strong></td>
      <td>F</td>
      <td>T</td>
      <td>F</td>
      <td>T</td>
      <td>F</td>
    </tr>
    <tr>
      <td><strong>c</strong></td>
      <td>F</td>
      <td>T</td>
      <td>F</td>
      <td>T</td>
      <td>F</td>
    </tr>
    <tr>
      <td><strong>e</strong></td>
      <td>F</td>
      <td>T</td>
      <td>F</td>
      <td>T</td>
      <td>F</td>
    </tr>
    <tr>
      <td><strong>b</strong></td>
      <td>F</td>
      <td>T</td>
      <td>F</td>
      <td>T</td>
      <td>T</td>
    </tr>
  </tbody>
</table>

<p><strong>Final Answer: <code class="language-plaintext highlighter-rouge">dp[5][4] = True</code></strong></p>

<p>Notes on the table:</p>
<ul>
  <li>The first row handles the empty string. Notice how <code class="language-plaintext highlighter-rouge">*</code> propagate <code class="language-plaintext highlighter-rouge">True</code>.</li>
  <li>The first column (after <code class="language-plaintext highlighter-rouge">[0][0]</code>) is always <code class="language-plaintext highlighter-rouge">False</code>.</li>
  <li>For <code class="language-plaintext highlighter-rouge">*</code>, we look <strong>Up</strong> (matching one char) or <strong>Left</strong> (matching empty).</li>
</ul>

<hr />

<h2 id="5-space-optimization-the-1d-rolling-array">5. Space Optimization: The 1D Rolling Array</h2>

<p>Looking at the transitions:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">dp[i][j]</code> depends on <code class="language-plaintext highlighter-rouge">dp[i-1][j-1]</code>, <code class="language-plaintext highlighter-rouge">dp[i][j-1]</code>, and <code class="language-plaintext highlighter-rouge">dp[i-1][j]</code>.</li>
  <li>This means we only need the <strong>previous row</strong> and the <strong>current row</strong>.</li>
</ul>

<p>We can reduce space to O(N) by using a single array of size <code class="language-plaintext highlighter-rouge">N+1</code>. However, we must be careful with the “diagonal” dependency (<code class="language-plaintext highlighter-rouge">dp[i-1][j-1]</code>). We usually store the previous row’s value in a temporary variable before overwriting.</p>

<hr />

<h2 id="6-theory-automata-and-non-determinism">6. Theory: Automata and Non-Determinism</h2>

<h3 id="61-nfa-vs-dfa">6.1 NFA vs DFA</h3>
<p>In automata theory, a wildcard pattern can be represented as a <strong>Non-deterministic Finite Automaton (NFA)</strong>.</p>
<ul>
  <li>A <strong>Non-deterministic</strong> machine can be in multiple states at once. When we see <code class="language-plaintext highlighter-rouge">*</code>, the machine “splits” into two: one state remains at the <code class="language-plaintext highlighter-rouge">*</code> loop, and another moves to the next character in the pattern.</li>
  <li>A <strong>Deterministic Finite Automaton (DFA)</strong> can only be in one state at any time.</li>
</ul>

<p>Any NFA can be converted into a DFA using the <strong>powerset construction</strong>. However, the number of states in the DFA can be exponential relative to the NFA (<code class="language-plaintext highlighter-rouge">2^N</code>). For wildcard matching, the DFA is usually manageable, but the DP approach effectively simulates the NFA in O(MN) time.</p>

<h3 id="62-thompsons-construction">6.2 Thompson’s Construction</h3>
<p>Thompson’s algorithm is a method for transforming a regular expression into an NFA. For wildcards:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">?</code> is a single transition with a wildcard label.</li>
  <li><code class="language-plaintext highlighter-rouge">*</code> is a state with an epsilon transition to itself (loop) and a transition to the next state.</li>
</ul>

<p>In production engines like Go’s <code class="language-plaintext highlighter-rouge">regexp</code> or Google’s <code class="language-plaintext highlighter-rouge">RE2</code>, this NFA simulation is used to guarantee linear time matching relative to the input string length, avoiding the “exponential blowup” seen in some backtracking engines.</p>

<hr />

<h2 id="7-approach-3-greedy-two-pointer-the-optimal-interview-answer">7. Approach 3: Greedy Two-Pointer (The “Optimal” Interview Answer)</h2>

<p>While DP is O(MN), there is a clever O(MN) worst-case but O(M+N) average-case greedy approach. It works because wildcards have a property: once a <code class="language-plaintext highlighter-rouge">*</code> matches a certain prefix, if we fail later, we only need to backtrack to the <strong>most recent</strong> <code class="language-plaintext highlighter-rouge">*</code> and try matching it against one more character.</p>

<h3 id="71-the-logic">7.1 The Logic</h3>
<p>Keep pointers <code class="language-plaintext highlighter-rouge">s_ptr</code>, <code class="language-plaintext highlighter-rouge">p_ptr</code>, <code class="language-plaintext highlighter-rouge">star_ptr</code> (index of last <code class="language-plaintext highlighter-rouge">*</code>), and <code class="language-plaintext highlighter-rouge">match_ptr</code> (index in <code class="language-plaintext highlighter-rouge">s</code> where <code class="language-plaintext highlighter-rouge">*</code> started matching).</p>

<ol>
  <li>If <code class="language-plaintext highlighter-rouge">s[s_ptr]</code> matches <code class="language-plaintext highlighter-rouge">p[p_ptr]</code> (literal or <code class="language-plaintext highlighter-rouge">?</code>), increment both.</li>
  <li>If <code class="language-plaintext highlighter-rouge">p[p_ptr]</code> is <code class="language-plaintext highlighter-rouge">*</code>:
    <ul>
      <li>Record <code class="language-plaintext highlighter-rouge">star_ptr = p_ptr</code> and <code class="language-plaintext highlighter-rouge">match_ptr = s_ptr</code>.</li>
      <li>Increment <code class="language-plaintext highlighter-rouge">p_ptr</code> (try matching <code class="language-plaintext highlighter-rouge">*</code> as empty first).</li>
    </ul>
  </li>
  <li>If mismatch occurs:
    <ul>
      <li>If we have a <code class="language-plaintext highlighter-rouge">star_ptr</code>, backtrack!</li>
      <li><code class="language-plaintext highlighter-rouge">p_ptr = star_ptr + 1</code>.</li>
      <li><code class="language-plaintext highlighter-rouge">match_ptr += 1</code> (the star now matches one more char).</li>
      <li><code class="language-plaintext highlighter-rouge">s_ptr = match_ptr</code>.</li>
    </ul>
  </li>
  <li>If no <code class="language-plaintext highlighter-rouge">star_ptr</code> and mismatch, return <code class="language-plaintext highlighter-rouge">False</code>.</li>
</ol>

<h3 id="72-why-this-works">7.2 Why this works</h3>
<p>This is a form of backtracking that only remembers the <strong>last</strong> bit of non-determinism. Because <code class="language-plaintext highlighter-rouge">*</code> matches anything, any string matched by an earlier <code class="language-plaintext highlighter-rouge">*</code> could also have been matched by a later <code class="language-plaintext highlighter-rouge">*</code>. Thus, we only ever need to “shift” the most recent star.</p>

<hr />

<h2 id="8-implementation">8. Implementation</h2>

<h3 id="81-approach-1-top-down-recursion-with-memoization">8.1 Approach 1: Top-Down Recursion with Memoization</h3>

<p>This approach is the most direct translation of the mathematical recurrence. It uses a cache to avoid redundant sub-problems.</p>

<p>``python
class SolutionRecursive:
 “””
 Top-Down Memoization.
 Time: O(M * N)
 Space: O(M * N) for the memoization table and recursion stack.
 “””
 def isMatch(self, s: str, p: str) -&gt; bool:
 memo = {}</p>

<p>def dp(i: int, j: int) -&gt; bool:
 # Check cache
 if (i, j) in memo:
 return memo[(i, j)]</p>

<p># Base Case: Both reached end
 if i == len(s) and j == len(p):
 return True
 # Pattern ended but string hasn’t
 if j == len(p):
 return False
 # String ended but pattern hasn’t
 if i == len(s):
 # Pattern must only contain ‘<em>’ to match empty string
 return p[j] == ‘</em>’ and dp(i, j + 1)</p>

<p># Recursive step
 res = False
 if p[j] == s[i] or p[j] == ‘?’:
 res = dp(i + 1, j + 1)
 elif p[j] == ‘*’:
 # Match empty OR match one/more characters
 res = dp(i, j + 1) or dp(i + 1, j)</p>

<p>memo[(i, j)] = res
 return res</p>

<p>return dp(0, 0)
``</p>

<h3 id="82-approach-2-bottom-up-dynamic-programming-standard">8.2 Approach 2: Bottom-Up Dynamic Programming (Standard)</h3>

<p>The iterative version is usually preferred in production for its predictable memory layout and lack of stack overflow risks.</p>

<p>``python
from typing import List</p>

<p>class SolutionDP:
 “””
 Standard Bottom-Up DP solution.
 Time Complexity: O(M * N)
 Space Complexity: O(M * N)
 “””
 def isMatch(self, s: str, p: str) -&gt; bool:
 m, n = len(s), len(p)</p>

<p># Initialize DP table: dp[i][j] means s[:i] matches p[:j]
 dp = [[False] * (n + 1) for _ in range(m + 1)]</p>

<p># Base Case: Empty string matches empty pattern
 dp[0][0] = True</p>

<p># Base Case: Empty string matching pattern with ‘<em>’
 # ‘</em>’ can match zero characters, so it inherits from the previous pattern index.
 for j in range(1, n + 1):
 if p[j-1] == ‘*’:
 dp[0][j] = dp[0][j-1]</p>

<p># Fill the table
 for i in range(1, m + 1):
 for j in range(1, n + 1):
 if p[j-1] == s[i-1] or p[j-1] == ‘?’:
 # Characters match, carry over the result from both prefixes
 dp[i][j] = dp[i-1][j-1]
 elif p[j-1] == ‘<em>’:
 # Branching logic for ‘</em>’:
 # Case 1: ‘<em>’ matches empty (treat it as skipping the star)
 # Case 2: ‘</em>’ matches one or more (treat it as consuming s[i-1])
 dp[i][j] = dp[i][j-1] or dp[i-1][j]</p>

<p>return dp[m][n]
``</p>

<h3 id="83-approach-3-greedy-two-pointer-optimal-space">8.3 Approach 3: Greedy Two-Pointer (Optimal Space)</h3>

<p>This is the “trick” solution that reduces space to O(1) by manually managing the backtracking to the last seen <code class="language-plaintext highlighter-rouge">*</code>.</p>

<p>``python
class SolutionGreedy:
 “””
 Greedy backtracking with O(1) extra space.
 Time Complexity: O(M * N) worst case, but near O(M+N) on average.
 Space Complexity: O(1)
 “””
 def isMatch(self, s: str, p: str) -&gt; bool:
 s_ptr = p_ptr = 0
 star_idx = -1
 last_s_match = 0</p>

<p>while s_ptr &lt; len(s):
 # 1. Match constant char or ‘?’
 if p_ptr &lt; len(p) and (p[p_ptr] == s[s_ptr] or p[p_ptr] == ‘?’):
 s_ptr += 1
 p_ptr += 1
 # 2. Match ‘<em>’
 elif p_ptr &lt; len(p) and p[p_ptr] == ‘</em>’:
 # Record the star position and the current string position
 star_idx = p_ptr
 last_s_match = s_ptr
 p_ptr += 1 # Try matching empty first
 # 3. Mismatch, but we have a previous ‘*’ to backtrack to
 elif star_idx != -1:
 # Backtrack pattern pointer to just after the star
 p_ptr = star_idx + 1
 # Increment the string pointer to the next possible match for the star
 last_s_match += 1
 s_ptr = last_s_match
 # 4. Total mismatch
 else:
 return False</p>

<p># Check if remaining characters in pattern are all ‘<em>’
 while p_ptr &lt; len(p) and p[p_ptr] == ‘</em>’:
 p_ptr += 1</p>

<p>return p_ptr == len(p)
``</p>

<hr />

<h2 id="9-advanced-the-bitap-algorithm">9. Advanced: The Bitap Algorithm</h2>

<p>For fuzzy string matching and wildcard patterns, the <strong>Bitap Algorithm</strong> (also known as the Shift-Or algorithm) is an extremely fast bit manipulation technique.</p>

<h3 id="91-how-it-works">9.1 How it Works</h3>
<p>The Bitap algorithm maintains a bitmask of potential matches. Each bit in the mask represents whether a prefix of the pattern matches the current prefix of the string.</p>
<ul>
  <li>When a <code class="language-plaintext highlighter-rouge">?</code> is encountered, we shift the bitmask.</li>
  <li>When a <code class="language-plaintext highlighter-rouge">*</code> is encountered, we perform bitwise operations to allow any number of characters.</li>
</ul>

<h3 id="92-why-use-it">9.2 Why use it?</h3>
<ul>
  <li><strong>Speed</strong>: It uses CPU bitwise instructions which are incredibly fast.</li>
  <li><strong>Hardware Friendship</strong>: It is very easy to implement in hardware (FGPAs) or low-level SIMD instructions.</li>
  <li><strong>Fuzzy matching</strong>: It can be easily extended to support “Levenstein distance” (allowing <code class="language-plaintext highlighter-rouge">k</code> errors).</li>
</ul>

<p>While Bitap is usually overkill for interview wildcard matching, mentioning it as a “high-performance alternative” shows a level of depth that many candidates lack.</p>

<hr />

<h2 id="10-complexity-analysis">10. Complexity Analysis</h2>

<table>
  <thead>
    <tr>
      <th>Approach</th>
      <th>Time Complexity</th>
      <th>Space Complexity</th>
      <th>Notes</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Brute Force</strong></td>
      <td>O(2^{M+N})</td>
      <td>O(M+N)</td>
      <td>Terrible for long strings with many stars.</td>
    </tr>
    <tr>
      <td><strong>Top-Down DP</strong></td>
      <td>O(MN)</td>
      <td>O(MN)</td>
      <td>Good if many states are unreachable.</td>
    </tr>
    <tr>
      <td><strong>Bottom-Up DP</strong></td>
      <td>O(MN)</td>
      <td>O(MN)</td>
      <td>Predictable and cache-friendly.</td>
    </tr>
    <tr>
      <td><strong>Space-Optimized DP</strong></td>
      <td>O(MN)</td>
      <td>O(N)</td>
      <td>The standard for memory-constrained systems.</td>
    </tr>
    <tr>
      <td><strong>Greedy Pointer</strong></td>
      <td>O(MN) worst-case</td>
      <td>O(1)</td>
      <td>Best in practice for most strings.</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="11-production-considerations">11. Production Considerations</h2>

<h3 id="111-history-unix-globs">11.1 History: Unix Globs</h3>
<p>The term “glob” comes from the very first versions of Unix. There was a standalone program called <code class="language-plaintext highlighter-rouge">/etc/glob</code> that would expand wildcard patterns for the shell. Later, this logic was moved into the C library as <code class="language-plaintext highlighter-rouge">glob()</code>. Wildcard matching is thus “baked into” the DNA of modern computing.</p>

<h3 id="112-pattern-normalization-optimization">11.2 Pattern Normalization (Optimization)</h3>
<p>Before running the matching algorithm, normalize your pattern:</p>
<ul>
  <li>Collapse multiple consecutive stars into one. <code class="language-plaintext highlighter-rouge">**</code> behaves exactly like <code class="language-plaintext highlighter-rouge">*</code>.</li>
  <li>Complexity impact: This reduces the <code class="language-plaintext highlighter-rouge">N</code> in O(MN), potentially saving significant time in complex patterns.</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">python
def normalize(p: str) -&gt; str:
 if not p: return p
 res = [p[0]]
 for i in range(1, len(p)):
 if p[i] == '*' and p[i-1] == '*':
 continue
 res.append(p[i])
 return "".join(res)
</code></p>

<h3 id="113-security-avoiding-redos-regex-denial-of-service">11.3 Security: Avoiding ReDoS (Regex Denial of Service)</h3>
<p>While Wildcard matching is safer than full Regex (which can have exponential O(2^N) backtracking in some engines), O(MN) can still be abused.</p>
<ul>
  <li>If a user provides a pattern of <code class="language-plaintext highlighter-rouge">10^5</code> characters and a string of <code class="language-plaintext highlighter-rouge">10^5</code> characters, the DP table would require <code class="language-plaintext highlighter-rouge">10^{10}</code> booleans (~10GB of RAM).</li>
  <li><strong>Defense</strong>: Enforce limits on pattern and string lengths in your API. Usually, 1024 or 2048 is more than enough for globbing.</li>
</ul>

<h3 id="114-wildcards-in-databases-sql-like">11.4 Wildcards in Databases: SQL <code class="language-plaintext highlighter-rouge">LIKE</code></h3>
<p>In SQL, the <code class="language-plaintext highlighter-rouge">%</code> character acts as a wildcard (matching zero or more characters) and <code class="language-plaintext highlighter-rouge">_</code> acts as a single-character wildcard (equivalent to <code class="language-plaintext highlighter-rouge">?</code>).</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">SELECT * FROM users WHERE email LIKE 'admin_%@google.com'</code></li>
  <li>Databases often optimize these queries by using indexes. If the pattern <strong>starts</strong> with literal characters (e.g., <code class="language-plaintext highlighter-rouge">admin_%</code>), the database can use a B-Tree index to perform a range scan. If it starts with a wildcard (e.g., <code class="language-plaintext highlighter-rouge">%@google.com</code>), it must perform a full table scan, which is O(N) relative to the number of rows.</li>
</ul>

<h3 id="115-compilation-to-machine-code">11.5 Compilation to Machine Code</h3>
<p>For extremely high-performance filtering (e.g., cloud networking layers), wildcard patterns are often compiled into specialized machine code or eBPF programs. This allows matching at line speed (100Gbps+) by reducing the matching logic to a series of optimized jumps and comparisons.</p>

<h3 id="116-case-study-aws-iam-policy-evaluation">11.6 Case Study: AWS IAM Policy Evaluation</h3>
<p>In AWS Identity and Access Management (IAM), policies allow you to define permissions for users and roles. These policies often use wildcards in the <code class="language-plaintext highlighter-rouge">Resource</code> field.
Example: <code class="language-plaintext highlighter-rouge">arn:aws:s3:::my-bucket/logs/2023/*</code></p>
<ul>
  <li>When a request comes in for <code class="language-plaintext highlighter-rouge">arn:aws:s3:::my-bucket/logs/2023/error.log</code>, AWS must match it against the policy.</li>
  <li>AWS evaluates thousands of these policies per second.</li>
  <li>To handle this scale, they don’t just run a naive DP. They use <strong>optimized state machines</strong> that can evaluate multiple patterns at once.</li>
  <li>Security is paramount: the matcher must be <strong>strictly linear</strong> to prevent “denial of service” attacks using complex patterns.</li>
</ul>

<hr />

<h2 id="12-implementation-deep-dive-line-by-line">12. Implementation Deep Dive: Line-by-Line</h2>

<h3 id="121-explaining-the-dp-implementation">12.1 Explaining the DP Implementation</h3>
<p>Let’s look at the core loop of the DP solution again:</p>

<p><code class="language-plaintext highlighter-rouge">python
for i in range(1, m + 1):
 for j in range(1, n + 1):
 if p[j-1] == s[i-1] or p[j-1] == '?':
 dp[i][j] = dp[i-1][j-1]
</code></p>
<ul>
  <li><strong>Line 1 &amp; 2</strong>: We iterate through every character of the string (<code class="language-plaintext highlighter-rouge">i</code>) and every character of the pattern (<code class="language-plaintext highlighter-rouge">j</code>).</li>
  <li><strong>Line 3</strong>: We check for a “local match”. If the characters are the same, or the pattern has a <code class="language-plaintext highlighter-rouge">?</code>.</li>
  <li><strong>Line 4</strong>: If it’s a local match, then the logic is: “Does this prefix match?” depends entirely on “Did the previous prefix (excluding these two chars) match?”. This is why we look at the diagonal <code class="language-plaintext highlighter-rouge">dp[i-1][j-1]</code>.</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">python
 elif p[j-1] == '*':
 dp[i][j] = dp[i][j-1] or dp[i-1][j]
</code></p>
<ul>
  <li><strong>Line 5</strong>: If the pattern is a star…</li>
  <li><strong>Line 6</strong>: This is the heart of the branching logic.</li>
  <li><code class="language-plaintext highlighter-rouge">dp[i][j-1]</code>: Can we match by treating the <code class="language-plaintext highlighter-rouge">*</code> as an empty string? (i.e., ignore the star and check if the current string prefix matched the pattern prefix <em>before</em> the star).</li>
  <li><code class="language-plaintext highlighter-rouge">dp[i-1][j]</code>: Can we match by letting the <code class="language-plaintext highlighter-rouge">*</code> consume the current character <code class="language-plaintext highlighter-rouge">s[i-1]</code>? (i.e., if the shorter string <code class="language-plaintext highlighter-rouge">s[:i-1]</code> already matched the current pattern prefix including the star, then the star just “eats” one more character).</li>
</ul>

<h3 id="122-explaining-the-greedy-implementation">12.2 Explaining the Greedy Implementation</h3>
<p>The greedy pointer approach is often more confusing. Let’s break down the “backtrack” logic:</p>

<p><code class="language-plaintext highlighter-rouge">python
elif star_idx != -1:
 p_ptr = star_idx + 1
 s_tmp_idx += 1
 s_ptr = s_tmp_idx
</code></p>
<ul>
  <li><strong>Line 1</strong>: We only reach this <code class="language-plaintext highlighter-rouge">elif</code> if there was a mismatch at the current <code class="language-plaintext highlighter-rouge">p_ptr</code> and <code class="language-plaintext highlighter-rouge">s_ptr</code>.</li>
  <li><strong>Line 2</strong>: We reset the pattern pointer to the character <strong>immediately following</strong> the last star we saw.</li>
  <li><strong>Line 3</strong>: We increment <code class="language-plaintext highlighter-rouge">s_tmp_idx</code>. This variable tracks the “end of the match” for the star. By incrementing it, we are effectively saying: “The star didn’t match enough characters; let’s try making it match one more.”</li>
  <li><strong>Line 4</strong>: We reset the string pointer to this new starting point.</li>
</ul>

<p>This “backtracking to the last star” is what allows the algorithm to explore different “lengths” for the star’s match without the full O(MN) overhead of a DP table in most cases.</p>

<hr />

<h2 id="13-connections-to-ml-systems">13. Connections to ML Systems</h2>

<h3 id="131-dynamic-matching-in-feature-engineering">13.1 Dynamic Matching in Feature Engineering</h3>
<p>In sequence-based ML (like NLP or Clickstream analysis), we often use wildcard-like patterns to define features.</p>
<ul>
  <li>“Did the user perform sequence <code class="language-plaintext highlighter-rouge">A -&gt; * -&gt; B</code>?”</li>
  <li>This is essentially wildcard matching. The DP approach we discussed is the foundation of <strong>DTW (Dynamic Time Warping)</strong>, a popular algorithm for matching two temporal sequences that may vary in speed.</li>
</ul>

<h3 id="132-data-validation-guardrails">13.2 Data Validation Guardrails</h3>
<p>Multi-agent systems and ML pipelines are notoriously “silent fail” prone. If a data schema changes slightly, the model might still produce results, but they will be garbage (<strong>GIGO - Garbage In, Garbage Out</strong>).</p>
<ul>
  <li>We use pattern matching in <strong>Data Contracts</strong>.</li>
  <li>Example: “Ensure the <code class="language-plaintext highlighter-rouge">source_id</code> follows the pattern <code class="language-plaintext highlighter-rouge">REGION_*_TYPE_??</code>”. This ensures that incoming data flows are structured correctly before hitting the model.</li>
</ul>

<h3 id="133-search-and-retrieval">13.3 Search and Retrieval</h3>
<p>In Agentic RAG (Retrieval-Augmented Generation), we often filter metadata.</p>
<ul>
  <li>“Find all documents where <code class="language-plaintext highlighter-rouge">category</code> matches <code class="language-plaintext highlighter-rouge">finance/*</code>”.</li>
  <li>If the metadata store is a SQL database, this is converted to a <code class="language-plaintext highlighter-rouge">LIKE 'finance/%'</code> query.</li>
  <li>Knowing the underlying matching logic helps you understand how the index will (or won’t) be used.</li>
</ul>

<hr />

<h2 id="14-key-takeaways">14. Key Takeaways</h2>

<ol>
  <li><strong>Fundamental State Machine</strong>: Wildcard matching is the bridge between simple string comparison and full Regular Expressions.</li>
  <li><strong>DP is Robust</strong>: The O(MN) DP approach is the most reliable way to handle the non-determinism of <code class="language-plaintext highlighter-rouge">*</code>.</li>
  <li><strong>Space Matters</strong>: Reducing O(MN) to O(N) space is a critical optimization for production scale.</li>
  <li><strong>History Matters</strong>: From Unix <code class="language-plaintext highlighter-rouge">glob</code> to modern SQL, wildcard matching is one of the most successful abstractions in computer science.</li>
</ol>

<hr />

<p><strong>Originally published at:</strong> <a href="https://www.arunbaby.com/dsa/0054-wildcard-matching/">arunbaby.com/dsa/0054-wildcard-matching</a></p>

<p><em>If you found this helpful, consider sharing it with others who might benefit.</em></p>

        
      </section>

      <footer class="page__meta">
        
        
  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-tags" aria-hidden="true"></i> Tags: </strong>
    <span itemprop="keywords">
    
      <a href="/tags/#dynamic-programming" class="page__taxonomy-item p-category" rel="tag">dynamic-programming</a><span class="sep">, </span>
    
      <a href="/tags/#edge-cases" class="page__taxonomy-item p-category" rel="tag">edge-cases</a><span class="sep">, </span>
    
      <a href="/tags/#hard" class="page__taxonomy-item p-category" rel="tag">hard</a><span class="sep">, </span>
    
      <a href="/tags/#pattern-matching" class="page__taxonomy-item p-category" rel="tag">pattern-matching</a><span class="sep">, </span>
    
      <a href="/tags/#state-machine" class="page__taxonomy-item p-category" rel="tag">state-machine</a><span class="sep">, </span>
    
      <a href="/tags/#string" class="page__taxonomy-item p-category" rel="tag">string</a>
    
    </span>
  </p>




  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> Categories: </strong>
    <span itemprop="keywords">
    
      <a href="/categories/#dsa" class="page__taxonomy-item p-category" rel="tag">dsa</a>
    
    </span>
  </p>


        
      </footer>

      <div class="page__related page__related--full">
  <h2 class="page__related-title">Related across topics</h2>
  <style>
    /* Make section span full content width and use 2 equal columns */
    .page__related--full { float: inline-start; width: 100%; padding: 0; }
    .cross-related-grid { display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 2rem; }
    @media (max-width: 768px) { .cross-related-grid { grid-template-columns: 1fr; } }
    /* Ensure archive cards stretch nicely in the grid */
    .cross-related-grid .list__item, .cross-related-grid .grid__item { width: auto; float: none; margin: 0; }
  </style>
  <div class="cross-related-grid">
    



<div class="list__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/ml-system-design/0054-pattern-matching-in-ml/" rel="permalink">Pattern Matching in ML
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          24 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">“Most ML pipelines are quietly powered by pattern matching—rules, validators, and weak labels before the model ever trains.”
</p>
  </article>
</div>




<div class="list__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/speech-tech/0054-acoustic-pattern-matching/" rel="permalink">Acoustic Pattern Matching
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          24 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">“Acoustic pattern matching is search—except your ‘strings’ are waveforms and your distance metric is learned.”
</p>
  </article>
</div>




<div class="list__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/ai-agents/0054-scaling-multi-agent-systems/" rel="permalink">Scaling Multi-Agent Systems
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          19 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">“A single agent is a demo. Scaling agents is distributed systems with language models in the loop.”
</p>
  </article>
</div>

  </div>
</div>

      <section class="page__share">
  <h4 class="page__share-title">Share on</h4>

  <a href="https://twitter.com/intent/tweet?via=arunbaby0&text=Wildcard+Matching%20https%3A%2F%2Fwww.arunbaby.com%2Fdsa%2F0054-wildcard-matching%2F" class="btn btn--twitter" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Twitter"><i class="fab fa-fw fa-twitter" aria-hidden="true"></i><span> Twitter</span></a>

  <a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fwww.arunbaby.com%2Fdsa%2F0054-wildcard-matching%2F" class="btn btn--facebook" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Facebook"><i class="fab fa-fw fa-facebook" aria-hidden="true"></i><span> Facebook</span></a>

  <a href="https://www.linkedin.com/shareArticle?mini=true&url=https://www.arunbaby.com/dsa/0054-wildcard-matching/" class="btn btn--linkedin" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on LinkedIn"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i><span> LinkedIn</span></a>
</section>


      
  <nav class="pagination">
    
      <a href="/dsa/0053-first-missing-positive/" class="pagination--pager" title="First Missing Positive">Previous</a>
    
    
      <a href="/dsa/0055-n-queens/" class="pagination--pager" title="N-Queens">Next</a>
    
  </nav>


    </div>

    
  </article>

  
  
</div>

      
    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';" role="search">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Enter your search term..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    

    
      
        
          <li><a href="https://twitter.com/arunbaby0" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-twitter-square" aria-hidden="true"></i> Twitter</a></li>
        
      
        
          <li><a href="https://github.com/arunbaby0" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
        
      
        
          <li><a href="https://www.linkedin.com/in/arunbaby0/" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i> LinkedIn</a></li>
        
      
        
          <li><a href="https://scholar.google.co.in/citations?user=6fSYWhkAAAAJ" rel="nofollow noopener noreferrer"><i class="fas fa-fw fa-graduation-cap" aria-hidden="true"></i> Google Scholar</a></li>
        
      
    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 1990 - 2143 <a href="https://www.arunbaby.com">Arun Baby</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>




  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-0JRJPEC9SS"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-0JRJPEC9SS', { 'anonymize_ip': false});
</script>








  </body>
</html>
