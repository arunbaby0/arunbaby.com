<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.26.2 by Michael Rose
  Copyright 2013-2024 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->

<html lang="en-US" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Median of Two Sorted Arrays - Arun Baby</title>
<meta name="description" content="“Stop thinking ‘merge’. Think ‘partition’—the median is just the boundary between two halves.”">


  <meta name="author" content="Arun Baby">
  
  <meta property="article:author" content="Arun Baby">
  


<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="Arun Baby">
<meta property="og:title" content="Median of Two Sorted Arrays">
<meta property="og:url" content="https://www.arunbaby.com/dsa/0051-median-of-two-sorted-arrays/">


  <meta property="og:description" content="“Stop thinking ‘merge’. Think ‘partition’—the median is just the boundary between two halves.”">



  <meta property="og:image" content="https://www.arunbaby.com/assets/images/profile-photo.png">



  <meta name="twitter:site" content="@arunbaby0">
  <meta name="twitter:title" content="Median of Two Sorted Arrays">
  <meta name="twitter:description" content="“Stop thinking ‘merge’. Think ‘partition’—the median is just the boundary between two halves.”">
  <meta name="twitter:url" content="https://www.arunbaby.com/dsa/0051-median-of-two-sorted-arrays/">

  
    <meta name="twitter:card" content="summary">
    
      <meta name="twitter:image" content="https://www.arunbaby.com/assets/images/profile-photo.png">
    
  

  



  <meta property="article:published_time" content="2025-12-31T09:51:02+05:30">





  

  


<link rel="canonical" href="https://www.arunbaby.com/dsa/0051-median-of-two-sorted-arrays/">












<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Arun Baby Feed">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
  
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css"></noscript>



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--single" dir="ltr">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
           
          <span class="site-subtitle">Arun Baby</span>
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a
                href="/about/"
                
                
              >About</a>
            </li><li class="masthead__menu-item">
              <a
                href="/dsa/"
                
                
              >DSA</a>
            </li><li class="masthead__menu-item">
              <a
                href="/ml-system-design/"
                
                
              >ML Systems</a>
            </li><li class="masthead__menu-item">
              <a
                href="/speech-tech/"
                
                
              >Speech Tech</a>
            </li><li class="masthead__menu-item">
              <a
                href="/ai-agents/"
                
                
              >AI Agents</a>
            </li><li class="masthead__menu-item">
              <a
                href="/publications/"
                
                
              >Publications</a>
            </li><li class="masthead__menu-item">
              <a
                href="/statuses/"
                
                
              >Statuses</a>
            </li><li class="masthead__menu-item">
              <a
                href="/contact/"
                
                
              >Contact</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <i class="fas fa-search"></i>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      





<div id="main" role="main" class="no-author-sidebar">
  
  <div class="sidebar sticky">
  
  
  </div>



  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="Median of Two Sorted Arrays">
    <meta itemprop="description" content="“Stop thinking ‘merge’. Think ‘partition’—the median is just the boundary between two halves.”">
    <meta itemprop="datePublished" content="2025-12-31T09:51:02+05:30">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">
            <a href="https://www.arunbaby.com/dsa/0051-median-of-two-sorted-arrays/" itemprop="url">Median of Two Sorted Arrays
</a>
          </h1>
          

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          22 minute read
        
      </span>
    
  </p>


        </header>
      

      <section class="page__content" itemprop="text">
        
          <aside class="sidebar__right sticky">
            <nav class="toc">
              <header><h4 class="nav__title"><i class="fas fa-file-alt"></i> On this page</h4></header>
              <ul class="toc__menu"><li><a href="#1-problem-statement">1. Problem Statement</a></li><li><a href="#2-understanding-the-problem">2. Understanding the Problem</a><ul><li><a href="#21-why-this-is-hard-and-why-its-famous">2.1 Why this is hard (and why it’s famous)</a></li><li><a href="#22-the-median-as-a-partition">2.2 The median as a partition</a></li></ul></li><li><a href="#3-approach-1-brute-force-merge-then-median">3. Approach 1: Brute Force (Merge Then Median)</a><ul><li><a href="#31-idea">3.1 Idea</a></li><li><a href="#32-complexity">3.2 Complexity</a></li><li><a href="#33-why-its-not-enough">3.3 Why it’s not enough</a></li></ul></li><li><a href="#4-approach-2-two-pointers-without-full-merge-streaming-median">4. Approach 2: Two Pointers Without Full Merge (Streaming Median)</a><ul><li><a href="#41-idea">4.1 Idea</a></li><li><a href="#42-complexity">4.2 Complexity</a></li><li><a href="#43-when-this-is-acceptable">4.3 When this is acceptable</a></li><li><a href="#44-implementation-constant-space-early-stop">4.4 Implementation (constant space, early stop)</a></li></ul></li><li><a href="#5-approach-3-optimal-binary-search-on-the-partition">5. Approach 3: Optimal (Binary Search on the Partition)</a><ul><li><a href="#51-key-insight">5.1 Key insight</a></li><li><a href="#52-why-binary-search-works-monotonicity">5.2 Why binary search works (monotonicity)</a></li><li><a href="#53-complexity">5.3 Complexity</a></li><li><a href="#54-a-concrete-picture-the-four-numbers-you-compare">5.4 A concrete picture (the “four numbers” you compare)</a></li><li><a href="#55-step-by-step-dry-run-so-it-feels-inevitable">5.5 Step-by-step dry run (so it feels inevitable)</a></li><li><a href="#56-proof-sketch-why-the-inequalities-are-sufficient">5.6 Proof sketch (why the inequalities are sufficient)</a></li><li><a href="#57-an-alternative-k-th-element-perspective-useful-in-interviews">5.7 An alternative “k-th element” perspective (useful in interviews)</a></li></ul></li><li><a href="#6-implementation-fully-commented-python">6. Implementation (Fully Commented Python)</a></li><li><a href="#7-testing-edge-cases-included">7. Testing (Edge Cases Included)</a><ul><li><a href="#71-minimal-cases">7.1 Minimal cases</a></li><li><a href="#72-highly-imbalanced-lengths">7.2 Highly imbalanced lengths</a></li><li><a href="#73-duplicates">7.3 Duplicates</a></li><li><a href="#74-negative-numbers">7.4 Negative numbers</a></li><li><a href="#75-property-test-mindset-production">7.5 Property test mindset (production)</a></li><li><a href="#76-a-compact-test-harness-baseline-vs-optimal">7.6 A compact test harness (baseline vs optimal)</a></li></ul></li><li><a href="#8-complexity-analysis-detailed">8. Complexity Analysis (Detailed)</a></li><li><a href="#9-production-considerations">9. Production Considerations</a><ul><li><a href="#91-numeric-types">9.1 Numeric types</a></li><li><a href="#92-data-location-matters">9.2 Data location matters</a></li><li><a href="#93-generalizing-kth-element-queries">9.3 Generalizing: kth element queries</a></li><li><a href="#94-external-memory-and-sorted-runs-why-merging-is-expensive-in-the-real-world">9.4 External-memory and “sorted runs” (why merging is expensive in the real world)</a></li><li><a href="#95-approximate-percentiles-when-exact-is-too-expensive">9.5 Approximate percentiles (when exact is too expensive)</a></li><li><a href="#96-streaming-and-sliding-windows">9.6 Streaming and sliding windows</a></li><li><a href="#97-testing-in-production-differential-testing-and-invariants">9.7 Testing in production: differential testing and invariants</a></li></ul></li><li><a href="#10-connections-to-ml-systems">10. Connections to ML Systems</a></li><li><a href="#11-interview-strategy">11. Interview Strategy</a><ul><li><a href="#111-what-to-say-while-you-code-signal-you-understand-the-invariants">11.1 What to say while you code (signal you understand the invariants)</a></li><li><a href="#112-follow-up-questions-you-should-be-ready-for">11.2 Follow-up questions you should be ready for</a></li><li><a href="#113-how-to-debug-when-it-fails-fast">11.3 How to debug when it fails (fast)</a></li><li><a href="#114-why-this-problem-is-a-great-systems-signal">11.4 Why this problem is a great “systems signal”</a></li></ul></li><li><a href="#12-key-takeaways">12. Key Takeaways</a><ul><li><a href="#121-mental-model-summary-the-one-you-want-to-internalize">12.1 Mental model summary (the one you want to internalize)</a></li><li><a href="#122-a-second-optimal-method-divide-and-conquer-k-th-element">12.2 A second optimal method (divide-and-conquer k-th element)</a></li><li><a href="#123-practical-note-stable-behavior-across-languages">12.3 Practical note: stable behavior across languages</a></li><li><a href="#124-if-youre-short-on-time-the-30-second-explanation">12.4 If you’re short on time: the 30-second explanation</a></li><li><a href="#125-one-more-invariant-useful-for-sanity-checks">12.5 One more invariant (useful for sanity checks)</a></li></ul></li></ul>
            </nav>
          </aside>
        
        <p><strong>“Stop thinking ‘merge’. Think ‘partition’—the median is just the boundary between two halves.”</strong></p>

<h2 id="1-problem-statement">1. Problem Statement</h2>

<p>You are given two sorted arrays <code class="language-plaintext highlighter-rouge">nums1</code> and <code class="language-plaintext highlighter-rouge">nums2</code> (possibly different lengths). Return the <strong>median</strong> of the combined multiset of numbers.</p>

<p><strong>Median definition</strong>:</p>
<ul>
  <li>If total count (N) is odd, median is the middle element.</li>
  <li>If (N) is even, median is the average of the two middle elements.</li>
</ul>

<p><strong>Example 1</strong></p>
<ul>
  <li>Input: <code class="language-plaintext highlighter-rouge">nums1 = [1,3]</code>, <code class="language-plaintext highlighter-rouge">nums2 = [2]</code></li>
  <li>Combined: <code class="language-plaintext highlighter-rouge">[1,2,3]</code></li>
  <li>Output: <code class="language-plaintext highlighter-rouge">2.0</code></li>
</ul>

<p><strong>Example 2</strong></p>
<ul>
  <li>Input: <code class="language-plaintext highlighter-rouge">nums1 = [1,2]</code>, <code class="language-plaintext highlighter-rouge">nums2 = [3,4]</code></li>
  <li>Combined: <code class="language-plaintext highlighter-rouge">[1,2,3,4]</code></li>
  <li>Output: <code class="language-plaintext highlighter-rouge">(2+3)/2 = 2.5</code></li>
</ul>

<p><strong>Constraints (typical interview)</strong></p>
<ul>
  <li>Arrays are individually sorted (non-decreasing).</li>
  <li>Lengths can be imbalanced (e.g., <code class="language-plaintext highlighter-rouge">m=1</code>, <code class="language-plaintext highlighter-rouge">n=10^6</code>).</li>
  <li>You’re expected to do better than merging both arrays.</li>
</ul>

<hr />

<h2 id="2-understanding-the-problem">2. Understanding the Problem</h2>

<h3 id="21-why-this-is-hard-and-why-its-famous">2.1 Why this is hard (and why it’s famous)</h3>

<p>Merging two sorted arrays is easy: two pointers, (O(m+n)).
But the “legendary” follow-up is: can you do it in <strong>logarithmic time</strong>?</p>

<p>That requirement forces a mental shift:</p>
<ul>
  <li>Don’t build the combined array.</li>
  <li>Don’t scan all items.</li>
  <li>Instead, <strong>search for a boundary condition</strong> that defines the median.</li>
</ul>

<p>This is the same mental model you use in:</p>
<ul>
  <li><strong>Distributed systems</strong>: you don’t pull all logs to one box; you query boundaries/aggregations.</li>
  <li><strong>Federated learning</strong>: you don’t centralize raw data; you coordinate updates to reach a global optimum.</li>
  <li><strong>Privacy-preserving speech</strong>: you can’t centralize raw audio, so you must compute what you need without seeing everything.</li>
  <li><strong>Knowledge graphs for agents</strong>: you can’t traverse the entire graph; you rely on indexes and targeted queries.</li>
</ul>

<h3 id="22-the-median-as-a-partition">2.2 The median as a partition</h3>

<p>Imagine combining both arrays into one sorted list of length (N = m+n).
Let:</p>
<ul>
  <li>(L) be the left half</li>
  <li>(R) be the right half</li>
</ul>

<p>We want:</p>
<ul>
  <li>
    <table>
      <tbody>
        <tr>
          <td>(</td>
          <td>L</td>
          <td>= \left\lfloor\frac{N+1}{2}\right\rfloor) (left has the extra item when odd)</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>Every element in (L) (\le) every element in (R)</li>
</ul>

<p>If we can find such a partition, the median is trivial:</p>
<ul>
  <li>If (N) is odd: median is <code class="language-plaintext highlighter-rouge">max(L)</code></li>
  <li>If (N) is even: median is <code class="language-plaintext highlighter-rouge">(max(L) + min(R)) / 2</code></li>
</ul>

<p>So the task becomes:</p>
<blockquote>
  <p>Find a partition across two arrays such that left sizes match and ordering holds.</p>
</blockquote>

<hr />

<h2 id="3-approach-1-brute-force-merge-then-median">3. Approach 1: Brute Force (Merge Then Median)</h2>

<h3 id="31-idea">3.1 Idea</h3>
<p>Merge <code class="language-plaintext highlighter-rouge">nums1</code> and <code class="language-plaintext highlighter-rouge">nums2</code> into a new sorted array, then compute the median.</p>

<h3 id="32-complexity">3.2 Complexity</h3>
<ul>
  <li><strong>Time</strong>: (O(m+n))</li>
  <li><strong>Space</strong>: (O(m+n)) if you build the merged array</li>
</ul>

<h3 id="33-why-its-not-enough">3.3 Why it’s not enough</h3>
<p>If <code class="language-plaintext highlighter-rouge">n=10^6</code>, you just did a million operations for a single median. Interviews want you to recognize that median depends on a <strong>boundary</strong>, not on every value.</p>

<hr />

<h2 id="4-approach-2-two-pointers-without-full-merge-streaming-median">4. Approach 2: Two Pointers Without Full Merge (Streaming Median)</h2>

<h3 id="41-idea">4.1 Idea</h3>
<p>Use two pointers to “merge” but stop once you reach the median position(s). You only need:</p>
<ul>
  <li>the (k)-th element (and maybe (k-1)-th)
where (k = \lfloor N/2 \rfloor).</li>
</ul>

<h3 id="42-complexity">4.2 Complexity</h3>
<ul>
  <li><strong>Time</strong>: (O(m+n)) worst case, but typically (O(N/2))</li>
  <li><strong>Space</strong>: (O(1))</li>
</ul>

<h3 id="43-when-this-is-acceptable">4.3 When this is acceptable</h3>
<p>This is a strong solution if:</p>
<ul>
  <li>constraints are small</li>
  <li>or you’re in production and the constant factors matter more than asymptotics</li>
</ul>

<p>But it still fails the “log time” requirement.</p>

<h3 id="44-implementation-constant-space-early-stop">4.4 Implementation (constant space, early stop)</h3>

<p>This is a great “interview warm-up” implementation because it’s simple and correct.
It also becomes the baseline for differential testing against the optimal method.</p>

<p>``python
from typing import List</p>

<p>def median_two_sorted_stream(nums1: List[int], nums2: List[int]) -&gt; float:
 “””
 Merge-like scan until the median position. O(m+n) time in worst case, O(1) space.
 “””
 m, n = len(nums1), len(nums2)
 total = m + n
 mid = total // 2</p>

<p>i = j = 0
 prev = curr = 0</p>

<p># We only need to advance ‘mid’ steps.
 for _ in range(mid + 1):
 prev = curr
 if i &lt; m and (j &gt;= n or nums1[i] &lt;= nums2[j]):
 curr = nums1[i]
 i += 1
 else:
 curr = nums2[j]
 j += 1</p>

<p>if total % 2 == 1:
 return float(curr)
 return (prev + curr) / 2.0
``</p>

<p>Edge case check:</p>
<ul>
  <li>if <code class="language-plaintext highlighter-rouge">nums1</code> is empty, we just walk <code class="language-plaintext highlighter-rouge">nums2</code></li>
  <li>if duplicates exist, the <code class="language-plaintext highlighter-rouge">&lt;=</code> tie-break maintains correctness</li>
</ul>

<hr />

<h2 id="5-approach-3-optimal-binary-search-on-the-partition">5. Approach 3: Optimal (Binary Search on the Partition)</h2>

<h3 id="51-key-insight">5.1 Key insight</h3>
<p>Instead of searching the median value, we search <strong>where the cut happens</strong> in the smaller array.</p>

<p>Let:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">A</code> = the smaller array (length <code class="language-plaintext highlighter-rouge">m</code>)</li>
  <li><code class="language-plaintext highlighter-rouge">B</code> = the larger array (length <code class="language-plaintext highlighter-rouge">n</code>)</li>
</ul>

<p>We choose an index <code class="language-plaintext highlighter-rouge">i</code> as the cut in <code class="language-plaintext highlighter-rouge">A</code>:</p>
<ul>
  <li>left part is <code class="language-plaintext highlighter-rouge">A[0:i]</code></li>
  <li>right part is <code class="language-plaintext highlighter-rouge">A[i:]</code></li>
</ul>

<p>The cut in <code class="language-plaintext highlighter-rouge">B</code> must then be <code class="language-plaintext highlighter-rouge">j</code> such that left sizes match:</p>

<p>[
i + j = \left\lfloor\frac{m+n+1}{2}\right\rfloor
]</p>

<p>So:
[
j = \left\lfloor\frac{m+n+1}{2}\right\rfloor - i
]</p>

<p>Now define boundary values (with sentinels for empty sides):</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">A_left_max = A[i-1]</code> if <code class="language-plaintext highlighter-rouge">i&gt;0</code> else <code class="language-plaintext highlighter-rouge">-∞</code></li>
  <li><code class="language-plaintext highlighter-rouge">A_right_min = A[i]</code> if <code class="language-plaintext highlighter-rouge">i&lt;m</code> else <code class="language-plaintext highlighter-rouge">+∞</code></li>
  <li><code class="language-plaintext highlighter-rouge">B_left_max = B[j-1]</code> if <code class="language-plaintext highlighter-rouge">j&gt;0</code> else <code class="language-plaintext highlighter-rouge">-∞</code></li>
  <li><code class="language-plaintext highlighter-rouge">B_right_min = B[j]</code> if <code class="language-plaintext highlighter-rouge">j&lt;n</code> else <code class="language-plaintext highlighter-rouge">+∞</code></li>
</ul>

<p>The partition is valid if:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">A_left_max &lt;= B_right_min</code></li>
  <li><code class="language-plaintext highlighter-rouge">B_left_max &lt;= A_right_min</code></li>
</ul>

<p>If invalid, we adjust <code class="language-plaintext highlighter-rouge">i</code> using binary search:</p>
<ul>
  <li>If <code class="language-plaintext highlighter-rouge">A_left_max &gt; B_right_min</code>, we cut too far right in <code class="language-plaintext highlighter-rouge">A</code> → move left (<code class="language-plaintext highlighter-rouge">hi = i-1</code>)</li>
  <li>Else if <code class="language-plaintext highlighter-rouge">B_left_max &gt; A_right_min</code>, we cut too far left in <code class="language-plaintext highlighter-rouge">A</code> → move right (<code class="language-plaintext highlighter-rouge">lo = i+1</code>)</li>
</ul>

<p>This is classic <strong>binary search on a monotonic condition</strong>: once you move the partition, the violations move predictably.</p>

<h3 id="52-why-binary-search-works-monotonicity">5.2 Why binary search works (monotonicity)</h3>
<p>As <code class="language-plaintext highlighter-rouge">i</code> increases:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">A_left_max</code> increases (or stays)</li>
  <li><code class="language-plaintext highlighter-rouge">A_right_min</code> increases (or stays)</li>
  <li><code class="language-plaintext highlighter-rouge">j</code> decreases, so <code class="language-plaintext highlighter-rouge">B_left_max</code> tends to decrease, <code class="language-plaintext highlighter-rouge">B_right_min</code> tends to decrease</li>
</ul>

<p>So the inequality flips in a single direction—perfect for binary search.</p>

<h3 id="53-complexity">5.3 Complexity</h3>
<ul>
  <li><strong>Time</strong>: (O(\log(\min(m,n))))</li>
  <li><strong>Space</strong>: (O(1))</li>
</ul>

<p>This is the “correct” interview answer.</p>

<h3 id="54-a-concrete-picture-the-four-numbers-you-compare">5.4 A concrete picture (the “four numbers” you compare)</h3>

<p>The entire algorithm can be explained with <strong>four boundary values</strong>:</p>

<p>``
A: [ … A[i-1] | A[i] … ]
 ^ ^
 | |
 A_left_max A_right_min</p>

<p>B: [ … B[j-1] | B[j] … ]
 ^ ^
 | |
 B_left_max B_right_min
``</p>

<p>We want the left partition to contain exactly half of the total elements (rounded up):</p>

<p>[
i + j = \left\lfloor\frac{m+n+1}{2}\right\rfloor
]</p>

<p>And we want <strong>all left elements</strong> (\le) <strong>all right elements</strong>.
Because each side is already sorted, we only need to check the boundary:</p>

<ul>
  <li>Left side max is <code class="language-plaintext highlighter-rouge">max(A_left_max, B_left_max)</code></li>
  <li>Right side min is <code class="language-plaintext highlighter-rouge">min(A_right_min, B_right_min)</code></li>
</ul>

<p>So the partition is valid if and only if:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">A_left_max &lt;= B_right_min</code></li>
  <li><code class="language-plaintext highlighter-rouge">B_left_max &lt;= A_right_min</code></li>
</ul>

<p>Once you say this out loud, the solution becomes “search for <code class="language-plaintext highlighter-rouge">i</code>”.</p>

<h3 id="55-step-by-step-dry-run-so-it-feels-inevitable">5.5 Step-by-step dry run (so it feels inevitable)</h3>

<p>Example:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">A = [1, 3]</code></li>
  <li><code class="language-plaintext highlighter-rouge">B = [2, 4, 5]</code></li>
</ul>

<p>Total (N=5), left size (=(5+1)//2 = 3).</p>

<p>Binary search on <code class="language-plaintext highlighter-rouge">i</code> in <code class="language-plaintext highlighter-rouge">A</code> (<code class="language-plaintext highlighter-rouge">m=2</code>):</p>

<p><strong>Try <code class="language-plaintext highlighter-rouge">i=1</code></strong></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">j = 3 - 1 = 2</code></li>
  <li><code class="language-plaintext highlighter-rouge">A_left_max = A[0]=1</code></li>
  <li><code class="language-plaintext highlighter-rouge">A_right_min = A[1]=3</code></li>
  <li><code class="language-plaintext highlighter-rouge">B_left_max = B[1]=4</code></li>
  <li><code class="language-plaintext highlighter-rouge">B_right_min = B[2]=5</code></li>
</ul>

<p>Check:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">A_left_max &lt;= B_right_min</code> → <code class="language-plaintext highlighter-rouge">1 &lt;= 5</code> ✓</li>
  <li><code class="language-plaintext highlighter-rouge">B_left_max &lt;= A_right_min</code> → <code class="language-plaintext highlighter-rouge">4 &lt;= 3</code> ✗</li>
</ul>

<p>Second inequality fails ⇒ we took <strong>too few</strong> from <code class="language-plaintext highlighter-rouge">A</code> (right side of A is too small).
Move right: <code class="language-plaintext highlighter-rouge">lo = i+1</code>.</p>

<p><strong>Try <code class="language-plaintext highlighter-rouge">i=2</code></strong></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">j = 3 - 2 = 1</code></li>
  <li><code class="language-plaintext highlighter-rouge">A_left_max = A[1]=3</code></li>
  <li><code class="language-plaintext highlighter-rouge">A_right_min = +inf</code> (because i==m)</li>
  <li><code class="language-plaintext highlighter-rouge">B_left_max = B[0]=2</code></li>
  <li><code class="language-plaintext highlighter-rouge">B_right_min = B[1]=4</code></li>
</ul>

<p>Check:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">3 &lt;= 4</code> ✓</li>
  <li><code class="language-plaintext highlighter-rouge">2 &lt;= +inf</code> ✓</li>
</ul>

<p>Valid partition.
Total is odd ⇒ median is <code class="language-plaintext highlighter-rouge">max(A_left_max, B_left_max)=max(3,2)=3</code>.
Combined array is <code class="language-plaintext highlighter-rouge">[1,2,3,4,5]</code> ⇒ correct.</p>

<h3 id="56-proof-sketch-why-the-inequalities-are-sufficient">5.6 Proof sketch (why the inequalities are sufficient)</h3>

<p>To prove correctness, we need to show:</p>
<ol>
  <li>If the inequalities hold, then every element on the left is (\le) every element on the right.</li>
  <li>If the inequalities do not hold, we can move <code class="language-plaintext highlighter-rouge">i</code> in the correct direction.</li>
</ol>

<p><strong>(1) Sufficiency</strong></p>
<ul>
  <li>In <code class="language-plaintext highlighter-rouge">A</code>, everything left of <code class="language-plaintext highlighter-rouge">i</code> is (\le A_left_max).</li>
  <li>In <code class="language-plaintext highlighter-rouge">B</code>, everything left of <code class="language-plaintext highlighter-rouge">j</code> is (\le B_left_max).
So every left element is (\le \max(A_left_max, B_left_max)).</li>
</ul>

<p>Similarly:</p>
<ul>
  <li>In <code class="language-plaintext highlighter-rouge">A</code>, everything right of <code class="language-plaintext highlighter-rouge">i</code> is (\ge A_right_min).</li>
  <li>In <code class="language-plaintext highlighter-rouge">B</code>, everything right of <code class="language-plaintext highlighter-rouge">j</code> is (\ge B_right_min).
So every right element is (\ge \min(A_right_min, B_right_min)).</li>
</ul>

<p>If <code class="language-plaintext highlighter-rouge">A_left_max &lt;= B_right_min</code> and <code class="language-plaintext highlighter-rouge">B_left_max &lt;= A_right_min</code>, then:
[
\max(A_left_max, B_left_max) \le \min(A_right_min, B_right_min)
]
which implies the left max is (\le) right min, therefore all left (\le) all right.</p>

<p><strong>(2) Direction of movement</strong></p>
<ul>
  <li>If <code class="language-plaintext highlighter-rouge">A_left_max &gt; B_right_min</code>, we took too many from <code class="language-plaintext highlighter-rouge">A</code>; moving <code class="language-plaintext highlighter-rouge">i</code> left decreases <code class="language-plaintext highlighter-rouge">A_left_max</code> and increases <code class="language-plaintext highlighter-rouge">B_right_min</code>.</li>
  <li>Else (the remaining case), <code class="language-plaintext highlighter-rouge">B_left_max &gt; A_right_min</code>, we took too few from <code class="language-plaintext highlighter-rouge">A</code>; moving <code class="language-plaintext highlighter-rouge">i</code> right increases <code class="language-plaintext highlighter-rouge">A_right_min</code> and decreases <code class="language-plaintext highlighter-rouge">B_left_max</code>.</li>
</ul>

<p>That monotonic behavior makes binary search valid.</p>

<h3 id="57-an-alternative-k-th-element-perspective-useful-in-interviews">5.7 An alternative “k-th element” perspective (useful in interviews)</h3>

<p>Another way to think about the median is “find the (k)-th smallest element”, where:</p>
<ul>
  <li>(k = \left\lfloor \frac{N+1}{2} \right\rfloor) for odd (the median)</li>
  <li>and also the ((k+1))-th for even</li>
</ul>

<p>There’s a classic divide-and-conquer method that discards (k/2) elements per step (like binary search over ranks).
Even if you don’t code it, mentioning it shows depth:</p>
<ul>
  <li>it generalizes to other selection problems</li>
  <li>it reinforces the “don’t merge” principle</li>
</ul>

<p>The partition method you implemented is effectively a highly optimized, constant-space specialization of selection on two sorted arrays.</p>

<hr />

<h2 id="6-implementation-fully-commented-python">6. Implementation (Fully Commented Python)</h2>

<p>``python
from typing import List</p>

<p>class Solution:
 def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -&gt; float:
 “””
 Find the median of two sorted arrays in O(log(min(m, n))) time and O(1) space.</p>

<p>Idea:</p>
<ul>
  <li>Binary search the partition index i in the smaller array A.</li>
  <li>Derive j in the larger array B so that left side has half the elements.</li>
  <li>Check partition validity via boundary comparisons.
 “””</li>
</ul>

<p># Ensure nums1 is the smaller array to minimize binary search space.
 A, B = nums1, nums2
 if len(A) &gt; len(B):
 A, B = B, A</p>

<p>m, n = len(A), len(B)</p>

<p># Left side size: (m+n+1)//2 ensures left gets the extra when total is odd.
 left_size = (m + n + 1) // 2</p>

<p>lo, hi = 0, m # i ranges over [0..m] inclusive boundaries</p>

<p>NEG_INF = float(“-inf”)
 POS_INF = float(“inf”)</p>

<p>while lo &lt;= hi:
 i = (lo + hi) // 2
 j = left_size - i</p>

<p># Collect boundary values with sentinels for empty partitions.
 A_left_max = A[i - 1] if i &gt; 0 else NEG_INF
 A_right_min = A[i] if i &lt; m else POS_INF</p>

<p>B_left_max = B[j - 1] if j &gt; 0 else NEG_INF
 B_right_min = B[j] if j &lt; n else POS_INF</p>

<p># Check if partition is valid.
 if A_left_max &lt;= B_right_min and B_left_max &lt;= A_right_min:
 # We found the correct partition.
 if (m + n) % 2 == 1:
 # Odd total: median is the max of left side.
 return float(max(A_left_max, B_left_max))</p>

<p># Even total: median is average of the two middle values.
 left_max = max(A_left_max, B_left_max)
 right_min = min(A_right_min, B_right_min)
 return (left_max + right_min) / 2.0</p>

<p># Partition is invalid; adjust binary search.
 if A_left_max &gt; B_right_min:
 # We took too many from A; move left.
 hi = i - 1
 else:
 # We took too few from A; move right.
 lo = i + 1</p>

<p># If input arrays are sorted, we should never reach here.
 raise ValueError(“Invalid input: arrays are not sorted or other invariant broken.”)
``</p>

<hr />

<h2 id="7-testing-edge-cases-included">7. Testing (Edge Cases Included)</h2>

<h3 id="71-minimal-cases">7.1 Minimal cases</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">A=[]</code>, <code class="language-plaintext highlighter-rouge">B=[1]</code> → median <code class="language-plaintext highlighter-rouge">1</code></li>
  <li><code class="language-plaintext highlighter-rouge">A=[]</code>, <code class="language-plaintext highlighter-rouge">B=[1,2]</code> → median <code class="language-plaintext highlighter-rouge">1.5</code></li>
</ul>

<h3 id="72-highly-imbalanced-lengths">7.2 Highly imbalanced lengths</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">A=[1000000]</code>, <code class="language-plaintext highlighter-rouge">B=[1,2,3,4,5,6,7,8,9]</code></li>
  <li>Median should be <code class="language-plaintext highlighter-rouge">5</code> (combined length 10, middle two are 5 and 6 → 5.5?) Actually combined sorted is <code class="language-plaintext highlighter-rouge">[1..9, 1000000]</code>, median is <code class="language-plaintext highlighter-rouge">(5+6)/2=5.5</code>.</li>
</ul>

<h3 id="73-duplicates">7.3 Duplicates</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">A=[1,1,1]</code>, <code class="language-plaintext highlighter-rouge">B=[1,1]</code> → median <code class="language-plaintext highlighter-rouge">1</code></li>
</ul>

<h3 id="74-negative-numbers">7.4 Negative numbers</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">A=[-5,-3,-1]</code>, <code class="language-plaintext highlighter-rouge">B=[-2]</code> → combined <code class="language-plaintext highlighter-rouge">[-5,-3,-2,-1]</code> → median <code class="language-plaintext highlighter-rouge">(-3 + -2)/2 = -2.5</code></li>
</ul>

<h3 id="75-property-test-mindset-production">7.5 Property test mindset (production)</h3>
<p>A good invariant-based test:</p>
<ul>
  <li>For random sorted arrays, compare the optimal method against a slow merge baseline.</li>
</ul>

<h3 id="76-a-compact-test-harness-baseline-vs-optimal">7.6 A compact test harness (baseline vs optimal)</h3>

<p>In interviews you rarely write a full test harness, but in real codebases you should.
The most valuable pattern here is <strong>differential testing</strong>:
compare the “obviously correct” method against the “clever” method.</p>

<p>``python
import random</p>

<p>def median_merge_baseline(a: list[int], b: list[int]) -&gt; float:
 merged = []
 i = j = 0
 while i &lt; len(a) and j &lt; len(b):
 if a[i] &lt;= b[j]:
 merged.append(a[i]); i += 1
 else:
 merged.append(b[j]); j += 1
 merged.extend(a[i:])
 merged.extend(b[j:])</p>

<p>n = len(merged)
 if n % 2 == 1:
 return float(merged[n // 2])
 return (merged[n // 2 - 1] + merged[n // 2]) / 2.0</p>

<p>def randomized_test(trials: int = 200) -&gt; None:
 sol = Solution()
 for _ in range(trials):
 m = random.randint(0, 20)
 n = random.randint(0, 20)
 a = sorted(random.randint(-50, 50) for _ in range(m))
 b = sorted(random.randint(-50, 50) for _ in range(n))
 if m + n == 0:
 continue
 expected = median_merge_baseline(a, b)
 got = sol.findMedianSortedArrays(a, b)
 assert abs(expected - got) &lt; 1e-9, (a, b, expected, got)</p>

<p>if <strong>name</strong> == “<strong>main</strong>”:
 randomized_test()
 print(“OK”)
``</p>

<p>Why this matters:</p>
<ul>
  <li>it catches off-by-one errors instantly</li>
  <li>it future-proofs refactors (porting to another language)</li>
</ul>

<hr />

<h2 id="8-complexity-analysis-detailed">8. Complexity Analysis (Detailed)</h2>

<table>
  <tbody>
    <tr>
      <td>Let (m =</td>
      <td>A</td>
      <td>), (n =</td>
      <td>B</td>
      <td>), and assume (m \le n).</td>
    </tr>
  </tbody>
</table>

<ul>
  <li><strong>Binary search iterations</strong>: (O(\log m))</li>
  <li><strong>Work per iteration</strong>: constant (a handful of index checks/comparisons)</li>
</ul>

<p>So:</p>
<ul>
  <li><strong>Time</strong>: (O(\log m))</li>
  <li><strong>Space</strong>: (O(1))</li>
</ul>

<hr />

<h2 id="9-production-considerations">9. Production Considerations</h2>

<h3 id="91-numeric-types">9.1 Numeric types</h3>
<p>In production, numbers may be floats, timestamps, or decimals:</p>
<ul>
  <li>Watch out for floating-point precision in the even-case average.</li>
  <li>If values can exceed 32-bit range, use 64-bit ints (Python is safe).</li>
</ul>

<h3 id="92-data-location-matters">9.2 Data location matters</h3>
<p>If the two arrays live on different machines (or one is on disk), an (O(m+n)) merge can become:</p>
<ul>
  <li>network-heavy</li>
  <li>I/O-heavy</li>
</ul>

<p>The partition-based approach hints at a pattern:</p>
<blockquote>
  <p>Move computation to boundaries; minimize data movement.</p>
</blockquote>

<p>This is exactly why federated and privacy-preserving designs exist.</p>

<h3 id="93-generalizing-kth-element-queries">9.3 Generalizing: kth element queries</h3>
<p>Many real systems need percentiles (p90, p95) rather than medians.
This algorithm can be extended to compute the (k)-th element in two sorted arrays using a similar boundary search.</p>

<h3 id="94-external-memory-and-sorted-runs-why-merging-is-expensive-in-the-real-world">9.4 External-memory and “sorted runs” (why merging is expensive in the real world)</h3>

<p>In production data systems, your “arrays” are often:</p>
<ul>
  <li>sorted files on disk (SSTables)</li>
  <li>sorted partitions across machines</li>
  <li>time-ordered event logs (already sorted by timestamp)</li>
</ul>

<p>In those settings, a full merge is not just (O(m+n)) CPU:</p>
<ul>
  <li>it is <strong>I/O</strong> (disk reads)</li>
  <li>it is <strong>network</strong> (cross-machine transfer)</li>
  <li>it is <strong>latency</strong> (you wait for stragglers)</li>
</ul>

<p>This is why analytic engines invest heavily in:</p>
<ul>
  <li>indexes</li>
  <li>metadata (min/max per block)</li>
  <li>partition pruning</li>
</ul>

<p>The partition-based median algorithm is a toy version of the same idea:</p>
<blockquote>
  <p>Touch only what you need. Use order + boundaries to avoid moving everything.</p>
</blockquote>

<h3 id="95-approximate-percentiles-when-exact-is-too-expensive">9.5 Approximate percentiles (when exact is too expensive)</h3>

<p>At very large scale, you often don’t compute the exact median.
You compute an approximation with guarantees:</p>
<ul>
  <li><strong>t-digest</strong></li>
  <li><strong>KLL sketches</strong></li>
  <li>histogram-based quantiles</li>
</ul>

<p>These algorithms are explicitly designed for distributed systems:</p>
<ul>
  <li>each worker computes a sketch locally</li>
  <li>sketches merge efficiently (small payload)</li>
  <li>global quantiles are approximated from merged sketches</li>
</ul>

<p>If you interview for data-intensive roles, bringing this up shows “systems taste”:</p>
<ul>
  <li>exact algorithms are great, but approximations are often the production answer</li>
</ul>

<h3 id="96-streaming-and-sliding-windows">9.6 Streaming and sliding windows</h3>

<p>If values arrive over time (a stream), and you want a rolling median:</p>
<ul>
  <li>you can’t keep arrays fully sorted cheaply</li>
  <li>common solution: two heaps (max-heap for left, min-heap for right)</li>
</ul>

<p>That’s a different problem than “two sorted arrays”, but it reinforces the same invariant:</p>
<ul>
  <li>keep a balanced partition</li>
  <li>keep all left (\le) all right</li>
</ul>

<p>This problem teaches you to reason with that invariant precisely.</p>

<h3 id="97-testing-in-production-differential-testing-and-invariants">9.7 Testing in production: differential testing and invariants</h3>

<p>For critical code paths, a strong strategy is <strong>differential testing</strong>:</p>
<ul>
  <li>compare the optimal partition method against a slow merge baseline</li>
  <li>generate randomized sorted inputs (including duplicates, negatives, empties)</li>
</ul>

<p>Additionally, assert invariants at runtime in debug builds:</p>
<ul>
  <li>input arrays sorted</li>
  <li>computed partition satisfies inequalities</li>
  <li>returned median is within min/max bounds of inputs</li>
</ul>

<p>These checks catch regressions early, especially when porting the algorithm between languages.</p>

<hr />

<h2 id="10-connections-to-ml-systems">10. Connections to ML Systems</h2>

<p>The theme today is <strong>binary search and distributed algorithms</strong>:</p>
<ul>
  <li><strong>Federated Learning</strong>: clients compute local statistics, then a server aggregates—global behavior emerges from boundary interactions, not centralized raw data.</li>
  <li><strong>Privacy-preserving Speech</strong>: you can’t centralize raw audio; you must design algorithms that preserve correctness while restricting access.</li>
  <li><strong>Knowledge Graphs for Agents</strong>: agents need fast retrieval and reasoning without scanning the entire graph; indexing and targeted search are the equivalent of “partitioning”.</li>
</ul>

<p>Concretely, this problem teaches a transferable skill:</p>
<blockquote>
  <p>When you see “two sorted streams”, don’t merge unless you have to—search for the boundary that answers the query.</p>
</blockquote>

<hr />

<h2 id="11-interview-strategy">11. Interview Strategy</h2>

<ol>
  <li><strong>Start with merge</strong>: show the baseline quickly (it builds confidence).</li>
  <li><strong>Call out the constraint</strong>: “If you need log time, we can’t merge.”</li>
  <li><strong>Explain partition clearly</strong>: draw the four boundary values and the two inequalities.</li>
  <li><strong>Force the swap</strong>: always binary search the smaller array.</li>
  <li><strong>Use sentinels</strong>: <code class="language-plaintext highlighter-rouge">-inf</code> and <code class="language-plaintext highlighter-rouge">+inf</code> to avoid messy edge-case branches.</li>
</ol>

<p>Common mistakes:</p>
<ul>
  <li>Off-by-one on left size when total is odd (use <code class="language-plaintext highlighter-rouge">(m+n+1)//2</code>).</li>
  <li>Forgetting that partition index ranges include <code class="language-plaintext highlighter-rouge">0</code> and <code class="language-plaintext highlighter-rouge">m</code>.</li>
  <li>Computing <code class="language-plaintext highlighter-rouge">j</code> outside <code class="language-plaintext highlighter-rouge">[0..n]</code> (fixed by ensuring <code class="language-plaintext highlighter-rouge">A</code> is smaller).</li>
</ul>

<h3 id="111-what-to-say-while-you-code-signal-you-understand-the-invariants">11.1 What to say while you code (signal you understand the invariants)</h3>

<p>As you implement, narrate the invariants:</p>
<ul>
  <li>“I’m searching <code class="language-plaintext highlighter-rouge">i</code> in the smaller array so the search space is <code class="language-plaintext highlighter-rouge">log m</code>.”</li>
  <li>“<code class="language-plaintext highlighter-rouge">j</code> is derived so left has exactly half the elements.”</li>
  <li>“I’ll compute four boundary values and only compare boundaries.”</li>
  <li>“If <code class="language-plaintext highlighter-rouge">A_left_max</code> is too big, shift left; otherwise shift right.”</li>
</ul>

<p>This matters because interviewers grade <strong>reasoning</strong>, not just final code.</p>

<h3 id="112-follow-up-questions-you-should-be-ready-for">11.2 Follow-up questions you should be ready for</h3>

<p>Interviewers often ask variants to see if you truly own the technique:</p>

<ul>
  <li><strong>“What if I ask for the 90th percentile instead of the median?”</strong></li>
  <li>Answer: median is a special case of the (k)-th smallest selection problem.</li>
  <li>For a single query on two sorted arrays, you can compute the (k)-th element similarly.</li>
  <li>
    <p>At massive distributed scale, you’ll often use approximate quantiles (sketches).</p>
  </li>
  <li><strong>“What if arrays contain floats or timestamps?”</strong></li>
  <li>Answer: algorithm is order-based, works as long as comparisons are consistent.</li>
  <li>
    <p>For even length, the “average” step may need domain-specific behavior (e.g., midpoint timestamp).</p>
  </li>
  <li><strong>“What if the arrays are descending?”</strong></li>
  <li>Answer: either reverse comparisons or normalize by reversing inputs.</li>
  <li>
    <p>The invariant is “left max &lt;= right min” under the chosen ordering.</p>
  </li>
  <li><strong>“Can you do it without using infinities?”</strong></li>
  <li>Answer: yes, but sentinels simplify edge conditions (and reduce bugs).</li>
</ul>

<h3 id="113-how-to-debug-when-it-fails-fast">11.3 How to debug when it fails (fast)</h3>

<p>If you get a wrong answer, print the four boundary values and check the inequalities:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">i</code>, <code class="language-plaintext highlighter-rouge">j</code></li>
  <li><code class="language-plaintext highlighter-rouge">A_left_max</code>, <code class="language-plaintext highlighter-rouge">A_right_min</code></li>
  <li><code class="language-plaintext highlighter-rouge">B_left_max</code>, <code class="language-plaintext highlighter-rouge">B_right_min</code></li>
</ul>

<p>Most bugs are:</p>
<ul>
  <li>wrong <code class="language-plaintext highlighter-rouge">left_size</code> formula</li>
  <li>wrong handling when <code class="language-plaintext highlighter-rouge">i==0</code> or <code class="language-plaintext highlighter-rouge">i==m</code> (or similarly for <code class="language-plaintext highlighter-rouge">j</code>)</li>
</ul>

<h3 id="114-why-this-problem-is-a-great-systems-signal">11.4 Why this problem is a great “systems signal”</h3>

<p>Even though it’s a DSA question, it tests a production instinct:</p>
<blockquote>
  <p>Don’t move or materialize data you don’t need.</p>
</blockquote>

<p>That instinct is directly useful in:</p>
<ul>
  <li>distributed query engines (pushdown predicates and limit scans)</li>
  <li>privacy-sensitive systems (compute aggregates locally)</li>
  <li>agent retrieval systems (retrieve the smallest evidence set that answers the question)</li>
</ul>

<hr />

<h2 id="12-key-takeaways">12. Key Takeaways</h2>

<ol>
  <li><strong>Median = partition boundary</strong>, not a merge artifact.</li>
  <li><strong>Binary search is a tool for monotonic conditions</strong>, not just “find a number”.</li>
  <li><strong>Boundary-first thinking scales</strong>: it’s the same instinct you need for distributed and privacy-constrained systems.</li>
</ol>

<h3 id="121-mental-model-summary-the-one-you-want-to-internalize">12.1 Mental model summary (the one you want to internalize)</h3>

<p>If you can remember one sentence, remember this:</p>
<blockquote>
  <p>We’re not searching values; we’re searching the cut that makes left and right “balanced and ordered”.</p>
</blockquote>

<p>Everything else follows:</p>
<ul>
  <li>The “balanced” condition gives you <code class="language-plaintext highlighter-rouge">j = left_size - i</code>.</li>
  <li>The “ordered” condition is two inequalities on four boundary values.</li>
  <li>The median is computed from the boundary once the inequalities hold.</li>
</ul>

<h3 id="122-a-second-optimal-method-divide-and-conquer-k-th-element">12.2 A second optimal method (divide-and-conquer k-th element)</h3>

<p>Sometimes an interviewer will ask:
“Can you find the (k)-th smallest element of two sorted arrays?”</p>

<p>There’s a classic selection algorithm:</p>
<ul>
  <li>compare (k/2)-th elements in each array</li>
  <li>discard (k/2) elements from one array each step</li>
  <li>recurse with reduced (k)</li>
</ul>

<p>This is essentially “binary search over ranks”.
It also runs in (O(\log k)), which is (O(\log(m+n))).</p>

<p>You don’t need to implement it here (the partition method is cleaner),
but it’s useful to know as an alternative for:</p>
<ul>
  <li>teaching</li>
  <li>reasoning about general percentiles</li>
  <li>interviews where they steer toward a recursive selection approach</li>
</ul>

<p>High-level pseudocode:</p>

<p>``python
def kth(a, b, k): # 1-indexed k
 if not a: return b[k-1]
 if not b: return a[k-1]
 if k == 1: return min(a[0], b[0])</p>

<p>i = min(len(a), k//2)
 j = min(len(b), k//2)</p>

<p>if a[i-1] &lt;= b[j-1]:
 # discard first i elements of a
 return kth(a[i:], b, k - i)
 else:
 # discard first j elements of b
 return kth(a, b[j:], k - j)
``</p>

<p>Why it works:</p>
<ul>
  <li>if <code class="language-plaintext highlighter-rouge">a[i-1] &lt;= b[j-1]</code>, then <code class="language-plaintext highlighter-rouge">a[:i]</code> cannot contain the k-th element
 (there are at least <code class="language-plaintext highlighter-rouge">i + j - 1 &gt;= k - 1</code> elements &lt;= <code class="language-plaintext highlighter-rouge">b[j-1]</code>),
 so we can safely discard it.</li>
</ul>

<p>This is the same “discard half the search space” principle that powers binary search.</p>

<h3 id="123-practical-note-stable-behavior-across-languages">12.3 Practical note: stable behavior across languages</h3>

<p>If you implement this in C++/Java:</p>
<ul>
  <li>avoid integer overflow when computing averages (use long / double carefully)</li>
  <li>sentinel usage differs (use <code class="language-plaintext highlighter-rouge">INT_MIN/INT_MAX</code> or explicit branches)</li>
</ul>

<p>In Python, <code class="language-plaintext highlighter-rouge">float("inf")</code> is convenient, but remember:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">inf</code> is only used for comparisons here, not returned as a median</li>
  <li>if your arrays could contain actual infinities (rare), you’d need explicit handling</li>
</ul>

<h3 id="124-if-youre-short-on-time-the-30-second-explanation">12.4 If you’re short on time: the 30-second explanation</h3>

<p>If you need to summarize fast:</p>
<ul>
  <li>Pick the smaller array <code class="language-plaintext highlighter-rouge">A</code>.</li>
  <li>Binary search a cut <code class="language-plaintext highlighter-rouge">i</code> in <code class="language-plaintext highlighter-rouge">A</code>.</li>
  <li>Compute <code class="language-plaintext highlighter-rouge">j</code> so left side has half the total.</li>
  <li>Check two inequalities using boundary values.</li>
  <li>When inequalities hold, compute median from <code class="language-plaintext highlighter-rouge">max(left)</code> and <code class="language-plaintext highlighter-rouge">min(right)</code>.</li>
</ul>

<p>That’s the entire solution.</p>

<h3 id="125-one-more-invariant-useful-for-sanity-checks">12.5 One more invariant (useful for sanity checks)</h3>

<p>After you compute a candidate median, a quick sanity check is:</p>
<ul>
  <li>the median must lie between the minimum and maximum of the combined arrays</li>
  <li>more specifically, it must be:</li>
  <li>(\ge) the maximum of the left boundary values</li>
  <li>(\le) the minimum of the right boundary values</li>
</ul>

<p>In code terms (once partition is valid):</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">left_max = max(A_left_max, B_left_max)</code></li>
  <li><code class="language-plaintext highlighter-rouge">right_min = min(A_right_min, B_right_min)</code></li>
  <li>for odd: <code class="language-plaintext highlighter-rouge">median == left_max</code></li>
  <li>for even: <code class="language-plaintext highlighter-rouge">left_max &lt;= median &lt;= right_min</code></li>
</ul>

<p>This is also a nice explanation when someone asks “why do we take max(left) and min(right)?”</p>

<hr />

<p><strong>Originally published at:</strong> <a href="https://www.arunbaby.com/dsa/0051-median-of-two-sorted-arrays/">arunbaby.com/dsa/0051-median-of-two-sorted-arrays</a></p>

<p><em>If you found this helpful, consider sharing it with others who might benefit.</em></p>


        
      </section>

      <footer class="page__meta">
        
        
  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-tags" aria-hidden="true"></i> Tags: </strong>
    <span itemprop="keywords">
    
      <a href="/tags/#arrays" class="page__taxonomy-item p-category" rel="tag">arrays</a><span class="sep">, </span>
    
      <a href="/tags/#binary-search" class="page__taxonomy-item p-category" rel="tag">binary-search</a><span class="sep">, </span>
    
      <a href="/tags/#divide-and-conquer" class="page__taxonomy-item p-category" rel="tag">divide-and-conquer</a><span class="sep">, </span>
    
      <a href="/tags/#hard" class="page__taxonomy-item p-category" rel="tag">hard</a><span class="sep">, </span>
    
      <a href="/tags/#interview-classic" class="page__taxonomy-item p-category" rel="tag">interview-classic</a><span class="sep">, </span>
    
      <a href="/tags/#partition" class="page__taxonomy-item p-category" rel="tag">partition</a>
    
    </span>
  </p>




  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> Categories: </strong>
    <span itemprop="keywords">
    
      <a href="/categories/#dsa" class="page__taxonomy-item p-category" rel="tag">dsa</a>
    
    </span>
  </p>


        
      </footer>

      <div class="page__related page__related--full">
  <h2 class="page__related-title">Related across topics</h2>
  <style>
    /* Make section span full content width and use 2 equal columns */
    .page__related--full { float: inline-start; width: 100%; padding: 0; }
    .cross-related-grid { display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 2rem; }
    @media (max-width: 768px) { .cross-related-grid { grid-template-columns: 1fr; } }
    /* Ensure archive cards stretch nicely in the grid */
    .cross-related-grid .list__item, .cross-related-grid .grid__item { width: auto; float: none; margin: 0; }
  </style>
  <div class="cross-related-grid">
    



<div class="list__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/ml-system-design/0051-federated-learning/" rel="permalink">Federated Learning
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          24 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">“If data can’t move, move the model—and design the system so the server never sees what matters.”
</p>
  </article>
</div>




<div class="list__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/speech-tech/0051-privacy-preserving-speech/" rel="permalink">Privacy-preserving Speech
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          23 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">“Speech is biometric. Treat every waveform like a password—design systems that learn without listening.”
</p>
  </article>
</div>




<div class="list__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/ai-agents/0051-knowledge-graphs-for-agents/" rel="permalink">Knowledge Graphs for Agents
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          23 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">“RAG gives you documents. A knowledge graph gives you facts with structure—and agents need structure to act reliably.”
</p>
  </article>
</div>

  </div>
</div>

      <section class="page__share">
  <h4 class="page__share-title">Share on</h4>

  <a href="https://twitter.com/intent/tweet?via=arunbaby0&text=Median+of+Two+Sorted+Arrays%20https%3A%2F%2Fwww.arunbaby.com%2Fdsa%2F0051-median-of-two-sorted-arrays%2F" class="btn btn--twitter" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Twitter"><i class="fab fa-fw fa-twitter" aria-hidden="true"></i><span> Twitter</span></a>

  <a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fwww.arunbaby.com%2Fdsa%2F0051-median-of-two-sorted-arrays%2F" class="btn btn--facebook" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Facebook"><i class="fab fa-fw fa-facebook" aria-hidden="true"></i><span> Facebook</span></a>

  <a href="https://www.linkedin.com/shareArticle?mini=true&url=https://www.arunbaby.com/dsa/0051-median-of-two-sorted-arrays/" class="btn btn--linkedin" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on LinkedIn"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i><span> LinkedIn</span></a>
</section>


      
  <nav class="pagination">
    
      <a href="/dsa/0050-alien-dictionary/" class="pagination--pager" title="Alien Dictionary">Previous</a>
    
    
      <a href="/dsa/0052-trapping-rain-water/" class="pagination--pager" title="Trapping Rain Water">Next</a>
    
  </nav>


    </div>

    
  </article>

  
  
</div>

      
    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';" role="search">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Enter your search term..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    

    
      
        
          <li><a href="https://twitter.com/arunbaby0" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-twitter-square" aria-hidden="true"></i> Twitter</a></li>
        
      
        
          <li><a href="https://github.com/arunbaby0" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
        
      
        
          <li><a href="https://www.linkedin.com/in/arunbaby0/" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i> LinkedIn</a></li>
        
      
        
          <li><a href="https://scholar.google.co.in/citations?user=6fSYWhkAAAAJ" rel="nofollow noopener noreferrer"><i class="fas fa-fw fa-graduation-cap" aria-hidden="true"></i> Google Scholar</a></li>
        
      
    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 1990 - 2143 <a href="https://www.arunbaby.com">Arun Baby</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>




  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-0JRJPEC9SS"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-0JRJPEC9SS', { 'anonymize_ip': false});
</script>








  </body>
</html>
