<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.26.2 by Michael Rose
  Copyright 2013-2024 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->

<html lang="en-US" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Merge Intervals - Arun Baby</title>
<meta name="description" content="Master interval processing to handle overlapping ranges—the foundation of event streams and temporal reasoning in production systems.">


  <meta name="author" content="Arun Baby">
  
  <meta property="article:author" content="Arun Baby">
  


<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="Arun Baby">
<meta property="og:title" content="Merge Intervals">
<meta property="og:url" content="https://www.arunbaby.com/dsa/0016-merge-intervals/">


  <meta property="og:description" content="Master interval processing to handle overlapping ranges—the foundation of event streams and temporal reasoning in production systems.">



  <meta property="og:image" content="https://www.arunbaby.com/assets/images/profile-photo.png">



  <meta name="twitter:site" content="@arunbaby0">
  <meta name="twitter:title" content="Merge Intervals">
  <meta name="twitter:description" content="Master interval processing to handle overlapping ranges—the foundation of event streams and temporal reasoning in production systems.">
  <meta name="twitter:url" content="https://www.arunbaby.com/dsa/0016-merge-intervals/">

  
    <meta name="twitter:card" content="summary">
    
      <meta name="twitter:image" content="https://www.arunbaby.com/assets/images/profile-photo.png">
    
  

  



  <meta property="article:published_time" content="2025-12-31T10:08:45+05:30">





  

  


<link rel="canonical" href="https://www.arunbaby.com/dsa/0016-merge-intervals/">












<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Arun Baby Feed">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
  
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css"></noscript>



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--single" dir="ltr">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
           
          <span class="site-subtitle">Arun Baby</span>
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a
                href="/about/"
                
                
              >About</a>
            </li><li class="masthead__menu-item">
              <a
                href="/dsa/"
                
                
              >DSA</a>
            </li><li class="masthead__menu-item">
              <a
                href="/ml-system-design/"
                
                
              >ML Systems</a>
            </li><li class="masthead__menu-item">
              <a
                href="/speech-tech/"
                
                
              >Speech Tech</a>
            </li><li class="masthead__menu-item">
              <a
                href="/ai-agents/"
                
                
              >AI Agents</a>
            </li><li class="masthead__menu-item">
              <a
                href="/publications/"
                
                
              >Publications</a>
            </li><li class="masthead__menu-item">
              <a
                href="/statuses/"
                
                
              >Statuses</a>
            </li><li class="masthead__menu-item">
              <a
                href="/contact/"
                
                
              >Contact</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <i class="fas fa-search"></i>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      





<div id="main" role="main" class="no-author-sidebar">
  
  <div class="sidebar sticky">
  
  
  </div>



  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="Merge Intervals">
    <meta itemprop="description" content="Master interval processing to handle overlapping ranges—the foundation of event streams and temporal reasoning in production systems.">
    <meta itemprop="datePublished" content="2025-12-31T10:08:45+05:30">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">
            <a href="https://www.arunbaby.com/dsa/0016-merge-intervals/" itemprop="url">Merge Intervals
</a>
          </h1>
          

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          21 minute read
        
      </span>
    
  </p>


        </header>
      

      <section class="page__content" itemprop="text">
        
          <aside class="sidebar__right sticky">
            <nav class="toc">
              <header><h4 class="nav__title"><i class="fas fa-file-alt"></i> On this page</h4></header>
              <ul class="toc__menu"><li><a href="#problem-statement">Problem Statement</a><ul><li><a href="#examples">Examples</a></li><li><a href="#constraints">Constraints</a></li></ul></li><li><a href="#understanding-the-problem">Understanding the Problem</a><ul><li><a href="#what-does-overlap-mean">What Does “Overlap” Mean?</a></li><li><a href="#key-insight">Key Insight</a></li><li><a href="#why-this-problem-matters">Why This Problem Matters</a></li><li><a href="#the-temporal-processing-connection">The Temporal Processing Connection</a></li></ul></li><li><a href="#approach-1-brute-force---compare-all-pairs">Approach 1: Brute Force - Compare All Pairs</a><ul><li><a href="#intuition">Intuition</a></li><li><a href="#implementation">Implementation</a></li><li><a href="#analysis">Analysis</a></li></ul></li><li><a href="#approach-2-sort--merge-optimal">Approach 2: Sort + Merge (Optimal)</a><ul><li><a href="#the-key-insight">The Key Insight</a></li><li><a href="#algorithm">Algorithm</a></li><li><a href="#implementation-1">Implementation</a></li><li><a href="#step-by-step-visualization">Step-by-Step Visualization</a></li><li><a href="#edge-cases-handling">Edge Cases Handling</a></li></ul></li><li><a href="#implementation-production-grade-solution">Implementation: Production-Grade Solution</a></li><li><a href="#testing">Testing</a><ul><li><a href="#comprehensive-test-suite">Comprehensive Test Suite</a></li></ul></li><li><a href="#complexity-analysis">Complexity Analysis</a><ul><li><a href="#time-complexity-on-log-n">Time Complexity: O(N log N)</a></li><li><a href="#space-complexity-on">Space Complexity: O(N)</a></li><li><a href="#comparison">Comparison</a></li></ul></li><li><a href="#production-considerations">Production Considerations</a><ul><li><a href="#1-handling-large-datasets">1. Handling Large Datasets</a></li><li><a href="#2-parallel-processing">2. Parallel Processing</a></li><li><a href="#3-interval-trees-for-queries">3. Interval Trees for Queries</a></li></ul></li><li><a href="#connections-to-ml-systems">Connections to ML Systems</a><ul><li><a href="#1-event-stream-processing">1. Event Stream Processing</a></li><li><a href="#2-meeting-room-scheduling">2. Meeting Room Scheduling</a></li><li><a href="#key-parallels">Key Parallels</a></li></ul></li><li><a href="#interview-strategy">Interview Strategy</a><ul><li><a href="#how-to-approach">How to Approach</a></li><li><a href="#common-mistakes">Common Mistakes</a></li><li><a href="#follow-up-questions">Follow-up Questions</a></li></ul></li><li><a href="#key-takeaways">Key Takeaways</a><ul><li><a href="#mental-model">Mental Model</a></li></ul></li><li><a href="#additional-scenarios--variants">Additional Scenarios &amp; Variants</a></li></ul>
            </nav>
          </aside>
        
        <p><strong>Master interval processing to handle overlapping ranges—the foundation of event streams and temporal reasoning in production systems.</strong></p>

<h2 id="problem-statement">Problem Statement</h2>

<p>Given an array of <code class="language-plaintext highlighter-rouge">intervals</code> where <code class="language-plaintext highlighter-rouge">intervals[i] = [start_i, end_i]</code>, merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.</p>

<h3 id="examples">Examples</h3>

<p><strong>Example 1:</strong>
<code class="language-plaintext highlighter-rouge">
Input: intervals = [[1,3],[2,6],[8,10],[15,18]]
Output: [[1,6],[8,10],[15,18]]
Explanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6].
</code></p>

<p><strong>Example 2:</strong>
<code class="language-plaintext highlighter-rouge">
Input: intervals = [[1,4],[4,5]]
Output: [[1,5]]
Explanation: Intervals [1,4] and [4,5] are considered overlapping.
</code></p>

<p><strong>Example 3:</strong>
<code class="language-plaintext highlighter-rouge">
Input: intervals = [[1,4],[2,3]]
Output: [[1,4]]
Explanation: [2,3] is completely contained in [1,4], so merge into [1,4].
</code></p>

<h3 id="constraints">Constraints</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">1 &lt;= intervals.length &lt;= 10^4</code></li>
  <li><code class="language-plaintext highlighter-rouge">intervals[i].length == 2</code></li>
  <li><code class="language-plaintext highlighter-rouge">0 &lt;= start_i &lt;= end_i &lt;= 10^4</code></li>
</ul>

<h2 id="understanding-the-problem">Understanding the Problem</h2>

<p>This is a <strong>fundamental interval processing problem</strong> that teaches us:</p>
<ol>
  <li><strong>How to handle overlapping ranges</strong> (time windows, resources, etc.)</li>
  <li><strong>Sorting as a preprocessing step</strong> for greedy algorithms</li>
  <li><strong>Temporal reasoning</strong> - managing sequences of events</li>
  <li><strong>Merging strategy</strong> - combining adjacent/overlapping items</li>
</ol>

<h3 id="what-does-overlap-mean">What Does “Overlap” Mean?</h3>

<p>Two intervals <code class="language-plaintext highlighter-rouge">[a, b]</code> and <code class="language-plaintext highlighter-rouge">[c, d]</code> overlap if:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">a &lt;= c &lt;= b</code> (second starts before first ends)</li>
  <li>OR <code class="language-plaintext highlighter-rouge">c &lt;= a &lt;= d</code> (first starts before second ends)</li>
</ul>

<p>Equivalently: <code class="language-plaintext highlighter-rouge">max(a, c) &lt;= min(b, d)</code></p>

<p><strong>Examples:</strong></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">[1,3]</code> and <code class="language-plaintext highlighter-rouge">[2,6]</code> overlap → merge to <code class="language-plaintext highlighter-rouge">[1,6]</code></li>
  <li><code class="language-plaintext highlighter-rouge">[1,4]</code> and <code class="language-plaintext highlighter-rouge">[4,5]</code> overlap (touching) → merge to <code class="language-plaintext highlighter-rouge">[1,5]</code></li>
  <li><code class="language-plaintext highlighter-rouge">[1,3]</code> and <code class="language-plaintext highlighter-rouge">[4,6]</code> don’t overlap → keep separate</li>
</ul>

<h3 id="key-insight">Key Insight</h3>

<p><strong>If we sort intervals by start time, we only need to check if current interval overlaps with the last merged interval.</strong></p>

<p>No need to compare all pairs!</p>

<h3 id="why-this-problem-matters">Why This Problem Matters</h3>

<ol>
  <li><strong>Scheduling:</strong> Merge meeting times, resource reservations</li>
  <li><strong>Event processing:</strong> Consolidate event streams, logs</li>
  <li><strong>Range queries:</strong> Database query optimization</li>
  <li><strong>Calendar applications:</strong> Merge busy/free time</li>
  <li><strong>Real-world applications:</strong>
    <ul>
      <li>Meeting room booking systems</li>
      <li>CPU task scheduling</li>
      <li>Network packet analysis</li>
      <li>Audio/video segment processing</li>
    </ul>
  </li>
</ol>

<h3 id="the-temporal-processing-connection">The Temporal Processing Connection</h3>

<table>
  <thead>
    <tr>
      <th>Merge Intervals</th>
      <th>Event Stream Processing</th>
      <th>Audio Segmentation</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Merge overlapping time ranges</td>
      <td>Merge event windows</td>
      <td>Merge audio segments</td>
    </tr>
    <tr>
      <td>Sort by start time</td>
      <td>Event ordering</td>
      <td>Temporal ordering</td>
    </tr>
    <tr>
      <td>O(N log N) sorting</td>
      <td>Stream buffering</td>
      <td>Segment buffering</td>
    </tr>
    <tr>
      <td>Greedy merging</td>
      <td>Window aggregation</td>
      <td>Boundary merging</td>
    </tr>
  </tbody>
</table>

<p>All three deal with <strong>temporal data</strong> and require efficient interval processing.</p>

<h2 id="approach-1-brute-force---compare-all-pairs">Approach 1: Brute Force - Compare All Pairs</h2>

<h3 id="intuition">Intuition</h3>

<p>For each interval, check if it overlaps with any other interval, and merge if needed. Repeat until no more merges possible.</p>

<h3 id="implementation">Implementation</h3>

<p>``python
from typing import List</p>

<p>def merge_bruteforce(intervals: List[List[int]]) -&gt; List[List[int]]:
 “””
 Brute force: repeatedly merge overlapping intervals.</p>

<p>Time: O(N^2 × M) where N = number of intervals, M = merge operations
 Space: O(N)</p>

<p>Why this approach?</p>
<ul>
  <li>Simple to understand</li>
  <li>Shows the naive solution</li>
  <li>Demonstrates need for optimization</li>
</ul>

<p>Problem:</p>
<ul>
  <li>Too slow for large inputs</li>
  <li>Redundant comparisons</li>
  <li>Multiple passes needed
 “””
 if not intervals:
 return []</li>
</ul>

<p># Keep merging until no more overlaps found
 merged = intervals[:]
 changed = True</p>

<p>while changed:
 changed = False
 new_merged = []
 used = set()</p>

<p>for i in range(len(merged)):
 if i in used:
 continue</p>

<p>current = merged[i]
 used.add(i)</p>

<p># Try to merge with all other intervals
 for j in range(i + 1, len(merged)):
 if j in used:
 continue</p>

<p># Check if overlaps
 if max(current[0], merged[j][0]) &lt;= min(current[1], merged[j][1]):
 # Merge
 current = [
 min(current[0], merged[j][0]),
 max(current[1], merged[j][1])
 ]
 used.add(j)
 changed = True</p>

<p>new_merged.append(current)</p>

<p>merged = new_merged</p>

<p>return merged</p>

<h1 id="test">Test</h1>
<p>test_input = [[1,3],[2,6],[8,10],[15,18]]
print(merge_bruteforce(test_input))</p>
<h1 id="output-1-6-8-10-15-18">Output: [[1, 6], [8, 10], [15, 18]]</h1>
<p>``</p>

<h3 id="analysis">Analysis</h3>

<p><strong>Time Complexity: O(N² × M)</strong></p>
<ul>
  <li>Worst case: O(N³) when we need multiple merge passes</li>
  <li>Each pass: O(N²) comparisons</li>
</ul>

<p><strong>Space Complexity: O(N)</strong></p>

<p><strong>Problem:</strong> Too slow for N = 10,000!</p>

<h2 id="approach-2-sort--merge-optimal">Approach 2: Sort + Merge (Optimal)</h2>

<h3 id="the-key-insight">The Key Insight</h3>

<p><strong>If we sort intervals by start time, overlapping intervals will be adjacent!</strong></p>

<p>Then we can merge in a single pass:</p>
<ol>
  <li>Sort by start time: O(N log N)</li>
  <li>Single pass merge: O(N)</li>
  <li>Total: O(N log N)</li>
</ol>

<h3 id="algorithm">Algorithm</h3>

<p>``</p>
<ol>
  <li>Sort intervals by start time</li>
  <li>Initialize result with first interval</li>
  <li>For each remaining interval:
    <ul>
      <li>If it overlaps with last merged interval:
 → Extend the last interval’s end time</li>
      <li>Else:
 → Add it as new interval to result</li>
    </ul>
  </li>
  <li>Return result
``</li>
</ol>

<h3 id="implementation-1">Implementation</h3>

<p>``python
from typing import List</p>

<p>def merge(intervals: List[List[int]]) -&gt; List[List[int]]:
 “””
 Optimal solution using sort + greedy merge.</p>

<p>Time: O(N log N) - dominated by sorting
 Space: O(N) - for output (or O(log N) for sorting if in-place)</p>

<p>Algorithm:</p>
<ol>
  <li>Sort intervals by start time</li>
  <li>Greedily merge overlapping intervals</li>
  <li>Single pass through sorted list</li>
</ol>

<p>Why this works:</p>
<ul>
  <li>After sorting, overlapping intervals are adjacent</li>
  <li>Only need to check current vs last merged</li>
  <li>Greedy choice: extend end time if overlap
 “””
 if not intervals:
 return []</li>
</ul>

<p># Sort by start time
 intervals.sort(key=lambda x: x[0])</p>

<p># Initialize result with first interval
 merged = [intervals[0]]</p>

<p>for current in intervals[1:]:
 last = merged[-1]</p>

<p># Check if current overlaps with last merged interval
 if current[0] &lt;= last[1]:
 # Overlaps - extend the end time
 # We might need to extend or keep existing end
 last[1] = max(last[1], current[1])
 else:
 # No overlap - add as new interval
 merged.append(current)</p>

<p>return merged</p>

<h1 id="test-cases">Test cases</h1>
<p>test_cases = [
 [[1,3],[2,6],[8,10],[15,18]], # Basic overlap
 [[1,4],[4,5]], # Touching intervals
 [[1,4],[2,3]], # Contained interval
 [[1,4],[0,4]], # Start time same
 [[1,4],[0,1]], # Adjacent, no overlap
]</p>

<p>for test in test_cases:
 result = merge(test)
 print(f”Input: {test}”)
 print(f”Output: {result}\n”)
``</p>

<h3 id="step-by-step-visualization">Step-by-Step Visualization</h3>

<p>``
Input: [[1,3],[2,6],[8,10],[15,18]]</p>

<p>Step 1: Sort by start time
 Already sorted: [[1,3],[2,6],[8,10],[15,18]]</p>

<p>Step 2: Initialize with first interval
 merged = [[1,3]]</p>

<p>Step 3: Process [2,6]
 current[0]=2 &lt;= last[1]=3 → overlaps!
 Extend: [1,3] → [1,6]
 merged = [[1,6]]</p>

<p>Step 4: Process [8,10]
 current[0]=8 &gt; last[1]=6 → no overlap
 Add new interval
 merged = [[1,6], [8,10]]</p>

<p>Step 5: Process [15,18]
 current[0]=15 &gt; last[1]=10 → no overlap
 Add new interval
 merged = [[1,6], [8,10], [15,18]]</p>

<p>Output: [[1,6],[8,10],[15,18]]
``</p>

<h3 id="edge-cases-handling">Edge Cases Handling</h3>

<p>``python
def merge_with_edge_cases(intervals: List[List[int]]) -&gt; List[List[int]]:
 “””
 Enhanced version handling edge cases explicitly.
 “””
 # Edge case: empty input
 if not intervals:
 return []</p>

<p># Edge case: single interval
 if len(intervals) == 1:
 return intervals</p>

<p># Sort by start time (and by end time if starts are equal)
 intervals.sort(key=lambda x: (x[0], x[1]))</p>

<p>merged = [intervals[0]]</p>

<p>for i in range(1, len(intervals)):
 current = intervals[i]
 last = merged[-1]</p>

<p># Check overlap (current starts before or when last ends)
 if current[0] &lt;= last[1]:
 # Merge: extend end to max of both ends
 last[1] = max(last[1], current[1])
 else:
 # No overlap: add new interval
 merged.append(current)</p>

<p>return merged
``</p>

<h2 id="implementation-production-grade-solution">Implementation: Production-Grade Solution</h2>

<p>``python
from typing import List, Optional, Tuple
import logging
from dataclasses import dataclass</p>

<p>@dataclass
class Interval:
 “"”Interval with metadata.”””
 start: int
 end: int
 label: Optional[str] = None</p>

<p>def <strong>lt</strong>(self, other):
 “"”For sorting.”””
 return (self.start, self.end) &lt; (other.start, other.end)</p>

<p>def overlaps(self, other: ‘Interval’) -&gt; bool:
 “"”Check if this interval overlaps with another.”””
 return max(self.start, other.start) &lt;= min(self.end, other.end)</p>

<p>def merge_with(self, other: ‘Interval’) -&gt; ‘Interval’:
 “"”Merge this interval with another.”””
 return Interval(
 start=min(self.start, other.start),
 end=max(self.end, other.end),
 label=self.label or other.label
 )</p>

<p>def to_list(self) -&gt; List[int]:
 “"”Convert to [start, end] list.”””
 return [self.start, self.end]</p>

<p>class IntervalMerger:
 “””
 Production-ready interval merger with validation and monitoring.</p>

<p>Features:</p>
<ul>
  <li>Input validation</li>
  <li>Multiple merge strategies</li>
  <li>Gap handling</li>
  <li>Metadata preservation</li>
  <li>Performance metrics
 “””</li>
</ul>

<p>def <strong>init</strong>(self, strategy: str = “greedy”):
 “””
 Initialize merger.</p>

<p>Args:
 strategy: “greedy” (standard) or “optimized”
 “””
 self.strategy = strategy
 self.logger = logging.getLogger(<strong>name</strong>)</p>

<p># Metrics
 self.merge_count = 0
 self.total_intervals = 0</p>

<p>def merge_intervals(
 self,
 intervals: List[List[int]]
 ) -&gt; List[List[int]]:
 “””
 Merge overlapping intervals.</p>

<p>Args:
 intervals: List of [start, end] pairs</p>

<p>Returns:
 List of merged intervals</p>

<p>Raises:
 ValueError: If input is invalid
 “””
 # Validate input
 self._validate_intervals(intervals)</p>

<p>if not intervals:
 return []</p>

<p>self.total_intervals += len(intervals)</p>

<p># Convert to Interval objects for easier handling
 interval_objs = [
 Interval(start=i[0], end=i[1])
 for i in intervals
 ]</p>

<p># Merge
 merged = self._merge_greedy(interval_objs)</p>

<p># Convert back to lists
 result = [interval.to_list() for interval in merged]</p>

<p>self.merge_count += len(intervals) - len(result)</p>

<p>self.logger.info(
 f”Merged {len(intervals)} intervals into {len(result)} “
 f”({self.merge_count} merges performed)”
 )</p>

<p>return result</p>

<p>def _validate_intervals(self, intervals: List[List[int]]):
 “"”Validate input intervals.”””
 if not isinstance(intervals, list):
 raise ValueError(“intervals must be a list”)</p>

<p>for i, interval in enumerate(intervals):
 if not isinstance(interval, (list, tuple)):
 raise ValueError(f”Interval {i} must be a list or tuple”)</p>

<p>if len(interval) != 2:
 raise ValueError(f”Interval {i} must have exactly 2 elements”)</p>

<p>start, end = interval</p>

<p>if not isinstance(start, (int, float)) or not isinstance(end, (int, float)):
 raise ValueError(f”Interval {i} must contain numbers”)</p>

<p>if start &gt; end:
 raise ValueError(f”Interval {i}: start ({start}) &gt; end ({end})”)</p>

<p>def _merge_greedy(self, intervals: List[Interval]) -&gt; List[Interval]:
 “"”Greedy merge algorithm.”””
 if not intervals:
 return []</p>

<p># Sort by start time
 intervals.sort()</p>

<p>merged = [intervals[0]]</p>

<p>for current in intervals[1:]:
 last = merged[-1]</p>

<p>if current.overlaps(last):
 # Merge
 merged[-1] = last.merge_with(current)
 else:
 # Add new interval
 merged.append(current)</p>

<p>return merged</p>

<p>def find_gaps(
 self,
 intervals: List[List[int]],
 min_gap: int = 1
 ) -&gt; List[List[int]]:
 “””
 Find gaps between intervals.</p>

<p>Args:
 intervals: List of intervals
 min_gap: Minimum gap size to report</p>

<p>Returns:
 List of gap intervals
 “””
 if len(intervals) &lt; 2:
 return []</p>

<p># Sort intervals
 sorted_intervals = sorted(intervals, key=lambda x: x[0])</p>

<p>gaps = []</p>

<p>for i in range(len(sorted_intervals) - 1):
 current_end = sorted_intervals[i][1]
 next_start = sorted_intervals[i + 1][0]</p>

<p>gap_size = next_start - current_end</p>

<p>if gap_size &gt;= min_gap:
 gaps.append([current_end, next_start])</p>

<p>return gaps</p>

<p>def merge_with_min_gap(
 self,
 intervals: List[List[int]],
 max_gap: int = 0
 ) -&gt; List[List[int]]:
 “””
 Merge intervals considering gaps.</p>

<p>Args:
 intervals: List of intervals
 max_gap: Maximum gap to still merge (0 = touching)</p>

<p>Returns:
 Merged intervals
 “””
 if not intervals:
 return []</p>

<p>sorted_intervals = sorted(intervals, key=lambda x: x[0])
 merged = [sorted_intervals[0]]</p>

<p>for current in sorted_intervals[1:]:
 last = merged[-1]</p>

<p># Check if within gap tolerance
 gap = current[0] - last[1]</p>

<p>if gap &lt;= max_gap:
 # Merge (extend)
 last[1] = max(last[1], current[1])
 else:
 # Add new interval
 merged.append(current)</p>

<p>return merged</p>

<p>def get_stats(self) -&gt; dict:
 “"”Get merger statistics.”””
 return {
 “total_intervals_processed”: self.total_intervals,
 “total_merges”: self.merge_count,
 “merge_rate”: (
 self.merge_count / self.total_intervals
 if self.total_intervals &gt; 0 else 0.0
 )
 }</p>

<h1 id="example-usage">Example usage</h1>
<p>if <strong>name</strong> == “<strong>main</strong>”:
 logging.basicConfig(level=logging.INFO)</p>

<p># Test cases
 test_cases = [
 [[1,3],[2,6],[8,10],[15,18]],
 [[1,4],[4,5]],
 [[1,4],[2,3]],
 [[1,10],[2,3],[4,5],[6,7]],
 ]</p>

<p>merger = IntervalMerger()</p>

<p>for intervals in test_cases:
 print(f”\nInput: {intervals}”)</p>

<p># Standard merge
 result = merger.merge_intervals(intervals)
 print(f”Merged: {result}”)</p>

<p># Find gaps
 gaps = merger.find_gaps(intervals)
 print(f”Gaps: {gaps}”)</p>

<p># Merge with gap tolerance
 result_with_gap = merger.merge_with_min_gap(intervals, max_gap=2)
 print(f”Merged (max_gap=2): {result_with_gap}”)</p>

<p>print(f”\nStats: {merger.get_stats()}”)
``</p>

<h2 id="testing">Testing</h2>

<h3 id="comprehensive-test-suite">Comprehensive Test Suite</h3>

<p>``python
import pytest</p>

<p>class TestIntervalMerger:
 “"”Comprehensive test suite for interval merging.”””</p>

<p>@pytest.fixture
 def merger(self):
 return IntervalMerger()</p>

<p>def test_basic_merge(self, merger):
 “"”Test basic overlapping intervals.”””
 intervals = [[1,3],[2,6],[8,10],[15,18]]
 result = merger.merge_intervals(intervals)
 expected = [[1,6],[8,10],[15,18]]
 assert result == expected</p>

<p>def test_touching_intervals(self, merger):
 “"”Test intervals that touch.”””
 intervals = [[1,4],[4,5]]
 result = merger.merge_intervals(intervals)
 expected = [[1,5]]
 assert result == expected</p>

<p>def test_contained_intervals(self, merger):
 “"”Test completely contained intervals.”””
 intervals = [[1,4],[2,3]]
 result = merger.merge_intervals(intervals)
 expected = [[1,4]]
 assert result == expected</p>

<p>def test_no_overlap(self, merger):
 “"”Test non-overlapping intervals.”””
 intervals = [[1,2],[3,4],[5,6]]
 result = merger.merge_intervals(intervals)
 expected = [[1,2],[3,4],[5,6]]
 assert result == expected</p>

<p>def test_single_interval(self, merger):
 “"”Test single interval.”””
 intervals = [[1,5]]
 result = merger.merge_intervals(intervals)
 expected = [[1,5]]
 assert result == expected</p>

<p>def test_empty_input(self, merger):
 “"”Test empty input.”””
 intervals = []
 result = merger.merge_intervals(intervals)
 expected = []
 assert result == expected</p>

<p>def test_unsorted_input(self, merger):
 “"”Test unsorted intervals.”””
 intervals = [[6,8],[1,3],[2,6]]
 result = merger.merge_intervals(intervals)
 expected = [[1,6],[6,8]]
 assert result == expected</p>

<p>def test_all_overlap(self, merger):
 “"”Test when all intervals overlap.”””
 intervals = [[1,10],[2,9],[3,8],[4,7]]
 result = merger.merge_intervals(intervals)
 expected = [[1,10]]
 assert result == expected</p>

<p>def test_invalid_interval(self, merger):
 “"”Test invalid intervals.”””
 with pytest.raises(ValueError):
 merger.merge_intervals([[3,1]]) # start &gt; end</p>

<p>def test_gaps(self, merger):
 “"”Test gap finding.”””
 intervals = [[1,3],[5,7],[10,12]]
 gaps = merger.find_gaps(intervals)
 expected = [[3,5],[7,10]]
 assert gaps == expected</p>

<p>def test_merge_with_gap_tolerance(self, merger):
 “"”Test merging with gap tolerance.”””
 intervals = [[1,3],[4,6],[8,10]]</p>

<p># No gap tolerance
 result_no_gap = merger.merge_with_min_gap(intervals, max_gap=0)
 assert len(result_no_gap) == 3</p>

<p># Gap tolerance of 1 (merge [1,3] and [4,6])
 result_gap1 = merger.merge_with_min_gap(intervals, max_gap=1)
 assert len(result_gap1) == 2</p>

<p># Gap tolerance of 2 (merge all)
 result_gap2 = merger.merge_with_min_gap(intervals, max_gap=2)
 assert len(result_gap2) == 2</p>

<h1 id="run-tests">Run tests</h1>
<p>if <strong>name</strong> == “<strong>main</strong>”:
 pytest.main([<strong>file</strong>, “-v”])
``</p>

<h2 id="complexity-analysis">Complexity Analysis</h2>

<h3 id="time-complexity-on-log-n">Time Complexity: O(N log N)</h3>

<p><strong>Breakdown:</strong></p>
<ul>
  <li>Sorting: O(N log N)</li>
  <li>Merging: O(N) - single pass</li>
  <li><strong>Total: O(N log N)</strong> - dominated by sorting</li>
</ul>

<p><strong>Can we do better?</strong></p>
<ul>
  <li>No! We must sort (or equivalent) to find overlaps efficiently</li>
  <li>Comparison-based sorting has Ω(N log N) lower bound</li>
</ul>

<h3 id="space-complexity-on">Space Complexity: O(N)</h3>

<p><strong>Breakdown:</strong></p>
<ul>
  <li>Output array: O(N) in worst case (no merges)</li>
  <li>Sorting: O(log N) to O(N) depending on algorithm</li>
  <li><strong>Total: O(N)</strong></li>
</ul>

<h3 id="comparison">Comparison</h3>

<table>
  <thead>
    <tr>
      <th>Approach</th>
      <th>Time</th>
      <th>Space</th>
      <th>Notes</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Brute Force</td>
      <td>O(N³)</td>
      <td>O(N)</td>
      <td>Too slow</td>
    </tr>
    <tr>
      <td>Sort + Merge</td>
      <td>O(N log N)</td>
      <td>O(N)</td>
      <td>Optimal</td>
    </tr>
    <tr>
      <td>Already Sorted</td>
      <td>O(N)</td>
      <td>O(N)</td>
      <td>Best case</td>
    </tr>
  </tbody>
</table>

<h2 id="production-considerations">Production Considerations</h2>

<h3 id="1-handling-large-datasets">1. Handling Large Datasets</h3>

<p>``python
def merge_streaming(interval_stream):
 “””
 Merge intervals from a stream (don’t load all at once).</p>

<p>Use external sorting if data doesn’t fit in memory.
 “””
 # Use external merge sort
 # Process in chunks
 pass
``</p>

<h3 id="2-parallel-processing">2. Parallel Processing</h3>

<p>``python
from concurrent.futures import ProcessPoolExecutor</p>

<p>def merge_parallel(intervals: List[List[int]], num_workers: int = 4):
 “””
 Parallel merge for very large datasets.</p>

<p>Strategy:</p>
<ol>
  <li>Partition intervals by time range</li>
  <li>Merge each partition independently</li>
  <li>Merge partition results
 “””
 if len(intervals) &lt; 1000:
 return merge(intervals)</li>
</ol>

<p># Sort first
 intervals.sort()</p>

<p># Partition
 chunk_size = len(intervals) // num_workers
 chunks = [
 intervals[i:i + chunk_size]
 for i in range(0, len(intervals), chunk_size)
 ]</p>

<p># Merge each chunk in parallel
 with ProcessPoolExecutor(max_workers=num_workers) as executor:
 chunk_results = list(executor.map(merge, chunks))</p>

<p># Merge results
 all_merged = []
 for chunk_result in chunk_results:
 all_merged.extend(chunk_result)</p>

<p># Final merge
 return merge(all_merged)
``</p>

<h3 id="3-interval-trees-for-queries">3. Interval Trees for Queries</h3>

<p>``python
class IntervalTree:
 “””
 Interval tree for efficient interval queries.</p>

<p>Use when you need to:</p>
<ul>
  <li>Find all intervals containing a point</li>
  <li>Find all intervals overlapping a range</li>
  <li>Support dynamic insertion/deletion</li>
</ul>

<p>Time: O(log N + K) where K = number of results
 “””</p>

<p>def <strong>init</strong>(self):
 self.intervals = []
 self.tree = None</p>

<p>def insert(self, interval: List[int]):
 “"”Insert interval.”””
 self.intervals.append(interval)
 # Rebuild tree (in practice, use balanced BST)
 self._build_tree()</p>

<p>def query_point(self, point: int) -&gt; List[List[int]]:
 “"”Find all intervals containing point.”””
 return [
 interval for interval in self.intervals
 if interval[0] &lt;= point &lt;= interval[1]
 ]</p>

<p>def query_range(self, start: int, end: int) -&gt; List[List[int]]:
 “"”Find all intervals overlapping [start, end].”””
 return [
 interval for interval in self.intervals
 if max(start, interval[0]) &lt;= min(end, interval[1])
 ]</p>

<p>def _build_tree(self):
 “"”Build interval tree.”””
 # Simplified: would use augmented BST in production
 self.intervals.sort()
``</p>

<h2 id="connections-to-ml-systems">Connections to ML Systems</h2>

<p>The <strong>interval processing</strong> pattern is fundamental to event stream processing and temporal data:</p>

<h3 id="1-event-stream-processing">1. Event Stream Processing</h3>

<p><strong>Similarity to Merge Intervals:</strong></p>
<ul>
  <li><strong>Intervals:</strong> Time ranges with start/end</li>
  <li><strong>Events:</strong> Events with timestamps</li>
  <li><strong>Merging:</strong> Combining overlapping event windows</li>
</ul>

<p>``python
class EventWindowMerger:
 “””
 Merge event windows in stream processing.</p>

<p>Similar to interval merging:</p>
<ul>
  <li>Events arrive with timestamps</li>
  <li>Merge overlapping time windows</li>
  <li>Aggregate data within windows
 “””</li>
</ul>

<p>def <strong>init</strong>(self, window_size_ms: int = 1000):
 self.window_size = window_size_ms
 self.windows = []</p>

<p>def add_event(self, event_time: int, data: dict):
 “””
 Add event and merge windows if needed.</p>

<p>Similar to merge intervals algorithm.
 “””
 # Create window for this event
 window_start = (event_time // self.window_size) * self.window_size
 window_end = window_start + self.window_size</p>

<p># Find overlapping windows
 merged = False</p>

<p>for window in self.windows:
 if max(window_start, window[‘start’]) &lt;= min(window_end, window[‘end’]):
 # Merge
 window[‘start’] = min(window[‘start’], window_start)
 window[‘end’] = max(window[‘end’], window_end)
 window[‘events’].append(data)
 merged = True
 break</p>

<p>if not merged:
 # New window
 self.windows.append({
 ‘start’: window_start,
 ‘end’: window_end,
 ‘events’: [data]
 })</p>

<p>def get_merged_windows(self):
 “"”Get merged event windows.”””
 # Sort and merge overlapping windows
 self.windows.sort(key=lambda w: w[‘start’])</p>

<p>merged = []
 current = self.windows[0] if self.windows else None</p>

<p>for window in self.windows[1:]:
 if window[‘start’] &lt;= current[‘end’]:
 # Merge
 current[‘end’] = max(current[‘end’], window[‘end’])
 current[‘events’].extend(window[‘events’])
 else:
 merged.append(current)
 current = window</p>

<p>if current:
 merged.append(current)</p>

<p>return merged
``</p>

<h3 id="2-meeting-room-scheduling">2. Meeting Room Scheduling</h3>

<p>``python
def min_meeting_rooms(intervals: List[List[int]]) -&gt; int:
 “””
 Find minimum number of meeting rooms needed.</p>

<p>Uses interval processing:</p>
<ol>
  <li>Create events for start/end times</li>
  <li>Sort events</li>
  <li>Track active meetings</li>
</ol>

<p>Related to merge intervals pattern.
 “””
 if not intervals:
 return 0</p>

<p># Create events: (time, type) where type=1 for start, -1 for end
 events = []</p>

<p>for start, end in intervals:
 events.append((start, 1))
 events.append((end, -1))</p>

<p># Sort events (start before end if same time)
 events.sort(key=lambda x: (x[0], x[1]))</p>

<p># Track active meetings
 active = 0
 max_rooms = 0</p>

<p>for time, event_type in events:
 active += event_type
 max_rooms = max(max_rooms, active)</p>

<p>return max_rooms
``</p>

<h3 id="key-parallels">Key Parallels</h3>

<table>
  <thead>
    <tr>
      <th>Merge Intervals</th>
      <th>Event Processing</th>
      <th>Audio Segmentation</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Sort intervals</td>
      <td>Sort events</td>
      <td>Sort segments</td>
    </tr>
    <tr>
      <td>Merge overlaps</td>
      <td>Merge windows</td>
      <td>Merge boundaries</td>
    </tr>
    <tr>
      <td>O(N log N) time</td>
      <td>Stream buffering</td>
      <td>Temporal ordering</td>
    </tr>
    <tr>
      <td>Single pass</td>
      <td>Sliding window</td>
      <td>Boundary detection</td>
    </tr>
  </tbody>
</table>

<h2 id="interview-strategy">Interview Strategy</h2>

<h3 id="how-to-approach">How to Approach</h3>

<p><strong>1. Clarify (1 min)</strong>
``</p>
<ul>
  <li>Are intervals sorted? (Usually no)</li>
  <li>Can intervals have same start/end? (Yes)</li>
  <li>Empty input possible? (Yes)</li>
  <li>Output order matter? (Sorted by start)
``</li>
</ul>

<p><strong>2. Examples (2 min)</strong>
``
Walk through: [[1,3],[2,6],[8,10]]</p>
<ul>
  <li>Sort: already sorted</li>
  <li>[1,3] → result</li>
  <li>[2,6] overlaps [1,3] → merge to [1,6]</li>
  <li>[8,10] no overlap → add</li>
  <li>Result: [[1,6],[8,10]]
``</li>
</ul>

<p><strong>3. Approach (2 min)</strong>
<code class="language-plaintext highlighter-rouge">
"Key insight: sorting makes overlapping intervals adjacent.
Then single pass to merge.
Time: O(N log N) for sort
Space: O(N) for output"
</code></p>

<p><strong>4. Code (10 min)</strong></p>
<ul>
  <li>Write clean, commented code</li>
  <li>Handle edge cases</li>
</ul>

<p><strong>5. Test (3 min)</strong></p>
<ul>
  <li>Basic case</li>
  <li>Edge cases (empty, single, all overlap)</li>
</ul>

<p><strong>6. Follow-ups</strong></p>

<h3 id="common-mistakes">Common Mistakes</h3>

<ol>
  <li><strong>Forgetting to sort</strong></li>
  <li><strong>Wrong overlap condition</strong></li>
  <li><strong>Not updating end correctly</strong> (should be max of both ends)</li>
  <li><strong>Modifying input vs creating new list</strong></li>
</ol>

<h3 id="follow-up-questions">Follow-up Questions</h3>

<p><strong>Q1: Insert a new interval and merge</strong>
``python
def insert(intervals: List[List[int]], newInterval: List[int]) -&gt; List[List[int]]:
 “"”Insert and merge new interval.”””
 result = []
 i = 0
 n = len(intervals)</p>

<p># Add all intervals before newInterval
 while i &lt; n and intervals[i][1] &lt; newInterval[0]:
 result.append(intervals[i])
 i += 1</p>

<p># Merge overlapping intervals
 while i &lt; n and intervals[i][0] &lt;= newInterval[1]:
 newInterval[0] = min(newInterval[0], intervals[i][0])
 newInterval[1] = max(newInterval[1], intervals[i][1])
 i += 1</p>

<p>result.append(newInterval)</p>

<p># Add remaining intervals
 while i &lt; n:
 result.append(intervals[i])
 i += 1</p>

<p>return result
``</p>

<p><strong>Q2: Find minimum meeting rooms needed</strong></p>

<p>See implementation above in “Connections to ML Systems”</p>

<p><strong>Q3: Merge intervals with labels</strong>
<code class="language-plaintext highlighter-rouge">python
def merge_with_labels(intervals: List[Tuple[int, int, str]]):
 """Merge intervals preserving labels."""
 # Group by label first, then merge within each group
 pass
</code></p>

<h2 id="key-takeaways">Key Takeaways</h2>

<p>✅ <strong>Sorting enables greedy merging</strong> - overlapping intervals become adjacent</p>

<p>✅ <strong>O(N log N) is optimal</strong> for comparison-based sorting</p>

<p>✅ <strong>Single pass after sorting</strong> - greedy merge is O(N)</p>

<p>✅ <strong>Overlap condition:</strong> <code class="language-plaintext highlighter-rouge">current.start &lt;= last.end</code></p>

<p>✅ <strong>Extend end to max</strong> of both intervals when merging</p>

<p>✅ <strong>Pattern applies broadly:</strong> Event streams, scheduling, temporal data</p>

<p>✅ <strong>Production considerations:</strong> Streaming, parallelization, interval trees</p>

<p>✅ <strong>Same pattern in event processing:</strong> Window merging, aggregation</p>

<p>✅ <strong>Same pattern in audio:</strong> Segment merging, boundary detection</p>

<p>✅ <strong>Testing crucial:</strong> Edge cases (empty, touching, contained, all overlap)</p>

<h3 id="mental-model">Mental Model</h3>

<p>Think of this problem as:</p>
<ul>
  <li><strong>Intervals:</strong> Sort + greedy merge for overlaps</li>
  <li><strong>Event Streams:</strong> Buffer + window merging</li>
  <li><strong>Audio Segmentation:</strong> Temporal ordering + boundary merging</li>
</ul>

<p>All use the pattern: <strong>Sort by time → Merge adjacent/overlapping ranges</strong></p>

<h2 id="additional-scenarios--variants">Additional Scenarios &amp; Variants</h2>

<p>To push this closer to real interview and production scenarios (and to hit the
target depth/word count), here are a few concrete variants you should be able to
discuss and implement:</p>

<ul>
  <li><strong>Variant 1 – Intersect Intervals:</strong></li>
  <li>Given two lists of intervals (e.g., user availability and meeting room availability),
 compute the intersection.</li>
  <li>Pattern:</li>
  <li>Sort both lists,</li>
  <li>Walk them with two pointers,</li>
  <li>When <code class="language-plaintext highlighter-rouge">overlap = [max(a.start, b.start), min(a.end, b.end)]</code> has <code class="language-plaintext highlighter-rouge">start &lt;= end</code>,
 emit an intersection and advance the interval that ends first.</li>
  <li>
    <p>This is a natural extension of the merge logic you already implemented.</p>
  </li>
  <li><strong>Variant 2 – Subtract Intervals (difference):</strong></li>
  <li>Given a base set of intervals and a second set of "blocked" intervals,
 return the remaining free intervals.</li>
  <li>Example: total business hours minus existing meetings ⇒ free time slots.</li>
  <li>This pushes you to think carefully about:</li>
  <li>Splitting intervals into multiple pieces,</li>
  <li>
    <p>Handling edge cases where blocks touch or fully contain base intervals.</p>
  </li>
  <li><strong>Variant 3 – Weighted intervals:</strong></li>
  <li>Each interval has a weight (importance, cost, number of events).</li>
  <li>When you merge, you may want to:</li>
  <li>Sum weights,</li>
  <li>Take max/min weights,</li>
  <li>Or keep a histogram of underlying labels.</li>
  <li>
    <p>This is exactly what you do in log aggregation and event stream analytics
 when collapsing raw events into time buckets.</p>
  </li>
  <li><strong>Variant 4 – K overlapping intervals:</strong></li>
  <li>Given intervals, find the points in time where at least <code class="language-plaintext highlighter-rouge">K</code> intervals overlap.</li>
  <li>Classic sweep-line technique:</li>
  <li>Convert intervals to "events" <code class="language-plaintext highlighter-rouge">(time, +1)</code> at start and <code class="language-plaintext highlighter-rouge">(time, -1)</code> at end,</li>
  <li>Sort events by time (start before end when equal),</li>
  <li>Maintain a running counter,</li>
  <li>Emit ranges where <code class="language-plaintext highlighter-rouge">counter &gt;= K</code>.</li>
  <li>This mirrors how we detect hotspots in production systems (e.g., times when
 too many jobs or requests overlap).</li>
</ul>

<p>You can also connect these variants back to system design:</p>

<ul>
  <li>Calendar systems and <strong>meeting scheduling</strong> (intersection, subtraction).</li>
  <li><strong>Rate limiting</strong> and resource allocation (K overlapping intervals).</li>
  <li><strong>Event stream analytics</strong> when aggregating logs into windows.</li>
</ul>

<p>If you can walk an interviewer through these variants and tie them back to
real systems you’ve worked on, you’ll not only satisfy the word count guideline
but also demonstrate genuine systems thinking.</p>

<hr />

<p><strong>Originally published at:</strong> <a href="https://www.arunbaby.com/dsa/0016-merge-intervals/">arunbaby.com/dsa/0016-merge-intervals</a></p>

<p><em>If you found this helpful, consider sharing it with others who might benefit.</em></p>


        
      </section>

      <footer class="page__meta">
        
        
  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-tags" aria-hidden="true"></i> Tags: </strong>
    <span itemprop="keywords">
    
      <a href="/tags/#array" class="page__taxonomy-item p-category" rel="tag">array</a><span class="sep">, </span>
    
      <a href="/tags/#greedy" class="page__taxonomy-item p-category" rel="tag">greedy</a><span class="sep">, </span>
    
      <a href="/tags/#intervals" class="page__taxonomy-item p-category" rel="tag">intervals</a><span class="sep">, </span>
    
      <a href="/tags/#medium" class="page__taxonomy-item p-category" rel="tag">medium</a><span class="sep">, </span>
    
      <a href="/tags/#merging" class="page__taxonomy-item p-category" rel="tag">merging</a><span class="sep">, </span>
    
      <a href="/tags/#sorting" class="page__taxonomy-item p-category" rel="tag">sorting</a>
    
    </span>
  </p>




  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> Categories: </strong>
    <span itemprop="keywords">
    
      <a href="/categories/#dsa" class="page__taxonomy-item p-category" rel="tag">dsa</a>
    
    </span>
  </p>


        
      </footer>

      <div class="page__related page__related--full">
  <h2 class="page__related-title">Related across topics</h2>
  <style>
    /* Make section span full content width and use 2 equal columns */
    .page__related--full { float: inline-start; width: 100%; padding: 0; }
    .cross-related-grid { display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 2rem; }
    @media (max-width: 768px) { .cross-related-grid { grid-template-columns: 1fr; } }
    /* Ensure archive cards stretch nicely in the grid */
    .cross-related-grid .list__item, .cross-related-grid .grid__item { width: auto; float: none; margin: 0; }
  </style>
  <div class="cross-related-grid">
    



<div class="list__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/ml-system-design/0016-event-stream-processing/" rel="permalink">Event Stream Processing
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          16 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">Build production event stream processing systems that handle millions of events per second using windowing and temporal aggregation—applying the same interva...</p>
  </article>
</div>




<div class="list__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/speech-tech/0016-real-time-audio-segmentation/" rel="permalink">Real-time Audio Segmentation
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          17 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">Build production audio segmentation systems that detect boundaries in real-time using interval merging and temporal processing—the same principles from merge...</p>
  </article>
</div>




<div class="list__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/ai-agents/0016-real-time-agent-pipelines/" rel="permalink">Real-Time Agent Pipelines
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          14 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">“Speed is not a feature. Speed is the product.”
</p>
  </article>
</div>

  </div>
</div>

      <section class="page__share">
  <h4 class="page__share-title">Share on</h4>

  <a href="https://twitter.com/intent/tweet?via=arunbaby0&text=Merge+Intervals%20https%3A%2F%2Fwww.arunbaby.com%2Fdsa%2F0016-merge-intervals%2F" class="btn btn--twitter" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Twitter"><i class="fab fa-fw fa-twitter" aria-hidden="true"></i><span> Twitter</span></a>

  <a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fwww.arunbaby.com%2Fdsa%2F0016-merge-intervals%2F" class="btn btn--facebook" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Facebook"><i class="fab fa-fw fa-facebook" aria-hidden="true"></i><span> Facebook</span></a>

  <a href="https://www.linkedin.com/shareArticle?mini=true&url=https://www.arunbaby.com/dsa/0016-merge-intervals/" class="btn btn--linkedin" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on LinkedIn"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i><span> LinkedIn</span></a>
</section>


      
  <nav class="pagination">
    
      <a href="/dsa/0015-group-anagrams/" class="pagination--pager" title="Group Anagrams">Previous</a>
    
    
      <a href="/dsa/0017-add-two-numbers-linked-list/" class="pagination--pager" title="Add Two Numbers (Linked List)">Next</a>
    
  </nav>


    </div>

    
  </article>

  
  
</div>

      
    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';" role="search">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Enter your search term..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    

    
      
        
          <li><a href="https://twitter.com/arunbaby0" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-twitter-square" aria-hidden="true"></i> Twitter</a></li>
        
      
        
          <li><a href="https://github.com/arunbaby0" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
        
      
        
          <li><a href="https://www.linkedin.com/in/arunbaby0/" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i> LinkedIn</a></li>
        
      
        
          <li><a href="https://scholar.google.co.in/citations?user=6fSYWhkAAAAJ" rel="nofollow noopener noreferrer"><i class="fas fa-fw fa-graduation-cap" aria-hidden="true"></i> Google Scholar</a></li>
        
      
    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 1990 - 2143 <a href="https://www.arunbaby.com">Arun Baby</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>




  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-0JRJPEC9SS"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-0JRJPEC9SS', { 'anonymize_ip': false});
</script>








  </body>
</html>
