<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.26.2 by Michael Rose
  Copyright 2013-2024 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->

<html lang="en-US" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Binary Tree Level Order Traversal - Arun Baby</title>
<meta name="description" content="How do you print a corporate hierarchy level by level? CEO first, then VPs, then Managers…">


  <meta name="author" content="Arun Baby">
  
  <meta property="article:author" content="Arun Baby">
  


<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="Arun Baby">
<meta property="og:title" content="Binary Tree Level Order Traversal">
<meta property="og:url" content="https://www.arunbaby.com/dsa/0026-level-order-traversal/">


  <meta property="og:description" content="How do you print a corporate hierarchy level by level? CEO first, then VPs, then Managers…">



  <meta property="og:image" content="https://www.arunbaby.com/assets/images/profile-photo.png">



  <meta name="twitter:site" content="@arunbaby0">
  <meta name="twitter:title" content="Binary Tree Level Order Traversal">
  <meta name="twitter:description" content="How do you print a corporate hierarchy level by level? CEO first, then VPs, then Managers…">
  <meta name="twitter:url" content="https://www.arunbaby.com/dsa/0026-level-order-traversal/">

  
    <meta name="twitter:card" content="summary">
    
      <meta name="twitter:image" content="https://www.arunbaby.com/assets/images/profile-photo.png">
    
  

  



  <meta property="article:published_time" content="2025-12-31T10:07:50+05:30">





  

  


<link rel="canonical" href="https://www.arunbaby.com/dsa/0026-level-order-traversal/">












<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Arun Baby Feed">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
  
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css"></noscript>



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--single" dir="ltr">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
           
          <span class="site-subtitle">Arun Baby</span>
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a
                href="/about/"
                
                
              >About</a>
            </li><li class="masthead__menu-item">
              <a
                href="/dsa/"
                
                
              >DSA</a>
            </li><li class="masthead__menu-item">
              <a
                href="/ml-system-design/"
                
                
              >ML Systems</a>
            </li><li class="masthead__menu-item">
              <a
                href="/speech-tech/"
                
                
              >Speech Tech</a>
            </li><li class="masthead__menu-item">
              <a
                href="/ai-agents/"
                
                
              >AI Agents</a>
            </li><li class="masthead__menu-item">
              <a
                href="/publications/"
                
                
              >Publications</a>
            </li><li class="masthead__menu-item">
              <a
                href="/statuses/"
                
                
              >Statuses</a>
            </li><li class="masthead__menu-item">
              <a
                href="/contact/"
                
                
              >Contact</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <i class="fas fa-search"></i>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      





<div id="main" role="main" class="no-author-sidebar">
  
  <div class="sidebar sticky">
  
  
  </div>



  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="Binary Tree Level Order Traversal">
    <meta itemprop="description" content="How do you print a corporate hierarchy level by level? CEO first, then VPs, then Managers…">
    <meta itemprop="datePublished" content="2025-12-31T10:07:50+05:30">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">
            <a href="https://www.arunbaby.com/dsa/0026-level-order-traversal/" itemprop="url">Binary Tree Level Order Traversal
</a>
          </h1>
          

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          20 minute read
        
      </span>
    
  </p>


        </header>
      

      <section class="page__content" itemprop="text">
        
          <aside class="sidebar__right sticky">
            <nav class="toc">
              <header><h4 class="nav__title"><i class="fas fa-file-alt"></i> On this page</h4></header>
              <ul class="toc__menu"><li><a href="#problem">Problem</a></li><li><a href="#intuition">Intuition</a></li><li><a href="#approach-1-iterative-bfs-using-queue">Approach 1: Iterative BFS using Queue</a></li><li><a href="#approach-2-recursive-dfs-preorder">Approach 2: Recursive DFS (Preorder)</a></li><li><a href="#variant-zigzag-level-order-traversal">Variant: Zigzag Level Order Traversal</a></li><li><a href="#variant-2-n-ary-tree-level-order-traversal">Variant 2: N-ary Tree Level Order Traversal</a></li><li><a href="#variant-3-binary-tree-level-order-traversal-ii-bottom-up">Variant 3: Binary Tree Level Order Traversal II (Bottom-Up)</a></li><li><a href="#variant-4a-binary-search-tree-bst-is-the-backbone-of-efficient-search-it-guarantees-olog-n-lookup-but-this-guarantee-only-holds-if-the-tree-is-valid-if-a-single-node-is-out-of-place-the-search-algorithm-breakst-node-of-each-level">Variant 4:A Binary Search Tree (BST) is the backbone of efficient search. It guarantees (O(\log N)) lookup. But this guarantee only holds if the tree is valid. If a single node is out of place, the search algorithm breaks.t node** of each level.</a></li><li><a href="#variant-5-cousins-in-binary-tree">Variant 5: Cousins in Binary Tree</a></li><li><a href="#advanced-variant-6-maximum-width-of-binary-tree">Advanced Variant 6: Maximum Width of Binary Tree</a></li><li><a href="#system-design-distributed-graph-traversal-pregel">System Design: Distributed Graph Traversal (Pregel)</a></li><li><a href="#deep-dive-vertical-order-traversal">Deep Dive: Vertical Order Traversal</a></li><li><a href="#appendix-b-boundary-traversal">Appendix B: Boundary Traversal</a></li><li><a href="#advanced-variant-7-diagonal-traversal">Advanced Variant 7: Diagonal Traversal</a></li><li><a href="#advanced-variant-8-serialize-and-deserialize-binary-tree">Advanced Variant 8: Serialize and Deserialize Binary Tree</a></li><li><a href="#deep-dive-tree-bfs-vs-graph-bfs">Deep Dive: Tree BFS vs. Graph BFS</a></li><li><a href="#appendix-c-the-rotting-oranges-pattern">Appendix C: The “Rotting Oranges” Pattern</a></li><li><a href="#appendix-d-interview-questions">Appendix D: Interview Questions</a></li><li><a href="#advanced-variant-9-populating-next-right-pointers-in-each-node">Advanced Variant 9: Populating Next Right Pointers in Each Node</a></li><li><a href="#advanced-variant-10-average-of-levels-in-binary-tree">Advanced Variant 10: Average of Levels in Binary Tree</a></li><li><a href="#advanced-variant-11-find-bottom-left-tree-value">Advanced Variant 11: Find Bottom Left Tree Value</a></li><li><a href="#deep-dive-queue-implementation-array-vs-linked-list">Deep Dive: Queue Implementation (Array vs. Linked List)</a></li><li><a href="#system-design-distributed-queue-kafka-vs-sqs">System Design: Distributed Queue (Kafka vs. SQS)</a></li><li><a href="#advanced-variant-12-deepest-leaves-sum">Advanced Variant 12: Deepest Leaves Sum</a></li><li><a href="#appendix-e-the-word-ladder-pattern">Appendix E: The “Word Ladder” Pattern</a></li><li><a href="#deep-dive-python-deque-internals">Deep Dive: Python deque Internals</a></li><li><a href="#advanced-variant-13-check-completeness-of-a-binary-tree">Advanced Variant 13: Check Completeness of a Binary Tree</a></li><li><a href="#advanced-variant-14-maximum-level-sum-of-a-binary-tree">Advanced Variant 14: Maximum Level Sum of a Binary Tree</a></li><li><a href="#advanced-variant-15-even-odd-tree">Advanced Variant 15: Even Odd Tree</a></li><li><a href="#system-design-rate-limiter-token-bucket">System Design: Rate Limiter (Token Bucket)</a></li><li><a href="#advanced-variant-16-pseudo-palindromic-paths">Advanced Variant 16: Pseudo-Palindromic Paths</a></li><li><a href="#conclusion">Conclusion</a></li></ul>
            </nav>
          </aside>
        
        <p><strong>How do you print a corporate hierarchy level by level? CEO first, then VPs, then Managers…</strong></p>

<h2 id="problem">Problem</h2>

<p>Given the <code class="language-plaintext highlighter-rouge">root</code> of a binary tree, return the <em>level order traversal</em> of its nodes’ values. (i.e., from left to right, level by level).</p>

<p><strong>Example 1:</strong>
<code class="language-plaintext highlighter-rouge">
 3
 / \
 9 20
 / \
 15 7
</code>
<strong>Input:</strong> <code class="language-plaintext highlighter-rouge">root = [3,9,20,null,null,15,7]</code>
<strong>Output:</strong> <code class="language-plaintext highlighter-rouge">[[3],[9,20],[15,7]]</code></p>

<p><strong>Example 2:</strong>
<strong>Input:</strong> <code class="language-plaintext highlighter-rouge">root = [1]</code>
<strong>Output:</strong> <code class="language-plaintext highlighter-rouge">[[1]]</code></p>

<h2 id="intuition">Intuition</h2>

<p>Depth First Search (DFS) dives deep. It goes <code class="language-plaintext highlighter-rouge">Root -&gt; Left -&gt; Left...</code> until it hits a leaf.
Breadth First Search (BFS) explores wide. It visits all neighbors at the current depth before moving deeper.</p>

<p>For a tree, BFS naturally produces a Level Order Traversal.
The key data structure for BFS is the <strong>Queue</strong> (FIFO - First In, First Out).</p>
<ul>
  <li>We enter the queue at the back.</li>
  <li>We leave the queue from the front.</li>
  <li>This ensures that nodes at depth <code class="language-plaintext highlighter-rouge">d</code> are processed before nodes at depth <code class="language-plaintext highlighter-rouge">d+1</code>.</li>
</ul>

<h2 id="approach-1-iterative-bfs-using-queue">Approach 1: Iterative BFS using Queue</h2>

<p>We use a <code class="language-plaintext highlighter-rouge">deque</code> (double-ended queue) in Python for efficient <code class="language-plaintext highlighter-rouge">popleft()</code>.</p>

<p>``python
from collections import deque</p>

<p>class TreeNode:
 def <strong>init</strong>(self, val=0, left=None, right=None):
 self.val = val
 self.left = left
 self.right = right</p>

<p>class Solution:
 def levelOrder(self, root: TreeNode) -&gt; List[List[int]]:
 if not root:
 return []</p>

<p>result = []
 queue = deque([root])</p>

<p>while queue:
 level_size = len(queue)
 current_level = []</p>

<p>for _ in range(level_size):
 node = queue.popleft()
 current_level.append(node.val)</p>

<p>if node.left:
 queue.append(node.left)
 if node.right:
 queue.append(node.right)</p>

<p>result.append(current_level)</p>

<p>return result
``</p>

<p><strong>Complexity Analysis:</strong></p>
<ul>
  <li><strong>Time:</strong> (O(N)). We visit every node once.</li>
  <li><strong>Space:</strong> (O(N)) (or (O(W)) where W is max width). In a perfect binary tree, the last level has (N/2) nodes.</li>
</ul>

<h2 id="approach-2-recursive-dfs-preorder">Approach 2: Recursive DFS (Preorder)</h2>

<p>Can we do this with DFS? Yes, but it’s less intuitive.
We pass the <code class="language-plaintext highlighter-rouge">level</code> index in the recursion.
<code class="language-plaintext highlighter-rouge">dfs(node, level)</code> adds <code class="language-plaintext highlighter-rouge">node.val</code> to <code class="language-plaintext highlighter-rouge">result[level]</code>.</p>

<p>``python
class Solution:
 def levelOrder(self, root: TreeNode) -&gt; List[List[int]]:
 result = []</p>

<p>def dfs(node, level):
 if not node:
 return</p>

<p># Ensure the list for this level exists
 if len(result) == level:
 result.append([])</p>

<p>result[level].append(node.val)</p>

<p>dfs(node.left, level + 1)
 dfs(node.right, level + 1)</p>

<p>dfs(root, 0)
 return result
``</p>

<p><strong>Pros:</strong> Simpler code (no queue).
<strong>Cons:</strong> Uses system stack (O(H)) space. BFS uses heap space.</p>

<h2 id="variant-zigzag-level-order-traversal">Variant: Zigzag Level Order Traversal</h2>

<p><strong>Problem:</strong> Return the zigzag level order traversal.
Level 0: Left -&gt; Right
Level 1: Right -&gt; Left
Level 2: Left -&gt; Right</p>

<p><strong>Solution:</strong>
Use a standard BFS.
Keep a flag <code class="language-plaintext highlighter-rouge">left_to_right</code>.
If <code class="language-plaintext highlighter-rouge">left_to_right</code> is False, append to <code class="language-plaintext highlighter-rouge">current_level</code> in reverse (or use <code class="language-plaintext highlighter-rouge">deque.appendleft</code>).</p>

<p>``python
class Solution:
 def zigzagLevelOrder(self, root: TreeNode) -&gt; List[List[int]]:
 if not root: return []</p>

<p>res = []
 q = deque([root])
 left_to_right = True</p>

<p>while q:
 level_size = len(q)
 level_nodes = deque() # Use deque for O(1) appendleft</p>

<p>for _ in range(level_size):
 node = q.popleft()</p>

<p>if left_to_right:
 level_nodes.append(node.val)
 else:
 level_nodes.appendleft(node.val)</p>

<p>if node.left: q.append(node.left)
 if node.right: q.append(node.right)</p>

<p>res.append(list(level_nodes))
 left_to_right = not left_to_right</p>

<p>return res
``</p>

<h2 id="variant-2-n-ary-tree-level-order-traversal">Variant 2: N-ary Tree Level Order Traversal</h2>

<p><strong>Problem:</strong> Given an N-ary tree (where each node has a list of <code class="language-plaintext highlighter-rouge">children</code>), return the level order traversal.</p>

<p><strong>Intuition:</strong>
Same as Binary Tree, but instead of adding <code class="language-plaintext highlighter-rouge">left</code> and <code class="language-plaintext highlighter-rouge">right</code>, we iterate through <code class="language-plaintext highlighter-rouge">children</code>.</p>

<p>``python
class Node:
 def <strong>init</strong>(self, val=None, children=None):
 self.val = val
 self.children = children</p>

<p>class Solution:
 def levelOrder(self, root: ‘Node’) -&gt; List[List[int]]:
 if not root: return []</p>

<p>res = []
 q = deque([root])</p>

<p>while q:
 level = []
 for _ in range(len(q)):
 node = q.popleft()
 level.append(node.val)
 if node.children:
 q.extend(node.children)
 res.append(level)</p>

<p>return res
``</p>

<h2 id="variant-3-binary-tree-level-order-traversal-ii-bottom-up">Variant 3: Binary Tree Level Order Traversal II (Bottom-Up)</h2>

<p><strong>Problem:</strong> Return the traversal from leaf to root. <code class="language-plaintext highlighter-rouge">[[15,7], [9,20], [3]]</code>.</p>

<p><strong>Solution:</strong>
Standard BFS, but <code class="language-plaintext highlighter-rouge">result.insert(0, level)</code> or <code class="language-plaintext highlighter-rouge">result.reverse()</code> at the end.
<code class="language-plaintext highlighter-rouge">reverse()</code> is (O(N)) but amortized (O(1)) per level. <code class="language-plaintext highlighter-rouge">insert(0)</code> is (O(N)) per level (Total (O(N^2))). <strong>Always use reverse.</strong></p>

<h2 id="variant-4a-binary-search-tree-bst-is-the-backbone-of-efficient-search-it-guarantees-olog-n-lookup-but-this-guarantee-only-holds-if-the-tree-is-valid-if-a-single-node-is-out-of-place-the-search-algorithm-breakst-node-of-each-level">Variant 4:A Binary Search Tree (BST) is the backbone of efficient search. It guarantees (O(\log N)) lookup. But this guarantee only holds if the tree is valid. If a single node is out of place, the search algorithm breaks.t node** of each level.</h2>

<p>``python
class Solution:
 def rightSideView(self, root: TreeNode) -&gt; List[int]:
 if not root: return []</p>

<p>res = []
 q = deque([root])</p>

<p>while q:
 level_len = len(q)
 for i in range(level_len):
 node = q.popleft()
 # If it’s the last node in the current level
 if i == level_len - 1:
 res.append(node.val)</p>

<p>if node.left: q.append(node.left)
 if node.right: q.append(node.right)
 return res
``</p>

<h2 id="variant-5-cousins-in-binary-tree">Variant 5: Cousins in Binary Tree</h2>

<p><strong>Problem:</strong> Two nodes are cousins if they have the same depth but different parents.
Given <code class="language-plaintext highlighter-rouge">root</code>, <code class="language-plaintext highlighter-rouge">x</code>, and <code class="language-plaintext highlighter-rouge">y</code>, return <code class="language-plaintext highlighter-rouge">True</code> if they are cousins.</p>

<p><strong>Intuition:</strong>
BFS is perfect for tracking depth. We also need to track the parent.
We can store <code class="language-plaintext highlighter-rouge">(node, parent)</code> in the queue.</p>

<p>``python
class Solution:
 def isCousins(self, root: TreeNode, x: int, y: int) -&gt; bool:
 q = deque([(root, None)])</p>

<p>while q:
 level_size = len(q)
 found_x = False
 found_y = False
 x_parent = None
 y_parent = None</p>

<p>for _ in range(level_size):
 node, parent = q.popleft()</p>

<p>if node.val == x:
 found_x = True
 x_parent = parent
 if node.val == y:
 found_y = True
 y_parent = parent</p>

<p>if node.left: q.append((node.left, node))
 if node.right: q.append((node.right, node))</p>

<p># Check after finishing the level
 if found_x and found_y:
 return x_parent != y_parent</p>

<p># If one found but not the other, they are at different depths
 if found_x or found_y:
 return False</p>

<p>return False
``</p>

<h2 id="advanced-variant-6-maximum-width-of-binary-tree">Advanced Variant 6: Maximum Width of Binary Tree</h2>

<p><strong>Problem:</strong> The maximum width among all levels.
The width of one level is defined as the length between the end-nodes (the leftmost and rightmost non-null nodes), where the null nodes between the end-nodes are also counted into the length calculation.</p>

<p><strong>Intuition:</strong>
This is tricky because of the “null nodes are counted” part.
We can index the nodes like a Heap.</p>
<ul>
  <li>Root index: <code class="language-plaintext highlighter-rouge">1</code></li>
  <li>Left child: <code class="language-plaintext highlighter-rouge">2*i</code></li>
  <li>Right child: <code class="language-plaintext highlighter-rouge">2*i + 1</code>
Width = <code class="language-plaintext highlighter-rouge">index_right - index_left + 1</code>.</li>
</ul>

<p>``python
class Solution:
 def widthOfBinaryTree(self, root: TreeNode) -&gt; int:
 if not root: return 0</p>

<p>max_width = 0
 # Queue stores (node, index)
 q = deque([(root, 0)])</p>

<p>while q:
 level_len = len(q)
 _, level_start_index = q[0]</p>

<p>for i in range(level_len):
 node, index = q.popleft()</p>

<p>if node.left:
 q.append((node.left, 2<em>index))
 if node.right:
 q.append((node.right, 2</em>index + 1))</p>

<p># Calculate width for this level
 # Current index is the last one popped
 max_width = max(max_width, index - level_start_index + 1)</p>

<p>return max_width
``</p>

<h2 id="system-design-distributed-graph-traversal-pregel">System Design: Distributed Graph Traversal (Pregel)</h2>

<p><strong>Interviewer:</strong> “How do you run BFS on a graph with 1 Trillion nodes (Facebook Friend Graph)?”
<strong>Candidate:</strong> “You can’t fit it in RAM. You need <strong>Pregel</strong> (Google’s Bulk Synchronous Parallel model).”</p>

<p><strong>The Pregel Model:</strong></p>
<ol>
  <li><strong>Supersteps:</strong> Computation happens in rounds.</li>
  <li><strong>Vertex-Centric:</strong> Each vertex runs a function <code class="language-plaintext highlighter-rouge">Compute(messages)</code>.</li>
  <li><strong>Message Passing:</strong> Vertices send messages to neighbors (to be received in the next Superstep).</li>
</ol>

<p><strong>BFS in Pregel:</strong></p>
<ul>
  <li><strong>Superstep 0:</strong> Source vertex sets <code class="language-plaintext highlighter-rouge">min_dist = 0</code> and sends <code class="language-plaintext highlighter-rouge">dist=1</code> to neighbors.</li>
  <li><strong>Superstep 1:</strong> Neighbors receive <code class="language-plaintext highlighter-rouge">dist=1</code>. If <code class="language-plaintext highlighter-rouge">current_dist &gt; 1</code>, update <code class="language-plaintext highlighter-rouge">current_dist = 1</code> and send <code class="language-plaintext highlighter-rouge">dist=2</code> to neighbors.</li>
  <li><strong>Halt:</strong> When no nodes update their distance.</li>
</ul>

<h2 id="deep-dive-vertical-order-traversal">Deep Dive: Vertical Order Traversal</h2>

<p><strong>Problem:</strong> Print the tree in vertical columns.
If two nodes are in the same row and column, the order should be from left to right.</p>

<p><strong>Intuition:</strong>
We need coordinates <code class="language-plaintext highlighter-rouge">(row, col)</code>.</p>
<ul>
  <li>Root: <code class="language-plaintext highlighter-rouge">(0, 0)</code></li>
  <li>Left: <code class="language-plaintext highlighter-rouge">(row+1, col-1)</code></li>
  <li>Right: <code class="language-plaintext highlighter-rouge">(row+1, col+1)</code></li>
</ul>

<p>We can use BFS to traverse. We store <code class="language-plaintext highlighter-rouge">(node, col)</code> in the queue.
We need a Hash Map <code class="language-plaintext highlighter-rouge">col -&gt; list of nodes</code>.
Finally, sort the map by keys (column index).</p>

<p>``python
class Solution:
 def verticalOrder(self, root: TreeNode) -&gt; List[List[int]]:
 if not root: return []</p>

<p>column_table = defaultdict(list)
 q = deque([(root, 0)])
 min_col = 0
 max_col = 0</p>

<p>while q:
 node, col = q.popleft()
 column_table[col].append(node.val)</p>

<p>min_col = min(min_col, col)
 max_col = max(max_col, col)</p>

<p>if node.left: q.append((node.left, col - 1))
 if node.right: q.append((node.right, col + 1))</p>

<p>return [column_table[x] for x in range(min_col, max_col + 1)]
``</p>

<h2 id="appendix-b-boundary-traversal">Appendix B: Boundary Traversal</h2>

<p><strong>Problem:</strong> Print the boundary of the tree (Left Boundary + Leaves + Right Boundary).
<strong>Intuition:</strong></p>
<ol>
  <li><strong>Left Boundary:</strong> Keep going left. If no left, go right. (Exclude leaf).</li>
  <li><strong>Leaves:</strong> DFS/Preorder. Add if <code class="language-plaintext highlighter-rouge">!left</code> and <code class="language-plaintext highlighter-rouge">!right</code>.</li>
  <li><strong>Right Boundary:</strong> Keep going right. If no right, go left. (Exclude leaf). Add in reverse order.</li>
</ol>

<p>This is a classic “Hard” problem that tests modular thinking. Don’t try to do it in one pass. Break it down.</p>

<h2 id="advanced-variant-7-diagonal-traversal">Advanced Variant 7: Diagonal Traversal</h2>

<p><strong>Problem:</strong> Print the tree diagonally.
<code class="language-plaintext highlighter-rouge">
 8
 / \
 3 10
 / \ \
1 6 14
 / \ /
 4 7 13
</code>
<strong>Output:</strong> <code class="language-plaintext highlighter-rouge">[[8, 10, 14], [3, 6, 7, 13], [1, 4]]</code></p>

<p><strong>Intuition:</strong></p>
<ul>
  <li>Root is at <code class="language-plaintext highlighter-rouge">d=0</code>.</li>
  <li>Left child is at <code class="language-plaintext highlighter-rouge">d+1</code>.</li>
  <li>Right child is at <code class="language-plaintext highlighter-rouge">d</code> (same diagonal).</li>
</ul>

<p>We can use a Queue. But instead of just popping, we iterate through the <strong>right child chain</strong> and add all of them to the current diagonal list, while pushing their left children to the queue for the next diagonal.</p>

<p>``python
class Solution:
 def diagonalTraversal(self, root: TreeNode) -&gt; List[List[int]]:
 if not root: return []</p>

<p>res = []
 q = deque([root])</p>

<p>while q:
 level_size = len(q)
 curr_diagonal = []</p>

<p>for _ in range(level_size):
 node = q.popleft()</p>

<p># Process the current node and all its right children
 while node:
 curr_diagonal.append(node.val)
 if node.left:
 q.append(node.left)
 node = node.right</p>

<p>res.append(curr_diagonal)</p>

<p>return res
``</p>

<h2 id="advanced-variant-8-serialize-and-deserialize-binary-tree">Advanced Variant 8: Serialize and Deserialize Binary Tree</h2>

<p><strong>Problem:</strong> Convert a tree to a string and back.
<strong>Method:</strong> Level Order Traversal (BFS).</p>

<p><strong>Serialization:</strong>
Use a Queue. If a node is <code class="language-plaintext highlighter-rouge">None</code>, append “null”.
<code class="language-plaintext highlighter-rouge">[1, 2, 3, null, null, 4, 5]</code></p>

<p><strong>Deserialization:</strong>
Use a Queue.</p>
<ol>
  <li>Read root <code class="language-plaintext highlighter-rouge">1</code>. Push to queue.</li>
  <li>Pop <code class="language-plaintext highlighter-rouge">1</code>. Read next two values <code class="language-plaintext highlighter-rouge">2</code>, <code class="language-plaintext highlighter-rouge">3</code>. Attach as left/right. Push <code class="language-plaintext highlighter-rouge">2</code>, <code class="language-plaintext highlighter-rouge">3</code>.</li>
  <li>Pop <code class="language-plaintext highlighter-rouge">2</code>. Read <code class="language-plaintext highlighter-rouge">null</code>, <code class="language-plaintext highlighter-rouge">null</code>. Attach.</li>
  <li>Pop <code class="language-plaintext highlighter-rouge">3</code>. Read <code class="language-plaintext highlighter-rouge">4</code>, <code class="language-plaintext highlighter-rouge">5</code>. Attach. Push <code class="language-plaintext highlighter-rouge">4</code>, <code class="language-plaintext highlighter-rouge">5</code>.</li>
</ol>

<p>``python
class Codec:
 def serialize(self, root):
 if not root: return “”
 q = deque([root])
 res = []
 while q:
 node = q.popleft()
 if node:
 res.append(str(node.val))
 q.append(node.left)
 q.append(node.right)
 else:
 res.append(“null”)
 return “,”.join(res)</p>

<p>def deserialize(self, data):
 if not data: return None
 vals = data.split(“,”)
 root = TreeNode(int(vals[0]))
 q = deque([root])
 i = 1
 while q:
 node = q.popleft()</p>

<p># Left Child
 if vals[i] != “null”:
 node.left = TreeNode(int(vals[i]))
 q.append(node.left)
 i += 1</p>

<p># Right Child
 if vals[i] != “null”:
 node.right = TreeNode(int(vals[i]))
 q.append(node.right)
 i += 1
 return root
``</p>

<h2 id="deep-dive-tree-bfs-vs-graph-bfs">Deep Dive: Tree BFS vs. Graph BFS</h2>

<p><strong>Tree BFS:</strong></p>
<ul>
  <li>No cycles.</li>
  <li>No <code class="language-plaintext highlighter-rouge">visited</code> set needed.</li>
  <li>Exactly one path to each node.</li>
</ul>

<p><strong>Graph BFS:</strong></p>
<ul>
  <li>Cycles exist.</li>
  <li><strong>Must</strong> use <code class="language-plaintext highlighter-rouge">visited</code> set to avoid infinite loops.</li>
  <li>Multiple paths exist. BFS finds the shortest path (in unweighted graphs).</li>
</ul>

<p><strong>Bidirectional BFS:</strong>
To find the shortest path between <code class="language-plaintext highlighter-rouge">A</code> and <code class="language-plaintext highlighter-rouge">B</code> in a massive graph.
Run BFS from <code class="language-plaintext highlighter-rouge">A</code> forward and from <code class="language-plaintext highlighter-rouge">B</code> backward.
Meet in the middle.
<strong>Complexity:</strong> (O(b^{d/2})) instead of (O(b^d)). Huge saving!</p>

<h2 id="appendix-c-the-rotting-oranges-pattern">Appendix C: The “Rotting Oranges” Pattern</h2>

<p><strong>Problem:</strong> Given a grid where <code class="language-plaintext highlighter-rouge">2</code> is rotten orange, <code class="language-plaintext highlighter-rouge">1</code> is fresh, <code class="language-plaintext highlighter-rouge">0</code> is empty.
Every minute, a rotten orange rots its 4-directional neighbors.
Return min minutes until all fresh oranges rot.</p>

<p><strong>Intuition:</strong>
This is <strong>Multi-Source BFS</strong>.</p>
<ol>
  <li>Push <em>all</em> initially rotten oranges into the Queue at <code class="language-plaintext highlighter-rouge">t=0</code>.</li>
  <li>Run standard BFS.</li>
  <li>The number of levels is the time.</li>
</ol>

<p>This pattern appears in:</p>
<ul>
  <li>“Walls and Gates”</li>
  <li>“01 Matrix”</li>
  <li>“Map of Highest Peak”</li>
</ul>

<h2 id="appendix-d-interview-questions">Appendix D: Interview Questions</h2>

<ol>
  <li>
    <p><strong>Q:</strong> “Can you perform Level Order Traversal without a Queue?”
 <strong>A:</strong> Yes, using Recursion (DFS) and passing the level index (Approach 2). Or using two arrays (current_level, next_level).</p>
  </li>
  <li>
    <p><strong>Q:</strong> “What is the space complexity of BFS?”
 <strong>A:</strong> (O(W)) where (W) is the maximum width. In a full binary tree, the last level has (N/2) leaves, so (O(N)).</p>
  </li>
  <li>
    <p><strong>Q:</strong> “When should you use DFS vs BFS?”
 <strong>A:</strong></p>
    <ul>
      <li><strong>BFS:</strong> Shortest path, levels, closer to root.</li>
      <li><strong>DFS:</strong> Exhaustive search, backtracking, path finding, closer to leaves.</li>
    </ul>
  </li>
</ol>

<h2 id="advanced-variant-9-populating-next-right-pointers-in-each-node">Advanced Variant 9: Populating Next Right Pointers in Each Node</h2>

<p><strong>Problem:</strong> You are given a perfect binary tree where all leaves are on the same level, and every parent has two children. Populate each <code class="language-plaintext highlighter-rouge">next</code> pointer to point to its next right node. If there is no next right node, the next pointer should be set to <code class="language-plaintext highlighter-rouge">NULL</code>.</p>

<p><strong>Intuition:</strong>
Level Order Traversal is the obvious choice.
But can we do it with <strong>O(1) Space</strong>?
Yes. We can use the <code class="language-plaintext highlighter-rouge">next</code> pointers we already established in the <em>previous</em> level to traverse the <em>current</em> level.</p>

<p>``python
class Node:
 def <strong>init</strong>(self, val: int = 0, left: ‘Node’ = None, right: ‘Node’ = None, next: ‘Node’ = None):
 self.val = val
 self.left = left
 self.right = right
 self.next = next</p>

<p>class Solution:
 def connect(self, root: ‘Node’) -&gt; ‘Node’:
 if not root: return None</p>

<p>leftmost = root</p>

<p>while leftmost.left:
 head = leftmost
 while head:
 # Connection 1: Left -&gt; Right (Same Parent)
 head.left.next = head.right</p>

<p># Connection 2: Right -&gt; Next’s Left (Different Parent)
 if head.next:
 head.right.next = head.next.left</p>

<p>head = head.next</p>

<p>leftmost = leftmost.left</p>

<p>return root
``</p>

<h2 id="advanced-variant-10-average-of-levels-in-binary-tree">Advanced Variant 10: Average of Levels in Binary Tree</h2>

<p><strong>Problem:</strong> return the average value of the nodes on each level in the form of an array.</p>

<p><strong>Intuition:</strong>
Standard BFS. Sum the values in the level loop, divide by <code class="language-plaintext highlighter-rouge">level_size</code>.</p>

<p>``python
class Solution:
 def averageOfLevels(self, root: TreeNode) -&gt; List[float]:
 if not root: return []
 res = []
 q = deque([root])</p>

<p>while q:
 level_sum = 0
 level_count = len(q)</p>

<p>for _ in range(level_count):
 node = q.popleft()
 level_sum += node.val
 if node.left: q.append(node.left)
 if node.right: q.append(node.right)</p>

<p>res.append(level_sum / level_count)</p>

<p>return res
``</p>

<h2 id="advanced-variant-11-find-bottom-left-tree-value">Advanced Variant 11: Find Bottom Left Tree Value</h2>

<p><strong>Problem:</strong> Given the root of a binary tree, return the leftmost value in the last row of the tree.</p>

<p><strong>Intuition:</strong>
Right-to-Left BFS.
The last node visited will be the bottom-left node.</p>

<p><code class="language-plaintext highlighter-rouge">python
class Solution:
 def findBottomLeftValue(self, root: TreeNode) -&gt; int:
 q = deque([root])
 node = root
 while q:
 node = q.popleft()
 # Add Right first, then Left
 if node.right: q.append(node.right)
 if node.left: q.append(node.left)
 return node.val
</code></p>

<h2 id="deep-dive-queue-implementation-array-vs-linked-list">Deep Dive: Queue Implementation (Array vs. Linked List)</h2>

<p><strong>Array (Python List):</strong></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">pop(0)</code> is (O(N)) because we have to shift all elements. <strong>Bad.</strong></li>
  <li><code class="language-plaintext highlighter-rouge">pop()</code> is (O(1)).</li>
</ul>

<p><strong>Linked List (Python deque):</strong></p>
<ul>
  <li>Doubly Linked List.</li>
  <li><code class="language-plaintext highlighter-rouge">popleft()</code> is (O(1)). <strong>Good.</strong></li>
  <li><code class="language-plaintext highlighter-rouge">append()</code> is (O(1)).</li>
</ul>

<p><strong>Circular Buffer (Ring Buffer):</strong></p>
<ul>
  <li>Fixed size array.</li>
  <li><code class="language-plaintext highlighter-rouge">head</code> and <code class="language-plaintext highlighter-rouge">tail</code> pointers wrap around.</li>
  <li>Used in low-latency systems (Network Drivers). No dynamic allocation overhead.</li>
</ul>

<h2 id="system-design-distributed-queue-kafka-vs-sqs">System Design: Distributed Queue (Kafka vs. SQS)</h2>

<p><strong>Interviewer:</strong> “We need a queue for our Distributed BFS. Should we use Kafka or SQS?”</p>

<p><strong>Candidate:</strong></p>
<ol>
  <li><strong>SQS (Simple Queue Service):</strong>
    <ul>
      <li><strong>Pros:</strong> Infinite scaling, no management.</li>
      <li><strong>Cons:</strong> No ordering guarantee (standard), expensive at high throughput.</li>
      <li><strong>Use Case:</strong> Task Queue (Celery).</li>
    </ul>
  </li>
  <li><strong>Kafka:</strong>
    <ul>
      <li><strong>Pros:</strong> High throughput (millions/sec), replayable (log), ordered within partition.</li>
      <li><strong>Cons:</strong> Hard to manage (Zookeeper), fixed partitions.</li>
      <li><strong>Use Case:</strong> Event Streaming, Data Pipeline.</li>
    </ul>
  </li>
</ol>

<p><strong>Decision:</strong> For BFS, we usually need a <strong>Priority Queue</strong> (to prioritize high-rank pages), so neither is perfect. We might use <strong>Redis Sorted Sets</strong>.</p>

<h2 id="advanced-variant-12-deepest-leaves-sum">Advanced Variant 12: Deepest Leaves Sum</h2>

<p><strong>Problem:</strong> Return the sum of values of the deepest leaves.</p>

<p><strong>Intuition:</strong>
Standard BFS. Reset <code class="language-plaintext highlighter-rouge">sum</code> at the start of each level. The last <code class="language-plaintext highlighter-rouge">sum</code> is the answer.</p>

<p>``python
class Solution:
 def deepestLeavesSum(self, root: TreeNode) -&gt; int:
 if not root: return 0
 q = deque([root])
 level_sum = 0</p>

<p>while q:
 level_sum = 0
 for _ in range(len(q)):
 node = q.popleft()
 level_sum += node.val
 if node.left: q.append(node.left)
 if node.right: q.append(node.right)
 return level_sum
``</p>

<h2 id="appendix-e-the-word-ladder-pattern">Appendix E: The “Word Ladder” Pattern</h2>

<p><strong>Problem:</strong> Transform “hit” to “cog” by changing one letter at a time. Each intermediate word must exist in the dictionary. Return shortest path.</p>

<p><strong>Intuition:</strong>
This is BFS on an implicit graph.</p>
<ul>
  <li><strong>Nodes:</strong> Words.</li>
  <li><strong>Edges:</strong> Words differing by 1 letter.</li>
  <li><strong>Start:</strong> “hit”.</li>
  <li><strong>Target:</strong> “cog”.</li>
</ul>

<p><strong>Optimization:</strong>
Pre-process the dictionary into generic states:
<code class="language-plaintext highlighter-rouge">hot</code> -&gt; <code class="language-plaintext highlighter-rouge">*ot</code>, <code class="language-plaintext highlighter-rouge">h*t</code>, <code class="language-plaintext highlighter-rouge">ho*</code>.
Map <code class="language-plaintext highlighter-rouge">*ot</code> -&gt; <code class="language-plaintext highlighter-rouge">[hot, dot, lot]</code>.
This allows O(1) neighbor finding.</p>

<h2 id="deep-dive-python-deque-internals">Deep Dive: Python <code class="language-plaintext highlighter-rouge">deque</code> Internals</h2>

<p>Why is <code class="language-plaintext highlighter-rouge">deque</code> faster than <code class="language-plaintext highlighter-rouge">list</code> for popping from the front?
<strong>List:</strong> Contiguous memory array. <code class="language-plaintext highlighter-rouge">pop(0)</code> requires shifting (N-1) elements. (O(N)).
<strong>Deque:</strong> Doubly Linked List of <strong>Blocks</strong> (Arrays).</p>
<ul>
  <li>Each block stores 64 elements.</li>
  <li><code class="language-plaintext highlighter-rouge">popleft()</code> just increments a pointer in the first block.</li>
  <li>If the block becomes empty, we unlink it. (O(1)).</li>
  <li><strong>Cache Locality:</strong> Better than a standard Linked List (one node per element) because of the block structure.</li>
</ul>

<h2 id="advanced-variant-13-check-completeness-of-a-binary-tree">Advanced Variant 13: Check Completeness of a Binary Tree</h2>

<p><strong>Problem:</strong> Check if the tree is a <strong>Complete Binary Tree</strong> (filled left to right).
<strong>Intuition:</strong>
Level Order Traversal.
If we see a <code class="language-plaintext highlighter-rouge">null</code> node, we should <strong>never</strong> see a non-null node again.
If we do, it’s not complete.</p>

<p>``python
class Solution:
 def isCompleteTree(self, root: TreeNode) -&gt; bool:
 q = deque([root])
 seen_null = False</p>

<p>while q:
 node = q.popleft()</p>

<p>if not node:
 seen_null = True
 else:
 if seen_null:
 return False
 q.append(node.left)
 q.append(node.right)</p>

<p>return True
``</p>

<h2 id="advanced-variant-14-maximum-level-sum-of-a-binary-tree">Advanced Variant 14: Maximum Level Sum of a Binary Tree</h2>

<p><strong>Problem:</strong> Return the level number (1-indexed) with the maximum sum.</p>

<p><strong>Intuition:</strong>
Standard BFS. Track <code class="language-plaintext highlighter-rouge">max_sum</code> and <code class="language-plaintext highlighter-rouge">max_level</code>.</p>

<p>``python
class Solution:
 def maxLevelSum(self, root: TreeNode) -&gt; int:
 if not root: return 0
 q = deque([root])
 max_sum = float(‘-inf’)
 max_level = 1
 curr_level = 1</p>

<p>while q:
 level_sum = 0
 level_len = len(q)</p>

<p>for _ in range(level_len):
 node = q.popleft()
 level_sum += node.val
 if node.left: q.append(node.left)
 if node.right: q.append(node.right)</p>

<p>if level_sum &gt; max_sum:
 max_sum = level_sum
 max_level = curr_level</p>

<p>curr_level += 1</p>

<p>return max_level
``</p>

<h2 id="advanced-variant-15-even-odd-tree">Advanced Variant 15: Even Odd Tree</h2>

<p><strong>Problem:</strong></p>
<ul>
  <li>Even-indexed levels: Strictly increasing, odd values.</li>
  <li>Odd-indexed levels: Strictly decreasing, even values.</li>
</ul>

<p><strong>Intuition:</strong>
BFS with a toggle flag. Check conditions inside the loop.</p>

<p>``python
class Solution:
 def isEvenOddTree(self, root: TreeNode) -&gt; bool:
 q = deque([root])
 level = 0</p>

<p>while q:
 prev = float(‘-inf’) if level % 2 == 0 else float(‘inf’)</p>

<p>for _ in range(len(q)):
 node = q.popleft()</p>

<p>if level % 2 == 0:
 # Even Level: Odd values, Increasing
 if node.val % 2 == 0 or node.val &lt;= prev:
 return False
 else:
 # Odd Level: Even values, Decreasing
 if node.val % 2 != 0 or node.val &gt;= prev:
<em>If you found this helpful, consider sharing it with others who might benefit.</em></p>

<p>prev = node.val
 if node.left: q.append(node.left)
 if node.right: q.append(node.right)</p>

<p>level += 1</p>

<p>return True
``</p>

<h2 id="system-design-rate-limiter-token-bucket">System Design: Rate Limiter (Token Bucket)</h2>

<p><strong>Interviewer:</strong> “Design a Rate Limiter.”
<strong>Candidate:</strong> “We can use a <strong>Token Bucket</strong> algorithm.”</p>

<p><strong>Concept:</strong></p>
<ul>
  <li>A bucket holds <code class="language-plaintext highlighter-rouge">N</code> tokens.</li>
  <li>Tokens are added at rate <code class="language-plaintext highlighter-rouge">R</code> per second.</li>
  <li>A request consumes 1 token.</li>
  <li>If bucket is empty, reject request.</li>
</ul>

<p><strong>Implementation:</strong>
We don’t need a literal Queue. We can use a counter and a timestamp.
<code class="language-plaintext highlighter-rouge">current_tokens = min(capacity, previous_tokens + (now - last_refill_time) * rate)</code></p>

<p><strong>Distributed Rate Limiter:</strong>
Use Redis (Lua Script) to make the read-update-write atomic.
Or use a <strong>Sliding Window Log</strong> (Queue of timestamps) for strict accuracy (but high memory).</p>

<h2 id="advanced-variant-16-pseudo-palindromic-paths">Advanced Variant 16: Pseudo-Palindromic Paths</h2>

<p><strong>Problem:</strong> Return the number of paths from root to leaf where the path values can form a palindrome.
<strong>Intuition:</strong>
A path can form a palindrome if at most one number has an odd frequency.
We can use BFS (or DFS) and a bitmask to track parity of counts.
<code class="language-plaintext highlighter-rouge">mask ^= (1 &lt;&lt; node.val)</code>.
If <code class="language-plaintext highlighter-rouge">mask &amp; (mask - 1) == 0</code>, it’s a palindrome.</p>

<p>``python
class Solution:
 def pseudoPalindromicPaths (self, root: TreeNode) -&gt; int:
 count = 0
 # (node, mask)
 q = deque([(root, 0)])</p>

<p>while q:
 node, mask = q.popleft()
 mask ^= (1 « node.val)</p>

<p>if not node.left and not node.right:
 if mask &amp; (mask - 1) == 0:
 count += 1</p>

<p>if node.left: q.append((node.left, mask))
 if node.right: q.append((node.right, mask))</p>

<p>return count
``</p>

<h2 id="conclusion">Conclusion</h2>

<p>Level Order Traversal is the “Hello World” of BFS.
Mastering the <code class="language-plaintext highlighter-rouge">while queue: ... for _ in range(len(queue)):</code> pattern is crucial. It appears in graph problems, tree problems, and even matrix problems (Rotting Oranges).</p>

<hr />

<p><strong>Originally published at:</strong> <a href="https://www.arunbaby.com/dsa/0026-level-order-traversal/">arunbaby.com/dsa/0026-level-order-traversal</a></p>

<p><em>If you found this helpful, consider sharing it with others who might benefit.</em></p>


        
      </section>

      <footer class="page__meta">
        
        
  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-tags" aria-hidden="true"></i> Tags: </strong>
    <span itemprop="keywords">
    
      <a href="/tags/#bfs" class="page__taxonomy-item p-category" rel="tag">bfs</a><span class="sep">, </span>
    
      <a href="/tags/#binary-tree" class="page__taxonomy-item p-category" rel="tag">binary-tree</a><span class="sep">, </span>
    
      <a href="/tags/#medium" class="page__taxonomy-item p-category" rel="tag">medium</a><span class="sep">, </span>
    
      <a href="/tags/#queue" class="page__taxonomy-item p-category" rel="tag">queue</a>
    
    </span>
  </p>




  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> Categories: </strong>
    <span itemprop="keywords">
    
      <a href="/categories/#dsa" class="page__taxonomy-item p-category" rel="tag">dsa</a>
    
    </span>
  </p>


        
      </footer>

      <div class="page__related page__related--full">
  <h2 class="page__related-title">Related across topics</h2>
  <style>
    /* Make section span full content width and use 2 equal columns */
    .page__related--full { float: inline-start; width: 100%; padding: 0; }
    .cross-related-grid { display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 2rem; }
    @media (max-width: 768px) { .cross-related-grid { grid-template-columns: 1fr; } }
    /* Ensure archive cards stretch nicely in the grid */
    .cross-related-grid .list__item, .cross-related-grid .grid__item { width: auto; float: none; margin: 0; }
  </style>
  <div class="cross-related-grid">
    



<div class="list__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/ml-system-design/0026-batch-processing-pipelines/" rel="permalink">Batch Processing Pipelines
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          13 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">Not everything needs to be real-time. Sometimes, “tomorrow morning” is fast enough.
</p>
  </article>
</div>




<div class="list__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/speech-tech/0026-batch-speech-processing/" rel="permalink">Batch Speech Processing
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          9 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">Real-time ASR is hard. Offline ASR is big.
</p>
  </article>
</div>




<div class="list__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/ai-agents/0026-tool-design-principles/" rel="permalink">Tool Design Principles &amp; Agentic Orchestration
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          20 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">“An agent is only as good as the tools it can wield.”
</p>
  </article>
</div>

  </div>
</div>

      <section class="page__share">
  <h4 class="page__share-title">Share on</h4>

  <a href="https://twitter.com/intent/tweet?via=arunbaby0&text=Binary+Tree+Level+Order+Traversal%20https%3A%2F%2Fwww.arunbaby.com%2Fdsa%2F0026-level-order-traversal%2F" class="btn btn--twitter" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Twitter"><i class="fab fa-fw fa-twitter" aria-hidden="true"></i><span> Twitter</span></a>

  <a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fwww.arunbaby.com%2Fdsa%2F0026-level-order-traversal%2F" class="btn btn--facebook" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Facebook"><i class="fab fa-fw fa-facebook" aria-hidden="true"></i><span> Facebook</span></a>

  <a href="https://www.linkedin.com/shareArticle?mini=true&url=https://www.arunbaby.com/dsa/0026-level-order-traversal/" class="btn btn--linkedin" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on LinkedIn"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i><span> LinkedIn</span></a>
</section>


      
  <nav class="pagination">
    
      <a href="/dsa/0025-validate-bst/" class="pagination--pager" title="Validate Binary Search Tree">Previous</a>
    
    
      <a href="/dsa/0027-construct-binary-tree/" class="pagination--pager" title="Construct Binary Tree from Preorder and Inorder Traversal">Next</a>
    
  </nav>


    </div>

    
  </article>

  
  
</div>

      
    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';" role="search">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Enter your search term..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    

    
      
        
          <li><a href="https://twitter.com/arunbaby0" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-twitter-square" aria-hidden="true"></i> Twitter</a></li>
        
      
        
          <li><a href="https://github.com/arunbaby0" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
        
      
        
          <li><a href="https://www.linkedin.com/in/arunbaby0/" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i> LinkedIn</a></li>
        
      
        
          <li><a href="https://scholar.google.co.in/citations?user=6fSYWhkAAAAJ" rel="nofollow noopener noreferrer"><i class="fas fa-fw fa-graduation-cap" aria-hidden="true"></i> Google Scholar</a></li>
        
      
    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 1990 - 2143 <a href="https://www.arunbaby.com">Arun Baby</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>




  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-0JRJPEC9SS"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-0JRJPEC9SS', { 'anonymize_ip': false});
</script>








  </body>
</html>
