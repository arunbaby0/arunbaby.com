<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.26.2 by Michael Rose
  Copyright 2013-2024 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->

<html lang="en-US" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Binary Tree Level Order Traversal - Arun Baby</title>
<meta name="description" content="How do you print a corporate hierarchy level by level? CEO first, then VPs, then Managers…">


  <meta name="author" content="Arun Baby">
  
  <meta property="article:author" content="Arun Baby">
  


<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="Arun Baby">
<meta property="og:title" content="Binary Tree Level Order Traversal">
<meta property="og:url" content="https://www.arunbaby.com/dsa/0026-level-order-traversal/">


  <meta property="og:description" content="How do you print a corporate hierarchy level by level? CEO first, then VPs, then Managers…">



  <meta property="og:image" content="https://www.arunbaby.com/assets/images/profile-photo.png">



  <meta name="twitter:site" content="@arunbaby0">
  <meta name="twitter:title" content="Binary Tree Level Order Traversal">
  <meta name="twitter:description" content="How do you print a corporate hierarchy level by level? CEO first, then VPs, then Managers…">
  <meta name="twitter:url" content="https://www.arunbaby.com/dsa/0026-level-order-traversal/">

  
    <meta name="twitter:card" content="summary">
    
      <meta name="twitter:image" content="https://www.arunbaby.com/assets/images/profile-photo.png">
    
  

  



  <meta property="article:published_time" content="2025-12-05T18:49:37+05:30">





  

  


<link rel="canonical" href="https://www.arunbaby.com/dsa/0026-level-order-traversal/">












<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Arun Baby Feed">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
  
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css"></noscript>



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--single" dir="ltr">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
           
          <span class="site-subtitle">Arun Baby</span>
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a
                href="/about/"
                
                
              >About</a>
            </li><li class="masthead__menu-item">
              <a
                href="/dsa/"
                
                
              >DSA</a>
            </li><li class="masthead__menu-item">
              <a
                href="/ml-system-design/"
                
                
              >ML Systems</a>
            </li><li class="masthead__menu-item">
              <a
                href="/speech-tech/"
                
                
              >Speech Tech</a>
            </li><li class="masthead__menu-item">
              <a
                href="/publications/"
                
                
              >Publications</a>
            </li><li class="masthead__menu-item">
              <a
                href="/statuses/"
                
                
              >Statuses</a>
            </li><li class="masthead__menu-item">
              <a
                href="/contact/"
                
                
              >Contact</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <i class="fas fa-search"></i>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      





<div id="main" role="main" class="no-author-sidebar">
  
  <div class="sidebar sticky">
  
  
  </div>



  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="Binary Tree Level Order Traversal">
    <meta itemprop="description" content="How do you print a corporate hierarchy level by level? CEO first, then VPs, then Managers…">
    <meta itemprop="datePublished" content="2025-12-05T18:49:37+05:30">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">
            <a href="https://www.arunbaby.com/dsa/0026-level-order-traversal/" itemprop="url">Binary Tree Level Order Traversal
</a>
          </h1>
          

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          19 minute read
        
      </span>
    
  </p>


        </header>
      

      <section class="page__content" itemprop="text">
        
          <aside class="sidebar__right sticky">
            <nav class="toc">
              <header><h4 class="nav__title"><i class="fas fa-file-alt"></i> On this page</h4></header>
              <ul class="toc__menu"><li><a href="#problem">Problem</a></li><li><a href="#intuition">Intuition</a></li><li><a href="#approach-1-iterative-bfs-using-queue">Approach 1: Iterative BFS using Queue</a></li><li><a href="#approach-2-recursive-dfs-preorder">Approach 2: Recursive DFS (Preorder)</a></li><li><a href="#variant-zigzag-level-order-traversal">Variant: Zigzag Level Order Traversal</a></li><li><a href="#variant-2-n-ary-tree-level-order-traversal">Variant 2: N-ary Tree Level Order Traversal</a></li><li><a href="#variant-3-binary-tree-level-order-traversal-ii-bottom-up">Variant 3: Binary Tree Level Order Traversal II (Bottom-Up)</a></li><li><a href="#variant-4a-binary-search-tree-bst-is-the-backbone-of-efficient-search-it-guarantees-olog-n-lookup-but-this-guarantee-only-holds-if-the-tree-is-valid-if-a-single-node-is-out-of-place-the-search-algorithm-breakst-node-of-each-level">Variant 4:A Binary Search Tree (BST) is the backbone of efficient search. It guarantees (O(\log N)) lookup. But this guarantee only holds if the tree is valid. If a single node is out of place, the search algorithm breaks.t node** of each level.</a></li><li><a href="#variant-5-cousins-in-binary-tree">Variant 5: Cousins in Binary Tree</a></li><li><a href="#advanced-variant-6-maximum-width-of-binary-tree">Advanced Variant 6: Maximum Width of Binary Tree</a></li><li><a href="#system-design-distributed-graph-traversal-pregel">System Design: Distributed Graph Traversal (Pregel)</a></li><li><a href="#deep-dive-vertical-order-traversal">Deep Dive: Vertical Order Traversal</a></li><li><a href="#appendix-b-boundary-traversal">Appendix B: Boundary Traversal</a></li><li><a href="#advanced-variant-7-diagonal-traversal">Advanced Variant 7: Diagonal Traversal</a></li><li><a href="#advanced-variant-8-serialize-and-deserialize-binary-tree">Advanced Variant 8: Serialize and Deserialize Binary Tree</a></li><li><a href="#deep-dive-tree-bfs-vs-graph-bfs">Deep Dive: Tree BFS vs. Graph BFS</a></li><li><a href="#appendix-c-the-rotting-oranges-pattern">Appendix C: The “Rotting Oranges” Pattern</a></li><li><a href="#appendix-d-interview-questions">Appendix D: Interview Questions</a></li><li><a href="#advanced-variant-9-populating-next-right-pointers-in-each-node">Advanced Variant 9: Populating Next Right Pointers in Each Node</a></li><li><a href="#advanced-variant-10-average-of-levels-in-binary-tree">Advanced Variant 10: Average of Levels in Binary Tree</a></li><li><a href="#advanced-variant-11-find-bottom-left-tree-value">Advanced Variant 11: Find Bottom Left Tree Value</a></li><li><a href="#deep-dive-queue-implementation-array-vs-linked-list">Deep Dive: Queue Implementation (Array vs. Linked List)</a></li><li><a href="#system-design-distributed-queue-kafka-vs-sqs">System Design: Distributed Queue (Kafka vs. SQS)</a></li><li><a href="#advanced-variant-12-deepest-leaves-sum">Advanced Variant 12: Deepest Leaves Sum</a></li><li><a href="#appendix-e-the-word-ladder-pattern">Appendix E: The “Word Ladder” Pattern</a></li><li><a href="#deep-dive-python-deque-internals">Deep Dive: Python deque Internals</a></li><li><a href="#advanced-variant-13-check-completeness-of-a-binary-tree">Advanced Variant 13: Check Completeness of a Binary Tree</a></li><li><a href="#advanced-variant-14-maximum-level-sum-of-a-binary-tree">Advanced Variant 14: Maximum Level Sum of a Binary Tree</a></li><li><a href="#advanced-variant-15-even-odd-tree">Advanced Variant 15: Even Odd Tree</a></li><li><a href="#system-design-rate-limiter-token-bucket">System Design: Rate Limiter (Token Bucket)</a></li><li><a href="#advanced-variant-16-pseudo-palindromic-paths">Advanced Variant 16: Pseudo-Palindromic Paths</a></li><li><a href="#conclusion">Conclusion</a></li></ul>
            </nav>
          </aside>
        
        <p><strong>How do you print a corporate hierarchy level by level? CEO first, then VPs, then Managers…</strong></p>

<h2 id="problem">Problem</h2>

<p>Given the <code class="language-plaintext highlighter-rouge">root</code> of a binary tree, return the <em>level order traversal</em> of its nodes’ values. (i.e., from left to right, level by level).</p>

<p><strong>Example 1:</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    3
   / \
  9  20
    /  \
   15   7
</code></pre></div></div>
<p><strong>Input:</strong> <code class="language-plaintext highlighter-rouge">root = [3,9,20,null,null,15,7]</code>
<strong>Output:</strong> <code class="language-plaintext highlighter-rouge">[[3],[9,20],[15,7]]</code></p>

<p><strong>Example 2:</strong>
<strong>Input:</strong> <code class="language-plaintext highlighter-rouge">root = [1]</code>
<strong>Output:</strong> <code class="language-plaintext highlighter-rouge">[[1]]</code></p>

<h2 id="intuition">Intuition</h2>

<p>Depth First Search (DFS) dives deep. It goes <code class="language-plaintext highlighter-rouge">Root -&gt; Left -&gt; Left...</code> until it hits a leaf.
Breadth First Search (BFS) explores wide. It visits all neighbors at the current depth before moving deeper.</p>

<p>For a tree, BFS naturally produces a Level Order Traversal.
The key data structure for BFS is the <strong>Queue</strong> (FIFO - First In, First Out).</p>
<ul>
  <li>We enter the queue at the back.</li>
  <li>We leave the queue from the front.</li>
  <li>This ensures that nodes at depth <code class="language-plaintext highlighter-rouge">d</code> are processed before nodes at depth <code class="language-plaintext highlighter-rouge">d+1</code>.</li>
</ul>

<h2 id="approach-1-iterative-bfs-using-queue">Approach 1: Iterative BFS using Queue</h2>

<p>We use a <code class="language-plaintext highlighter-rouge">deque</code> (double-ended queue) in Python for efficient <code class="language-plaintext highlighter-rouge">popleft()</code>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">deque</span>

<span class="k">class</span> <span class="nc">TreeNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="n">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="n">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">levelOrder</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">queue</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">([</span><span class="n">root</span><span class="p">])</span>
        
        <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
            <span class="n">level_size</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span>
            <span class="n">current_level</span> <span class="o">=</span> <span class="p">[]</span>
            
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">level_size</span><span class="p">):</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="nf">popleft</span><span class="p">()</span>
                <span class="n">current_level</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
                
                <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">:</span>
                    <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
                    <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
            
            <span class="n">result</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">current_level</span><span class="p">)</span>
            
        <span class="k">return</span> <span class="n">result</span>
</code></pre></div></div>

<p><strong>Complexity Analysis:</strong></p>
<ul>
  <li><strong>Time:</strong> (O(N)). We visit every node once.</li>
  <li><strong>Space:</strong> (O(N)) (or (O(W)) where W is max width). In a perfect binary tree, the last level has (N/2) nodes.</li>
</ul>

<h2 id="approach-2-recursive-dfs-preorder">Approach 2: Recursive DFS (Preorder)</h2>

<p>Can we do this with DFS? Yes, but it’s less intuitive.
We pass the <code class="language-plaintext highlighter-rouge">level</code> index in the recursion.
<code class="language-plaintext highlighter-rouge">dfs(node, level)</code> adds <code class="language-plaintext highlighter-rouge">node.val</code> to <code class="language-plaintext highlighter-rouge">result[level]</code>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">levelOrder</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">level</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="p">:</span>
                <span class="k">return</span>
            
            <span class="c1"># Ensure the list for this level exists
</span>            <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">==</span> <span class="n">level</span><span class="p">:</span>
                <span class="n">result</span><span class="p">.</span><span class="nf">append</span><span class="p">([])</span>
            
            <span class="n">result</span><span class="p">[</span><span class="n">level</span><span class="p">].</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
            
            <span class="nf">dfs</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="nf">dfs</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">,</span> <span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            
        <span class="nf">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>
</code></pre></div></div>

<p><strong>Pros:</strong> Simpler code (no queue).
<strong>Cons:</strong> Uses system stack (O(H)) space. BFS uses heap space.</p>

<h2 id="variant-zigzag-level-order-traversal">Variant: Zigzag Level Order Traversal</h2>

<p><strong>Problem:</strong> Return the zigzag level order traversal.
Level 0: Left -&gt; Right
Level 1: Right -&gt; Left
Level 2: Left -&gt; Right</p>

<p><strong>Solution:</strong>
Use a standard BFS.
Keep a flag <code class="language-plaintext highlighter-rouge">left_to_right</code>.
If <code class="language-plaintext highlighter-rouge">left_to_right</code> is False, append to <code class="language-plaintext highlighter-rouge">current_level</code> in reverse (or use <code class="language-plaintext highlighter-rouge">deque.appendleft</code>).</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">zigzagLevelOrder</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span> <span class="k">return</span> <span class="p">[]</span>
        
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">q</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">([</span><span class="n">root</span><span class="p">])</span>
        <span class="n">left_to_right</span> <span class="o">=</span> <span class="bp">True</span>
        
        <span class="k">while</span> <span class="n">q</span><span class="p">:</span>
            <span class="n">level_size</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
            <span class="n">level_nodes</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">()</span> <span class="c1"># Use deque for O(1) appendleft
</span>            
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">level_size</span><span class="p">):</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="nf">popleft</span><span class="p">()</span>
                
                <span class="k">if</span> <span class="n">left_to_right</span><span class="p">:</span>
                    <span class="n">level_nodes</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">level_nodes</span><span class="p">.</span><span class="nf">appendleft</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
                    
                <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">:</span> <span class="n">q</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">:</span> <span class="n">q</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
            
            <span class="n">res</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="nf">list</span><span class="p">(</span><span class="n">level_nodes</span><span class="p">))</span>
            <span class="n">left_to_right</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">left_to_right</span>
            
        <span class="k">return</span> <span class="n">res</span>
</code></pre></div></div>

<h2 id="variant-2-n-ary-tree-level-order-traversal">Variant 2: N-ary Tree Level Order Traversal</h2>

<p><strong>Problem:</strong> Given an N-ary tree (where each node has a list of <code class="language-plaintext highlighter-rouge">children</code>), return the level order traversal.</p>

<p><strong>Intuition:</strong>
Same as Binary Tree, but instead of adding <code class="language-plaintext highlighter-rouge">left</code> and <code class="language-plaintext highlighter-rouge">right</code>, we iterate through <code class="language-plaintext highlighter-rouge">children</code>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">children</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="n">self</span><span class="p">.</span><span class="n">children</span> <span class="o">=</span> <span class="n">children</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">levelOrder</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="sh">'</span><span class="s">Node</span><span class="sh">'</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span> <span class="k">return</span> <span class="p">[]</span>
        
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">q</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">([</span><span class="n">root</span><span class="p">])</span>
        
        <span class="k">while</span> <span class="n">q</span><span class="p">:</span>
            <span class="n">level</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">q</span><span class="p">)):</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="nf">popleft</span><span class="p">()</span>
                <span class="n">level</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">children</span><span class="p">:</span>
                    <span class="n">q</span><span class="p">.</span><span class="nf">extend</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">children</span><span class="p">)</span>
            <span class="n">res</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">level</span><span class="p">)</span>
            
        <span class="k">return</span> <span class="n">res</span>
</code></pre></div></div>

<h2 id="variant-3-binary-tree-level-order-traversal-ii-bottom-up">Variant 3: Binary Tree Level Order Traversal II (Bottom-Up)</h2>

<p><strong>Problem:</strong> Return the traversal from leaf to root. <code class="language-plaintext highlighter-rouge">[[15,7], [9,20], [3]]</code>.</p>

<p><strong>Solution:</strong>
Standard BFS, but <code class="language-plaintext highlighter-rouge">result.insert(0, level)</code> or <code class="language-plaintext highlighter-rouge">result.reverse()</code> at the end.
<code class="language-plaintext highlighter-rouge">reverse()</code> is (O(N)) but amortized (O(1)) per level. <code class="language-plaintext highlighter-rouge">insert(0)</code> is (O(N)) per level (Total (O(N^2))). <strong>Always use reverse.</strong></p>

<h2 id="variant-4a-binary-search-tree-bst-is-the-backbone-of-efficient-search-it-guarantees-olog-n-lookup-but-this-guarantee-only-holds-if-the-tree-is-valid-if-a-single-node-is-out-of-place-the-search-algorithm-breakst-node-of-each-level">Variant 4:A Binary Search Tree (BST) is the backbone of efficient search. It guarantees (O(\log N)) lookup. But this guarantee only holds if the tree is valid. If a single node is out of place, the search algorithm breaks.t node** of each level.</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">rightSideView</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span> <span class="k">return</span> <span class="p">[]</span>
        
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">q</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">([</span><span class="n">root</span><span class="p">])</span>
        
        <span class="k">while</span> <span class="n">q</span><span class="p">:</span>
            <span class="n">level_len</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">level_len</span><span class="p">):</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="nf">popleft</span><span class="p">()</span>
                <span class="c1"># If it's the last node in the current level
</span>                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">level_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">res</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
                
                <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">:</span> <span class="n">q</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">:</span> <span class="n">q</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span>
</code></pre></div></div>

<h2 id="variant-5-cousins-in-binary-tree">Variant 5: Cousins in Binary Tree</h2>

<p><strong>Problem:</strong> Two nodes are cousins if they have the same depth but different parents.
Given <code class="language-plaintext highlighter-rouge">root</code>, <code class="language-plaintext highlighter-rouge">x</code>, and <code class="language-plaintext highlighter-rouge">y</code>, return <code class="language-plaintext highlighter-rouge">True</code> if they are cousins.</p>

<p><strong>Intuition:</strong>
BFS is perfect for tracking depth. We also need to track the parent.
We can store <code class="language-plaintext highlighter-rouge">(node, parent)</code> in the queue.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">isCousins</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">q</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">([(</span><span class="n">root</span><span class="p">,</span> <span class="bp">None</span><span class="p">)])</span>
        
        <span class="k">while</span> <span class="n">q</span><span class="p">:</span>
            <span class="n">level_size</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
            <span class="n">found_x</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="n">found_y</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="n">x_parent</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="n">y_parent</span> <span class="o">=</span> <span class="bp">None</span>
            
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">level_size</span><span class="p">):</span>
                <span class="n">node</span><span class="p">,</span> <span class="n">parent</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="nf">popleft</span><span class="p">()</span>
                
                <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">val</span> <span class="o">==</span> <span class="n">x</span><span class="p">:</span>
                    <span class="n">found_x</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="n">x_parent</span> <span class="o">=</span> <span class="n">parent</span>
                <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">val</span> <span class="o">==</span> <span class="n">y</span><span class="p">:</span>
                    <span class="n">found_y</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="n">y_parent</span> <span class="o">=</span> <span class="n">parent</span>
                
                <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">:</span> <span class="n">q</span><span class="p">.</span><span class="nf">append</span><span class="p">((</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">node</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">:</span> <span class="n">q</span><span class="p">.</span><span class="nf">append</span><span class="p">((</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">,</span> <span class="n">node</span><span class="p">))</span>
            
            <span class="c1"># Check after finishing the level
</span>            <span class="k">if</span> <span class="n">found_x</span> <span class="ow">and</span> <span class="n">found_y</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">x_parent</span> <span class="o">!=</span> <span class="n">y_parent</span>
            
            <span class="c1"># If one found but not the other, they are at different depths
</span>            <span class="k">if</span> <span class="n">found_x</span> <span class="ow">or</span> <span class="n">found_y</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>
                
        <span class="k">return</span> <span class="bp">False</span>
</code></pre></div></div>

<h2 id="advanced-variant-6-maximum-width-of-binary-tree">Advanced Variant 6: Maximum Width of Binary Tree</h2>

<p><strong>Problem:</strong> The maximum width among all levels.
The width of one level is defined as the length between the end-nodes (the leftmost and rightmost non-null nodes), where the null nodes between the end-nodes are also counted into the length calculation.</p>

<p><strong>Intuition:</strong>
This is tricky because of the “null nodes are counted” part.
We can index the nodes like a Heap.</p>
<ul>
  <li>Root index: <code class="language-plaintext highlighter-rouge">1</code></li>
  <li>Left child: <code class="language-plaintext highlighter-rouge">2*i</code></li>
  <li>Right child: <code class="language-plaintext highlighter-rouge">2*i + 1</code>
Width = <code class="language-plaintext highlighter-rouge">index_right - index_left + 1</code>.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">widthOfBinaryTree</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span> <span class="k">return</span> <span class="mi">0</span>
        
        <span class="n">max_width</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># Queue stores (node, index)
</span>        <span class="n">q</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">([(</span><span class="n">root</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>
        
        <span class="k">while</span> <span class="n">q</span><span class="p">:</span>
            <span class="n">level_len</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">level_start_index</span> <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">level_len</span><span class="p">):</span>
                <span class="n">node</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="nf">popleft</span><span class="p">()</span>
                
                <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">:</span>
                    <span class="n">q</span><span class="p">.</span><span class="nf">append</span><span class="p">((</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">index</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
                    <span class="n">q</span><span class="p">.</span><span class="nf">append</span><span class="p">((</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
                    
            <span class="c1"># Calculate width for this level
</span>            <span class="c1"># Current index is the last one popped
</span>            <span class="n">max_width</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="n">max_width</span><span class="p">,</span> <span class="n">index</span> <span class="o">-</span> <span class="n">level_start_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            
        <span class="k">return</span> <span class="n">max_width</span>
</code></pre></div></div>

<h2 id="system-design-distributed-graph-traversal-pregel">System Design: Distributed Graph Traversal (Pregel)</h2>

<p><strong>Interviewer:</strong> “How do you run BFS on a graph with 1 Trillion nodes (Facebook Friend Graph)?”
<strong>Candidate:</strong> “You can’t fit it in RAM. You need <strong>Pregel</strong> (Google’s Bulk Synchronous Parallel model).”</p>

<p><strong>The Pregel Model:</strong></p>
<ol>
  <li><strong>Supersteps:</strong> Computation happens in rounds.</li>
  <li><strong>Vertex-Centric:</strong> Each vertex runs a function <code class="language-plaintext highlighter-rouge">Compute(messages)</code>.</li>
  <li><strong>Message Passing:</strong> Vertices send messages to neighbors (to be received in the next Superstep).</li>
</ol>

<p><strong>BFS in Pregel:</strong></p>
<ul>
  <li><strong>Superstep 0:</strong> Source vertex sets <code class="language-plaintext highlighter-rouge">min_dist = 0</code> and sends <code class="language-plaintext highlighter-rouge">dist=1</code> to neighbors.</li>
  <li><strong>Superstep 1:</strong> Neighbors receive <code class="language-plaintext highlighter-rouge">dist=1</code>. If <code class="language-plaintext highlighter-rouge">current_dist &gt; 1</code>, update <code class="language-plaintext highlighter-rouge">current_dist = 1</code> and send <code class="language-plaintext highlighter-rouge">dist=2</code> to neighbors.</li>
  <li><strong>Halt:</strong> When no nodes update their distance.</li>
</ul>

<h2 id="deep-dive-vertical-order-traversal">Deep Dive: Vertical Order Traversal</h2>

<p><strong>Problem:</strong> Print the tree in vertical columns.
If two nodes are in the same row and column, the order should be from left to right.</p>

<p><strong>Intuition:</strong>
We need coordinates <code class="language-plaintext highlighter-rouge">(row, col)</code>.</p>
<ul>
  <li>Root: <code class="language-plaintext highlighter-rouge">(0, 0)</code></li>
  <li>Left: <code class="language-plaintext highlighter-rouge">(row+1, col-1)</code></li>
  <li>Right: <code class="language-plaintext highlighter-rouge">(row+1, col+1)</code></li>
</ul>

<p>We can use BFS to traverse. We store <code class="language-plaintext highlighter-rouge">(node, col)</code> in the queue.
We need a Hash Map <code class="language-plaintext highlighter-rouge">col -&gt; list of nodes</code>.
Finally, sort the map by keys (column index).</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">verticalOrder</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span> <span class="k">return</span> <span class="p">[]</span>
        
        <span class="n">column_table</span> <span class="o">=</span> <span class="nf">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="n">q</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">([(</span><span class="n">root</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>
        <span class="n">min_col</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">max_col</span> <span class="o">=</span> <span class="mi">0</span>
        
        <span class="k">while</span> <span class="n">q</span><span class="p">:</span>
            <span class="n">node</span><span class="p">,</span> <span class="n">col</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="nf">popleft</span><span class="p">()</span>
            <span class="n">column_table</span><span class="p">[</span><span class="n">col</span><span class="p">].</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
            
            <span class="n">min_col</span> <span class="o">=</span> <span class="nf">min</span><span class="p">(</span><span class="n">min_col</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span>
            <span class="n">max_col</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="n">max_col</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">:</span> <span class="n">q</span><span class="p">.</span><span class="nf">append</span><span class="p">((</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">col</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">:</span> <span class="n">q</span><span class="p">.</span><span class="nf">append</span><span class="p">((</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">,</span> <span class="n">col</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
            
        <span class="k">return</span> <span class="p">[</span><span class="n">column_table</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">min_col</span><span class="p">,</span> <span class="n">max_col</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
</code></pre></div></div>

<h2 id="appendix-b-boundary-traversal">Appendix B: Boundary Traversal</h2>

<p><strong>Problem:</strong> Print the boundary of the tree (Left Boundary + Leaves + Right Boundary).
<strong>Intuition:</strong></p>
<ol>
  <li><strong>Left Boundary:</strong> Keep going left. If no left, go right. (Exclude leaf).</li>
  <li><strong>Leaves:</strong> DFS/Preorder. Add if <code class="language-plaintext highlighter-rouge">!left</code> and <code class="language-plaintext highlighter-rouge">!right</code>.</li>
  <li><strong>Right Boundary:</strong> Keep going right. If no right, go left. (Exclude leaf). Add in reverse order.</li>
</ol>

<p>This is a classic “Hard” problem that tests modular thinking. Don’t try to do it in one pass. Break it down.</p>

<h2 id="advanced-variant-7-diagonal-traversal">Advanced Variant 7: Diagonal Traversal</h2>

<p><strong>Problem:</strong> Print the tree diagonally.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    8
   / \
  3   10
 / \    \
1   6    14
   / \   /
  4   7 13
</code></pre></div></div>
<p><strong>Output:</strong> <code class="language-plaintext highlighter-rouge">[[8, 10, 14], [3, 6, 7, 13], [1, 4]]</code></p>

<p><strong>Intuition:</strong></p>
<ul>
  <li>Root is at <code class="language-plaintext highlighter-rouge">d=0</code>.</li>
  <li>Left child is at <code class="language-plaintext highlighter-rouge">d+1</code>.</li>
  <li>Right child is at <code class="language-plaintext highlighter-rouge">d</code> (same diagonal).</li>
</ul>

<p>We can use a Queue. But instead of just popping, we iterate through the <strong>right child chain</strong> and add all of them to the current diagonal list, while pushing their left children to the queue for the next diagonal.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">diagonalTraversal</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span> <span class="k">return</span> <span class="p">[]</span>
        
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">q</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">([</span><span class="n">root</span><span class="p">])</span>
        
        <span class="k">while</span> <span class="n">q</span><span class="p">:</span>
            <span class="n">level_size</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
            <span class="n">curr_diagonal</span> <span class="o">=</span> <span class="p">[]</span>
            
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">level_size</span><span class="p">):</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="nf">popleft</span><span class="p">()</span>
                
                <span class="c1"># Process the current node and all its right children
</span>                <span class="k">while</span> <span class="n">node</span><span class="p">:</span>
                    <span class="n">curr_diagonal</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">:</span>
                        <span class="n">q</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
                    <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span>
            
            <span class="n">res</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">curr_diagonal</span><span class="p">)</span>
            
        <span class="k">return</span> <span class="n">res</span>
</code></pre></div></div>

<h2 id="advanced-variant-8-serialize-and-deserialize-binary-tree">Advanced Variant 8: Serialize and Deserialize Binary Tree</h2>

<p><strong>Problem:</strong> Convert a tree to a string and back.
<strong>Method:</strong> Level Order Traversal (BFS).</p>

<p><strong>Serialization:</strong>
Use a Queue. If a node is <code class="language-plaintext highlighter-rouge">None</code>, append “null”.
<code class="language-plaintext highlighter-rouge">[1, 2, 3, null, null, 4, 5]</code></p>

<p><strong>Deserialization:</strong>
Use a Queue.</p>
<ol>
  <li>Read root <code class="language-plaintext highlighter-rouge">1</code>. Push to queue.</li>
  <li>Pop <code class="language-plaintext highlighter-rouge">1</code>. Read next two values <code class="language-plaintext highlighter-rouge">2</code>, <code class="language-plaintext highlighter-rouge">3</code>. Attach as left/right. Push <code class="language-plaintext highlighter-rouge">2</code>, <code class="language-plaintext highlighter-rouge">3</code>.</li>
  <li>Pop <code class="language-plaintext highlighter-rouge">2</code>. Read <code class="language-plaintext highlighter-rouge">null</code>, <code class="language-plaintext highlighter-rouge">null</code>. Attach.</li>
  <li>Pop <code class="language-plaintext highlighter-rouge">3</code>. Read <code class="language-plaintext highlighter-rouge">4</code>, <code class="language-plaintext highlighter-rouge">5</code>. Attach. Push <code class="language-plaintext highlighter-rouge">4</code>, <code class="language-plaintext highlighter-rouge">5</code>.</li>
</ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Codec</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">serialize</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span> <span class="k">return</span> <span class="sh">""</span>
        <span class="n">q</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">([</span><span class="n">root</span><span class="p">])</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="n">q</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="nf">popleft</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">node</span><span class="p">:</span>
                <span class="n">res</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="nf">str</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">val</span><span class="p">))</span>
                <span class="n">q</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
                <span class="n">q</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">res</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="sh">"</span><span class="s">null</span><span class="sh">"</span><span class="p">)</span>
        <span class="k">return</span> <span class="sh">"</span><span class="s">,</span><span class="sh">"</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">deserialize</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">data</span><span class="p">:</span> <span class="k">return</span> <span class="bp">None</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="sh">"</span><span class="s">,</span><span class="sh">"</span><span class="p">)</span>
        <span class="n">root</span> <span class="o">=</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="nf">int</span><span class="p">(</span><span class="n">vals</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">q</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">([</span><span class="n">root</span><span class="p">])</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="n">q</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="nf">popleft</span><span class="p">()</span>
            
            <span class="c1"># Left Child
</span>            <span class="k">if</span> <span class="n">vals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="sh">"</span><span class="s">null</span><span class="sh">"</span><span class="p">:</span>
                <span class="n">node</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="nf">int</span><span class="p">(</span><span class="n">vals</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
                <span class="n">q</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            
            <span class="c1"># Right Child
</span>            <span class="k">if</span> <span class="n">vals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="sh">"</span><span class="s">null</span><span class="sh">"</span><span class="p">:</span>
                <span class="n">node</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="nf">int</span><span class="p">(</span><span class="n">vals</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
                <span class="n">q</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">root</span>
</code></pre></div></div>

<h2 id="deep-dive-tree-bfs-vs-graph-bfs">Deep Dive: Tree BFS vs. Graph BFS</h2>

<p><strong>Tree BFS:</strong></p>
<ul>
  <li>No cycles.</li>
  <li>No <code class="language-plaintext highlighter-rouge">visited</code> set needed.</li>
  <li>Exactly one path to each node.</li>
</ul>

<p><strong>Graph BFS:</strong></p>
<ul>
  <li>Cycles exist.</li>
  <li><strong>Must</strong> use <code class="language-plaintext highlighter-rouge">visited</code> set to avoid infinite loops.</li>
  <li>Multiple paths exist. BFS finds the shortest path (in unweighted graphs).</li>
</ul>

<p><strong>Bidirectional BFS:</strong>
To find the shortest path between <code class="language-plaintext highlighter-rouge">A</code> and <code class="language-plaintext highlighter-rouge">B</code> in a massive graph.
Run BFS from <code class="language-plaintext highlighter-rouge">A</code> forward and from <code class="language-plaintext highlighter-rouge">B</code> backward.
Meet in the middle.
<strong>Complexity:</strong> (O(b^{d/2})) instead of (O(b^d)). Huge saving!</p>

<h2 id="appendix-c-the-rotting-oranges-pattern">Appendix C: The “Rotting Oranges” Pattern</h2>

<p><strong>Problem:</strong> Given a grid where <code class="language-plaintext highlighter-rouge">2</code> is rotten orange, <code class="language-plaintext highlighter-rouge">1</code> is fresh, <code class="language-plaintext highlighter-rouge">0</code> is empty.
Every minute, a rotten orange rots its 4-directional neighbors.
Return min minutes until all fresh oranges rot.</p>

<p><strong>Intuition:</strong>
This is <strong>Multi-Source BFS</strong>.</p>
<ol>
  <li>Push <em>all</em> initially rotten oranges into the Queue at <code class="language-plaintext highlighter-rouge">t=0</code>.</li>
  <li>Run standard BFS.</li>
  <li>The number of levels is the time.</li>
</ol>

<p>This pattern appears in:</p>
<ul>
  <li>“Walls and Gates”</li>
  <li>“01 Matrix”</li>
  <li>“Map of Highest Peak”</li>
</ul>

<h2 id="appendix-d-interview-questions">Appendix D: Interview Questions</h2>

<ol>
  <li>
    <p><strong>Q:</strong> “Can you perform Level Order Traversal without a Queue?”
<strong>A:</strong> Yes, using Recursion (DFS) and passing the level index (Approach 2). Or using two arrays (current_level, next_level).</p>
  </li>
  <li>
    <p><strong>Q:</strong> “What is the space complexity of BFS?”
<strong>A:</strong> (O(W)) where (W) is the maximum width. In a full binary tree, the last level has (N/2) leaves, so (O(N)).</p>
  </li>
  <li>
    <p><strong>Q:</strong> “When should you use DFS vs BFS?”
<strong>A:</strong></p>
    <ul>
      <li><strong>BFS:</strong> Shortest path, levels, closer to root.</li>
      <li><strong>DFS:</strong> Exhaustive search, backtracking, path finding, closer to leaves.</li>
    </ul>
  </li>
</ol>

<h2 id="advanced-variant-9-populating-next-right-pointers-in-each-node">Advanced Variant 9: Populating Next Right Pointers in Each Node</h2>

<p><strong>Problem:</strong> You are given a perfect binary tree where all leaves are on the same level, and every parent has two children. Populate each <code class="language-plaintext highlighter-rouge">next</code> pointer to point to its next right node. If there is no next right node, the next pointer should be set to <code class="language-plaintext highlighter-rouge">NULL</code>.</p>

<p><strong>Intuition:</strong>
Level Order Traversal is the obvious choice.
But can we do it with <strong>O(1) Space</strong>?
Yes. We can use the <code class="language-plaintext highlighter-rouge">next</code> pointers we already established in the <em>previous</em> level to traverse the <em>current</em> level.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span> <span class="sh">'</span><span class="s">Node</span><span class="sh">'</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="sh">'</span><span class="s">Node</span><span class="sh">'</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="nb">next</span><span class="p">:</span> <span class="sh">'</span><span class="s">Node</span><span class="sh">'</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="n">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="n">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>
        <span class="n">self</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="nb">next</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">connect</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="sh">'</span><span class="s">Node</span><span class="sh">'</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="sh">'</span><span class="s">Node</span><span class="sh">'</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span> <span class="k">return</span> <span class="bp">None</span>
        
        <span class="n">leftmost</span> <span class="o">=</span> <span class="n">root</span>
        
        <span class="k">while</span> <span class="n">leftmost</span><span class="p">.</span><span class="n">left</span><span class="p">:</span>
            <span class="n">head</span> <span class="o">=</span> <span class="n">leftmost</span>
            <span class="k">while</span> <span class="n">head</span><span class="p">:</span>
                <span class="c1"># Connection 1: Left -&gt; Right (Same Parent)
</span>                <span class="n">head</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">head</span><span class="p">.</span><span class="n">right</span>
                
                <span class="c1"># Connection 2: Right -&gt; Next's Left (Different Parent)
</span>                <span class="k">if</span> <span class="n">head</span><span class="p">.</span><span class="nb">next</span><span class="p">:</span>
                    <span class="n">head</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">head</span><span class="p">.</span><span class="nb">next</span><span class="p">.</span><span class="n">left</span>
                
                <span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="p">.</span><span class="nb">next</span>
            
            <span class="n">leftmost</span> <span class="o">=</span> <span class="n">leftmost</span><span class="p">.</span><span class="n">left</span>
            
        <span class="k">return</span> <span class="n">root</span>
</code></pre></div></div>

<h2 id="advanced-variant-10-average-of-levels-in-binary-tree">Advanced Variant 10: Average of Levels in Binary Tree</h2>

<p><strong>Problem:</strong> return the average value of the nodes on each level in the form of an array.</p>

<p><strong>Intuition:</strong>
Standard BFS. Sum the values in the level loop, divide by <code class="language-plaintext highlighter-rouge">level_size</code>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">averageOfLevels</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span> <span class="k">return</span> <span class="p">[]</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">q</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">([</span><span class="n">root</span><span class="p">])</span>
        
        <span class="k">while</span> <span class="n">q</span><span class="p">:</span>
            <span class="n">level_sum</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">level_count</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
            
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">level_count</span><span class="p">):</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="nf">popleft</span><span class="p">()</span>
                <span class="n">level_sum</span> <span class="o">+=</span> <span class="n">node</span><span class="p">.</span><span class="n">val</span>
                <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">:</span> <span class="n">q</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">:</span> <span class="n">q</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
                
            <span class="n">res</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">level_sum</span> <span class="o">/</span> <span class="n">level_count</span><span class="p">)</span>
            
        <span class="k">return</span> <span class="n">res</span>
</code></pre></div></div>

<h2 id="advanced-variant-11-find-bottom-left-tree-value">Advanced Variant 11: Find Bottom Left Tree Value</h2>

<p><strong>Problem:</strong> Given the root of a binary tree, return the leftmost value in the last row of the tree.</p>

<p><strong>Intuition:</strong>
Right-to-Left BFS.
The last node visited will be the bottom-left node.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">findBottomLeftValue</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">q</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">([</span><span class="n">root</span><span class="p">])</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">root</span>
        <span class="k">while</span> <span class="n">q</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="nf">popleft</span><span class="p">()</span>
            <span class="c1"># Add Right first, then Left
</span>            <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">:</span> <span class="n">q</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">:</span> <span class="n">q</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">node</span><span class="p">.</span><span class="n">val</span>
</code></pre></div></div>

<h2 id="deep-dive-queue-implementation-array-vs-linked-list">Deep Dive: Queue Implementation (Array vs. Linked List)</h2>

<p><strong>Array (Python List):</strong></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">pop(0)</code> is (O(N)) because we have to shift all elements. <strong>Bad.</strong></li>
  <li><code class="language-plaintext highlighter-rouge">pop()</code> is (O(1)).</li>
</ul>

<p><strong>Linked List (Python deque):</strong></p>
<ul>
  <li>Doubly Linked List.</li>
  <li><code class="language-plaintext highlighter-rouge">popleft()</code> is (O(1)). <strong>Good.</strong></li>
  <li><code class="language-plaintext highlighter-rouge">append()</code> is (O(1)).</li>
</ul>

<p><strong>Circular Buffer (Ring Buffer):</strong></p>
<ul>
  <li>Fixed size array.</li>
  <li><code class="language-plaintext highlighter-rouge">head</code> and <code class="language-plaintext highlighter-rouge">tail</code> pointers wrap around.</li>
  <li>Used in low-latency systems (Network Drivers). No dynamic allocation overhead.</li>
</ul>

<h2 id="system-design-distributed-queue-kafka-vs-sqs">System Design: Distributed Queue (Kafka vs. SQS)</h2>

<p><strong>Interviewer:</strong> “We need a queue for our Distributed BFS. Should we use Kafka or SQS?”</p>

<p><strong>Candidate:</strong></p>
<ol>
  <li><strong>SQS (Simple Queue Service):</strong>
    <ul>
      <li><strong>Pros:</strong> Infinite scaling, no management.</li>
      <li><strong>Cons:</strong> No ordering guarantee (standard), expensive at high throughput.</li>
      <li><strong>Use Case:</strong> Task Queue (Celery).</li>
    </ul>
  </li>
  <li><strong>Kafka:</strong>
    <ul>
      <li><strong>Pros:</strong> High throughput (millions/sec), replayable (log), ordered within partition.</li>
      <li><strong>Cons:</strong> Hard to manage (Zookeeper), fixed partitions.</li>
      <li><strong>Use Case:</strong> Event Streaming, Data Pipeline.</li>
    </ul>
  </li>
</ol>

<p><strong>Decision:</strong> For BFS, we usually need a <strong>Priority Queue</strong> (to prioritize high-rank pages), so neither is perfect. We might use <strong>Redis Sorted Sets</strong>.</p>

<h2 id="advanced-variant-12-deepest-leaves-sum">Advanced Variant 12: Deepest Leaves Sum</h2>

<p><strong>Problem:</strong> Return the sum of values of the deepest leaves.</p>

<p><strong>Intuition:</strong>
Standard BFS. Reset <code class="language-plaintext highlighter-rouge">sum</code> at the start of each level. The last <code class="language-plaintext highlighter-rouge">sum</code> is the answer.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">deepestLeavesSum</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span> <span class="k">return</span> <span class="mi">0</span>
        <span class="n">q</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">([</span><span class="n">root</span><span class="p">])</span>
        <span class="n">level_sum</span> <span class="o">=</span> <span class="mi">0</span>
        
        <span class="k">while</span> <span class="n">q</span><span class="p">:</span>
            <span class="n">level_sum</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">q</span><span class="p">)):</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="nf">popleft</span><span class="p">()</span>
                <span class="n">level_sum</span> <span class="o">+=</span> <span class="n">node</span><span class="p">.</span><span class="n">val</span>
                <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">:</span> <span class="n">q</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">:</span> <span class="n">q</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">level_sum</span>
</code></pre></div></div>

<h2 id="appendix-e-the-word-ladder-pattern">Appendix E: The “Word Ladder” Pattern</h2>

<p><strong>Problem:</strong> Transform “hit” to “cog” by changing one letter at a time. Each intermediate word must exist in the dictionary. Return shortest path.</p>

<p><strong>Intuition:</strong>
This is BFS on an implicit graph.</p>
<ul>
  <li><strong>Nodes:</strong> Words.</li>
  <li><strong>Edges:</strong> Words differing by 1 letter.</li>
  <li><strong>Start:</strong> “hit”.</li>
  <li><strong>Target:</strong> “cog”.</li>
</ul>

<p><strong>Optimization:</strong>
Pre-process the dictionary into generic states:
<code class="language-plaintext highlighter-rouge">hot</code> -&gt; <code class="language-plaintext highlighter-rouge">*ot</code>, <code class="language-plaintext highlighter-rouge">h*t</code>, <code class="language-plaintext highlighter-rouge">ho*</code>.
Map <code class="language-plaintext highlighter-rouge">*ot</code> -&gt; <code class="language-plaintext highlighter-rouge">[hot, dot, lot]</code>.
This allows <code class="language-plaintext highlighter-rouge">O(1)</code> neighbor finding.</p>

<h2 id="deep-dive-python-deque-internals">Deep Dive: Python <code class="language-plaintext highlighter-rouge">deque</code> Internals</h2>

<p>Why is <code class="language-plaintext highlighter-rouge">deque</code> faster than <code class="language-plaintext highlighter-rouge">list</code> for popping from the front?
<strong>List:</strong> Contiguous memory array. <code class="language-plaintext highlighter-rouge">pop(0)</code> requires shifting (N-1) elements. (O(N)).
<strong>Deque:</strong> Doubly Linked List of <strong>Blocks</strong> (Arrays).</p>
<ul>
  <li>Each block stores 64 elements.</li>
  <li><code class="language-plaintext highlighter-rouge">popleft()</code> just increments a pointer in the first block.</li>
  <li>If the block becomes empty, we unlink it. (O(1)).</li>
  <li><strong>Cache Locality:</strong> Better than a standard Linked List (one node per element) because of the block structure.</li>
</ul>

<h2 id="advanced-variant-13-check-completeness-of-a-binary-tree">Advanced Variant 13: Check Completeness of a Binary Tree</h2>

<p><strong>Problem:</strong> Check if the tree is a <strong>Complete Binary Tree</strong> (filled left to right).
<strong>Intuition:</strong>
Level Order Traversal.
If we see a <code class="language-plaintext highlighter-rouge">null</code> node, we should <strong>never</strong> see a non-null node again.
If we do, it’s not complete.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">isCompleteTree</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">q</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">([</span><span class="n">root</span><span class="p">])</span>
        <span class="n">seen_null</span> <span class="o">=</span> <span class="bp">False</span>
        
        <span class="k">while</span> <span class="n">q</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="nf">popleft</span><span class="p">()</span>
            
            <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="p">:</span>
                <span class="n">seen_null</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">seen_null</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">False</span>
                <span class="n">q</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
                <span class="n">q</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
                
        <span class="k">return</span> <span class="bp">True</span>
</code></pre></div></div>

<h2 id="advanced-variant-14-maximum-level-sum-of-a-binary-tree">Advanced Variant 14: Maximum Level Sum of a Binary Tree</h2>

<p><strong>Problem:</strong> Return the level number (1-indexed) with the maximum sum.</p>

<p><strong>Intuition:</strong>
Standard BFS. Track <code class="language-plaintext highlighter-rouge">max_sum</code> and <code class="language-plaintext highlighter-rouge">max_level</code>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">maxLevelSum</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span> <span class="k">return</span> <span class="mi">0</span>
        <span class="n">q</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">([</span><span class="n">root</span><span class="p">])</span>
        <span class="n">max_sum</span> <span class="o">=</span> <span class="nf">float</span><span class="p">(</span><span class="sh">'</span><span class="s">-inf</span><span class="sh">'</span><span class="p">)</span>
        <span class="n">max_level</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">curr_level</span> <span class="o">=</span> <span class="mi">1</span>
        
        <span class="k">while</span> <span class="n">q</span><span class="p">:</span>
            <span class="n">level_sum</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">level_len</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
            
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">level_len</span><span class="p">):</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="nf">popleft</span><span class="p">()</span>
                <span class="n">level_sum</span> <span class="o">+=</span> <span class="n">node</span><span class="p">.</span><span class="n">val</span>
                <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">:</span> <span class="n">q</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">:</span> <span class="n">q</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">level_sum</span> <span class="o">&gt;</span> <span class="n">max_sum</span><span class="p">:</span>
                <span class="n">max_sum</span> <span class="o">=</span> <span class="n">level_sum</span>
                <span class="n">max_level</span> <span class="o">=</span> <span class="n">curr_level</span>
                
            <span class="n">curr_level</span> <span class="o">+=</span> <span class="mi">1</span>
            
        <span class="k">return</span> <span class="n">max_level</span>
</code></pre></div></div>

<h2 id="advanced-variant-15-even-odd-tree">Advanced Variant 15: Even Odd Tree</h2>

<p><strong>Problem:</strong></p>
<ul>
  <li>Even-indexed levels: Strictly increasing, odd values.</li>
  <li>Odd-indexed levels: Strictly decreasing, even values.</li>
</ul>

<p><strong>Intuition:</strong>
BFS with a toggle flag. Check conditions inside the loop.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">isEvenOddTree</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">q</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">([</span><span class="n">root</span><span class="p">])</span>
        <span class="n">level</span> <span class="o">=</span> <span class="mi">0</span>
        
        <span class="k">while</span> <span class="n">q</span><span class="p">:</span>
            <span class="n">prev</span> <span class="o">=</span> <span class="nf">float</span><span class="p">(</span><span class="sh">'</span><span class="s">-inf</span><span class="sh">'</span><span class="p">)</span> <span class="k">if</span> <span class="n">level</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="nf">float</span><span class="p">(</span><span class="sh">'</span><span class="s">inf</span><span class="sh">'</span><span class="p">)</span>
            
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">q</span><span class="p">)):</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="nf">popleft</span><span class="p">()</span>
                
                <span class="k">if</span> <span class="n">level</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># Even Level: Odd values, Increasing
</span>                    <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">val</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">node</span><span class="p">.</span><span class="n">val</span> <span class="o">&lt;=</span> <span class="n">prev</span><span class="p">:</span>
                        <span class="k">return</span> <span class="bp">False</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Odd Level: Even values, Decreasing
</span>                    <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">val</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">node</span><span class="p">.</span><span class="n">val</span> <span class="o">&gt;=</span> <span class="n">prev</span><span class="p">:</span>
<span class="o">*</span><span class="n">If</span> <span class="n">you</span> <span class="n">found</span> <span class="n">this</span> <span class="n">helpful</span><span class="p">,</span> <span class="n">consider</span> <span class="n">sharing</span> <span class="n">it</span> <span class="k">with</span> <span class="n">others</span> <span class="n">who</span> <span class="n">might</span> <span class="n">benefit</span><span class="p">.</span><span class="o">*</span>


                        
                <span class="n">prev</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">val</span>
                <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">:</span> <span class="n">q</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">:</span> <span class="n">q</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
                
            <span class="n">level</span> <span class="o">+=</span> <span class="mi">1</span>
            
        <span class="k">return</span> <span class="bp">True</span>
</code></pre></div></div>

<h2 id="system-design-rate-limiter-token-bucket">System Design: Rate Limiter (Token Bucket)</h2>

<p><strong>Interviewer:</strong> “Design a Rate Limiter.”
<strong>Candidate:</strong> “We can use a <strong>Token Bucket</strong> algorithm.”</p>

<p><strong>Concept:</strong></p>
<ul>
  <li>A bucket holds <code class="language-plaintext highlighter-rouge">N</code> tokens.</li>
  <li>Tokens are added at rate <code class="language-plaintext highlighter-rouge">R</code> per second.</li>
  <li>A request consumes 1 token.</li>
  <li>If bucket is empty, reject request.</li>
</ul>

<p><strong>Implementation:</strong>
We don’t need a literal Queue. We can use a counter and a timestamp.
<code class="language-plaintext highlighter-rouge">current_tokens = min(capacity, previous_tokens + (now - last_refill_time) * rate)</code></p>

<p><strong>Distributed Rate Limiter:</strong>
Use Redis (Lua Script) to make the read-update-write atomic.
Or use a <strong>Sliding Window Log</strong> (Queue of timestamps) for strict accuracy (but high memory).</p>

<h2 id="advanced-variant-16-pseudo-palindromic-paths">Advanced Variant 16: Pseudo-Palindromic Paths</h2>

<p><strong>Problem:</strong> Return the number of paths from root to leaf where the path values can form a palindrome.
<strong>Intuition:</strong>
A path can form a palindrome if at most one number has an odd frequency.
We can use BFS (or DFS) and a bitmask to track parity of counts.
<code class="language-plaintext highlighter-rouge">mask ^= (1 &lt;&lt; node.val)</code>.
If <code class="language-plaintext highlighter-rouge">mask &amp; (mask - 1) == 0</code>, it’s a palindrome.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">pseudoPalindromicPaths</span> <span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># (node, mask)
</span>        <span class="n">q</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">([(</span><span class="n">root</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>
        
        <span class="k">while</span> <span class="n">q</span><span class="p">:</span>
            <span class="n">node</span><span class="p">,</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="nf">popleft</span><span class="p">()</span>
            <span class="n">mask</span> <span class="o">^=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">node</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">mask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">mask</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
            
            <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">:</span> <span class="n">q</span><span class="p">.</span><span class="nf">append</span><span class="p">((</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">mask</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">:</span> <span class="n">q</span><span class="p">.</span><span class="nf">append</span><span class="p">((</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">,</span> <span class="n">mask</span><span class="p">))</span>
            
        <span class="k">return</span> <span class="n">count</span>
</code></pre></div></div>

<h2 id="conclusion">Conclusion</h2>

<p>Level Order Traversal is the “Hello World” of BFS.
Mastering the <code class="language-plaintext highlighter-rouge">while queue: ... for _ in range(len(queue)):</code> pattern is crucial. It appears in graph problems, tree problems, and even matrix problems (Rotting Oranges).</p>

        
      </section>

      <footer class="page__meta">
        
        
  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-tags" aria-hidden="true"></i> Tags: </strong>
    <span itemprop="keywords">
    
      <a href="/tags/#bfs" class="page__taxonomy-item p-category" rel="tag">bfs</a><span class="sep">, </span>
    
      <a href="/tags/#binary-tree" class="page__taxonomy-item p-category" rel="tag">binary-tree</a><span class="sep">, </span>
    
      <a href="/tags/#medium" class="page__taxonomy-item p-category" rel="tag">medium</a><span class="sep">, </span>
    
      <a href="/tags/#queue" class="page__taxonomy-item p-category" rel="tag">queue</a>
    
    </span>
  </p>




  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> Categories: </strong>
    <span itemprop="keywords">
    
      <a href="/categories/#dsa" class="page__taxonomy-item p-category" rel="tag">dsa</a>
    
    </span>
  </p>


        
      </footer>

      <div class="page__related page__related--full">
  <h2 class="page__related-title">Related across topics</h2>
  <style>
    /* Make section span full content width and use 2 equal columns */
    .page__related--full { float: inline-start; width: 100%; padding: 0; }
    .cross-related-grid { display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 2rem; }
    @media (max-width: 768px) { .cross-related-grid { grid-template-columns: 1fr; } }
    /* Ensure archive cards stretch nicely in the grid */
    .cross-related-grid .list__item, .cross-related-grid .grid__item { width: auto; float: none; margin: 0; }
  </style>
  <div class="cross-related-grid">
    



<div class="list__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/ml-system-design/0026-batch-processing-pipelines/" rel="permalink">Batch Processing Pipelines
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          13 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">Not everything needs to be real-time. Sometimes, “tomorrow morning” is fast enough.
</p>
  </article>
</div>




<div class="list__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/speech-tech/0026-batch-speech-processing/" rel="permalink">Batch Speech Processing
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          9 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">Real-time ASR is hard. Offline ASR is big.
</p>
  </article>
</div>

  </div>
</div>

      <section class="page__share">
  <h4 class="page__share-title">Share on</h4>

  <a href="https://twitter.com/intent/tweet?via=arunbaby0&text=Binary+Tree+Level+Order+Traversal%20https%3A%2F%2Fwww.arunbaby.com%2Fdsa%2F0026-level-order-traversal%2F" class="btn btn--twitter" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Twitter"><i class="fab fa-fw fa-twitter" aria-hidden="true"></i><span> Twitter</span></a>

  <a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fwww.arunbaby.com%2Fdsa%2F0026-level-order-traversal%2F" class="btn btn--facebook" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Facebook"><i class="fab fa-fw fa-facebook" aria-hidden="true"></i><span> Facebook</span></a>

  <a href="https://www.linkedin.com/shareArticle?mini=true&url=https://www.arunbaby.com/dsa/0026-level-order-traversal/" class="btn btn--linkedin" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on LinkedIn"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i><span> LinkedIn</span></a>
</section>


      
  <nav class="pagination">
    
      <a href="/dsa/0025-validate-bst/" class="pagination--pager" title="Validate Binary Search Tree">Previous</a>
    
    
      <a href="/dsa/0027-construct-binary-tree/" class="pagination--pager" title="Construct Binary Tree from Preorder and Inorder Traversal">Next</a>
    
  </nav>


    </div>

    
  </article>

  
  
</div>

      
    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';" role="search">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Enter your search term..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    

    
      
        
          <li><a href="https://twitter.com/arunbaby0" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-twitter-square" aria-hidden="true"></i> Twitter</a></li>
        
      
        
          <li><a href="https://github.com/arunbaby0" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
        
      
        
          <li><a href="https://www.linkedin.com/in/arunbaby0/" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i> LinkedIn</a></li>
        
      
        
          <li><a href="https://scholar.google.co.in/citations?user=6fSYWhkAAAAJ" rel="nofollow noopener noreferrer"><i class="fas fa-fw fa-graduation-cap" aria-hidden="true"></i> Google Scholar</a></li>
        
      
    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 1990 - 2143 <a href="https://www.arunbaby.com">Arun Baby</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>




  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-0JRJPEC9SS"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-0JRJPEC9SS', { 'anonymize_ip': false});
</script>








  </body>
</html>
