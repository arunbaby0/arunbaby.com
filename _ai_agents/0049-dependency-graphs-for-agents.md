---
title: "Dependency Graphs for Agents"
day: 49
collection: ai_agents
categories:
  - ai-agents
tags:
  - langgraph
  - planning
  - task-decomposition
  - dag
  - agent-architecture
difficulty: Hard
subdomain: "Agent Architecture"
tech_stack: Python, LangGraph, LangChain
scale: "Dynamic graphs generated at runtime"
companies: LangChain, AutoGPT, Microsoft (AutoGen)
related_dsa_day: 49
related_ml_day: 49
related_speech_day: 49
---

**"Agents don't just follow instructions. They plan. And a plan is just a dependency graph."**

## 1. Introduction: The "Planner" Agent

Simple agents are loops: `while True: think() -> act()`.
This works for "Search Google". It fails for "Research the history of Rome, compare it to the US, and write an essay".

If a simple agent tries this, it gets lost. It searches Rome. It forgets about the US. It writes a bad essay.
Advanced agents use a **Planning Step**. They break a high-level goal into a **Task Graph**.

- Task A: Research Rome.
- Task B: Research US.
- Task C: Compare A & B. (Dependencies: A, B)
- Task D: Write Essay. (Dependencies: C)

Unlike MLOps pipelines which are static (defined by engineers), Agent DAGs are **dynamic** (generated by the LLM itself).

---

## 2. Generating the Graph (The "Architecture" Prompt)

How do we get an LLM to output a DAG? We ask for it in JSON.

**System Prompt:**
"You are a Project Manager. Break the user query into atomic tasks. For each task, list its `dependencies` (IDs of tasks that must finish first)."

**User:** "Compare the battery life of iPhone 15 and Pixel 8."

**Agent Output:**
```json
{
  "tasks": [
    {"id": 1, "task": "Search iPhone 15 battery specs", "dependencies": []},
    {"id": 2, "task": "Search Pixel 8 battery specs", "dependencies": []},
    {"id": 3, "task": "Compare specs and summarize", "dependencies": [1, 2]}
  ]
}
```

This JSON *is* our Graph. The Agent Runtime parses this and executes it.

---

## 3. Execution: The Topological Walker

Once we have the plan, we need an **Executor**. The Executor logic is identical to **Kahn's Algorithm** (Day 49 DSA).

1. **Loop**:
2. Find all tasks where `status == PENDING` and `dependencies` are all `COMPLETED`.
   - In our example: Task 1 and Task 2 are ready immediately.
3. **Execute**:
   - Run Task 1 (Search) and Task 2 (Search) **in parallel**.
   - This makes the agent 2x faster than a sequential agent!
4. **Update**:
   - Mark 1 and 2 as COMPLETED. Store their results in a shared state.
5. **Loop**:
   - Now Task 3's dependencies are met. Run Task 3.

---

## 4. Why LangGraph?

Standard graphs are DAGs (Directed Acyclic Graphs).
But Agents often need **Cycles**.

- **Example**: "Write code. Test it. If error, Fix code. Test again."
- This is a loop: `Code -> Test -> (if fail) Code`.

**LangGraph** is a library specifically designed to model these **State Machines**.
It allows us to define:
- **Nodes**: Agent functions (Writer, Tester).
- **Edges**: Deterministic transitions (`Writer -> Tester`).
- **Conditional Edge**: `Tester -> (success ? End : Writer)`.

This cyclic capability is what separates "Task Pipelines" (Airflow) from "Agent Cognitive Architectures" (LangGraph).

---

## 5. Challenges in Dynamic Graphs

### 5.1 The "Forever Loop"
If the Agent gets stuck in a cycle ("Fix code" -> "Test" -> "Still broken" -> "Fix code"...), it can burn infinite money.
**Solution**: Maximum recursion depth (e.g., max 5 retries).

### 5.2 Context Window Explosion
Task 1 generates 5 pages of text. Task 2 generates 5 pages.
Task 3 (Compare) receives 10 pages of input context.
This can crash the context window or confuse the model.
**Solution**: Add a "Summarizer" step to the graph edges to compress information passing between nodes.

---

## 6. Summary

The most powerful agents today (like **Devin** or **AutoGPT**) are not single LLM calls. They are engines that:
1. **Plan**: Generate a graph of tasks.
2. **Execute**: Traverse the graph (often correctly handling dependencies).
3. **Reflect**: Modify the graph at runtime if a task fails.

By explicitly modeling dependencies, we enable parallelism, error handling, and complex multi-step reasoning that single-shot prompts can never achieve.

---

**Originally published at:** [arunbaby.com/ai-agents/0049-dependency-graphs-for-agents](https://www.arunbaby.com/ai-agents/0049-dependency-graphs-for-agents/)

*If you found this helpful, consider sharing it with others who might benefit.*
