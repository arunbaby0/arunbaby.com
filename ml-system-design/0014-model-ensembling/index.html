<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.26.2 by Michael Rose
  Copyright 2013-2024 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->

<html lang="en-US" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Model Ensembling - Arun Baby</title>
<meta name="description" content="Build production ensemble systems that combine multiple models using backtracking strategies to explore optimal combinations.">


  <meta name="author" content="Arun Baby">
  
  <meta property="article:author" content="Arun Baby">
  


<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="Arun Baby">
<meta property="og:title" content="Model Ensembling">
<meta property="og:url" content="https://www.arunbaby.com/ml-system-design/0014-model-ensembling/">


  <meta property="og:description" content="Build production ensemble systems that combine multiple models using backtracking strategies to explore optimal combinations.">



  <meta property="og:image" content="https://www.arunbaby.com/assets/images/profile-photo.png">



  <meta name="twitter:site" content="@arunbaby0">
  <meta name="twitter:title" content="Model Ensembling">
  <meta name="twitter:description" content="Build production ensemble systems that combine multiple models using backtracking strategies to explore optimal combinations.">
  <meta name="twitter:url" content="https://www.arunbaby.com/ml-system-design/0014-model-ensembling/">

  
    <meta name="twitter:card" content="summary">
    
      <meta name="twitter:image" content="https://www.arunbaby.com/assets/images/profile-photo.png">
    
  

  



  <meta property="article:published_time" content="2025-10-27T23:05:50+05:30">





  

  


<link rel="canonical" href="https://www.arunbaby.com/ml-system-design/0014-model-ensembling/">












<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Arun Baby Feed">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
  
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css"></noscript>



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--single" dir="ltr">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
           
          <span class="site-subtitle">Arun Baby</span>
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a
                href="/about/"
                
                
              >About</a>
            </li><li class="masthead__menu-item">
              <a
                href="/dsa/"
                
                
              >DSA</a>
            </li><li class="masthead__menu-item">
              <a
                href="/ml-system-design/"
                
                
              >ML Systems</a>
            </li><li class="masthead__menu-item">
              <a
                href="/speech-tech/"
                
                
              >Speech Tech</a>
            </li><li class="masthead__menu-item">
              <a
                href="/publications/"
                
                
              >Publications</a>
            </li><li class="masthead__menu-item">
              <a
                href="/statuses/"
                
                
              >Statuses</a>
            </li><li class="masthead__menu-item">
              <a
                href="/contact/"
                
                
              >Contact</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <i class="fas fa-search"></i>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      





<div id="main" role="main" class="no-author-sidebar">
  
  <div class="sidebar sticky">
  
  
  </div>



  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="Model Ensembling">
    <meta itemprop="description" content="Build production ensemble systems that combine multiple models using backtracking strategies to explore optimal combinations.">
    <meta itemprop="datePublished" content="2025-10-27T23:05:50+05:30">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">
            <a href="https://www.arunbaby.com/ml-system-design/0014-model-ensembling/" itemprop="url">Model Ensembling
</a>
          </h1>
          

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          25 minute read
        
      </span>
    
  </p>


        </header>
      

      <section class="page__content" itemprop="text">
        
          <aside class="sidebar__right sticky">
            <nav class="toc">
              <header><h4 class="nav__title"><i class="fas fa-file-alt"></i> On this page</h4></header>
              <ul class="toc__menu"><li><a href="#problem-statement">Problem Statement</a><ul><li><a href="#functional-requirements">Functional Requirements</a></li><li><a href="#non-functional-requirements">Non-Functional Requirements</a></li></ul></li><li><a href="#understanding-the-requirements">Understanding the Requirements</a><ul><li><a href="#when-to-use-ensembles">When to Use Ensembles</a></li><li><a href="#real-world-examples">Real-World Examples</a></li><li><a href="#the-backtracking-connection">The Backtracking Connection</a></li></ul></li><li><a href="#high-level-architecture">High-Level Architecture</a><ul><li><a href="#key-components">Key Components</a></li></ul></li><li><a href="#component-deep-dives">Component Deep-Dives</a><ul><li><a href="#1-ensemble-orchestrator---model-selection">1. Ensemble Orchestrator - Model Selection</a></li><li><a href="#2-combination-strategies">2. Combination Strategies</a></li><li><a href="#3-diversity-optimization">3. Diversity Optimization</a></li><li><a href="#4-dynamic-ensemble-selection">4. Dynamic Ensemble Selection</a></li></ul></li><li><a href="#data-flow">Data Flow</a><ul><li><a href="#prediction-pipeline">Prediction Pipeline</a></li><li><a href="#training-pipeline">Training Pipeline</a></li></ul></li><li><a href="#scaling-strategies">Scaling Strategies</a><ul><li><a href="#horizontal-scaling---parallel-inference">Horizontal Scaling - Parallel Inference</a></li><li><a href="#vertical-scaling---model-compression">Vertical Scaling - Model Compression</a></li></ul></li><li><a href="#implementation-complete-system">Implementation: Complete System</a></li><li><a href="#real-world-case-study-netflix-recommendation-ensemble">Real-World Case Study: Netflix Recommendation Ensemble</a><ul><li><a href="#netflixs-approach">Netflix’s Approach</a></li><li><a href="#key-lessons">Key Lessons</a></li></ul></li><li><a href="#cost-analysis">Cost Analysis</a><ul><li><a href="#cost-breakdown-1m-predictionsday">Cost Breakdown (1M predictions/day)</a></li><li><a href="#optimization-strategies">Optimization Strategies</a></li></ul></li><li><a href="#key-takeaways">Key Takeaways</a><ul><li><a href="#connection-to-day-14-theme-backtracking-and-combination-strategies">Connection to Day 14 Theme: Backtracking and Combination Strategies</a></li></ul></li></ul>
            </nav>
          </aside>
        
        <p><strong>Build production ensemble systems that combine multiple models using backtracking strategies to explore optimal combinations.</strong></p>

<h2 id="problem-statement">Problem Statement</h2>

<p>Design a <strong>Model Ensembling System</strong> that combines predictions from multiple ML models to achieve better accuracy, robustness, and reliability than any single model.</p>

<h3 id="functional-requirements">Functional Requirements</h3>

<ol>
  <li><strong>Model combination:</strong> Aggregate predictions from N heterogeneous models</li>
  <li><strong>Combination strategies:</strong> Support voting, averaging, stacking, boosting</li>
  <li><strong>Dynamic selection:</strong> Choose best subset of models based on input characteristics</li>
  <li><strong>Confidence scoring:</strong> Provide uncertainty estimates</li>
  <li><strong>Fallback handling:</strong> Gracefully handle model failures</li>
  <li><strong>A/B testing:</strong> Compare ensemble vs individual models</li>
  <li><strong>Model versioning:</strong> Support multiple versions of same model</li>
  <li><strong>Real-time inference:</strong> Serve predictions with low latency</li>
</ol>

<h3 id="non-functional-requirements">Non-Functional Requirements</h3>

<ol>
  <li><strong>Latency:</strong> p95 &lt; 100ms for inference</li>
  <li><strong>Throughput:</strong> 100K+ predictions/second</li>
  <li><strong>Accuracy:</strong> +5-10% improvement over single best model</li>
  <li><strong>Availability:</strong> 99.95% uptime (handle individual model failures)</li>
  <li><strong>Scalability:</strong> Support 100+ models in ensemble</li>
  <li><strong>Cost efficiency:</strong> Optimal resource usage</li>
  <li><strong>Explainability:</strong> Understand why ensemble made prediction</li>
</ol>

<h2 id="understanding-the-requirements">Understanding the Requirements</h2>

<p>Model ensembles are <strong>widely used in production</strong> because they:</p>

<ol>
  <li><strong>Improve accuracy:</strong> Reduce bias and variance</li>
  <li><strong>Increase robustness:</strong> No single point of failure</li>
  <li><strong>Handle uncertainty:</strong> Better calibrated confidence scores</li>
  <li><strong>Leverage diversity:</strong> Different models capture different patterns</li>
</ol>

<h3 id="when-to-use-ensembles">When to Use Ensembles</h3>

<p><strong>Good use cases:</strong></p>
<ul>
  <li><strong>High-stakes predictions:</strong> Fraud detection, medical diagnosis</li>
  <li><strong>Complex problems:</strong> Multiple weak signals</li>
  <li><strong>Competitive ML:</strong> Kaggle, research benchmarks</li>
  <li><strong>Production stability:</strong> Reduce risk of single model failure</li>
</ul>

<p><strong>Not ideal when:</strong></p>
<ul>
  <li><strong>Latency critical:</strong> &lt;10ms requirements</li>
  <li><strong>Resource constrained:</strong> Mobile/edge deployment</li>
  <li><strong>Interpretability required:</strong> Individual model predictions needed</li>
  <li><strong>Simple problem:</strong> Single model already achieves 99%+ accuracy</li>
</ul>

<h3 id="real-world-examples">Real-World Examples</h3>

<table>
  <thead>
    <tr>
      <th>Company</th>
      <th>Use Case</th>
      <th>Ensemble Approach</th>
      <th>Results</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Netflix</td>
      <td>Recommendation</td>
      <td>Collaborative filtering + content-based + deep learning</td>
      <td>+10% engagement</td>
    </tr>
    <tr>
      <td>Spotify</td>
      <td>Music recommendation</td>
      <td>Audio features + CF + NLP + context</td>
      <td>+15% listening time</td>
    </tr>
    <tr>
      <td>Airbnb</td>
      <td>Price prediction</td>
      <td>GBM + Linear + Neural network</td>
      <td>-5% RMSE</td>
    </tr>
    <tr>
      <td>Uber</td>
      <td>ETA prediction</td>
      <td>LightGBM ensemble + traffic models</td>
      <td>+12% accuracy</td>
    </tr>
    <tr>
      <td>Kaggle Winners</td>
      <td>Various</td>
      <td>Stacked ensembles of 50-100 models</td>
      <td>Consistent top ranks</td>
    </tr>
  </tbody>
</table>

<h3 id="the-backtracking-connection">The Backtracking Connection</h3>

<p>Just like <strong>Generate Parentheses</strong> (Day 14 DSA):</p>

<table>
  <thead>
    <tr>
      <th>Generate Parentheses</th>
      <th>Model Ensembling</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Generate valid string combinations</td>
      <td>Generate valid model combinations</td>
    </tr>
    <tr>
      <td>Constraints: balanced parens</td>
      <td>Constraints: latency, diversity, accuracy</td>
    </tr>
    <tr>
      <td>Backtracking to explore all paths</td>
      <td>Backtracking to explore ensemble configurations</td>
    </tr>
    <tr>
      <td>Prune invalid branches early</td>
      <td>Prune underperforming combinations early</td>
    </tr>
    <tr>
      <td>Result: all valid strings</td>
      <td>Result: all viable ensembles</td>
    </tr>
  </tbody>
</table>

<p><strong>Core pattern:</strong> Use backtracking to explore the space of possible model combinations and select the best one.</p>

<h2 id="high-level-architecture">High-Level Architecture</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌─────────────────────────────────────────────────────────────────┐
│                      Ensemble System                             │
└─────────────────────────────────────────────────────────────────┘

                            ┌──────────────┐
                            │   Request    │
                            │   (Features) │
                            └──────┬───────┘
                                   │
                    ┌──────────────▼──────────────┐
                    │   Ensemble Orchestrator     │
                    │   - Route to models         │
                    │   - Collect predictions     │
                    │   - Apply combination       │
                    └──────────────┬──────────────┘
                                   │
        ┌──────────────────────────┼──────────────────────────┐
        │                          │                          │
┌───────▼────────┐        ┌───────▼────────┐        ┌───────▼────────┐
│   Model 1      │        │   Model 2      │        │   Model N      │
│   (XGBoost)    │        │   (Neural Net) │        │   (Linear)     │
│                │        │                │        │                │
│  Pred: 0.85    │        │  Pred: 0.72    │        │  Pred: 0.79    │
└────────┬───────┘        └────────┬───────┘        └────────┬───────┘
         │                         │                         │
         └─────────────────────────┼─────────────────────────┘
                                   │
                    ┌──────────────▼──────────────┐
                    │   Combiner                  │
                    │   - Voting / Averaging      │
                    │   - Stacking                │
                    │   - Weighted combination    │
                    └──────────────┬──────────────┘
                                   │
                            ┌──────▼───────┐
                            │  Final Pred  │
                            │   0.80       │
                            │  (conf 0.92) │
                            └──────────────┘
</code></pre></div></div>

<h3 id="key-components">Key Components</h3>

<ol>
  <li><strong>Ensemble Orchestrator:</strong> Routes requests, manages model execution</li>
  <li><strong>Base Models:</strong> Individual models (diverse architectures)</li>
  <li><strong>Combiner:</strong> Aggregates predictions using chosen strategy</li>
  <li><strong>Meta-learner:</strong> (Optional) Learns how to combine predictions</li>
  <li><strong>Monitoring:</strong> Tracks individual and ensemble performance</li>
</ol>

<h2 id="component-deep-dives">Component Deep-Dives</h2>

<h3 id="1-ensemble-orchestrator---model-selection">1. Ensemble Orchestrator - Model Selection</h3>

<p>The orchestrator decides which models to query using backtracking:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">dataclasses</span> <span class="kn">import</span> <span class="n">dataclass</span>
<span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Callable</span>
<span class="kn">from</span> <span class="n">enum</span> <span class="kn">import</span> <span class="n">Enum</span>
<span class="kn">import</span> <span class="n">asyncio</span>
<span class="kn">import</span> <span class="n">time</span>

<span class="k">class</span> <span class="nc">ModelStatus</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">Model health status.</span><span class="sh">"""</span>
    <span class="n">HEALTHY</span> <span class="o">=</span> <span class="sh">"</span><span class="s">healthy</span><span class="sh">"</span>
    <span class="n">DEGRADED</span> <span class="o">=</span> <span class="sh">"</span><span class="s">degraded</span><span class="sh">"</span>
    <span class="n">FAILED</span> <span class="o">=</span> <span class="sh">"</span><span class="s">failed</span><span class="sh">"</span>

<span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">Model</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">Represents a single model in the ensemble.</span><span class="sh">"""</span>
    <span class="n">model_id</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">model_type</span><span class="p">:</span> <span class="nb">str</span>  <span class="c1"># "xgboost", "neural_net", "linear", etc.
</span>    <span class="n">version</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">avg_latency_ms</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">accuracy</span><span class="p">:</span> <span class="nb">float</span>  <span class="c1"># On validation set
</span>    <span class="n">status</span><span class="p">:</span> <span class="n">ModelStatus</span> <span class="o">=</span> <span class="n">ModelStatus</span><span class="p">.</span><span class="n">HEALTHY</span>
    
    <span class="c1"># For diversity
</span>    <span class="n">architecture</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="sh">""</span>
    <span class="n">training_data</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="sh">""</span>
    
    <span class="k">async</span> <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">features</span><span class="p">:</span> <span class="n">Dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sh">"""</span><span class="s">Make prediction (async for parallel execution).</span><span class="sh">"""</span>
        <span class="c1"># Simulate prediction
</span>        <span class="k">await</span> <span class="n">asyncio</span><span class="p">.</span><span class="nf">sleep</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">avg_latency_ms</span> <span class="o">/</span> <span class="mf">1000.0</span><span class="p">)</span>
        
        <span class="c1"># In production: call actual model
</span>        <span class="c1"># return self.model.predict(features)
</span>        
        <span class="c1"># For demo: return dummy prediction
</span>        <span class="k">return</span> <span class="mf">0.5</span> <span class="o">+</span> <span class="nf">hash</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">model_id</span><span class="p">)</span> <span class="o">%</span> <span class="mi">50</span> <span class="o">/</span> <span class="mf">100.0</span>

<span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">EnsembleConfig</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">Configuration for ensemble.</span><span class="sh">"""</span>
    <span class="n">max_models</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="n">max_latency_ms</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">100.0</span>
    <span class="n">min_diversity</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.3</span>  <span class="c1"># Min difference in architecture
</span>    <span class="n">combination_strategy</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="sh">"</span><span class="s">voting</span><span class="sh">"</span>  <span class="c1"># "voting", "averaging", "stacking"
</span>    
<span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">EnsembleResult</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">Result from ensemble prediction.</span><span class="sh">"""</span>
    <span class="n">prediction</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">confidence</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">models_used</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>
    <span class="n">latency_ms</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">individual_predictions</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span>


<span class="k">class</span> <span class="nc">EnsembleOrchestrator</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">
    Orchestrates ensemble prediction using backtracking for model selection.
    
    Similar to Generate Parentheses:
    - Explore combinations of models
    - Prune combinations that violate constraints
    - Select optimal subset
    </span><span class="sh">"""</span>
    
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">config</span><span class="p">:</span> <span class="n">EnsembleConfig</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">config</span> <span class="o">=</span> <span class="n">config</span>
        <span class="n">self</span><span class="p">.</span><span class="n">models</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Model</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        
    <span class="k">def</span> <span class="nf">add_model</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">model</span><span class="p">:</span> <span class="n">Model</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">Add a model to the ensemble.</span><span class="sh">"""</span>
        <span class="n">self</span><span class="p">.</span><span class="n">models</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">select_models_backtracking</span><span class="p">(</span>
        <span class="n">self</span><span class="p">,</span>
        <span class="n">features</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span>
        <span class="n">max_latency</span><span class="p">:</span> <span class="nb">float</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Model</span><span class="p">]:</span>
        <span class="sh">"""</span><span class="s">
        Select best subset of models using backtracking.
        
        Similar to Generate Parentheses backtracking:
        1. Start with empty selection
        2. Try adding each model
        3. Check constraints (latency, diversity)
        4. Recurse to try more models
        5. Backtrack if constraints violated
        
        Constraints:
        - Total latency &lt;= max_latency
        - Model diversity &gt;= min_diversity
        - Number of models &lt;= max_models
        
        Returns:
            List of selected models
        </span><span class="sh">"""</span>
        <span class="n">best_selection</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">best_score</span> <span class="o">=</span> <span class="o">-</span><span class="nf">float</span><span class="p">(</span><span class="sh">'</span><span class="s">inf</span><span class="sh">'</span><span class="p">)</span>
        
        <span class="k">def</span> <span class="nf">calculate_diversity</span><span class="p">(</span><span class="n">models</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Model</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
            <span class="sh">"""</span><span class="s">Calculate diversity score for model set.</span><span class="sh">"""</span>
            <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">models</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="mf">1.0</span>
            
            <span class="c1"># Diversity = fraction of unique architectures
</span>            <span class="n">unique_archs</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="nf">set</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">architecture</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">models</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">unique_archs</span> <span class="o">/</span> <span class="nf">len</span><span class="p">(</span><span class="n">models</span><span class="p">)</span>
        
        <span class="k">def</span> <span class="nf">estimate_accuracy</span><span class="p">(</span><span class="n">models</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Model</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
            <span class="sh">"""</span><span class="s">Estimate ensemble accuracy from individual models.</span><span class="sh">"""</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">models</span><span class="p">:</span>
                <span class="k">return</span> <span class="mf">0.0</span>
            
            <span class="c1"># Simple heuristic: weighted average with diversity bonus
</span>            <span class="n">avg_acc</span> <span class="o">=</span> <span class="nf">sum</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">accuracy</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">models</span><span class="p">)</span> <span class="o">/</span> <span class="nf">len</span><span class="p">(</span><span class="n">models</span><span class="p">)</span>
            <span class="n">diversity_bonus</span> <span class="o">=</span> <span class="nf">calculate_diversity</span><span class="p">(</span><span class="n">models</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.1</span>
            <span class="k">return</span> <span class="n">avg_acc</span> <span class="o">+</span> <span class="n">diversity_bonus</span>
        
        <span class="k">def</span> <span class="nf">backtrack</span><span class="p">(</span>
            <span class="n">index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
            <span class="n">current_selection</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Model</span><span class="p">],</span>
            <span class="n">current_latency</span><span class="p">:</span> <span class="nb">float</span>
        <span class="p">):</span>
            <span class="sh">"""</span><span class="s">
            Backtracking function to explore model combinations.
            
            Args:
                index: Current model index to consider
                current_selection: Models selected so far
                current_latency: Cumulative latency
            </span><span class="sh">"""</span>
            <span class="k">nonlocal</span> <span class="n">best_selection</span><span class="p">,</span> <span class="n">best_score</span>
            
            <span class="c1"># Base case: evaluated all models
</span>            <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="nf">len</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">models</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">current_selection</span><span class="p">:</span>
                    <span class="n">score</span> <span class="o">=</span> <span class="nf">estimate_accuracy</span><span class="p">(</span><span class="n">current_selection</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">score</span> <span class="o">&gt;</span> <span class="n">best_score</span><span class="p">:</span>
                        <span class="n">best_score</span> <span class="o">=</span> <span class="n">score</span>
                        <span class="n">best_selection</span> <span class="o">=</span> <span class="n">current_selection</span><span class="p">[:]</span>
                <span class="k">return</span>
            
            <span class="n">model</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">models</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
            
            <span class="c1"># Skip unhealthy models
</span>            <span class="k">if</span> <span class="n">model</span><span class="p">.</span><span class="n">status</span> <span class="o">!=</span> <span class="n">ModelStatus</span><span class="p">.</span><span class="n">HEALTHY</span><span class="p">:</span>
                <span class="nf">backtrack</span><span class="p">(</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">current_selection</span><span class="p">,</span> <span class="n">current_latency</span><span class="p">)</span>
                <span class="k">return</span>
            
            <span class="c1"># Choice 1: Include current model (if constraints satisfied)
</span>            <span class="n">new_latency</span> <span class="o">=</span> <span class="n">current_latency</span> <span class="o">+</span> <span class="n">model</span><span class="p">.</span><span class="n">avg_latency_ms</span>
            
            <span class="n">can_add</span> <span class="o">=</span> <span class="p">(</span>
                <span class="nf">len</span><span class="p">(</span><span class="n">current_selection</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">self</span><span class="p">.</span><span class="n">config</span><span class="p">.</span><span class="n">max_models</span> <span class="ow">and</span>
                <span class="n">new_latency</span> <span class="o">&lt;=</span> <span class="n">max_latency</span> <span class="ow">and</span>
                <span class="nf">calculate_diversity</span><span class="p">(</span><span class="n">current_selection</span> <span class="o">+</span> <span class="p">[</span><span class="n">model</span><span class="p">])</span> <span class="o">&gt;=</span> <span class="n">self</span><span class="p">.</span><span class="n">config</span><span class="p">.</span><span class="n">min_diversity</span>
            <span class="p">)</span>
            
            <span class="k">if</span> <span class="n">can_add</span><span class="p">:</span>
                <span class="n">current_selection</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
                <span class="nf">backtrack</span><span class="p">(</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">current_selection</span><span class="p">,</span> <span class="n">new_latency</span><span class="p">)</span>
                <span class="n">current_selection</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>  <span class="c1"># Backtrack
</span>            
            <span class="c1"># Choice 2: Skip current model
</span>            <span class="nf">backtrack</span><span class="p">(</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">current_selection</span><span class="p">,</span> <span class="n">current_latency</span><span class="p">)</span>
        
        <span class="c1"># Start backtracking
</span>        <span class="nf">backtrack</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">[],</span> <span class="mf">0.0</span><span class="p">)</span>
        
        <span class="c1"># Ensure at least one model
</span>        <span class="k">if</span> <span class="ow">not</span> <span class="n">best_selection</span> <span class="ow">and</span> <span class="n">self</span><span class="p">.</span><span class="n">models</span><span class="p">:</span>
            <span class="c1"># Fallback: use single best model
</span>            <span class="n">best_selection</span> <span class="o">=</span> <span class="p">[</span><span class="nf">max</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">models</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">m</span><span class="p">:</span> <span class="n">m</span><span class="p">.</span><span class="n">accuracy</span><span class="p">)]</span>
        
        <span class="k">return</span> <span class="n">best_selection</span>
    
    <span class="k">async</span> <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">features</span><span class="p">:</span> <span class="n">Dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">EnsembleResult</span><span class="p">:</span>
        <span class="sh">"""</span><span class="s">
        Make ensemble prediction.
        
        Steps:
        1. Select models using backtracking
        2. Query selected models in parallel
        3. Combine predictions
        4. Return result with metadata
        </span><span class="sh">"""</span>
        <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">perf_counter</span><span class="p">()</span>
        
        <span class="c1"># Select models
</span>        <span class="n">selected_models</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">select_models_backtracking</span><span class="p">(</span>
            <span class="n">features</span><span class="p">,</span>
            <span class="n">max_latency</span><span class="o">=</span><span class="n">self</span><span class="p">.</span><span class="n">config</span><span class="p">.</span><span class="n">max_latency_ms</span>
        <span class="p">)</span>
        
        <span class="c1"># Query models in parallel (async)
</span>        <span class="n">prediction_tasks</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">model</span><span class="p">.</span><span class="nf">predict</span><span class="p">(</span><span class="n">features</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="n">selected_models</span>
        <span class="p">]</span>
        
        <span class="n">predictions</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="p">.</span><span class="nf">gather</span><span class="p">(</span><span class="o">*</span><span class="n">prediction_tasks</span><span class="p">)</span>
        
        <span class="c1"># Build predictions map
</span>        <span class="n">pred_map</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">model</span><span class="p">.</span><span class="n">model_id</span><span class="p">:</span> <span class="n">pred</span>
            <span class="k">for</span> <span class="n">model</span><span class="p">,</span> <span class="n">pred</span> <span class="ow">in</span> <span class="nf">zip</span><span class="p">(</span><span class="n">selected_models</span><span class="p">,</span> <span class="n">predictions</span><span class="p">)</span>
        <span class="p">}</span>
        
        <span class="c1"># Combine predictions
</span>        <span class="n">final_pred</span><span class="p">,</span> <span class="n">confidence</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">_combine_predictions</span><span class="p">(</span>
            <span class="n">selected_models</span><span class="p">,</span>
            <span class="n">predictions</span>
        <span class="p">)</span>
        
        <span class="c1"># Calculate latency
</span>        <span class="n">latency_ms</span> <span class="o">=</span> <span class="p">(</span><span class="n">time</span><span class="p">.</span><span class="nf">perf_counter</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1000</span>
        
        <span class="k">return</span> <span class="nc">EnsembleResult</span><span class="p">(</span>
            <span class="n">prediction</span><span class="o">=</span><span class="n">final_pred</span><span class="p">,</span>
            <span class="n">confidence</span><span class="o">=</span><span class="n">confidence</span><span class="p">,</span>
            <span class="n">models_used</span><span class="o">=</span><span class="p">[</span><span class="n">m</span><span class="p">.</span><span class="n">model_id</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">selected_models</span><span class="p">],</span>
            <span class="n">latency_ms</span><span class="o">=</span><span class="n">latency_ms</span><span class="p">,</span>
            <span class="n">individual_predictions</span><span class="o">=</span><span class="n">pred_map</span>
        <span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">_combine_predictions</span><span class="p">(</span>
        <span class="n">self</span><span class="p">,</span>
        <span class="n">models</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Model</span><span class="p">],</span>
        <span class="n">predictions</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
        <span class="sh">"""</span><span class="s">
        Combine predictions using configured strategy.
        
        Returns:
            (final_prediction, confidence)
        </span><span class="sh">"""</span>
        <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">config</span><span class="p">.</span><span class="n">combination_strategy</span> <span class="o">==</span> <span class="sh">"</span><span class="s">voting</span><span class="sh">"</span><span class="p">:</span>
            <span class="c1"># For binary classification: majority vote
</span>            <span class="n">votes</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="k">if</span> <span class="n">p</span> <span class="o">&gt;</span> <span class="mf">0.5</span> <span class="k">else</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">predictions</span><span class="p">]</span>
            <span class="n">final</span> <span class="o">=</span> <span class="nf">sum</span><span class="p">(</span><span class="n">votes</span><span class="p">)</span> <span class="o">/</span> <span class="nf">len</span><span class="p">(</span><span class="n">votes</span><span class="p">)</span>
            <span class="n">confidence</span> <span class="o">=</span> <span class="nf">abs</span><span class="p">(</span><span class="n">final</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span>  <span class="c1"># How confident is majority
</span>            
        <span class="k">elif</span> <span class="n">self</span><span class="p">.</span><span class="n">config</span><span class="p">.</span><span class="n">combination_strategy</span> <span class="o">==</span> <span class="sh">"</span><span class="s">averaging</span><span class="sh">"</span><span class="p">:</span>
            <span class="c1"># Simple average
</span>            <span class="n">final</span> <span class="o">=</span> <span class="nf">sum</span><span class="p">(</span><span class="n">predictions</span><span class="p">)</span> <span class="o">/</span> <span class="nf">len</span><span class="p">(</span><span class="n">predictions</span><span class="p">)</span>
            
            <span class="c1"># Confidence based on agreement
</span>            <span class="n">variance</span> <span class="o">=</span> <span class="nf">sum</span><span class="p">((</span><span class="n">p</span> <span class="o">-</span> <span class="n">final</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">predictions</span><span class="p">)</span> <span class="o">/</span> <span class="nf">len</span><span class="p">(</span><span class="n">predictions</span><span class="p">)</span>
            <span class="n">confidence</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">variance</span><span class="p">)</span>  <span class="c1"># High agreement = high confidence
</span>            
        <span class="k">elif</span> <span class="n">self</span><span class="p">.</span><span class="n">config</span><span class="p">.</span><span class="n">combination_strategy</span> <span class="o">==</span> <span class="sh">"</span><span class="s">weighted_averaging</span><span class="sh">"</span><span class="p">:</span>
            <span class="c1"># Weight by model accuracy
</span>            <span class="n">total_weight</span> <span class="o">=</span> <span class="nf">sum</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">accuracy</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">models</span><span class="p">)</span>
            <span class="n">final</span> <span class="o">=</span> <span class="nf">sum</span><span class="p">(</span>
                <span class="n">m</span><span class="p">.</span><span class="n">accuracy</span> <span class="o">*</span> <span class="n">p</span>
                <span class="k">for</span> <span class="n">m</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nf">zip</span><span class="p">(</span><span class="n">models</span><span class="p">,</span> <span class="n">predictions</span><span class="p">)</span>
            <span class="p">)</span> <span class="o">/</span> <span class="n">total_weight</span>
            
            <span class="c1"># Weighted variance for confidence
</span>            <span class="n">variance</span> <span class="o">=</span> <span class="nf">sum</span><span class="p">(</span>
                <span class="n">m</span><span class="p">.</span><span class="n">accuracy</span> <span class="o">*</span> <span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="n">final</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
                <span class="k">for</span> <span class="n">m</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nf">zip</span><span class="p">(</span><span class="n">models</span><span class="p">,</span> <span class="n">predictions</span><span class="p">)</span>
            <span class="p">)</span> <span class="o">/</span> <span class="n">total_weight</span>
            <span class="n">confidence</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">variance</span><span class="p">)</span>
            
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Default: simple average
</span>            <span class="n">final</span> <span class="o">=</span> <span class="nf">sum</span><span class="p">(</span><span class="n">predictions</span><span class="p">)</span> <span class="o">/</span> <span class="nf">len</span><span class="p">(</span><span class="n">predictions</span><span class="p">)</span>
            <span class="n">confidence</span> <span class="o">=</span> <span class="mf">0.5</span>
        
        <span class="k">return</span> <span class="n">final</span><span class="p">,</span> <span class="n">confidence</span>
</code></pre></div></div>

<h3 id="2-combination-strategies">2. Combination Strategies</h3>

<p>Different strategies for combining model predictions:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">LogisticRegression</span>
<span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>

<span class="k">class</span> <span class="nc">EnsembleCombiner</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">Different strategies for combining model predictions.</span><span class="sh">"""</span>
    
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">simple_voting</span><span class="p">(</span><span class="n">predictions</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sh">"""</span><span class="s">
        Majority voting for binary classification.
        
        Each model votes 0 or 1, return majority.
        </span><span class="sh">"""</span>
        <span class="n">votes</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="k">if</span> <span class="n">p</span> <span class="o">&gt;</span> <span class="n">threshold</span> <span class="k">else</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">predictions</span><span class="p">]</span>
        <span class="k">return</span> <span class="nf">sum</span><span class="p">(</span><span class="n">votes</span><span class="p">)</span> <span class="o">/</span> <span class="nf">len</span><span class="p">(</span><span class="n">votes</span><span class="p">)</span>
    
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">weighted_voting</span><span class="p">(</span>
        <span class="n">predictions</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
        <span class="n">weights</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sh">"""</span><span class="s">
        Weighted voting.
        
        Models with higher accuracy get more weight.
        </span><span class="sh">"""</span>
        <span class="n">total_weight</span> <span class="o">=</span> <span class="nf">sum</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
        <span class="k">return</span> <span class="nf">sum</span><span class="p">(</span><span class="n">w</span> <span class="o">*</span> <span class="n">p</span> <span class="k">for</span> <span class="n">w</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nf">zip</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">predictions</span><span class="p">))</span> <span class="o">/</span> <span class="n">total_weight</span>
    
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">simple_averaging</span><span class="p">(</span><span class="n">predictions</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sh">"""</span><span class="s">Simple arithmetic mean.</span><span class="sh">"""</span>
        <span class="k">return</span> <span class="nf">sum</span><span class="p">(</span><span class="n">predictions</span><span class="p">)</span> <span class="o">/</span> <span class="nf">len</span><span class="p">(</span><span class="n">predictions</span><span class="p">)</span>
    
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">geometric_mean</span><span class="p">(</span><span class="n">predictions</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sh">"""</span><span class="s">
        Geometric mean - useful when models have different scales.
        
        Formula: (p1 * p2 * ... * pn)^(1/n)
        </span><span class="sh">"""</span>
        <span class="n">product</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">predictions</span><span class="p">:</span>
            <span class="n">product</span> <span class="o">*=</span> <span class="nf">max</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mf">1e-10</span><span class="p">)</span>  <span class="c1"># Avoid zero
</span>        <span class="k">return</span> <span class="n">product</span> <span class="o">**</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="nf">len</span><span class="p">(</span><span class="n">predictions</span><span class="p">))</span>
    
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">rank_averaging</span><span class="p">(</span><span class="n">predictions</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sh">"""</span><span class="s">
        Average of ranks instead of raw predictions.
        
        Useful when models have different scales/calibrations.
        </span><span class="sh">"""</span>
        <span class="c1"># Sort predictions and assign ranks
</span>        <span class="n">sorted_preds</span> <span class="o">=</span> <span class="nf">sorted</span><span class="p">(</span><span class="nf">enumerate</span><span class="p">(</span><span class="n">predictions</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">ranks</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nf">len</span><span class="p">(</span><span class="n">predictions</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">rank</span><span class="p">,</span> <span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">sorted_preds</span><span class="p">):</span>
            <span class="n">ranks</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">rank</span>
        
        <span class="c1"># Normalize ranks to [0, 1]
</span>        <span class="n">avg_rank</span> <span class="o">=</span> <span class="nf">sum</span><span class="p">(</span><span class="n">ranks</span><span class="p">)</span> <span class="o">/</span> <span class="nf">len</span><span class="p">(</span><span class="n">ranks</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">avg_rank</span> <span class="o">/</span> <span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">ranks</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">ranks</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="mf">0.5</span>


<span class="k">class</span> <span class="nc">StackingCombiner</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">
    Stacking: Train a meta-model to combine base model predictions.
    
    This is the most powerful but also most complex approach.
    </span><span class="sh">"""</span>
    
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">meta_model</span> <span class="o">=</span> <span class="nc">LogisticRegression</span><span class="p">()</span>
        <span class="n">self</span><span class="p">.</span><span class="n">is_trained</span> <span class="o">=</span> <span class="bp">False</span>
    
    <span class="k">def</span> <span class="nf">train</span><span class="p">(</span>
        <span class="n">self</span><span class="p">,</span>
        <span class="n">base_predictions</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">,</span>  <span class="c1"># Shape: (n_samples, n_models)
</span>        <span class="n">true_labels</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span>
    <span class="p">):</span>
        <span class="sh">"""</span><span class="s">
        Train meta-model on base model predictions.
        
        Args:
            base_predictions: Predictions from base models (holdout set)
            true_labels: True labels
        </span><span class="sh">"""</span>
        <span class="n">self</span><span class="p">.</span><span class="n">meta_model</span><span class="p">.</span><span class="nf">fit</span><span class="p">(</span><span class="n">base_predictions</span><span class="p">,</span> <span class="n">true_labels</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">is_trained</span> <span class="o">=</span> <span class="bp">True</span>
    
    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">base_predictions</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sh">"""</span><span class="s">
        Predict using meta-model.
        
        Args:
            base_predictions: Predictions from base models
            
        Returns:
            Final ensemble predictions
        </span><span class="sh">"""</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">self</span><span class="p">.</span><span class="n">is_trained</span><span class="p">:</span>
            <span class="k">raise</span> <span class="nc">ValueError</span><span class="p">(</span><span class="sh">"</span><span class="s">Meta-model not trained. Call train() first.</span><span class="sh">"</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">meta_model</span><span class="p">.</span><span class="nf">predict_proba</span><span class="p">(</span><span class="n">base_predictions</span><span class="p">)[:,</span> <span class="mi">1</span><span class="p">]</span>
    
    <span class="k">def</span> <span class="nf">get_model_importances</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
        <span class="sh">"""</span><span class="s">
        Get feature importances (which base models are most important).
        
        Returns:
            Dictionary mapping model index to importance
        </span><span class="sh">"""</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">self</span><span class="p">.</span><span class="n">is_trained</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{}</span>
        
        <span class="c1"># For logistic regression, coefficients indicate importance
</span>        <span class="n">coeffs</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">abs</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">meta_model</span><span class="p">.</span><span class="n">coef_</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">normalized</span> <span class="o">=</span> <span class="n">coeffs</span> <span class="o">/</span> <span class="n">coeffs</span><span class="p">.</span><span class="nf">sum</span><span class="p">()</span>
        
        <span class="k">return</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="nf">float</span><span class="p">(</span><span class="n">imp</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">imp</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">normalized</span><span class="p">)}</span>
</code></pre></div></div>

<h3 id="3-diversity-optimization">3. Diversity Optimization</h3>

<p>Diverse models make better ensembles. Here’s how to measure and ensure diversity:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">scipy.spatial.distance</span> <span class="kn">import</span> <span class="n">pdist</span><span class="p">,</span> <span class="n">squareform</span>
<span class="kn">from</span> <span class="n">scipy.stats</span> <span class="kn">import</span> <span class="n">spearmanr</span>
<span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>

<span class="k">class</span> <span class="nc">DiversityAnalyzer</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">Analyze and optimize model diversity in ensemble.</span><span class="sh">"""</span>
    
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">prediction_diversity</span><span class="p">(</span>
        <span class="n">predictions</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span>  <span class="c1"># Shape: (n_samples, n_models)
</span>    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sh">"""</span><span class="s">
        Calculate diversity based on prediction disagreement.
        
        High diversity = models make different predictions.
        
        Returns:
            Diversity score in [0, 1]
        </span><span class="sh">"""</span>
        <span class="n">n_models</span> <span class="o">=</span> <span class="n">predictions</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="n">n_models</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">0.0</span>
        
        <span class="c1"># Calculate pairwise correlation between model predictions
</span>        <span class="n">correlations</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n_models</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_models</span><span class="p">):</span>
                <span class="n">corr</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="nf">spearmanr</span><span class="p">(</span><span class="n">predictions</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">predictions</span><span class="p">[:,</span> <span class="n">j</span><span class="p">])</span>
                <span class="n">correlations</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">corr</span><span class="p">)</span>
        
        <span class="c1"># Diversity = 1 - average correlation
</span>        <span class="n">avg_correlation</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">mean</span><span class="p">(</span><span class="n">correlations</span><span class="p">)</span>
        <span class="n">diversity</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">avg_correlation</span>
        
        <span class="k">return</span> <span class="nf">max</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">diversity</span><span class="p">)</span>
    
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">architectural_diversity</span><span class="p">(</span><span class="n">models</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Model</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sh">"""</span><span class="s">
        Calculate diversity based on model architectures.
        
        Different architectures (XGBoost, NN, Linear) = high diversity.
        </span><span class="sh">"""</span>
        <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">models</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">0.0</span>
        
        <span class="c1"># Count unique architectures
</span>        <span class="n">unique_archs</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="nf">set</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">architecture</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">models</span><span class="p">))</span>
        
        <span class="c1"># Diversity = ratio of unique to total
</span>        <span class="k">return</span> <span class="n">unique_archs</span> <span class="o">/</span> <span class="nf">len</span><span class="p">(</span><span class="n">models</span><span class="p">)</span>
    
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">error_diversity</span><span class="p">(</span>
        <span class="n">predictions</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">,</span>  <span class="c1"># Shape: (n_samples, n_models)
</span>        <span class="n">true_labels</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sh">"""</span><span class="s">
        Calculate diversity based on error patterns.
        
        Good diversity = models make errors on different samples.
        
        Returns:
            Error diversity score
        </span><span class="sh">"""</span>
        <span class="n">n_samples</span><span class="p">,</span> <span class="n">n_models</span> <span class="o">=</span> <span class="n">predictions</span><span class="p">.</span><span class="n">shape</span>
        
        <span class="c1"># Determine which samples each model gets wrong
</span>        <span class="n">errors</span> <span class="o">=</span> <span class="p">(</span><span class="n">predictions</span> <span class="o">&gt;</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">!=</span> <span class="n">true_labels</span><span class="p">.</span><span class="nf">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        
        <span class="c1"># Calculate pairwise error overlap
</span>        <span class="n">overlaps</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n_models</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_models</span><span class="p">):</span>
                <span class="c1"># What fraction of errors are shared?
</span>                <span class="n">shared_errors</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">sum</span><span class="p">(</span><span class="n">errors</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">errors</span><span class="p">[:,</span> <span class="n">j</span><span class="p">])</span>
                <span class="n">total_errors</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">sum</span><span class="p">(</span><span class="n">errors</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">|</span> <span class="n">errors</span><span class="p">[:,</span> <span class="n">j</span><span class="p">])</span>
                
                <span class="k">if</span> <span class="n">total_errors</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">overlap</span> <span class="o">=</span> <span class="n">shared_errors</span> <span class="o">/</span> <span class="n">total_errors</span>
                    <span class="n">overlaps</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">overlap</span><span class="p">)</span>
        
        <span class="c1"># Diversity = 1 - average overlap
</span>        <span class="n">avg_overlap</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">mean</span><span class="p">(</span><span class="n">overlaps</span><span class="p">)</span> <span class="k">if</span> <span class="n">overlaps</span> <span class="k">else</span> <span class="mf">0.5</span>
        <span class="k">return</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">avg_overlap</span>
    
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">select_diverse_subset</span><span class="p">(</span>
        <span class="n">models</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Model</span><span class="p">],</span>
        <span class="n">predictions</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">,</span>  <span class="c1"># Shape: (n_samples, n_models)
</span>        <span class="n">k</span><span class="p">:</span> <span class="nb">int</span>  <span class="c1"># Number of models to select
</span>    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="sh">"""</span><span class="s">
        Select k most diverse models using greedy algorithm.
        
        Similar to backtracking but greedy instead of exhaustive.
        
        Algorithm:
        1. Start with best individual model
        2. Iteratively add model that maximizes diversity
        3. Stop when k models selected
        
        Returns:
            Indices of selected models
        </span><span class="sh">"""</span>
        <span class="n">n_models</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">models</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;=</span> <span class="n">n_models</span><span class="p">:</span>
            <span class="k">return</span> <span class="nf">list</span><span class="p">(</span><span class="nf">range</span><span class="p">(</span><span class="n">n_models</span><span class="p">))</span>
        
        <span class="c1"># Start with best model
</span>        <span class="n">accuracies</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span><span class="p">.</span><span class="n">accuracy</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">models</span><span class="p">]</span>
        <span class="n">selected</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="p">.</span><span class="nf">argmax</span><span class="p">(</span><span class="n">accuracies</span><span class="p">)]</span>
        
        <span class="c1"># Greedily add most diverse models
</span>        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">max_diversity</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">best_candidate</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            
            <span class="k">for</span> <span class="n">candidate</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n_models</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">candidate</span> <span class="ow">in</span> <span class="n">selected</span><span class="p">:</span>
                    <span class="k">continue</span>
                
                <span class="c1"># Calculate diversity if we add this candidate
</span>                <span class="n">test_selection</span> <span class="o">=</span> <span class="n">selected</span> <span class="o">+</span> <span class="p">[</span><span class="n">candidate</span><span class="p">]</span>
                <span class="n">test_predictions</span> <span class="o">=</span> <span class="n">predictions</span><span class="p">[:,</span> <span class="n">test_selection</span><span class="p">]</span>
                
                <span class="n">diversity</span> <span class="o">=</span> <span class="n">DiversityAnalyzer</span><span class="p">.</span><span class="nf">prediction_diversity</span><span class="p">(</span><span class="n">test_predictions</span><span class="p">)</span>
                
                <span class="k">if</span> <span class="n">diversity</span> <span class="o">&gt;</span> <span class="n">max_diversity</span><span class="p">:</span>
                    <span class="n">max_diversity</span> <span class="o">=</span> <span class="n">diversity</span>
                    <span class="n">best_candidate</span> <span class="o">=</span> <span class="n">candidate</span>
            
            <span class="k">if</span> <span class="n">best_candidate</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">selected</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">best_candidate</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">selected</span>
</code></pre></div></div>

<h3 id="4-dynamic-ensemble-selection">4. Dynamic Ensemble Selection</h3>

<p>Select different model subsets based on input characteristics:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">sklearn.cluster</span> <span class="kn">import</span> <span class="n">KMeans</span>
<span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">Callable</span>

<span class="k">class</span> <span class="nc">DynamicEnsembleSelector</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">
    Dynamic ensemble selection: choose models based on input.
    
    Idea: Different models are good for different types of inputs.
    
    Example:
    - Linear models good for simple patterns
    - Neural nets good for complex patterns
    - Tree models good for categorical features
    </span><span class="sh">"""</span>
    
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">models</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Model</span><span class="p">],</span> <span class="n">n_regions</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">models</span> <span class="o">=</span> <span class="n">models</span>
        <span class="n">self</span><span class="p">.</span><span class="n">n_regions</span> <span class="o">=</span> <span class="n">n_regions</span>
        
        <span class="c1"># Cluster validation set to identify regions
</span>        <span class="n">self</span><span class="p">.</span><span class="n">clusterer</span> <span class="o">=</span> <span class="nc">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="n">n_regions</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
        
        <span class="c1"># Best models for each region
</span>        <span class="n">self</span><span class="p">.</span><span class="n">region_models</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span>
        
        <span class="n">self</span><span class="p">.</span><span class="n">is_trained</span> <span class="o">=</span> <span class="bp">False</span>
    
    <span class="k">def</span> <span class="nf">train</span><span class="p">(</span>
        <span class="n">self</span><span class="p">,</span>
        <span class="n">X_val</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">y_val</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">model_predictions</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span>  <span class="c1"># Shape: (n_samples, n_models)
</span>    <span class="p">):</span>
        <span class="sh">"""</span><span class="s">
        Train selector on validation data.
        
        Steps:
        1. Cluster input space into regions
        2. For each region, find best models
        3. Store region -&gt; models mapping
        </span><span class="sh">"""</span>
        <span class="c1"># Cluster input space
</span>        <span class="n">self</span><span class="p">.</span><span class="n">clusterer</span><span class="p">.</span><span class="nf">fit</span><span class="p">(</span><span class="n">X_val</span><span class="p">)</span>
        <span class="n">clusters</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">clusterer</span><span class="p">.</span><span class="n">labels_</span>
        
        <span class="c1"># For each region, find best models
</span>        <span class="k">for</span> <span class="n">region</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">n_regions</span><span class="p">):</span>
            <span class="n">region_mask</span> <span class="o">=</span> <span class="n">clusters</span> <span class="o">==</span> <span class="n">region</span>
            <span class="n">region_y</span> <span class="o">=</span> <span class="n">y_val</span><span class="p">[</span><span class="n">region_mask</span><span class="p">]</span>
            <span class="n">region_preds</span> <span class="o">=</span> <span class="n">model_predictions</span><span class="p">[</span><span class="n">region_mask</span><span class="p">]</span>
            
            <span class="c1"># Evaluate each model on this region
</span>            <span class="n">model_scores</span> <span class="o">=</span> <span class="p">[]</span>
            
            <span class="k">for</span> <span class="n">model_idx</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">models</span><span class="p">)):</span>
                <span class="n">preds</span> <span class="o">=</span> <span class="n">region_preds</span><span class="p">[:,</span> <span class="n">model_idx</span><span class="p">]</span>
                
                <span class="c1"># Calculate accuracy for this model in this region
</span>                <span class="n">accuracy</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">mean</span><span class="p">((</span><span class="n">preds</span> <span class="o">&gt;</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">==</span> <span class="n">region_y</span><span class="p">)</span>
                <span class="n">model_scores</span><span class="p">.</span><span class="nf">append</span><span class="p">((</span><span class="n">model_idx</span><span class="p">,</span> <span class="n">accuracy</span><span class="p">))</span>
            
            <span class="c1"># Sort by accuracy and take top models
</span>            <span class="n">model_scores</span><span class="p">.</span><span class="nf">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            
            <span class="c1"># Take top 3 models for this region
</span>            <span class="n">self</span><span class="p">.</span><span class="n">region_models</span><span class="p">[</span><span class="n">region</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">idx</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">model_scores</span><span class="p">[:</span><span class="mi">3</span><span class="p">]]</span>
        
        <span class="n">self</span><span class="p">.</span><span class="n">is_trained</span> <span class="o">=</span> <span class="bp">True</span>
    
    <span class="k">def</span> <span class="nf">select_models</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">features</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="sh">"""</span><span class="s">
        Select best models for given input.
        
        Args:
            features: Input features (single sample)
            
        Returns:
            Indices of selected models
        </span><span class="sh">"""</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">self</span><span class="p">.</span><span class="n">is_trained</span><span class="p">:</span>
            <span class="c1"># Fallback: use all models
</span>            <span class="k">return</span> <span class="nf">list</span><span class="p">(</span><span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">models</span><span class="p">)))</span>
        
        <span class="c1"># Determine which region this input belongs to
</span>        <span class="n">region</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">clusterer</span><span class="p">.</span><span class="nf">predict</span><span class="p">(</span><span class="n">features</span><span class="p">.</span><span class="nf">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="c1"># Return best models for this region
</span>        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">region_models</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">region</span><span class="p">,</span> <span class="nf">list</span><span class="p">(</span><span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">models</span><span class="p">))))</span>
</code></pre></div></div>

<h2 id="data-flow">Data Flow</h2>

<h3 id="prediction-pipeline">Prediction Pipeline</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. Request arrives with features
   └─&gt; Feature preprocessing/validation

2. Model selection (backtracking or dynamic)
   └─&gt; Identify optimal subset of models
   └─&gt; Consider: latency budget, diversity, accuracy

3. Parallel inference
   └─&gt; Query selected models concurrently
   └─&gt; Set timeout for each model
   └─&gt; Handle failures gracefully

4. Prediction combination
   └─&gt; Apply combination strategy
   └─&gt; Calculate confidence score

5. Post-processing
   └─&gt; Calibration
   └─&gt; Threshold optimization
   └─&gt; Explanation generation

6. Return result
   └─&gt; Final prediction
   └─&gt; Confidence
   └─&gt; Models used
   └─&gt; Latency breakdown
</code></pre></div></div>

<h3 id="training-pipeline">Training Pipeline</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. Train base models
   ├─&gt; Different algorithms
   ├─&gt; Different feature sets
   ├─&gt; Different train/val splits
   └─&gt; Ensure diversity

2. Generate meta-features (for stacking)
   └─&gt; Cross-validation predictions
   └─&gt; Avoid overfitting

3. Train meta-model
   └─&gt; Learn optimal combination
   └─&gt; Regularization to prevent overfitting

4. Evaluate ensemble
   └─&gt; Compare to individual models
   └─&gt; A/B test in production

5. Deploy
   └─&gt; Canary rollout
   └─&gt; Monitor performance
</code></pre></div></div>

<h2 id="scaling-strategies">Scaling Strategies</h2>

<h3 id="horizontal-scaling---parallel-inference">Horizontal Scaling - Parallel Inference</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">ray</span>

<span class="nd">@ray.remote</span>
<span class="k">class</span> <span class="nc">ModelServer</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">Ray actor for serving a single model.</span><span class="sh">"""</span>
    
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">model</span><span class="p">:</span> <span class="n">Model</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">model</span>
        <span class="c1"># Load actual model weights
</span>        <span class="c1"># self.model_impl = load_model(model.model_id)
</span>    
    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">features</span><span class="p">:</span> <span class="n">Dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sh">"""</span><span class="s">Make prediction.</span><span class="sh">"""</span>
        <span class="c1"># return self.model_impl.predict(features)
</span>        <span class="k">return</span> <span class="mf">0.5</span>  <span class="c1"># Dummy
</span>

<span class="k">class</span> <span class="nc">DistributedEnsemble</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">Distributed ensemble using Ray.</span><span class="sh">"""</span>
    
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">models</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Model</span><span class="p">]):</span>
        <span class="c1"># Create Ray actor for each model
</span>        <span class="n">self</span><span class="p">.</span><span class="n">model_servers</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">ModelServer</span><span class="p">.</span><span class="nf">remote</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="n">models</span>
        <span class="p">]</span>
        <span class="n">self</span><span class="p">.</span><span class="n">models</span> <span class="o">=</span> <span class="n">models</span>
    
    <span class="k">async</span> <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">features</span><span class="p">:</span> <span class="n">Dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">EnsembleResult</span><span class="p">:</span>
        <span class="sh">"""</span><span class="s">Make distributed prediction.</span><span class="sh">"""</span>
        <span class="c1"># Query all models in parallel using Ray
</span>        <span class="n">prediction_futures</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">server</span><span class="p">.</span><span class="n">predict</span><span class="p">.</span><span class="nf">remote</span><span class="p">(</span><span class="n">features</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">server</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">model_servers</span>
        <span class="p">]</span>
        
        <span class="c1"># Wait for all predictions
</span>        <span class="n">predictions</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="p">.</span><span class="nf">gather</span><span class="p">(</span><span class="o">*</span><span class="p">[</span>
            <span class="n">asyncio</span><span class="p">.</span><span class="nf">create_task</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="nf">_ray_to_asyncio</span><span class="p">(</span><span class="n">future</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">future</span> <span class="ow">in</span> <span class="n">prediction_futures</span>
        <span class="p">])</span>
        
        <span class="c1"># Combine predictions
</span>        <span class="n">final_pred</span> <span class="o">=</span> <span class="nf">sum</span><span class="p">(</span><span class="n">predictions</span><span class="p">)</span> <span class="o">/</span> <span class="nf">len</span><span class="p">(</span><span class="n">predictions</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="nc">EnsembleResult</span><span class="p">(</span>
            <span class="n">prediction</span><span class="o">=</span><span class="n">final_pred</span><span class="p">,</span>
            <span class="n">confidence</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span>
            <span class="n">models_used</span><span class="o">=</span><span class="p">[</span><span class="n">m</span><span class="p">.</span><span class="n">model_id</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">models</span><span class="p">],</span>
            <span class="n">latency_ms</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
            <span class="n">individual_predictions</span><span class="o">=</span><span class="p">{}</span>
        <span class="p">)</span>
    
    <span class="nd">@staticmethod</span>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">_ray_to_asyncio</span><span class="p">(</span><span class="n">ray_future</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">Convert Ray future to asyncio.</span><span class="sh">"""</span>
        <span class="k">return</span> <span class="n">ray</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">ray_future</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="vertical-scaling---model-compression">Vertical Scaling - Model Compression</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">EnsembleOptimizer</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">Optimize ensemble for production.</span><span class="sh">"""</span>
    
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">knowledge_distillation</span><span class="p">(</span>
        <span class="n">ensemble</span><span class="p">:</span> <span class="n">EnsembleOrchestrator</span><span class="p">,</span>
        <span class="n">X_train</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">student_model</span><span class="p">:</span> <span class="nb">any</span>
    <span class="p">):</span>
        <span class="sh">"""</span><span class="s">
        Distill ensemble into single student model.
        
        Benefits:
        - Single model = lower latency
        - Retains most of ensemble</span><span class="sh">'</span><span class="s">s accuracy
        - Easier deployment
        
        Process:
        1. Generate ensemble predictions on training data
        2. Train student model to mimic ensemble
        3. Use soft labels (probabilities) not hard labels
        </span><span class="sh">"""</span>
        <span class="c1"># Get ensemble predictions (soft labels)
</span>        <span class="n">ensemble_preds</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">X_train</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">ensemble</span><span class="p">.</span><span class="nf">predict</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="n">ensemble_preds</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">prediction</span><span class="p">)</span>
        
        <span class="n">ensemble_preds</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">(</span><span class="n">ensemble_preds</span><span class="p">)</span>
        
        <span class="c1"># Train student model
</span>        <span class="n">student_model</span><span class="p">.</span><span class="nf">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">ensemble_preds</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">student_model</span>
    
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">prune_models</span><span class="p">(</span>
        <span class="n">models</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Model</span><span class="p">],</span>
        <span class="n">predictions</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">true_labels</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">target_size</span><span class="p">:</span> <span class="nb">int</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="sh">"""</span><span class="s">
        Prune ensemble to target size while maintaining accuracy.
        
        Greedy algorithm:
        1. Start with full ensemble
        2. Iteratively remove least important model
        3. Stop when target size reached or accuracy drops
        
        Returns:
            Indices of models to keep
        </span><span class="sh">"""</span>
        <span class="n">n_models</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">models</span><span class="p">)</span>
        <span class="n">remaining</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="nf">range</span><span class="p">(</span><span class="n">n_models</span><span class="p">))</span>
        
        <span class="c1"># Calculate baseline accuracy
</span>        <span class="n">ensemble_preds</span> <span class="o">=</span> <span class="n">predictions</span><span class="p">[:,</span> <span class="n">remaining</span><span class="p">].</span><span class="nf">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">baseline_acc</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">mean</span><span class="p">((</span><span class="n">ensemble_preds</span> <span class="o">&gt;</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">==</span> <span class="n">true_labels</span><span class="p">)</span>
        
        <span class="k">while</span> <span class="nf">len</span><span class="p">(</span><span class="n">remaining</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">target_size</span><span class="p">:</span>
            <span class="n">min_impact</span> <span class="o">=</span> <span class="nf">float</span><span class="p">(</span><span class="sh">'</span><span class="s">inf</span><span class="sh">'</span><span class="p">)</span>
            <span class="n">model_to_remove</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            
            <span class="c1"># Try removing each model
</span>            <span class="k">for</span> <span class="n">model_idx</span> <span class="ow">in</span> <span class="n">remaining</span><span class="p">:</span>
                <span class="n">test_remaining</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">remaining</span> <span class="k">if</span> <span class="n">m</span> <span class="o">!=</span> <span class="n">model_idx</span><span class="p">]</span>
                
                <span class="k">if</span> <span class="ow">not</span> <span class="n">test_remaining</span><span class="p">:</span>
                    <span class="k">break</span>
                
                <span class="c1"># Evaluate ensemble without this model
</span>                <span class="n">test_preds</span> <span class="o">=</span> <span class="n">predictions</span><span class="p">[:,</span> <span class="n">test_remaining</span><span class="p">].</span><span class="nf">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">test_acc</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">mean</span><span class="p">((</span><span class="n">test_preds</span> <span class="o">&gt;</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">==</span> <span class="n">true_labels</span><span class="p">)</span>
                
                <span class="c1"># How much does accuracy drop?
</span>                <span class="n">impact</span> <span class="o">=</span> <span class="n">baseline_acc</span> <span class="o">-</span> <span class="n">test_acc</span>
                
                <span class="k">if</span> <span class="n">impact</span> <span class="o">&lt;</span> <span class="n">min_impact</span><span class="p">:</span>
                    <span class="n">min_impact</span> <span class="o">=</span> <span class="n">impact</span>
                    <span class="n">model_to_remove</span> <span class="o">=</span> <span class="n">model_idx</span>
            
            <span class="k">if</span> <span class="n">model_to_remove</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">break</span>
            
            <span class="c1"># Remove least important model
</span>            <span class="n">remaining</span><span class="p">.</span><span class="nf">remove</span><span class="p">(</span><span class="n">model_to_remove</span><span class="p">)</span>
            
            <span class="c1"># Update baseline
</span>            <span class="n">ensemble_preds</span> <span class="o">=</span> <span class="n">predictions</span><span class="p">[:,</span> <span class="n">remaining</span><span class="p">].</span><span class="nf">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">baseline_acc</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">mean</span><span class="p">((</span><span class="n">ensemble_preds</span> <span class="o">&gt;</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">==</span> <span class="n">true_labels</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">remaining</span>
</code></pre></div></div>

<h2 id="implementation-complete-system">Implementation: Complete System</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">logging</span>
<span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Optional</span>
<span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>

<span class="k">class</span> <span class="nc">ProductionEnsemble</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">
    Complete production ensemble system.
    
    Features:
    - Model selection using backtracking
    - Multiple combination strategies
    - Fallback handling
    - Performance monitoring
    - A/B testing support
    </span><span class="sh">"""</span>
    
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span>
        <span class="n">self</span><span class="p">,</span>
        <span class="n">models</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Model</span><span class="p">],</span>
        <span class="n">config</span><span class="p">:</span> <span class="n">EnsembleConfig</span><span class="p">,</span>
        <span class="n">combiner_type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="sh">"</span><span class="s">weighted_averaging</span><span class="sh">"</span>
    <span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">orchestrator</span> <span class="o">=</span> <span class="nc">EnsembleOrchestrator</span><span class="p">(</span><span class="n">config</span><span class="p">)</span>
        
        <span class="c1"># Add models to orchestrator
</span>        <span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="n">models</span><span class="p">:</span>
            <span class="n">self</span><span class="p">.</span><span class="n">orchestrator</span><span class="p">.</span><span class="nf">add_model</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
        
        <span class="n">self</span><span class="p">.</span><span class="n">combiner_type</span> <span class="o">=</span> <span class="n">combiner_type</span>
        <span class="n">self</span><span class="p">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="p">.</span><span class="nf">getLogger</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>
        
        <span class="c1"># Metrics
</span>        <span class="n">self</span><span class="p">.</span><span class="n">prediction_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">self</span><span class="p">.</span><span class="n">total_latency</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">self</span><span class="p">.</span><span class="n">fallback_count</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="k">async</span> <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span>
        <span class="n">self</span><span class="p">,</span>
        <span class="n">features</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span>
        <span class="n">explain</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">:</span>
        <span class="sh">"""</span><span class="s">
        Make ensemble prediction with optional explanation.
        
        Args:
            features: Input features
            explain: Whether to include explanation
            
        Returns:
            Dictionary with prediction and metadata
        </span><span class="sh">"""</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Get ensemble prediction
</span>            <span class="n">result</span> <span class="o">=</span> <span class="k">await</span> <span class="n">self</span><span class="p">.</span><span class="n">orchestrator</span><span class="p">.</span><span class="nf">predict</span><span class="p">(</span><span class="n">features</span><span class="p">)</span>
            
            <span class="c1"># Update metrics
</span>            <span class="n">self</span><span class="p">.</span><span class="n">prediction_count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">self</span><span class="p">.</span><span class="n">total_latency</span> <span class="o">+=</span> <span class="n">result</span><span class="p">.</span><span class="n">latency_ms</span>
            
            <span class="c1"># Build response
</span>            <span class="n">response</span> <span class="o">=</span> <span class="p">{</span>
                <span class="sh">"</span><span class="s">prediction</span><span class="sh">"</span><span class="p">:</span> <span class="n">result</span><span class="p">.</span><span class="n">prediction</span><span class="p">,</span>
                <span class="sh">"</span><span class="s">confidence</span><span class="sh">"</span><span class="p">:</span> <span class="n">result</span><span class="p">.</span><span class="n">confidence</span><span class="p">,</span>
                <span class="sh">"</span><span class="s">latency_ms</span><span class="sh">"</span><span class="p">:</span> <span class="n">result</span><span class="p">.</span><span class="n">latency_ms</span><span class="p">,</span>
                <span class="sh">"</span><span class="s">models_used</span><span class="sh">"</span><span class="p">:</span> <span class="n">result</span><span class="p">.</span><span class="n">models_used</span><span class="p">,</span>
                <span class="sh">"</span><span class="s">success</span><span class="sh">"</span><span class="p">:</span> <span class="bp">True</span>
            <span class="p">}</span>
            
            <span class="c1"># Add explanation if requested
</span>            <span class="k">if</span> <span class="n">explain</span><span class="p">:</span>
                <span class="n">response</span><span class="p">[</span><span class="sh">"</span><span class="s">explanation</span><span class="sh">"</span><span class="p">]</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">_generate_explanation</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
            
            <span class="n">self</span><span class="p">.</span><span class="n">logger</span><span class="p">.</span><span class="nf">info</span><span class="p">(</span>
                <span class="sa">f</span><span class="sh">"</span><span class="s">Prediction: </span><span class="si">{</span><span class="n">result</span><span class="p">.</span><span class="n">prediction</span><span class="si">:</span><span class="p">.</span><span class="mi">3</span><span class="n">f</span><span class="si">}</span><span class="s"> </span><span class="sh">"</span>
                <span class="sa">f</span><span class="sh">"</span><span class="s">(confidence: </span><span class="si">{</span><span class="n">result</span><span class="p">.</span><span class="n">confidence</span><span class="si">:</span><span class="p">.</span><span class="mi">3</span><span class="n">f</span><span class="si">}</span><span class="s">, </span><span class="sh">"</span>
                <span class="sa">f</span><span class="sh">"</span><span class="s">latency: </span><span class="si">{</span><span class="n">result</span><span class="p">.</span><span class="n">latency_ms</span><span class="si">:</span><span class="p">.</span><span class="mi">1</span><span class="n">f</span><span class="si">}</span><span class="s">ms, </span><span class="sh">"</span>
                <span class="sa">f</span><span class="sh">"</span><span class="s">models: </span><span class="si">{</span><span class="nf">len</span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">models_used</span><span class="p">)</span><span class="si">}</span><span class="s">)</span><span class="sh">"</span>
            <span class="p">)</span>
            
            <span class="k">return</span> <span class="n">response</span>
            
        <span class="k">except</span> <span class="nb">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="c1"># Fallback: use simple heuristic or cached result
</span>            <span class="n">self</span><span class="p">.</span><span class="n">fallback_count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">self</span><span class="p">.</span><span class="n">logger</span><span class="p">.</span><span class="nf">error</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Ensemble prediction failed: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
            
            <span class="k">return</span> <span class="p">{</span>
                <span class="sh">"</span><span class="s">prediction</span><span class="sh">"</span><span class="p">:</span> <span class="mf">0.5</span><span class="p">,</span>  <span class="c1"># Neutral prediction
</span>                <span class="sh">"</span><span class="s">confidence</span><span class="sh">"</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span>
                <span class="sh">"</span><span class="s">latency_ms</span><span class="sh">"</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span>
                <span class="sh">"</span><span class="s">models_used</span><span class="sh">"</span><span class="p">:</span> <span class="p">[],</span>
                <span class="sh">"</span><span class="s">success</span><span class="sh">"</span><span class="p">:</span> <span class="bp">False</span><span class="p">,</span>
                <span class="sh">"</span><span class="s">error</span><span class="sh">"</span><span class="p">:</span> <span class="nf">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
            <span class="p">}</span>
    
    <span class="k">def</span> <span class="nf">_generate_explanation</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">result</span><span class="p">:</span> <span class="n">EnsembleResult</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">:</span>
        <span class="sh">"""</span><span class="s">
        Generate explanation for ensemble prediction.
        
        Returns:
            Dictionary with explanation details
        </span><span class="sh">"""</span>
        <span class="c1"># Analyze which models contributed most
</span>        <span class="n">preds</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">individual_predictions</span><span class="p">.</span><span class="nf">values</span><span class="p">())</span>
        <span class="n">final_pred</span> <span class="o">=</span> <span class="n">result</span><span class="p">.</span><span class="n">prediction</span>
        
        <span class="c1"># Calculate agreement
</span>        <span class="n">agreements</span> <span class="o">=</span> <span class="p">[</span>
            <span class="mf">1.0</span> <span class="o">-</span> <span class="nf">abs</span><span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="n">final_pred</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">preds</span>
        <span class="p">]</span>
        
        <span class="c1"># Sort models by agreement
</span>        <span class="n">model_agreements</span> <span class="o">=</span> <span class="nf">sorted</span><span class="p">(</span>
            <span class="nf">zip</span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">models_used</span><span class="p">,</span> <span class="n">agreements</span><span class="p">),</span>
            <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">reverse</span><span class="o">=</span><span class="bp">True</span>
        <span class="p">)</span>
        
        <span class="k">return</span> <span class="p">{</span>
            <span class="sh">"</span><span class="s">final_prediction</span><span class="sh">"</span><span class="p">:</span> <span class="n">final_pred</span><span class="p">,</span>
            <span class="sh">"</span><span class="s">model_contributions</span><span class="sh">"</span><span class="p">:</span> <span class="p">[</span>
                <span class="p">{</span>
                    <span class="sh">"</span><span class="s">model_id</span><span class="sh">"</span><span class="p">:</span> <span class="n">model_id</span><span class="p">,</span>
                    <span class="sh">"</span><span class="s">agreement</span><span class="sh">"</span><span class="p">:</span> <span class="n">agreement</span><span class="p">,</span>
                    <span class="sh">"</span><span class="s">prediction</span><span class="sh">"</span><span class="p">:</span> <span class="n">result</span><span class="p">.</span><span class="n">individual_predictions</span><span class="p">[</span><span class="n">model_id</span><span class="p">]</span>
                <span class="p">}</span>
                <span class="k">for</span> <span class="n">model_id</span><span class="p">,</span> <span class="n">agreement</span> <span class="ow">in</span> <span class="n">model_agreements</span>
            <span class="p">],</span>
            <span class="sh">"</span><span class="s">consensus_level</span><span class="sh">"</span><span class="p">:</span> <span class="nf">sum</span><span class="p">(</span><span class="n">agreements</span><span class="p">)</span> <span class="o">/</span> <span class="nf">len</span><span class="p">(</span><span class="n">agreements</span><span class="p">)</span> <span class="k">if</span> <span class="n">agreements</span> <span class="k">else</span> <span class="mf">0.0</span>
        <span class="p">}</span>
    
    <span class="k">def</span> <span class="nf">get_metrics</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">:</span>
        <span class="sh">"""</span><span class="s">Get performance metrics.</span><span class="sh">"""</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="sh">"</span><span class="s">prediction_count</span><span class="sh">"</span><span class="p">:</span> <span class="n">self</span><span class="p">.</span><span class="n">prediction_count</span><span class="p">,</span>
            <span class="sh">"</span><span class="s">avg_latency_ms</span><span class="sh">"</span><span class="p">:</span> <span class="p">(</span>
                <span class="n">self</span><span class="p">.</span><span class="n">total_latency</span> <span class="o">/</span> <span class="n">self</span><span class="p">.</span><span class="n">prediction_count</span>
                <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">prediction_count</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mf">0.0</span>
            <span class="p">),</span>
            <span class="sh">"</span><span class="s">fallback_rate</span><span class="sh">"</span><span class="p">:</span> <span class="p">(</span>
                <span class="n">self</span><span class="p">.</span><span class="n">fallback_count</span> <span class="o">/</span> <span class="n">self</span><span class="p">.</span><span class="n">prediction_count</span>
                <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">prediction_count</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mf">0.0</span>
            <span class="p">),</span>
            <span class="sh">"</span><span class="s">models_available</span><span class="sh">"</span><span class="p">:</span> <span class="nf">len</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">orchestrator</span><span class="p">.</span><span class="n">models</span><span class="p">),</span>
            <span class="sh">"</span><span class="s">healthy_models</span><span class="sh">"</span><span class="p">:</span> <span class="nf">sum</span><span class="p">(</span>
                <span class="mi">1</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">orchestrator</span><span class="p">.</span><span class="n">models</span>
                <span class="k">if</span> <span class="n">m</span><span class="p">.</span><span class="n">status</span> <span class="o">==</span> <span class="n">ModelStatus</span><span class="p">.</span><span class="n">HEALTHY</span>
            <span class="p">)</span>
        <span class="p">}</span>


<span class="c1"># Example usage
</span><span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="c1"># Create models
</span>    <span class="n">models</span> <span class="o">=</span> <span class="p">[</span>
        <span class="nc">Model</span><span class="p">(</span><span class="sh">"</span><span class="s">xgb_v1</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">xgboost</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">1.0</span><span class="sh">"</span><span class="p">,</span> <span class="mf">15.0</span><span class="p">,</span> <span class="mf">0.85</span><span class="p">,</span> <span class="n">architecture</span><span class="o">=</span><span class="sh">"</span><span class="s">tree</span><span class="sh">"</span><span class="p">),</span>
        <span class="nc">Model</span><span class="p">(</span><span class="sh">"</span><span class="s">nn_v1</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">neural_net</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">1.0</span><span class="sh">"</span><span class="p">,</span> <span class="mf">25.0</span><span class="p">,</span> <span class="mf">0.87</span><span class="p">,</span> <span class="n">architecture</span><span class="o">=</span><span class="sh">"</span><span class="s">deep_learning</span><span class="sh">"</span><span class="p">),</span>
        <span class="nc">Model</span><span class="p">(</span><span class="sh">"</span><span class="s">lr_v1</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">linear</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">1.0</span><span class="sh">"</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">,</span> <span class="mf">0.80</span><span class="p">,</span> <span class="n">architecture</span><span class="o">=</span><span class="sh">"</span><span class="s">linear</span><span class="sh">"</span><span class="p">),</span>
        <span class="nc">Model</span><span class="p">(</span><span class="sh">"</span><span class="s">lgbm_v1</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">lightgbm</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">1.0</span><span class="sh">"</span><span class="p">,</span> <span class="mf">12.0</span><span class="p">,</span> <span class="mf">0.86</span><span class="p">,</span> <span class="n">architecture</span><span class="o">=</span><span class="sh">"</span><span class="s">tree</span><span class="sh">"</span><span class="p">),</span>
        <span class="nc">Model</span><span class="p">(</span><span class="sh">"</span><span class="s">rf_v1</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">random_forest</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">1.0</span><span class="sh">"</span><span class="p">,</span> <span class="mf">20.0</span><span class="p">,</span> <span class="mf">0.84</span><span class="p">,</span> <span class="n">architecture</span><span class="o">=</span><span class="sh">"</span><span class="s">tree</span><span class="sh">"</span><span class="p">),</span>
    <span class="p">]</span>
    
    <span class="c1"># Configure ensemble
</span>    <span class="n">config</span> <span class="o">=</span> <span class="nc">EnsembleConfig</span><span class="p">(</span>
        <span class="n">max_models</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
        <span class="n">max_latency_ms</span><span class="o">=</span><span class="mf">50.0</span><span class="p">,</span>
        <span class="n">min_diversity</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span>
        <span class="n">combination_strategy</span><span class="o">=</span><span class="sh">"</span><span class="s">weighted_averaging</span><span class="sh">"</span>
    <span class="p">)</span>
    
    <span class="c1"># Create ensemble
</span>    <span class="n">ensemble</span> <span class="o">=</span> <span class="nc">ProductionEnsemble</span><span class="p">(</span><span class="n">models</span><span class="p">,</span> <span class="n">config</span><span class="p">)</span>
    
    <span class="c1"># Make predictions
</span>    <span class="n">features</span> <span class="o">=</span> <span class="p">{</span><span class="sh">"</span><span class="s">feature1</span><span class="sh">"</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="sh">"</span><span class="s">feature2</span><span class="sh">"</span><span class="p">:</span> <span class="mf">0.5</span><span class="p">}</span>
    
    <span class="n">result</span> <span class="o">=</span> <span class="k">await</span> <span class="n">ensemble</span><span class="p">.</span><span class="nf">predict</span><span class="p">(</span><span class="n">features</span><span class="p">,</span> <span class="n">explain</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Prediction: </span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
    
    <span class="c1"># Get metrics
</span>    <span class="n">metrics</span> <span class="o">=</span> <span class="n">ensemble</span><span class="p">.</span><span class="nf">get_metrics</span><span class="p">()</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Metrics: </span><span class="si">{</span><span class="n">metrics</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="sh">"</span><span class="s">__main__</span><span class="sh">"</span><span class="p">:</span>
    <span class="kn">import</span> <span class="n">asyncio</span>
    <span class="n">asyncio</span><span class="p">.</span><span class="nf">run</span><span class="p">(</span><span class="nf">main</span><span class="p">())</span>
</code></pre></div></div>

<h2 id="real-world-case-study-netflix-recommendation-ensemble">Real-World Case Study: Netflix Recommendation Ensemble</h2>

<h3 id="netflixs-approach">Netflix’s Approach</h3>

<p>Netflix uses one of the most sophisticated ensemble systems in production:</p>

<p><strong>Architecture:</strong></p>
<ol>
  <li><strong>100+ base models:</strong>
    <ul>
      <li>Collaborative filtering (matrix factorization)</li>
      <li>Content-based filtering (metadata)</li>
      <li>Deep learning (sequential models)</li>
      <li>Contextual bandits (A/B testing integration)</li>
      <li>Session-based models (recent activity)</li>
    </ul>
  </li>
  <li><strong>Ensemble strategy:</strong>
    <ul>
      <li>Blending (weighted combination)</li>
      <li>Separate ensembles for different contexts (homepage, search, continue watching)</li>
      <li>Dynamic weights based on user segment</li>
    </ul>
  </li>
  <li><strong>Model selection:</strong>
    <ul>
      <li>Not all models run for every request</li>
      <li>Dynamic selection based on:
        <ul>
          <li>User type (new vs established)</li>
          <li>Device (mobile vs TV vs web)</li>
          <li>Time of day</li>
          <li>Available data</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>Combination:</strong>
    <ul>
      <li>Learned weights (meta-learning)</li>
      <li>Context-specific weights</li>
      <li>Fallback to simpler models if latency budget exceeded</li>
    </ul>
  </li>
</ol>

<p><strong>Results:</strong></p>
<ul>
  <li><strong>+10% engagement</strong> vs single best model</li>
  <li><strong>p95 latency: 80ms</strong> despite 100+ models</li>
  <li><strong>Cost optimization:</strong> Only query necessary models</li>
  <li><strong>A/B testing:</strong> Continuous experimentation with ensemble configs</li>
</ul>

<h3 id="key-lessons">Key Lessons</h3>

<ol>
  <li><strong>More models ≠ better:</strong> Diminishing returns after ~20 diverse models</li>
  <li><strong>Diversity matters more than individual accuracy</strong></li>
  <li><strong>Dynamic selection crucial for latency</strong></li>
  <li><strong>Meta-learning (stacking) outperforms simple averaging</strong></li>
  <li><strong>Context-aware ensembles beat one-size-fits-all</strong></li>
</ol>

<h2 id="cost-analysis">Cost Analysis</h2>

<h3 id="cost-breakdown-1m-predictionsday">Cost Breakdown (1M predictions/day)</h3>

<table>
  <thead>
    <tr>
      <th>Component</th>
      <th>Single Model</th>
      <th>Ensemble (5 models)</th>
      <th>Savings/Cost</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Compute</strong></td>
      <td>$100/day</td>
      <td>$300/day</td>
      <td>+$200/day</td>
    </tr>
    <tr>
      <td><strong>Latency (p95)</strong></td>
      <td>20ms</td>
      <td>50ms</td>
      <td>+30ms</td>
    </tr>
    <tr>
      <td><strong>Accuracy</strong></td>
      <td>85%</td>
      <td>91%</td>
      <td>+6%</td>
    </tr>
    <tr>
      <td><strong>False positives</strong></td>
      <td>15,000/day</td>
      <td>9,000/day</td>
      <td>-6,000/day</td>
    </tr>
  </tbody>
</table>

<p><strong>Cost per false positive:</strong> $10 (fraud loss, support tickets, etc.)</p>

<p><strong>ROI Calculation:</strong></p>
<ul>
  <li>Additional compute cost: +$200/day</li>
  <li>Reduced false positives: 6,000 × $10 = $60,000/day saved</li>
  <li><strong>Net benefit: $59,800/day = $21.8M/year</strong></li>
</ul>

<h3 id="optimization-strategies">Optimization Strategies</h3>

<ol>
  <li><strong>Model pruning:</strong> Remove redundant models
    <ul>
      <li>From 10 models → 5 models</li>
      <li>Accuracy drop: &lt;1%</li>
      <li>Cost reduction: 50%</li>
    </ul>
  </li>
  <li><strong>Dynamic selection:</strong> Query only needed models
    <ul>
      <li>Average models per prediction: 3 instead of 5</li>
      <li>Cost reduction: 40%</li>
    </ul>
  </li>
  <li><strong>Knowledge distillation:</strong> Distill ensemble into single model
    <ul>
      <li>Single model retains 95% of ensemble accuracy</li>
      <li>Cost reduction: 80%</li>
      <li>Latency reduction: 75%</li>
    </ul>
  </li>
  <li><strong>Caching:</strong> Cache predictions for repeated queries
    <ul>
      <li>Cache hit rate: 30%</li>
      <li>Cost reduction: 30%</li>
    </ul>
  </li>
</ol>

<h2 id="key-takeaways">Key Takeaways</h2>

<p>✅ <strong>Ensembles improve accuracy by 5-15%</strong> over single best model</p>

<p>✅ <strong>Diversity is more important than individual model quality</strong></p>

<p>✅ <strong>Backtracking explores model combinations</strong> to find optimal subset</p>

<p>✅ <strong>Dynamic selection reduces latency</strong> while maintaining accuracy</p>

<p>✅ <strong>Stacking (meta-learning) outperforms</strong> simple averaging</p>

<p>✅ <strong>Parallel inference is critical</strong> for managing latency</p>

<p>✅ <strong>Fallback handling ensures robustness</strong> against individual model failures</p>

<p>✅ <strong>Knowledge distillation captures</strong> ensemble knowledge in single model</p>

<p>✅ <strong>Real-time monitoring enables</strong> adaptive ensemble strategies</p>

<p>✅ <strong>Same backtracking pattern</strong> as Generate Parentheses—explore combinations with constraints</p>

<h3 id="connection-to-day-14-theme-backtracking-and-combination-strategies">Connection to Day 14 Theme: Backtracking and Combination Strategies</h3>

<p>All three topics share the same core pattern:</p>

<p><strong>DSA (Generate Parentheses):</strong></p>
<ul>
  <li>Backtrack to explore all valid string combinations</li>
  <li>Prune invalid paths (close &gt; open)</li>
  <li>Result: all valid parentheses strings</li>
</ul>

<p><strong>ML System Design (Model Ensembling):</strong></p>
<ul>
  <li>Backtrack to explore model combinations</li>
  <li>Prune combinations violating constraints (latency, diversity)</li>
  <li>Result: optimal ensemble configuration</li>
</ul>

<p><strong>Speech Tech (Multi-model Speech Ensemble):</strong></p>
<ul>
  <li>Backtrack to explore speech model combinations</li>
  <li>Prune based on accuracy/latency trade-offs</li>
  <li>Result: optimal multi-model speech system</li>
</ul>

<p>The <strong>universal pattern</strong>: Generate combinations, validate constraints, prune invalid branches, select optimal solution.</p>

<hr />

<p><strong>Originally published at:</strong> <a href="https://www.arunbaby.com/ml-system-design/0014-model-ensembling/">arunbaby.com/ml-system-design/0014-model-ensembling</a></p>

<p><em>If you found this helpful, consider sharing it with others who might benefit.</em></p>


        
      </section>

      <footer class="page__meta">
        
        
  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-tags" aria-hidden="true"></i> Tags: </strong>
    <span itemprop="keywords">
    
      <a href="/tags/#bagging" class="page__taxonomy-item p-category" rel="tag">bagging</a><span class="sep">, </span>
    
      <a href="/tags/#boosting" class="page__taxonomy-item p-category" rel="tag">boosting</a><span class="sep">, </span>
    
      <a href="/tags/#ensemble-learning" class="page__taxonomy-item p-category" rel="tag">ensemble-learning</a><span class="sep">, </span>
    
      <a href="/tags/#model-combination" class="page__taxonomy-item p-category" rel="tag">model-combination</a><span class="sep">, </span>
    
      <a href="/tags/#production-ml" class="page__taxonomy-item p-category" rel="tag">production-ml</a><span class="sep">, </span>
    
      <a href="/tags/#stacking" class="page__taxonomy-item p-category" rel="tag">stacking</a><span class="sep">, </span>
    
      <a href="/tags/#voting" class="page__taxonomy-item p-category" rel="tag">voting</a>
    
    </span>
  </p>




  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> Categories: </strong>
    <span itemprop="keywords">
    
      <a href="/categories/#ml-system-design" class="page__taxonomy-item p-category" rel="tag">ml-system-design</a>
    
    </span>
  </p>


        
      </footer>

      <div class="page__related page__related--full">
  <h2 class="page__related-title">Related across topics</h2>
  <style>
    /* Make section span full content width and use 2 equal columns */
    .page__related--full { float: inline-start; width: 100%; padding: 0; }
    .cross-related-grid { display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 2rem; }
    @media (max-width: 768px) { .cross-related-grid { grid-template-columns: 1fr; } }
    /* Ensure archive cards stretch nicely in the grid */
    .cross-related-grid .list__item, .cross-related-grid .grid__item { width: auto; float: none; margin: 0; }
  </style>
  <div class="cross-related-grid">
    



<div class="list__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/dsa/0014-generate-parentheses/" rel="permalink">Generate Parentheses
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          24 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">Master backtracking to generate all valid combinations—the foundation of ensemble model selection and multi-model systems.
</p>
  </article>
</div>




<div class="list__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/ml-system-design/0014-model-ensembling/" rel="permalink">Model Ensembling
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          25 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">Build production ensemble systems that combine multiple models using backtracking strategies to explore optimal combinations.
</p>
  </article>
</div>




<div class="list__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/speech-tech/0014-multi-model-speech-ensemble/" rel="permalink">Multi-model Speech Ensemble
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          17 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">Build production speech systems that combine multiple ASR/TTS models using backtracking-based selection strategies to achieve state-of-the-art accuracy.
</p>
  </article>
</div>

  </div>
</div>

      <section class="page__share">
  <h4 class="page__share-title">Share on</h4>

  <a href="https://twitter.com/intent/tweet?via=arunbaby0&text=Model+Ensembling%20https%3A%2F%2Fwww.arunbaby.com%2Fml-system-design%2F0014-model-ensembling%2F" class="btn btn--twitter" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Twitter"><i class="fab fa-fw fa-twitter" aria-hidden="true"></i><span> Twitter</span></a>

  <a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fwww.arunbaby.com%2Fml-system-design%2F0014-model-ensembling%2F" class="btn btn--facebook" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Facebook"><i class="fab fa-fw fa-facebook" aria-hidden="true"></i><span> Facebook</span></a>

  <a href="https://www.linkedin.com/shareArticle?mini=true&url=https://www.arunbaby.com/ml-system-design/0014-model-ensembling/" class="btn btn--linkedin" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on LinkedIn"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i><span> LinkedIn</span></a>
</section>


      
  <nav class="pagination">
    
      <a href="/ml-system-design/0013-resource-allocation-for-ml/" class="pagination--pager" title="Resource Allocation for ML">Previous</a>
    
    
      <a href="#" class="pagination--pager disabled">Next</a>
    
  </nav>


    </div>

    
  </article>

  
  
</div>

      
    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';" role="search">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Enter your search term..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    

    
      
        
          <li><a href="https://twitter.com/arunbaby0" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-twitter-square" aria-hidden="true"></i> Twitter</a></li>
        
      
        
          <li><a href="https://github.com/arunbaby0" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
        
      
        
          <li><a href="https://www.linkedin.com/in/arunbaby0/" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i> LinkedIn</a></li>
        
      
        
          <li><a href="https://scholar.google.co.in/citations?user=6fSYWhkAAAAJ" rel="nofollow noopener noreferrer"><i class="fas fa-fw fa-graduation-cap" aria-hidden="true"></i> Google Scholar</a></li>
        
      
    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 1990 - 2143 <a href="https://www.arunbaby.com">Arun Baby</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>




  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-0JRJPEC9SS"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-0JRJPEC9SS', { 'anonymize_ip': false});
</script>








  </body>
</html>
